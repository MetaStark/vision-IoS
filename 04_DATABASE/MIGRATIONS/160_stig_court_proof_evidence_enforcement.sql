-- Migration 160: STIG Court-Proof Evidence Enforcement
-- CEO Directive: No Summary Without Raw Query Evidence
-- Purpose: Prevent split-brain divergence through mandatory evidence attachment
--
-- This migration enforces that ALL summaries generated by any agent must include:
--   1. raw_query: The exact SQL query that produced the data
--   2. query_result_hash: SHA-256 of the query result
--   3. query_result_snapshot: JSON snapshot of the raw data
--
-- Court-proof means: Any summary can be verified by re-running the query
-- and comparing the hash. No claims without proof.

BEGIN;

-- ============================================================================
-- SECTION 1: Core Evidence Enforcement Table
-- ============================================================================

CREATE TABLE IF NOT EXISTS vision_verification.summary_evidence_ledger (
    evidence_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Summary identification
    summary_id VARCHAR(255) NOT NULL,
    summary_type VARCHAR(100) NOT NULL,  -- 'SIGNAL_SUMMARY', 'REGIME_SUMMARY', 'ALPHA_SUMMARY', etc.

    -- The generating agent (FINN, STIG, LINE, LARS, VEGA)
    generating_agent VARCHAR(50) NOT NULL,

    -- COURT-PROOF EVIDENCE (ALL MANDATORY)
    raw_query TEXT NOT NULL,  -- The exact SQL that produced the data
    query_result_hash VARCHAR(64) NOT NULL,  -- SHA-256 of query result
    query_result_snapshot JSONB NOT NULL,  -- The actual raw data used

    -- The summary content itself
    summary_content JSONB NOT NULL,
    summary_hash VARCHAR(64) NOT NULL,  -- SHA-256 of summary_content

    -- Traceability
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    execution_context JSONB,  -- Additional context (e.g., market conditions, config)

    -- Cryptographic binding
    evidence_signature VARCHAR(128),  -- Ed25519 signature of complete record
    signature_verified BOOLEAN DEFAULT FALSE,

    -- Governance linkage
    governance_action_id UUID,
    attestation_id UUID,

    -- Constraints
    CONSTRAINT chk_query_result_hash_format CHECK (query_result_hash ~ '^[a-f0-9]{64}$'),
    CONSTRAINT chk_summary_hash_format CHECK (summary_hash ~ '^[a-f0-9]{64}$'),
    CONSTRAINT chk_raw_query_not_empty CHECK (LENGTH(raw_query) > 10),
    CONSTRAINT chk_query_result_not_empty CHECK (jsonb_typeof(query_result_snapshot) IS NOT NULL),
    CONSTRAINT chk_valid_agent CHECK (generating_agent IN ('FINN', 'STIG', 'LINE', 'LARS', 'VEGA'))
);

-- Index for fast lookups
CREATE INDEX IF NOT EXISTS idx_sel_summary_id ON vision_verification.summary_evidence_ledger(summary_id);
CREATE INDEX IF NOT EXISTS idx_sel_summary_type ON vision_verification.summary_evidence_ledger(summary_type);
CREATE INDEX IF NOT EXISTS idx_sel_generating_agent ON vision_verification.summary_evidence_ledger(generating_agent);
CREATE INDEX IF NOT EXISTS idx_sel_created_at ON vision_verification.summary_evidence_ledger(created_at);
CREATE INDEX IF NOT EXISTS idx_sel_query_result_hash ON vision_verification.summary_evidence_ledger(query_result_hash);

-- ============================================================================
-- SECTION 2: Evidence Verification Function
-- ============================================================================

-- Function to verify evidence integrity by recomputing hash
CREATE OR REPLACE FUNCTION vision_verification.verify_evidence_integrity(
    p_evidence_id UUID
) RETURNS JSONB AS $$
DECLARE
    v_record RECORD;
    v_recomputed_hash VARCHAR(64);
    v_is_valid BOOLEAN;
BEGIN
    -- Fetch the evidence record
    SELECT * INTO v_record
    FROM vision_verification.summary_evidence_ledger
    WHERE evidence_id = p_evidence_id;

    IF v_record IS NULL THEN
        RETURN jsonb_build_object(
            'valid', FALSE,
            'error', 'Evidence record not found',
            'evidence_id', p_evidence_id
        );
    END IF;

    -- Recompute hash from stored query result
    v_recomputed_hash := encode(sha256(v_record.query_result_snapshot::text::bytea), 'hex');
    v_is_valid := (v_recomputed_hash = v_record.query_result_hash);

    RETURN jsonb_build_object(
        'valid', v_is_valid,
        'evidence_id', p_evidence_id,
        'summary_id', v_record.summary_id,
        'stored_hash', v_record.query_result_hash,
        'recomputed_hash', v_recomputed_hash,
        'generating_agent', v_record.generating_agent,
        'created_at', v_record.created_at,
        'verification_timestamp', NOW()
    );
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- SECTION 3: Enforcement Gate Function
-- ============================================================================

-- This function MUST be called before any summary is considered valid
-- Returns the evidence_id if valid, raises exception if evidence is missing/invalid
CREATE OR REPLACE FUNCTION vision_verification.enforce_evidence_attachment(
    p_summary_id VARCHAR(255),
    p_summary_type VARCHAR(100),
    p_generating_agent VARCHAR(50),
    p_raw_query TEXT,
    p_query_result JSONB,
    p_summary_content JSONB,
    p_execution_context JSONB DEFAULT NULL
) RETURNS UUID AS $$
DECLARE
    v_query_result_hash VARCHAR(64);
    v_summary_hash VARCHAR(64);
    v_evidence_id UUID;
BEGIN
    -- Validate inputs (court-proof requirements)
    IF p_raw_query IS NULL OR LENGTH(p_raw_query) < 10 THEN
        RAISE EXCEPTION 'COURT_PROOF_VIOLATION: raw_query is mandatory and must contain valid SQL (min 10 chars)';
    END IF;

    IF p_query_result IS NULL OR jsonb_typeof(p_query_result) IS NULL THEN
        RAISE EXCEPTION 'COURT_PROOF_VIOLATION: query_result is mandatory - no summary without raw data evidence';
    END IF;

    IF p_summary_content IS NULL THEN
        RAISE EXCEPTION 'COURT_PROOF_VIOLATION: summary_content cannot be null';
    END IF;

    -- Compute hashes
    v_query_result_hash := encode(sha256(p_query_result::text::bytea), 'hex');
    v_summary_hash := encode(sha256(p_summary_content::text::bytea), 'hex');

    -- Insert evidence record
    INSERT INTO vision_verification.summary_evidence_ledger (
        summary_id,
        summary_type,
        generating_agent,
        raw_query,
        query_result_hash,
        query_result_snapshot,
        summary_content,
        summary_hash,
        execution_context
    ) VALUES (
        p_summary_id,
        p_summary_type,
        p_generating_agent,
        p_raw_query,
        v_query_result_hash,
        p_query_result,
        p_summary_content,
        v_summary_hash,
        p_execution_context
    )
    RETURNING evidence_id INTO v_evidence_id;

    -- Log to governance
    INSERT INTO fhq_governance.governance_actions_log (
        action_type,
        action_target,
        decision,
        decision_rationale,
        initiated_by,
        initiated_at
    ) VALUES (
        'EVIDENCE_ATTACHMENT',
        p_summary_id,
        'ENFORCED',
        format('Court-proof evidence attached: query_hash=%s, summary_type=%s', v_query_result_hash, p_summary_type),
        p_generating_agent,
        NOW()
    );

    RETURN v_evidence_id;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- SECTION 4: Split-Brain Detection View
-- ============================================================================

-- View to detect potential split-brain conditions:
-- Summaries that reference the same data but have different hashes
CREATE OR REPLACE VIEW vision_verification.split_brain_detector AS
SELECT
    s1.summary_id AS summary_1,
    s2.summary_id AS summary_2,
    s1.summary_type,
    s1.query_result_hash,
    s2.query_result_hash AS conflicting_hash,
    s1.raw_query,
    s1.created_at AS created_at_1,
    s2.created_at AS created_at_2,
    CASE
        WHEN s1.query_result_hash != s2.query_result_hash THEN 'HASH_MISMATCH'
        ELSE 'OK'
    END AS status
FROM vision_verification.summary_evidence_ledger s1
JOIN vision_verification.summary_evidence_ledger s2
    ON s1.raw_query = s2.raw_query
    AND s1.evidence_id != s2.evidence_id
    AND s1.created_at < s2.created_at
WHERE s1.query_result_hash != s2.query_result_hash;

-- ============================================================================
-- SECTION 5: Audit Trail for Evidence Verification
-- ============================================================================

CREATE TABLE IF NOT EXISTS vision_verification.evidence_verification_log (
    verification_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    evidence_id UUID NOT NULL REFERENCES vision_verification.summary_evidence_ledger(evidence_id),
    verified_by VARCHAR(50) NOT NULL,
    verification_result BOOLEAN NOT NULL,
    verification_details JSONB,
    verified_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_evl_evidence_id ON vision_verification.evidence_verification_log(evidence_id);
CREATE INDEX IF NOT EXISTS idx_evl_verified_at ON vision_verification.evidence_verification_log(verified_at);

-- ============================================================================
-- SECTION 6: Register Migration in Governance Actions Log
-- ============================================================================

INSERT INTO fhq_governance.governance_actions_log (
    action_type,
    action_target,
    decision,
    decision_rationale,
    initiated_by,
    initiated_at
) VALUES (
    'MIGRATION_DEPLOYMENT',
    '160_stig_court_proof_evidence_enforcement',
    'DEPLOYED',
    'CEO Directive 2025-12-20: No Summary Without Raw Query Evidence. Tables: summary_evidence_ledger, evidence_verification_log. Functions: enforce_evidence_attachment, verify_evidence_integrity. View: split_brain_detector. Court-proof requirement enforced.',
    'STIG',
    NOW()
);

COMMIT;

-- ============================================================================
-- Post-migration verification
-- ============================================================================
DO $$
BEGIN
    RAISE NOTICE 'Migration 160 Complete: Court-Proof Evidence Enforcement Active';
    RAISE NOTICE 'Rule Enforced: NO SUMMARY WITHOUT RAW QUERY EVIDENCE';
    RAISE NOTICE 'Split-brain prevention: All summaries now require cryptographic proof';
END $$;
