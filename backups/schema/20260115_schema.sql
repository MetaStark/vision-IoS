-- FjordHQ Schema Backup
-- Date: 20260115
-- Timestamp: 2026-01-15T02:00:06.443308+00:00
-- Tier 1+2 Schemas (Governance, Canonical, Configs)
-- Hash: 61289fd0c2d08014
--

--
-- PostgreSQL database dump
--

\restrict UKAhqHDxjHnNz2oIBwVn7f9I1jonQcZLQ0n5NntB1pKFlMj0uJQtVN0IRmXPAzz

-- Dumped from database version 17.6
-- Dumped by pg_dump version 17.6

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET transaction_timeout = 0;
SET client_encoding = 'WIN1252';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: fhq_canonical; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA fhq_canonical;


--
-- Name: SCHEMA fhq_canonical; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON SCHEMA fhq_canonical IS 'G3 Canonical Persistence Layer - Immutable storage for Golden Needles and audit-grade evidence. ADR-013 compliant.';


--
-- Name: fhq_finn; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA fhq_finn;


--
-- Name: SCHEMA fhq_finn; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON SCHEMA fhq_finn IS 'FINN intelligence layer (signals, regimes, CDS)';


--
-- Name: fhq_governance; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA fhq_governance;


--
-- Name: SCHEMA fhq_governance; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON SCHEMA fhq_governance IS 'Constitutional Governance & Authority Registry (ADR-001)';


--
-- Name: fhq_meta; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA fhq_meta;


--
-- Name: SCHEMA fhq_meta; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON SCHEMA fhq_meta IS 'Metadata, ADRs, dashboard config';


--
-- Name: fhq_org; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA fhq_org;


--
-- Name: SCHEMA fhq_org; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON SCHEMA fhq_org IS 'FjordHQ Intelligence Operating System - Multi-Agent Orchestration Layer';


--
-- Name: fhq_security; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA fhq_security;


--
-- Name: SCHEMA fhq_security; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON SCHEMA fhq_security IS 'ADR-008 Cryptographic Key Management Schema';


--
-- Name: vega; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA vega;


--
-- Name: SCHEMA vega; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON SCHEMA vega IS 'ADR-012: VEGA-owned economic safety controls. Governance owns this schema, not agents.';


--
-- Name: vision_autonomy; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA vision_autonomy;


--
-- Name: vision_cinematic; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA vision_cinematic;


--
-- Name: SCHEMA vision_cinematic; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON SCHEMA vision_cinematic IS 'ADR-022/023/024: Visual Cinematic Engine - Dumb Glass Frontend Architecture';


--
-- Name: vision_core; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA vision_core;


--
-- Name: vision_signals; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA vision_signals;


--
-- Name: vision_verification; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA vision_verification;


--
-- Name: needle_promotion_status; Type: TYPE; Schema: fhq_canonical; Owner: -
--

CREATE TYPE fhq_canonical.needle_promotion_status AS ENUM (
    'NEEDLE',
    'REJECT_ADMISSIBILITY',
    'CANDIDATE',
    'REJECT_VALIDATION',
    'VALIDATED_CONTEXTUAL',
    'DORMANT_SIGNAL'
);


--
-- Name: defcon_enforcement_result; Type: TYPE; Schema: fhq_governance; Owner: -
--

CREATE TYPE fhq_governance.defcon_enforcement_result AS (
	action_permitted boolean,
	current_defcon integer,
	action_type text,
	enforcement_rule text,
	blocked_reason text
);


--
-- Name: discrepancy_severity; Type: TYPE; Schema: fhq_governance; Owner: -
--

CREATE TYPE fhq_governance.discrepancy_severity AS ENUM (
    'INFO',
    'WARN',
    'CRITICAL'
);


--
-- Name: execution_guard_result; Type: TYPE; Schema: fhq_governance; Owner: -
--

CREATE TYPE fhq_governance.execution_guard_result AS (
	execution_permitted boolean,
	skill_score numeric,
	skill_version_id text,
	min_required_skill numeric,
	economic_safety_check text,
	rejection_reason text,
	guard_timestamp timestamp with time zone
);


--
-- Name: mandate_validation_result; Type: TYPE; Schema: fhq_governance; Owner: -
--

CREATE TYPE fhq_governance.mandate_validation_result AS (
	mandate_valid boolean,
	mandate_id uuid,
	plan_hash text,
	signature_agent text,
	authorized_signer boolean,
	hash_verified boolean,
	failure_reason text,
	validation_timestamp timestamp with time zone
);


--
-- Name: signature_validation_result; Type: TYPE; Schema: fhq_governance; Owner: -
--

CREATE TYPE fhq_governance.signature_validation_result AS (
	is_valid boolean,
	agent_id text,
	public_key text,
	verification_timestamp timestamp with time zone,
	failure_reason text
);


--
-- Name: telemetry_error_type; Type: TYPE; Schema: fhq_governance; Owner: -
--

CREATE TYPE fhq_governance.telemetry_error_type AS ENUM (
    'TIMEOUT_ERROR',
    'PROVIDER_ERROR',
    'HALLUCINATION_BLOCK',
    'IKEA_BOUNDARY_VIOLATION',
    'DIMINISHING_RETURNS_TERMINATION',
    'BUDGET_EXCEEDED',
    'GOVERNANCE_BLOCK',
    'TELEMETRY_WRITE_FAILURE',
    'VALIDATION_ERROR',
    'COGNITIVE_CONTEXT_MISSING',
    'ASRP_STATE_BLOCKED',
    'DEFCON_BLOCKED',
    'UNKNOWN_ERROR'
);


--
-- Name: activate_eqs_threshold(uuid, text); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.activate_eqs_threshold(p_config_id uuid, p_enforcer text DEFAULT 'STIG'::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_config RECORD;
BEGIN
    -- Verify config exists and is approved by VEGA
    SELECT * INTO v_config
    FROM fhq_canonical.eqs_threshold_config
    WHERE config_id = p_config_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Config % not found', p_config_id;
    END IF;

    IF v_config.approved_by IS NULL THEN
        RAISE EXCEPTION 'Config % not approved by VEGA - cannot activate', p_config_id;
    END IF;

    -- Deactivate current active threshold
    UPDATE fhq_canonical.eqs_threshold_config
    SET is_active = FALSE,
        effective_until = NOW(),
        updated_at = NOW()
    WHERE is_active = TRUE;

    -- Activate new threshold
    UPDATE fhq_canonical.eqs_threshold_config
    SET is_active = TRUE,
        enforced_by = p_enforcer,
        enforced_at = NOW(),
        updated_at = NOW()
    WHERE config_id = p_config_id;

    -- Log to governance
    INSERT INTO fhq_governance.governance_actions_log (
        action_id,
        action_type,
        action_target,
        action_target_type,
        initiated_by,
        initiated_at,
        decision,
        decision_rationale,
        metadata,
        agent_id,
        timestamp
    ) VALUES (
        gen_random_uuid(),
        'EQS_THRESHOLD_ACTIVATION',
        p_config_id::TEXT,
        'EQS_CONFIG',
        p_enforcer,
        NOW(),
        'ACTIVATED',
        'EQS threshold activated per CEO-DIR-2025-EQS-001',
        jsonb_build_object(
            'config_id', p_config_id,
            'threshold_value', v_config.threshold_value,
            'proposed_by', v_config.proposed_by,
            'approved_by', v_config.approved_by,
            'version', v_config.version
        ),
        p_enforcer,
        NOW()
    );

    RETURN TRUE;
END;
$$;


--
-- Name: block_needle_deletion(); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.block_needle_deletion() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    RAISE EXCEPTION 'IMMUTABILITY VIOLATION: Golden Needles cannot be deleted. Use supersession for corrections.';
END;
$$;


--
-- Name: calculate_evidence_ttl(integer, text); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.calculate_evidence_ttl(p_base_ttl_days integer, p_regime text) RETURNS timestamp with time zone
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_multiplier NUMERIC;
    v_param_name TEXT;
BEGIN
    -- Map regime to calibration parameter
    v_param_name := 'TTL_' || UPPER(p_regime);

    -- Get active multiplier from calibration_versions
    SELECT value INTO v_multiplier
    FROM fhq_governance.calibration_versions
    WHERE parameter_name = v_param_name
      AND is_active = TRUE
    LIMIT 1;

    -- Default to 1.0 if not found
    IF v_multiplier IS NULL THEN
        v_multiplier := 1.0;
    END IF;

    RETURN NOW() + (p_base_ttl_days * v_multiplier || ' days')::INTERVAL;
END;
$$;


--
-- Name: capture_eqs_distribution_snapshot(date); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.capture_eqs_distribution_snapshot(p_snapshot_date date DEFAULT CURRENT_DATE) RETURNS TABLE(out_asset text, out_regime text, out_signal_count integer, out_median_eqs numeric, out_pct_above_threshold numeric, out_distribution_collapsed boolean)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_threshold NUMERIC;
BEGIN
    -- Get active threshold
    v_threshold := fhq_canonical.get_active_eqs_threshold();

    -- Capture distribution for each asset/regime combination
    RETURN QUERY
    WITH stats AS (
        SELECT
            gn.target_asset,
            gn.regime_technical,
            ss.current_state,
            COUNT(*) as cnt,
            MIN(gn.eqs_score) as min_eqs,
            MAX(gn.eqs_score) as max_eqs,
            PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY gn.eqs_score) as med_eqs,
            AVG(gn.eqs_score) as mean_eqs,
            STDDEV(gn.eqs_score) as std_dev,
            PERCENTILE_CONT(0.10) WITHIN GROUP (ORDER BY gn.eqs_score) as p10,
            PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY gn.eqs_score) as p25,
            PERCENTILE_CONT(0.50) WITHIN GROUP (ORDER BY gn.eqs_score) as p50,
            PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY gn.eqs_score) as p75,
            PERCENTILE_CONT(0.90) WITHIN GROUP (ORDER BY gn.eqs_score) as p90,
            PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY gn.eqs_score) as p95,
            PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY gn.eqs_score) as p99,
            SUM(CASE WHEN gn.eqs_score >= v_threshold THEN 1 ELSE 0 END) as above_threshold
        FROM fhq_canonical.golden_needles gn
        JOIN fhq_canonical.g5_signal_state ss ON gn.needle_id = ss.needle_id
        WHERE ss.current_state = 'DORMANT'
        GROUP BY gn.target_asset, gn.regime_technical, ss.current_state
    ),
    inserted AS (
        INSERT INTO fhq_canonical.eqs_distribution_snapshots (
            snapshot_date,
            asset,
            regime,
            signal_state,
            signal_count,
            min_eqs,
            max_eqs,
            median_eqs,
            mean_eqs,
            std_dev,
            active_threshold,
            count_above_threshold,
            pct_above_threshold,
            p10, p25, p50, p75, p90, p95, p99,
            distribution_collapsed,
            collapse_reason
        )
        SELECT
            p_snapshot_date,
            s.target_asset,
            COALESCE(s.regime_technical, 'UNKNOWN'),
            s.current_state,
            s.cnt::INTEGER,
            s.min_eqs::NUMERIC(5,4),
            s.max_eqs::NUMERIC(5,4),
            s.med_eqs::NUMERIC(5,4),
            s.mean_eqs::NUMERIC(5,4),
            s.std_dev::NUMERIC(5,4),
            v_threshold,
            s.above_threshold::INTEGER,
            ROUND(100.0 * s.above_threshold / NULLIF(s.cnt, 0), 2)::NUMERIC(5,2),
            s.p10::NUMERIC(5,4), s.p25::NUMERIC(5,4), s.p50::NUMERIC(5,4),
            s.p75::NUMERIC(5,4), s.p90::NUMERIC(5,4), s.p95::NUMERIC(5,4), s.p99::NUMERIC(5,4),
            (100.0 * s.above_threshold / NULLIF(s.cnt, 0)) > 50,
            CASE
                WHEN (100.0 * s.above_threshold / NULLIF(s.cnt, 0)) > 50
                THEN 'VEGA ALERT: ' || ROUND(100.0 * s.above_threshold / NULLIF(s.cnt, 0), 1) || '% above threshold (max 50%)'
                ELSE NULL
            END
        FROM stats s
        ON CONFLICT (snapshot_date, asset, regime, signal_state)
        DO UPDATE SET
            signal_count = EXCLUDED.signal_count,
            min_eqs = EXCLUDED.min_eqs,
            max_eqs = EXCLUDED.max_eqs,
            median_eqs = EXCLUDED.median_eqs,
            mean_eqs = EXCLUDED.mean_eqs,
            std_dev = EXCLUDED.std_dev,
            active_threshold = EXCLUDED.active_threshold,
            count_above_threshold = EXCLUDED.count_above_threshold,
            pct_above_threshold = EXCLUDED.pct_above_threshold,
            p10 = EXCLUDED.p10, p25 = EXCLUDED.p25, p50 = EXCLUDED.p50,
            p75 = EXCLUDED.p75, p90 = EXCLUDED.p90, p95 = EXCLUDED.p95, p99 = EXCLUDED.p99,
            distribution_collapsed = EXCLUDED.distribution_collapsed,
            collapse_reason = EXCLUDED.collapse_reason,
            created_at = NOW()
        RETURNING
            eqs_distribution_snapshots.asset,
            eqs_distribution_snapshots.regime,
            eqs_distribution_snapshots.signal_count,
            eqs_distribution_snapshots.median_eqs,
            eqs_distribution_snapshots.pct_above_threshold,
            eqs_distribution_snapshots.distribution_collapsed
    )
    SELECT * FROM inserted;
END;
$$;


--
-- Name: capture_trade_outcome(uuid, numeric, text, text, integer, numeric, numeric); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.capture_trade_outcome(p_trade_id uuid, p_exit_price numeric, p_exit_reason text, p_exit_regime text DEFAULT NULL::text, p_exit_defcon integer DEFAULT NULL::integer, p_max_favorable numeric DEFAULT NULL::numeric, p_max_adverse numeric DEFAULT NULL::numeric) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_outcome_id UUID;
    v_trade RECORD;
    v_needle RECORD;
    v_pnl_absolute NUMERIC;
    v_pnl_percent NUMERIC;
    v_hold_minutes INTEGER;
BEGIN
    -- Get trade details
    SELECT * INTO v_trade
    FROM fhq_canonical.g5_paper_trades
    WHERE trade_id = p_trade_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Trade not found: %', p_trade_id;
    END IF;

    IF v_trade.needle_id IS NULL THEN
        RAISE EXCEPTION 'Trade % has no needle_id - cannot capture outcome (CEO Directive violation)', p_trade_id;
    END IF;

    -- Get needle context
    SELECT * INTO v_needle
    FROM fhq_canonical.golden_needles
    WHERE needle_id = v_trade.needle_id AND is_current = TRUE;

    -- Calculate PnL
    IF v_trade.direction = 'LONG' THEN
        v_pnl_absolute := (p_exit_price - v_trade.entry_price) * COALESCE(v_trade.position_size / v_trade.entry_price, 1);
        v_pnl_percent := ((p_exit_price - v_trade.entry_price) / v_trade.entry_price) * 100;
    ELSE
        v_pnl_absolute := (v_trade.entry_price - p_exit_price) * COALESCE(v_trade.position_size / v_trade.entry_price, 1);
        v_pnl_percent := ((v_trade.entry_price - p_exit_price) / v_trade.entry_price) * 100;
    END IF;

    -- Calculate hold duration
    v_hold_minutes := EXTRACT(EPOCH FROM (NOW() - v_trade.entry_timestamp)) / 60;

    -- Insert canonical outcome
    INSERT INTO fhq_canonical.canonical_outcomes (
        needle_id,
        trade_id,
        trade_source,
        symbol,
        direction,
        entry_price,
        entry_timestamp,
        entry_regime,
        entry_defcon,
        exit_price,
        exit_timestamp,
        exit_reason,
        exit_regime,
        exit_defcon,
        pnl_absolute,
        pnl_percent,
        hold_duration_minutes,
        max_favorable_excursion,
        max_adverse_excursion,
        needle_eqs_score,
        needle_hypothesis_category,
        needle_target_asset,
        needle_sitc_confidence
    ) VALUES (
        v_trade.needle_id,
        p_trade_id,
        'g5_paper_trades',
        v_trade.symbol,
        v_trade.direction,
        v_trade.entry_price,
        v_trade.entry_timestamp,
        v_trade.entry_regime,
        NULL,  -- entry_defcon from context if available
        p_exit_price,
        NOW(),
        p_exit_reason,
        p_exit_regime,
        p_exit_defcon,
        v_pnl_absolute,
        v_pnl_percent,
        v_hold_minutes,
        p_max_favorable,
        p_max_adverse,
        v_needle.eqs_score,
        v_needle.hypothesis_category,
        v_needle.target_asset,
        v_needle.sitc_confidence_level
    ) RETURNING outcome_id INTO v_outcome_id;

    -- Update the trade record
    UPDATE fhq_canonical.g5_paper_trades
    SET
        exit_price = p_exit_price,
        exit_timestamp = NOW(),
        exit_trigger = p_exit_reason,
        pnl_absolute = v_pnl_absolute,
        pnl_percent = v_pnl_percent,
        trade_outcome = CASE
            WHEN v_pnl_absolute > 0 THEN 'WIN'
            WHEN v_pnl_absolute < 0 THEN 'LOSS'
            ELSE 'BREAKEVEN'
        END
    WHERE trade_id = p_trade_id;

    -- Update signal state
    UPDATE fhq_canonical.g5_signal_state
    SET
        current_state = 'COOLING',
        exit_price = p_exit_price,
        exit_pnl = v_pnl_absolute,
        exit_reason = p_exit_reason,
        cooling_started_at = NOW(),
        last_transition = 'PRIMED_TO_COOLING',
        last_transition_at = NOW(),
        transition_count = transition_count + 1,
        updated_at = NOW()
    WHERE needle_id = v_trade.needle_id;

    RETURN v_outcome_id;
END;
$$;


--
-- Name: FUNCTION capture_trade_outcome(p_trade_id uuid, p_exit_price numeric, p_exit_reason text, p_exit_regime text, p_exit_defcon integer, p_max_favorable numeric, p_max_adverse numeric); Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON FUNCTION fhq_canonical.capture_trade_outcome(p_trade_id uuid, p_exit_price numeric, p_exit_reason text, p_exit_regime text, p_exit_defcon integer, p_max_favorable numeric, p_max_adverse numeric) IS 'Capture ground truth outcome when a trade exits.
CEO Directive CEO-G5-TRACE-2025-12-21: No learning, just facts.
Returns outcome_id for audit trail.';


--
-- Name: check_hypothesis_duplicate(text, text, text); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.check_hypothesis_duplicate(p_hypothesis_title text, p_target_asset text, p_regime_technical text) RETURNS TABLE(is_duplicate boolean, existing_needle_id uuid, existing_created_at timestamp with time zone, existing_state text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_dedup_hash TEXT;
BEGIN
    -- Calculate dedup hash
    v_dedup_hash := encode(
        sha256(
            (COALESCE(p_hypothesis_title, '') || '|' ||
             COALESCE(p_target_asset, '') || '|' ||
             COALESCE(p_regime_technical, ''))::bytea
        ),
        'hex'
    );

    -- Check for existing active/dormant signal with same hash
    RETURN QUERY
    SELECT
        TRUE as is_duplicate,
        gn.needle_id as existing_needle_id,
        gn.created_at as existing_created_at,
        ss.current_state as existing_state
    FROM fhq_canonical.golden_needles gn
    JOIN fhq_canonical.g5_signal_state ss ON gn.needle_id = ss.needle_id
    WHERE gn.dedup_hash = v_dedup_hash
      AND ss.current_state IN ('DORMANT', 'PRIMED', 'EXECUTING', 'POSITION_OPEN')
    ORDER BY gn.created_at DESC
    LIMIT 1;

    -- If no duplicate found, return false
    IF NOT FOUND THEN
        RETURN QUERY SELECT FALSE, NULL::UUID, NULL::TIMESTAMPTZ, NULL::TEXT;
    END IF;
END;
$$;


--
-- Name: check_ikea_grounding(uuid[], integer); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.check_ikea_grounding(p_snippet_ids uuid[], p_minimum_count integer DEFAULT 1) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_valid_count INTEGER;
BEGIN
    -- Count how many snippet_ids exist in evidence_nodes
    SELECT COUNT(*) INTO v_valid_count
    FROM fhq_canonical.evidence_nodes e
    WHERE e.evidence_id = ANY(p_snippet_ids)
      AND e.verification_status != 'FABRICATION';

    RETURN v_valid_count >= p_minimum_count;
END;
$$;


--
-- Name: FUNCTION check_ikea_grounding(p_snippet_ids uuid[], p_minimum_count integer); Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON FUNCTION fhq_canonical.check_ikea_grounding(p_snippet_ids uuid[], p_minimum_count integer) IS 'Validates that snippet_ids reference valid, non-fabricated evidence nodes.';


--
-- Name: check_promotion_rate_limit(); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.check_promotion_rate_limit() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_config RECORD;
    v_current_count INTEGER;
    v_hour_bucket TIMESTAMPTZ;
BEGIN
    SELECT * INTO v_config FROM fhq_canonical.g5_promotion_config WHERE is_active = TRUE LIMIT 1;

    IF NOT v_config.rate_limit_enabled THEN
        RETURN TRUE;
    END IF;

    v_hour_bucket := date_trunc('hour', NOW());

    SELECT promotions_count INTO v_current_count
    FROM fhq_canonical.g5_promotion_rate_log
    WHERE hour_bucket = v_hour_bucket;

    IF v_current_count IS NULL THEN
        INSERT INTO fhq_canonical.g5_promotion_rate_log (hour_bucket, promotions_count)
        VALUES (v_hour_bucket, 0)
        ON CONFLICT (hour_bucket) DO NOTHING;
        v_current_count := 0;
    END IF;

    RETURN v_current_count < v_config.max_promotions_per_hour;
END;
$$;


--
-- Name: deduplicate_dormant_signals(); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.deduplicate_dormant_signals() RETURNS TABLE(pruned_count integer, unique_hypotheses integer, kept_count integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_pruned INTEGER;
    v_unique INTEGER;
    v_kept INTEGER;
BEGIN
    -- For each dedup_hash, keep only the newest signal, mark rest as DUPLICATE_PRUNED
    WITH ranked AS (
        SELECT
            ss.state_id,
            ss.needle_id,
            gn.dedup_hash,
            gn.created_at,
            ROW_NUMBER() OVER (
                PARTITION BY gn.dedup_hash
                ORDER BY gn.created_at DESC
            ) as rn
        FROM fhq_canonical.g5_signal_state ss
        JOIN fhq_canonical.golden_needles gn ON ss.needle_id = gn.needle_id
        WHERE ss.current_state = 'DORMANT'
    ),
    duplicates AS (
        UPDATE fhq_canonical.g5_signal_state ss
        SET
            current_state = 'DUPLICATE_PRUNED',
            last_transition = 'DORMANT->DUPLICATE_PRUNED',
            last_transition_at = NOW(),
            updated_at = NOW()
        FROM ranked r
        WHERE ss.state_id = r.state_id
          AND r.rn > 1  -- Keep only newest (rn=1)
        RETURNING ss.needle_id
    )
    SELECT COUNT(*)::INTEGER INTO v_pruned FROM duplicates;

    -- Count unique hypotheses and kept signals
    SELECT
        COUNT(DISTINCT gn.dedup_hash)::INTEGER,
        COUNT(*)::INTEGER
    INTO v_unique, v_kept
    FROM fhq_canonical.g5_signal_state ss
    JOIN fhq_canonical.golden_needles gn ON ss.needle_id = gn.needle_id
    WHERE ss.current_state = 'DORMANT';

    -- Log to governance
    IF v_pruned > 0 THEN
        INSERT INTO fhq_governance.governance_actions_log (
            action_id,
            action_type,
            action_target,
            action_target_type,
            initiated_by,
            initiated_at,
            decision,
            decision_rationale,
            metadata,
            agent_id,
            timestamp
        ) VALUES (
            gen_random_uuid(),
            'SIGNAL_DEDUPLICATION',
            'fhq_canonical.g5_signal_state',
            'BATCH_UPDATE',
            'STIG',
            NOW(),
            'EXECUTED',
            'Deduplication per CEO Directive 2025-12-25 - keeping newest of each hypothesis',
            jsonb_build_object(
                'pruned_count', v_pruned,
                'unique_hypotheses', v_unique,
                'kept_count', v_kept,
                'dedup_policy', 'SHA256(hypothesis_title|target_asset|regime_technical)'
            ),
            'STIG',
            NOW()
        );
    END IF;

    RETURN QUERY SELECT v_pruned, v_unique, v_kept;
END;
$$;


--
-- Name: detect_eqs_collapse(); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.detect_eqs_collapse() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Check for collapse conditions
    IF NEW.pct_above_threshold > 50.0 THEN
        -- Log VEGA alert
        INSERT INTO fhq_governance.governance_actions_log (
            action_id,
            action_type,
            action_target,
            action_target_type,
            initiated_by,
            initiated_at,
            decision,
            decision_rationale,
            metadata,
            agent_id,
            timestamp
        ) VALUES (
            gen_random_uuid(),
            'EQS_COLLAPSE_DETECTED',
            NEW.snapshot_id::TEXT,
            'EQS_DISTRIBUTION',
            'STIG',
            NOW(),
            'VEGA_ALERT_TRIGGERED',
            'EQS distribution collapsed: ' || NEW.pct_above_threshold || '% above threshold (max 50%)',
            jsonb_build_object(
                'snapshot_id', NEW.snapshot_id,
                'snapshot_date', NEW.snapshot_date,
                'asset', NEW.asset,
                'regime', NEW.regime,
                'signal_count', NEW.signal_count,
                'pct_above_threshold', NEW.pct_above_threshold,
                'active_threshold', NEW.active_threshold,
                'alert_level', CASE
                    WHEN NEW.pct_above_threshold > 90 THEN 'CRITICAL'
                    WHEN NEW.pct_above_threshold > 75 THEN 'HIGH'
                    ELSE 'MEDIUM'
                END,
                'directive', 'CEO-DIR-2025-EQS-003'
            ),
            'STIG',
            NOW()
        );

        -- Mark snapshot as collapsed
        NEW.distribution_collapsed := TRUE;
        NEW.collapse_reason := 'AUTO-DETECTED: ' ||
            ROUND(NEW.pct_above_threshold, 1) || '% above threshold (max 50%)';
    END IF;

    RETURN NEW;
END;
$$;


--
-- Name: FUNCTION detect_eqs_collapse(); Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON FUNCTION fhq_canonical.detect_eqs_collapse() IS 'CEO-DIR-2025-EQS-003: Automated collapse detection trigger. Alerts VEGA when distribution degrades.';


--
-- Name: enforce_needle_immutability(); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.enforce_needle_immutability() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Only allow updates to supersession fields
    IF OLD.needle_id IS NOT NULL THEN
        IF NEW.eqs_score != OLD.eqs_score OR
           NEW.hypothesis_statement != OLD.hypothesis_statement OR
           NEW.asrp_hash != OLD.asrp_hash OR
           NEW.sitc_plan_id != OLD.sitc_plan_id OR
           NEW.price_witness_id != OLD.price_witness_id THEN
            RAISE EXCEPTION 'IMMUTABILITY VIOLATION: Golden Needle core fields cannot be modified. Create superseding record instead.';
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


--
-- Name: enforce_needle_staleness(); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.enforce_needle_staleness() RETURNS TABLE(expired_count integer, oldest_expired timestamp with time zone, newest_expired timestamp with time zone)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_expired_count INT;
    v_oldest TIMESTAMPTZ;
    v_newest TIMESTAMPTZ;
BEGIN
    -- Find needles to expire (older than 7 days)
    SELECT
        COUNT(*),
        MIN(created_at),
        MAX(created_at)
    INTO v_expired_count, v_oldest, v_newest
    FROM fhq_canonical.golden_needles
    WHERE is_current = TRUE
      AND created_at < NOW() - INTERVAL '7 days';

    -- Expire stale needles
    IF v_expired_count > 0 THEN
        UPDATE fhq_canonical.golden_needles
        SET is_current = FALSE,
            supersession_reason = 'STALENESS_SENTINEL: Auto-expired after 7-day validity window'
        WHERE is_current = TRUE
          AND created_at < NOW() - INTERVAL '7 days';

        -- Log to governance
        INSERT INTO fhq_governance.governance_actions_log (
            action_type,
            action_target,
            decision,
            decision_rationale,
            initiated_by,
            vega_reviewed
        ) VALUES (
            'AUTO_EXPIRE',
            'GOLDEN_NEEDLES',
            'EXECUTED',
            format('Staleness Sentinel: %s needles auto-expired (validity: 7d). Oldest: %s, Newest: %s',
                   v_expired_count, v_oldest, v_newest),
            'STALENESS_SENTINEL',
            FALSE
        );
    END IF;

    RETURN QUERY SELECT v_expired_count, v_oldest, v_newest;
END;
$$;


--
-- Name: FUNCTION enforce_needle_staleness(); Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON FUNCTION fhq_canonical.enforce_needle_staleness() IS 'CEO-DIR-2026-01-03: Auto-expires golden needles exceeding 7-day validity window';


--
-- Name: evidence_bundle_hash_trigger(); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.evidence_bundle_hash_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.bundle_hash := fhq_memory.sha256_hash(
        NEW.query_text || '|' || COALESCE(NEW.rrf_fused_results::TEXT, '') || '|' || NEW.created_at::TEXT
    );
    RETURN NEW;
END;
$$;


--
-- Name: evidence_hash_chain_trigger(); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.evidence_hash_chain_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_prev_hash TEXT;
BEGIN
    -- Calculate content hash
    NEW.content_hash := fhq_canonical.hash_evidence_content(
        NEW.content, NEW.source_type, NEW.data_timestamp
    );

    -- Get previous hash from last evidence in same domain
    SELECT hash_self INTO v_prev_hash
    FROM fhq_canonical.evidence_nodes
    WHERE domain = NEW.domain
    ORDER BY created_at DESC
    LIMIT 1;

    NEW.hash_prev := COALESCE(v_prev_hash, 'GENESIS');

    -- Calculate self hash (includes prev for chain integrity)
    NEW.hash_self := encode(
        sha256((NEW.content_hash || '|' || NEW.hash_prev)::bytea),
        'hex'
    );

    NEW.updated_at := NOW();

    RETURN NEW;
END;
$$;


--
-- Name: expire_stale_signals(); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.expire_stale_signals() RETURNS TABLE(expired_count integer, oldest_expired timestamp with time zone, newest_expired timestamp with time zone)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_expired_count INTEGER;
    v_oldest TIMESTAMPTZ;
    v_newest TIMESTAMPTZ;
BEGIN
    -- Mark signals as EXPIRED where created_at + TTL < NOW()
    WITH expired AS (
        UPDATE fhq_canonical.g5_signal_state ss
        SET
            current_state = 'EXPIRED',
            last_transition = 'DORMANT->EXPIRED',
            last_transition_at = NOW(),
            updated_at = NOW()
        FROM fhq_canonical.golden_needles gn
        WHERE ss.needle_id = gn.needle_id
          AND ss.current_state = 'DORMANT'
          AND gn.created_at + (gn.expected_timeframe_days || ' days')::INTERVAL < NOW()
        RETURNING ss.needle_id, gn.created_at
    )
    SELECT
        COUNT(*)::INTEGER,
        MIN(created_at),
        MAX(created_at)
    INTO v_expired_count, v_oldest, v_newest
    FROM expired;

    -- Log to governance
    IF v_expired_count > 0 THEN
        INSERT INTO fhq_governance.governance_actions_log (
            action_id,
            action_type,
            action_target,
            action_target_type,
            initiated_by,
            initiated_at,
            decision,
            decision_rationale,
            metadata,
            agent_id,
            timestamp
        ) VALUES (
            gen_random_uuid(),
            'SIGNAL_EXPIRATION',
            'fhq_canonical.g5_signal_state',
            'BATCH_UPDATE',
            'STIG',
            NOW(),
            'EXECUTED',
            'Automated TTL expiration per CEO Directive 2025-12-25',
            jsonb_build_object(
                'expired_count', v_expired_count,
                'oldest_signal', v_oldest,
                'newest_signal', v_newest,
                'ttl_policy', 'created_at + expected_timeframe_days < NOW()'
            ),
            'STIG',
            NOW()
        );
    END IF;

    RETURN QUERY SELECT v_expired_count, v_oldest, v_newest;
END;
$$;


--
-- Name: finn_eqs_sandbox(text, integer); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.finn_eqs_sandbox(p_formula_description text, p_sample_limit integer DEFAULT 500) RETURNS TABLE(formula_description text, sample_size integer, current_min_eqs numeric, current_max_eqs numeric, current_mean_eqs numeric, current_median_eqs numeric, current_std numeric, current_p05 numeric, current_p10 numeric, current_p25 numeric, current_p50 numeric, current_p75 numeric, current_p90 numeric, current_p95 numeric, pct_above_085 numeric, pct_above_090 numeric, pct_above_095 numeric, regime_distribution jsonb, asset_distribution jsonb, sandbox_timestamp timestamp with time zone)
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Log sandbox usage for audit
    INSERT INTO fhq_governance.governance_actions_log (
        action_id,
        action_type,
        action_target,
        action_target_type,
        initiated_by,
        initiated_at,
        decision,
        decision_rationale,
        metadata,
        agent_id,
        timestamp
    ) VALUES (
        gen_random_uuid(),
        'FINN_EQS_SANDBOX_INVOKED',
        p_formula_description,
        'EQS_FORMULA_TEST',
        'FINN',
        NOW(),
        'SANDBOX_RUN',
        'FINN testing EQS formula per CEO-DIR-2025-EQS-003',
        jsonb_build_object(
            'formula_description', p_formula_description,
            'sample_limit', p_sample_limit,
            'directive', 'CEO-DIR-2025-EQS-003'
        ),
        'FINN',
        NOW()
    );

    -- Return current distribution statistics
    RETURN QUERY
    WITH sample AS (
        SELECT
            gn.needle_id,
            gn.target_asset,
            gn.regime_technical,
            gn.eqs_score
        FROM fhq_canonical.golden_needles gn
        JOIN fhq_canonical.g5_signal_state ss ON gn.needle_id = ss.needle_id
        WHERE ss.current_state = 'DORMANT'
        ORDER BY gn.created_at DESC
        LIMIT p_sample_limit
    ),
    stats AS (
        SELECT
            COUNT(*)::INTEGER as cnt,
            MIN(eqs_score) as min_eqs,
            MAX(eqs_score) as max_eqs,
            AVG(eqs_score) as mean_eqs,
            PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY eqs_score) as median_eqs,
            STDDEV(eqs_score) as std_dev,
            PERCENTILE_CONT(0.05) WITHIN GROUP (ORDER BY eqs_score) as p05,
            PERCENTILE_CONT(0.10) WITHIN GROUP (ORDER BY eqs_score) as p10,
            PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY eqs_score) as p25,
            PERCENTILE_CONT(0.50) WITHIN GROUP (ORDER BY eqs_score) as p50,
            PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY eqs_score) as p75,
            PERCENTILE_CONT(0.90) WITHIN GROUP (ORDER BY eqs_score) as p90,
            PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY eqs_score) as p95,
            ROUND(100.0 * SUM(CASE WHEN eqs_score >= 0.85 THEN 1 ELSE 0 END) / COUNT(*), 2) as above_085,
            ROUND(100.0 * SUM(CASE WHEN eqs_score >= 0.90 THEN 1 ELSE 0 END) / COUNT(*), 2) as above_090,
            ROUND(100.0 * SUM(CASE WHEN eqs_score >= 0.95 THEN 1 ELSE 0 END) / COUNT(*), 2) as above_095
        FROM sample
    ),
    regime_dist AS (
        SELECT jsonb_object_agg(
            COALESCE(regime_technical, 'NULL'),
            cnt
        ) as dist
        FROM (
            SELECT regime_technical, COUNT(*) as cnt
            FROM sample
            GROUP BY regime_technical
        ) r
    ),
    asset_dist AS (
        SELECT jsonb_object_agg(target_asset, cnt) as dist
        FROM (
            SELECT target_asset, COUNT(*) as cnt
            FROM sample
            GROUP BY target_asset
        ) a
    )
    SELECT
        p_formula_description,
        stats.cnt,
        ROUND(stats.min_eqs::numeric, 4),
        ROUND(stats.max_eqs::numeric, 4),
        ROUND(stats.mean_eqs::numeric, 4),
        ROUND(stats.median_eqs::numeric, 4),
        ROUND(stats.std_dev::numeric, 6),
        ROUND(stats.p05::numeric, 4),
        ROUND(stats.p10::numeric, 4),
        ROUND(stats.p25::numeric, 4),
        ROUND(stats.p50::numeric, 4),
        ROUND(stats.p75::numeric, 4),
        ROUND(stats.p90::numeric, 4),
        ROUND(stats.p95::numeric, 4),
        stats.above_085,
        stats.above_090,
        stats.above_095,
        regime_dist.dist,
        asset_dist.dist,
        NOW()
    FROM stats, regime_dist, asset_dist;
END;
$$;


--
-- Name: FUNCTION finn_eqs_sandbox(p_formula_description text, p_sample_limit integer); Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON FUNCTION fhq_canonical.finn_eqs_sandbox(p_formula_description text, p_sample_limit integer) IS 'CEO-DIR-2025-EQS-003: Read-only sandbox for FINN to test EQS formula concepts. Returns current distribution statistics.';


--
-- Name: fn_classify_3axis(numeric, numeric, numeric, text, text); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.fn_classify_3axis(p_oos_sharpe numeric, p_edge_retained_1000ms numeric, p_signal_half_life numeric, p_regime_sovereign text, p_hypothesis_category text) RETURNS TABLE(axis_a text, axis_b text, axis_c text, composite text, eligible_g5 boolean)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_axis_a TEXT;
    v_axis_b TEXT;
    v_axis_c TEXT;
    v_composite TEXT;
    v_eligible BOOLEAN := false;
BEGIN
    -- AXIS A: Historical Merit
    IF p_oos_sharpe IS NULL THEN
        v_axis_a := 'NONE';
    ELSIF p_oos_sharpe < 0 THEN
        v_axis_a := 'NEGATIVE';
    ELSIF p_oos_sharpe >= 1.5 THEN
        v_axis_a := 'STRONG';
    ELSIF p_oos_sharpe >= 1.0 THEN
        v_axis_a := 'MODERATE';
    ELSIF p_oos_sharpe >= 0.5 THEN
        v_axis_a := 'WEAK';
    ELSE
        v_axis_a := 'NONE';
    END IF;

    -- AXIS B: Physical Robustness
    IF p_edge_retained_1000ms IS NULL OR p_signal_half_life IS NULL THEN
        v_axis_b := 'THEORETICAL';
    ELSIF p_edge_retained_1000ms >= 50 THEN
        v_axis_b := 'ROBUST';
    ELSIF p_edge_retained_1000ms > 0 THEN
        v_axis_b := 'FRAGILE';
    ELSE
        v_axis_b := 'THEORETICAL';
    END IF;

    -- AXIS C: Regime Dependence
    -- Categories that are regime-specific
    IF p_hypothesis_category IN ('REGIME_EDGE', 'CATALYST_AMPLIFICATION') THEN
        v_axis_c := 'SPECIFIC';
    ELSE
        v_axis_c := 'AGNOSTIC';
    END IF;

    -- COMPOSITE CLASSIFICATION (WAVE 16A Rules)
    IF v_axis_a = 'NEGATIVE' THEN
        v_composite := 'REJECT';  -- Only true REJECT: negative expectancy
    ELSIF v_axis_a = 'STRONG' AND v_axis_b = 'ROBUST' THEN
        v_composite := 'PLATINUM';
        v_eligible := true;
    ELSIF v_axis_a = 'STRONG' AND v_axis_b = 'FRAGILE' THEN
        v_composite := 'GOLD';
    ELSIF v_axis_a = 'MODERATE' AND v_axis_b = 'ROBUST' THEN
        v_composite := 'GOLD';
    ELSIF v_axis_a = 'MODERATE' AND v_axis_b = 'FRAGILE' THEN
        v_composite := 'SILVER';
    ELSIF v_axis_a = 'WEAK' AND v_axis_b = 'ROBUST' THEN
        v_composite := 'SILVER';
    ELSIF v_axis_a = 'WEAK' AND v_axis_b = 'FRAGILE' THEN
        v_composite := 'BRONZE';
    ELSIF v_axis_a IN ('NONE', 'WEAK') AND v_axis_b = 'THEORETICAL' THEN
        v_composite := 'BRONZE';  -- Still mappable, not rejected
    ELSE
        v_composite := 'BRONZE';  -- Default to lowest non-reject tier
    END IF;

    RETURN QUERY SELECT v_axis_a, v_axis_b, v_axis_c, v_composite, v_eligible;
END;
$$;


--
-- Name: fn_queue_needle_for_g4(); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.fn_queue_needle_for_g4() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_priority INTEGER;
BEGIN
    -- Priority based on EQS (1.00 = priority 1, 0.85 = priority 10)
    v_priority := GREATEST(1, LEAST(10, CEIL((1.00 - NEW.eqs_score) * 66.67)));

    -- Insert into G4 queue
    INSERT INTO fhq_canonical.g4_validation_queue (needle_id, priority)
    VALUES (NEW.needle_id, v_priority)
    ON CONFLICT (needle_id) DO NOTHING;

    RETURN NEW;
END;
$$;


--
-- Name: g4_2_calculate_orthogonality(numeric[], numeric[]); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.g4_2_calculate_orthogonality(p_signal_features numeric[], p_context_features numeric[]) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_correlation NUMERIC;
BEGIN
    -- Calculate Pearson correlation
    SELECT corr(s.val, c.val)
    INTO v_correlation
    FROM unnest(p_signal_features) WITH ORDINALITY AS s(val, idx)
    JOIN unnest(p_context_features) WITH ORDINALITY AS c(val, idx) ON s.idx = c.idx;

    RETURN COALESCE(ABS(v_correlation), 1.0);  -- Default to 1.0 (fail) if null
END;
$$;


--
-- Name: g4_2_validate_context(numeric, numeric, integer, numeric); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.g4_2_validate_context(p_orthogonality_score numeric, p_coverage_ratio numeric, p_trade_count integer, p_sharpe numeric) RETURNS TABLE(passes_orthogonality boolean, passes_coverage boolean, passes_sample_size boolean, passes_sharpe boolean, overall_pass boolean, classification text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_orth_threshold NUMERIC;
    v_coverage_floor NUMERIC;
    v_min_sample INT;
BEGIN
    -- Get locked parameters
    SELECT parameter_value INTO v_orth_threshold
    FROM fhq_canonical.g4_2_parameters WHERE parameter_name = 'ORTHOGONALITY_THRESHOLD';

    SELECT parameter_value INTO v_coverage_floor
    FROM fhq_canonical.g4_2_parameters WHERE parameter_name = 'CONTEXT_COVERAGE_FLOOR';

    SELECT parameter_value::INT INTO v_min_sample
    FROM fhq_canonical.g4_2_parameters WHERE parameter_name = 'MINIMUM_SAMPLE_SIZE';

    -- Evaluate thresholds
    passes_orthogonality := (p_orthogonality_score < v_orth_threshold);
    passes_coverage := (p_coverage_ratio >= v_coverage_floor);
    passes_sample_size := (p_trade_count >= v_min_sample);
    passes_sharpe := (p_sharpe >= 1.5);

    overall_pass := passes_orthogonality AND passes_coverage AND passes_sample_size AND passes_sharpe;

    -- Determine classification
    IF NOT passes_orthogonality THEN
        classification := 'ILLUSORY';  -- Correlated context = not real edge
    ELSIF NOT passes_coverage THEN
        classification := 'UNSTABLE-CONTEXTUAL';  -- Too rare
    ELSIF NOT passes_sample_size THEN
        classification := 'INSUFFICIENT_SAMPLE';
    ELSIF NOT passes_sharpe THEN
        classification := 'UNSTABLE-CONTEXTUAL';  -- Edge too weak
    ELSE
        classification := 'VALIDATED-CONTEXTUAL';
    END IF;

    RETURN NEXT;
END;
$$;


--
-- Name: g5_check_cco_coherence(); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.g5_check_cco_coherence() RETURNS TABLE(is_coherent boolean, context_age_seconds numeric, cco_status text, permit_allowed boolean, reason text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_coherence_window NUMERIC;
    v_degraded_lag NUMERIC;
    v_context_age NUMERIC;
    v_cco_status TEXT;
BEGIN
    -- Get parameters
    SELECT parameter_value INTO v_coherence_window
    FROM fhq_canonical.g4_2_parameters WHERE parameter_name = 'CCO_COHERENCE_WINDOW_SECONDS';

    SELECT parameter_value INTO v_degraded_lag
    FROM fhq_canonical.g4_2_parameters WHERE parameter_name = 'CCO_DEGRADED_LAG_SECONDS';

    -- Get current CCO state
    SELECT
        EXTRACT(EPOCH FROM (NOW() - cco.context_timestamp)),
        cco.cco_status
    INTO v_context_age, v_cco_status
    FROM fhq_canonical.g5_cco_state cco
    WHERE cco.is_active = TRUE;

    -- Evaluate coherence
    IF v_context_age IS NULL THEN
        is_coherent := FALSE;
        context_age_seconds := NULL;
        cco_status := 'UNAVAILABLE';
        permit_allowed := FALSE;
        reason := 'No CCO state found';
    ELSIF v_context_age > v_coherence_window THEN
        is_coherent := FALSE;
        context_age_seconds := v_context_age;
        cco_status := 'UNAVAILABLE';
        permit_allowed := FALSE;
        reason := 'Context expired (age: ' || v_context_age || 's > ' || v_coherence_window || 's)';
    ELSIF v_context_age > v_degraded_lag THEN
        is_coherent := TRUE;
        context_age_seconds := v_context_age;
        cco_status := 'DEGRADED';
        permit_allowed := TRUE;  -- But only high-Sharpe signals
        reason := 'Context degraded (age: ' || v_context_age || 's > ' || v_degraded_lag || 's)';
    ELSE
        is_coherent := TRUE;
        context_age_seconds := v_context_age;
        cco_status := 'OPERATIONAL';
        permit_allowed := TRUE;
        reason := 'Context coherent';
    END IF;

    RETURN NEXT;
END;
$$;


--
-- Name: g5_check_cco_coherence_v2(); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.g5_check_cco_coherence_v2() RETURNS TABLE(cco_status text, global_permit text, permit_attribution text, context_age_seconds numeric, context_valid boolean, context_hash text, execution_allowed boolean, block_reason text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_cco RECORD;
    v_coherence_window NUMERIC;
    v_degraded_lag NUMERIC;
    v_context_age NUMERIC;
BEGIN
    -- Get parameters
    SELECT parameter_value INTO v_coherence_window
    FROM fhq_canonical.g4_2_parameters WHERE parameter_name = 'CCO_COHERENCE_WINDOW_SECONDS';

    SELECT parameter_value INTO v_degraded_lag
    FROM fhq_canonical.g4_2_parameters WHERE parameter_name = 'CCO_DEGRADED_LAG_SECONDS';

    -- Get current CCO state
    SELECT * INTO v_cco
    FROM fhq_canonical.g5_cco_state
    WHERE is_active = TRUE;

    IF v_cco IS NULL THEN
        cco_status := 'UNAVAILABLE';
        global_permit := 'UNKNOWN';
        permit_attribution := 'SYSTEM_INIT';
        context_age_seconds := NULL;
        context_valid := FALSE;
        context_hash := NULL;
        execution_allowed := FALSE;
        block_reason := 'No CCO state found';
        RETURN NEXT;
        RETURN;
    END IF;

    -- Calculate context age
    v_context_age := EXTRACT(EPOCH FROM (NOW() - v_cco.context_timestamp));

    -- WAVE 17A Section 3.1: Cold-Start Integrity
    IF v_cco.cco_status = 'INIT' THEN
        cco_status := 'INIT';
        global_permit := 'UNKNOWN';
        permit_attribution := 'SYSTEM_INIT';
        context_age_seconds := v_context_age;
        context_valid := FALSE;
        context_hash := v_cco.context_hash;
        execution_allowed := FALSE;
        block_reason := 'SYSTEM_INIT: Awaiting first signed context update';
        RETURN NEXT;
        RETURN;
    END IF;

    -- WAVE 17A Section 3.3: Failover Semantics
    IF v_context_age > v_coherence_window THEN
        -- Context expired -> UNAVAILABLE
        cco_status := 'UNAVAILABLE';
        global_permit := 'UNKNOWN';
        permit_attribution := 'CONTEXT_STALE';
        context_age_seconds := v_context_age;
        context_valid := FALSE;
        context_hash := v_cco.context_hash;
        execution_allowed := FALSE;
        block_reason := 'Context expired (age: ' || ROUND(v_context_age) || 's > ' || v_coherence_window || 's)';

        -- Update CCO to UNAVAILABLE
        UPDATE fhq_canonical.g5_cco_state SET
            cco_status = 'UNAVAILABLE',
            global_permit = 'UNKNOWN',
            permit_attribution = 'CONTEXT_STALE'
        WHERE is_active = TRUE;

        RETURN NEXT;
        RETURN;
    ELSIF v_context_age > v_degraded_lag THEN
        -- Context degraded
        cco_status := 'DEGRADED';
        global_permit := v_cco.global_permit;
        permit_attribution := 'DEGRADED_MODE';
        context_age_seconds := v_context_age;
        context_valid := TRUE;
        context_hash := v_cco.context_hash;
        -- In DEGRADED, only high-Sharpe signals allowed (handled by validation function)
        execution_allowed := TRUE;
        block_reason := 'DEGRADED: Only Sharpe >= 2.0 signals permitted';
        RETURN NEXT;
        RETURN;
    ELSE
        -- OPERATIONAL
        cco_status := 'OPERATIONAL';
        global_permit := v_cco.global_permit;
        permit_attribution := v_cco.permit_attribution;
        context_age_seconds := v_context_age;
        context_valid := TRUE;
        context_hash := v_cco.context_hash;
        execution_allowed := (v_cco.global_permit = 'PERMITTED');
        block_reason := CASE
            WHEN v_cco.global_permit = 'PERMITTED' THEN NULL
            ELSE v_cco.permit_reason
        END;
        RETURN NEXT;
        RETURN;
    END IF;
END;
$$;


--
-- Name: g5_check_exit_criteria(); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.g5_check_exit_criteria() RETURNS TABLE(all_passed boolean, trades_passed boolean, sharpe_passed boolean, drawdown_passed boolean, win_rate_passed boolean, duration_passed boolean, vega_passed boolean, ceo_passed boolean, blocking_criteria text[])
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_min_trades INT;
    v_min_sharpe NUMERIC;
    v_max_dd NUMERIC;
    v_min_wr NUMERIC;
    v_min_days INT;
    r RECORD;
BEGIN
    -- Get thresholds
    SELECT parameter_value::INT INTO v_min_trades
    FROM fhq_canonical.g4_2_parameters WHERE parameter_name = 'G5_MIN_PAPER_TRADES';

    SELECT parameter_value INTO v_min_sharpe
    FROM fhq_canonical.g4_2_parameters WHERE parameter_name = 'G5_MIN_PAPER_SHARPE';

    SELECT parameter_value INTO v_max_dd
    FROM fhq_canonical.g4_2_parameters WHERE parameter_name = 'G5_MAX_PAPER_DRAWDOWN';

    SELECT parameter_value INTO v_min_wr
    FROM fhq_canonical.g4_2_parameters WHERE parameter_name = 'G5_MIN_PAPER_WIN_RATE';

    SELECT parameter_value::INT INTO v_min_days
    FROM fhq_canonical.g4_2_parameters WHERE parameter_name = 'G5_MIN_PAPER_DURATION_DAYS';

    -- Get current status
    SELECT * INTO r FROM fhq_canonical.g5_exit_criteria_status WHERE is_active = TRUE;

    IF r IS NULL THEN
        all_passed := FALSE;
        blocking_criteria := ARRAY['No exit criteria status found'];
        RETURN NEXT;
        RETURN;
    END IF;

    -- Evaluate each criterion
    trades_passed := r.total_paper_trades >= v_min_trades;
    sharpe_passed := r.paper_sharpe >= v_min_sharpe;
    drawdown_passed := r.paper_max_drawdown <= v_max_dd;
    win_rate_passed := r.paper_win_rate >= v_min_wr;
    duration_passed := r.paper_duration_days >= v_min_days;
    vega_passed := r.vega_attestation = 'G5_PASS';
    ceo_passed := r.ceo_two_man_rule = 'FULFILLED';

    -- Build blocking list
    blocking_criteria := ARRAY[]::TEXT[];
    IF NOT trades_passed THEN
        blocking_criteria := array_append(blocking_criteria, 'Trades: ' || r.total_paper_trades || ' < ' || v_min_trades);
    END IF;
    IF NOT COALESCE(sharpe_passed, FALSE) THEN
        blocking_criteria := array_append(blocking_criteria, 'Sharpe: ' || COALESCE(r.paper_sharpe::TEXT, 'NULL') || ' < ' || v_min_sharpe);
    END IF;
    IF NOT COALESCE(drawdown_passed, FALSE) THEN
        blocking_criteria := array_append(blocking_criteria, 'Drawdown: ' || COALESCE(r.paper_max_drawdown::TEXT, 'NULL') || ' > ' || v_max_dd);
    END IF;
    IF NOT COALESCE(win_rate_passed, FALSE) THEN
        blocking_criteria := array_append(blocking_criteria, 'Win Rate: ' || COALESCE(r.paper_win_rate::TEXT, 'NULL') || ' < ' || v_min_wr);
    END IF;
    IF NOT COALESCE(duration_passed, FALSE) THEN
        blocking_criteria := array_append(blocking_criteria, 'Duration: ' || r.paper_duration_days || ' < ' || v_min_days || ' days');
    END IF;
    IF NOT vega_passed THEN
        blocking_criteria := array_append(blocking_criteria, 'VEGA: ' || r.vega_attestation);
    END IF;
    IF NOT ceo_passed THEN
        blocking_criteria := array_append(blocking_criteria, 'CEO: ' || r.ceo_two_man_rule);
    END IF;

    all_passed := COALESCE(trades_passed, FALSE) AND COALESCE(sharpe_passed, FALSE) AND
                  COALESCE(drawdown_passed, FALSE) AND COALESCE(win_rate_passed, FALSE) AND
                  COALESCE(duration_passed, FALSE) AND vega_passed AND ceo_passed;

    RETURN NEXT;
END;
$$;


--
-- Name: g5_transition_signal_state(uuid, text, text, jsonb); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.g5_transition_signal_state(p_needle_id uuid, p_new_state text, p_trigger text, p_context jsonb DEFAULT '{}'::jsonb) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_current_state TEXT;
    v_valid_transition BOOLEAN;
BEGIN
    -- Get current state
    SELECT current_state INTO v_current_state
    FROM fhq_canonical.g5_signal_state
    WHERE needle_id = p_needle_id;

    -- If no state exists, create it
    IF v_current_state IS NULL THEN
        INSERT INTO fhq_canonical.g5_signal_state (needle_id, current_state, dormant_since)
        VALUES (p_needle_id, 'DORMANT', NOW());
        v_current_state := 'DORMANT';
    END IF;

    -- Validate transition (state machine rules)
    v_valid_transition := CASE
        WHEN v_current_state = 'DORMANT' AND p_new_state = 'PRIMED' THEN TRUE
        WHEN v_current_state = 'PRIMED' AND p_new_state IN ('EXECUTING', 'DORMANT') THEN TRUE
        WHEN v_current_state = 'EXECUTING' AND p_new_state IN ('POSITION', 'DORMANT') THEN TRUE
        WHEN v_current_state = 'POSITION' AND p_new_state = 'COOLING' THEN TRUE
        WHEN v_current_state = 'COOLING' AND p_new_state = 'DORMANT' THEN TRUE
        ELSE FALSE
    END;

    IF NOT v_valid_transition THEN
        -- Log invalid transition attempt
        INSERT INTO fhq_canonical.g5_state_transitions (
            needle_id, from_state, to_state, transition_trigger,
            transition_valid, validation_errors
        ) VALUES (
            p_needle_id, v_current_state, p_new_state, p_trigger,
            FALSE, jsonb_build_object('error', 'Invalid state transition')
        );
        RETURN FALSE;
    END IF;

    -- Perform transition
    UPDATE fhq_canonical.g5_signal_state SET
        current_state = p_new_state,
        state_entered_at = NOW(),
        last_transition = v_current_state || '->' || p_new_state,
        last_transition_at = NOW(),
        transition_count = transition_count + 1,
        updated_at = NOW(),
        -- Set state-specific timestamps
        primed_at = CASE WHEN p_new_state = 'PRIMED' THEN NOW() ELSE primed_at END,
        executing_at = CASE WHEN p_new_state = 'EXECUTING' THEN NOW() ELSE executing_at END,
        position_entered_at = CASE WHEN p_new_state = 'POSITION' THEN NOW() ELSE position_entered_at END,
        cooling_started_at = CASE WHEN p_new_state = 'COOLING' THEN NOW() ELSE cooling_started_at END,
        dormant_since = CASE WHEN p_new_state = 'DORMANT' THEN NOW() ELSE dormant_since END
    WHERE needle_id = p_needle_id;

    -- Log transition
    INSERT INTO fhq_canonical.g5_state_transitions (
        needle_id, from_state, to_state, transition_trigger,
        context_snapshot, transition_valid
    ) VALUES (
        p_needle_id, v_current_state, p_new_state, p_trigger,
        p_context, TRUE
    );

    RETURN TRUE;
END;
$$;


--
-- Name: g5_update_cco_context(text, numeric, numeric, text, text, boolean, text[], text); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.g5_update_cco_context(p_regime text, p_regime_confidence numeric, p_vol_percentile numeric, p_vol_state text, p_liquidity_state text, p_market_hours boolean, p_source_tables text[], p_signed_by text DEFAULT 'CCO_DAEMON'::text) RETURNS TABLE(success boolean, new_status text, new_permit text, context_hash text, error_message text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_context_vector JSONB;
    v_context_hash TEXT;
    v_input_hash TEXT;
    v_coherence_window INT;
    v_new_status TEXT;
    v_new_permit TEXT;
    v_permit_attribution TEXT;
BEGIN
    -- Build context vector
    v_context_vector := jsonb_build_object(
        'regime', p_regime,
        'regime_confidence', p_regime_confidence,
        'vol_percentile', p_vol_percentile,
        'vol_state', p_vol_state,
        'liquidity_state', p_liquidity_state,
        'market_hours', p_market_hours,
        'timestamp', NOW()
    );

    -- Compute hashes (ADR-013 provenance)
    v_context_hash := encode(sha256(v_context_vector::text::bytea), 'hex');
    v_input_hash := encode(sha256(array_to_string(p_source_tables, ',')::bytea), 'hex');

    -- Get coherence window
    SELECT parameter_value::INT INTO v_coherence_window
    FROM fhq_canonical.g4_2_parameters
    WHERE parameter_name = 'CCO_COHERENCE_WINDOW_SECONDS';

    -- Validate provenance (WAVE 17A Section 3.2)
    IF p_source_tables IS NULL OR array_length(p_source_tables, 1) IS NULL THEN
        success := FALSE;
        new_status := NULL;
        new_permit := NULL;
        context_hash := NULL;
        error_message := 'PROVENANCE_VIOLATION: source_tables required (ADR-013)';
        RETURN NEXT;
        RETURN;
    END IF;

    -- Determine permit based on context
    IF p_vol_percentile BETWEEN 30 AND 70 THEN
        v_new_permit := 'PERMITTED';
        v_permit_attribution := 'MARKET_DRIVEN';
    ELSE
        v_new_permit := 'SUPPRESSED';
        v_permit_attribution := 'MARKET_DRIVEN';
    END IF;

    -- Always transition to OPERATIONAL on valid update
    v_new_status := 'OPERATIONAL';

    -- Update CCO state
    UPDATE fhq_canonical.g5_cco_state SET
        cco_status = v_new_status,
        current_regime = p_regime,
        current_regime_confidence = p_regime_confidence,
        current_vol_percentile = p_vol_percentile,
        current_vol_state = p_vol_state,
        current_liquidity_state = p_liquidity_state,
        current_market_hours = p_market_hours,
        context_timestamp = NOW(),
        valid_until = NOW() + (v_coherence_window || ' seconds')::INTERVAL,
        global_permit = v_new_permit,
        global_permit_active = (v_new_permit = 'PERMITTED'),
        permit_attribution = v_permit_attribution,
        permit_reason = CASE
            WHEN v_new_permit = 'PERMITTED' THEN 'VOL_NEUTRAL context (30-70%)'
            ELSE 'Outside VOL_NEUTRAL window'
        END,
        context_vector = v_context_vector,
        context_hash = v_context_hash,
        input_hash = v_input_hash,
        source_tables = p_source_tables,
        signed_by = p_signed_by,
        updated_at = NOW()
    WHERE is_active = TRUE;

    -- Log state transition
    INSERT INTO fhq_canonical.g5_cco_health_log (
        check_timestamp, context_age_seconds, cco_status, previous_status,
        triggered_degraded, triggered_unavailable
    ) VALUES (
        NOW(), 0, v_new_status, 'INIT',
        FALSE, FALSE
    );

    success := TRUE;
    new_status := v_new_status;
    new_permit := v_new_permit;
    context_hash := v_context_hash;
    error_message := NULL;
    RETURN NEXT;
END;
$$;


--
-- Name: g5_validate_signal_execution(uuid); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.g5_validate_signal_execution(p_needle_id uuid) RETURNS TABLE(can_execute boolean, cco_status text, signal_sharpe numeric, block_reason text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_cco_status TEXT;
    v_degraded_min_sharpe NUMERIC;
    v_signal_sharpe NUMERIC;
    v_defcon_level INT;
BEGIN
    -- Get CCO status
    SELECT cco.cco_status, cco.defcon_level
    INTO v_cco_status, v_defcon_level
    FROM fhq_canonical.g5_cco_state cco
    WHERE cco.is_active = TRUE;

    -- Get signal Sharpe
    SELECT cv.best_contextual_sharpe
    INTO v_signal_sharpe
    FROM fhq_canonical.g4_2_composite_verdict cv
    WHERE cv.needle_id = p_needle_id;

    -- Get degraded threshold
    SELECT parameter_value INTO v_degraded_min_sharpe
    FROM fhq_canonical.g4_2_parameters WHERE parameter_name = 'CCO_DEGRADED_MIN_SHARPE';

    cco_status := COALESCE(v_cco_status, 'UNAVAILABLE');
    signal_sharpe := v_signal_sharpe;

    -- DEFCON check first
    IF v_defcon_level IS NOT NULL AND v_defcon_level <= 2 THEN
        can_execute := FALSE;
        block_reason := 'DEFCON-' || v_defcon_level || ' blocks all execution';
        RETURN NEXT;
        RETURN;
    END IF;

    -- CCO status check
    CASE v_cco_status
        WHEN 'OPERATIONAL' THEN
            can_execute := TRUE;
            block_reason := NULL;
        WHEN 'DEGRADED' THEN
            IF v_signal_sharpe >= v_degraded_min_sharpe THEN
                can_execute := TRUE;
                block_reason := NULL;
            ELSE
                can_execute := FALSE;
                block_reason := 'CCO DEGRADED: Sharpe ' || v_signal_sharpe || ' < ' || v_degraded_min_sharpe;
            END IF;
        WHEN 'UNAVAILABLE' THEN
            can_execute := FALSE;
            block_reason := 'CCO UNAVAILABLE - full halt';
        ELSE
            can_execute := FALSE;
            block_reason := 'Unknown CCO status';
    END CASE;

    RETURN NEXT;
END;
$$;


--
-- Name: generate_needle_hash(); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.generate_needle_hash() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.canonical_hash := encode(
        sha256(
            (COALESCE(NEW.hypothesis_id, '') || '|' ||
             COALESCE(NEW.eqs_score::text, '') || '|' ||
             COALESCE(NEW.asrp_hash, '') || '|' ||
             COALESCE(NEW.sitc_plan_id::text, '') || '|' ||
             COALESCE(NEW.price_witness_id, '') || '|' ||
             COALESCE(NEW.price_witness_timestamp::text, '') || '|' ||
             COALESCE(NEW.hypothesis_statement, ''))::bytea
        ),
        'hex'
    );
    RETURN NEW;
END;
$$;


--
-- Name: get_active_eqs_threshold(); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.get_active_eqs_threshold() RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_threshold NUMERIC;
BEGIN
    SELECT threshold_value INTO v_threshold
    FROM fhq_canonical.eqs_threshold_config
    WHERE is_active = TRUE
      AND (effective_until IS NULL OR effective_until > NOW())
    ORDER BY effective_from DESC
    LIMIT 1;

    -- Fallback to constitutional default if no active config
    RETURN COALESCE(v_threshold, 0.85);
END;
$$;


--
-- Name: get_outcome_statistics(); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.get_outcome_statistics() RETURNS TABLE(total_outcomes bigint, wins bigint, losses bigint, breakeven bigint, win_rate numeric, total_pnl numeric, avg_pnl numeric, avg_winner numeric, avg_loser numeric, avg_hold_minutes numeric, by_exit_reason jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        COUNT(*) as total_outcomes,
        COUNT(*) FILTER (WHERE pnl_absolute > 0) as wins,
        COUNT(*) FILTER (WHERE pnl_absolute < 0) as losses,
        COUNT(*) FILTER (WHERE pnl_absolute = 0) as breakeven,
        ROUND(
            (COUNT(*) FILTER (WHERE pnl_absolute > 0)::NUMERIC / NULLIF(COUNT(*), 0)) * 100,
            2
        ) as win_rate,
        ROUND(SUM(pnl_absolute), 2) as total_pnl,
        ROUND(AVG(pnl_absolute), 2) as avg_pnl,
        ROUND(AVG(pnl_absolute) FILTER (WHERE pnl_absolute > 0), 2) as avg_winner,
        ROUND(AVG(pnl_absolute) FILTER (WHERE pnl_absolute < 0), 2) as avg_loser,
        ROUND(AVG(hold_duration_minutes), 0) as avg_hold_minutes,
        jsonb_object_agg(
            COALESCE(exit_reason, 'UNKNOWN'),
            reason_count
        ) as by_exit_reason
    FROM fhq_canonical.canonical_outcomes,
    LATERAL (
        SELECT exit_reason, COUNT(*) as reason_count
        FROM fhq_canonical.canonical_outcomes
        GROUP BY exit_reason
    ) exit_reasons;
END;
$$;


--
-- Name: hash_evidence_content(text, text, timestamp with time zone); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.hash_evidence_content(p_content text, p_source_type text, p_data_timestamp timestamp with time zone) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
    RETURN encode(
        sha256(
            (p_content || '|' || p_source_type || '|' || COALESCE(p_data_timestamp::TEXT, 'NULL'))::bytea
        ),
        'hex'
    );
END;
$$;


--
-- Name: increment_promotion_rate(); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.increment_promotion_rate() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_hour_bucket TIMESTAMPTZ;
BEGIN
    v_hour_bucket := date_trunc('hour', NOW());

    INSERT INTO fhq_canonical.g5_promotion_rate_log (hour_bucket, promotions_count, promotions_allowed)
    VALUES (v_hour_bucket, 1, 1)
    ON CONFLICT (hour_bucket) DO UPDATE SET
        promotions_count = fhq_canonical.g5_promotion_rate_log.promotions_count + 1,
        promotions_allowed = fhq_canonical.g5_promotion_rate_log.promotions_allowed + 1;
END;
$$;


--
-- Name: persist_golden_needle(text, uuid, text, numeric, text[], jsonb, text, text, text, text, uuid, text, integer, integer, text, timestamp with time zone, uuid, text, text, text, numeric, text, timestamp with time zone, text, text, text, numeric, text, timestamp with time zone, integer, jsonb, jsonb, text, text, text); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.persist_golden_needle(p_hypothesis_id text, p_hunt_session_id uuid, p_cycle_id text, p_eqs_score numeric, p_confluence_factors text[], p_eqs_components jsonb, p_hypothesis_title text, p_hypothesis_statement text, p_hypothesis_category text, p_executive_summary text, p_sitc_plan_id uuid, p_sitc_confidence text, p_sitc_nodes_completed integer, p_sitc_nodes_total integer, p_asrp_hash text, p_asrp_timestamp timestamp with time zone, p_state_vector_id uuid, p_state_hash text, p_price_witness_id text, p_price_witness_symbol text, p_price_witness_value numeric, p_price_witness_source text, p_price_witness_timestamp timestamp with time zone, p_regime_asset_id text, p_regime_technical text, p_regime_sovereign text, p_regime_confidence numeric, p_regime_crio_driver text, p_regime_snapshot_timestamp timestamp with time zone, p_defcon_level integer, p_falsification_criteria jsonb, p_backtest_requirements jsonb, p_g2_exam_session_id text DEFAULT NULL::text, p_chain_of_query_hash text DEFAULT NULL::text, p_target_asset text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_needle_id UUID;
    v_target_asset TEXT;
BEGIN
    -- Validate EQS threshold (constitutional constraint)
    IF p_eqs_score < 0.85 THEN
        RAISE EXCEPTION 'G3 VIOLATION: Cannot persist hypothesis with EQS < 0.85. EQS=% is below threshold.', p_eqs_score;
    END IF;

    -- Derive target_asset from p_target_asset or fallback to p_regime_asset_id or p_price_witness_symbol
    v_target_asset := COALESCE(
        p_target_asset,
        p_regime_asset_id,
        CASE
            WHEN p_price_witness_symbol ILIKE '%BTC%' THEN 'BTC-USD'
            WHEN p_price_witness_symbol ILIKE '%ETH%' THEN 'ETH-USD'
            WHEN p_price_witness_symbol ILIKE '%SOL%' THEN 'SOL-USD'
            WHEN p_price_witness_symbol ILIKE '%XRP%' THEN 'XRP-USD'
            ELSE p_price_witness_symbol
        END
    );

    INSERT INTO fhq_canonical.golden_needles (
        hypothesis_id,
        hunt_session_id,
        cycle_id,
        eqs_score,
        -- Confluence factors
        factor_price_technical,
        factor_volume_confirmation,
        factor_regime_alignment,
        factor_temporal_coherence,
        factor_catalyst_present,
        factor_specific_testable,
        factor_testable_criteria,
        -- EQS weights
        weight_price_technical,
        weight_volume_confirmation,
        weight_regime_alignment,
        weight_temporal_coherence,
        weight_catalyst_present,
        weight_specificity_bonus,
        weight_testability_bonus,
        stress_modifier,
        -- Hypothesis
        hypothesis_title,
        hypothesis_statement,
        hypothesis_category,
        executive_summary,
        -- SitC
        sitc_plan_id,
        sitc_confidence_level,
        sitc_nodes_completed,
        sitc_nodes_total,
        -- ASRP
        asrp_hash,
        asrp_timestamp,
        state_vector_id,
        state_hash_at_creation,
        -- Price Witness
        price_witness_id,
        price_witness_symbol,
        price_witness_value,
        price_witness_source,
        price_witness_timestamp,
        -- Regime
        regime_asset_id,
        regime_technical,
        regime_sovereign,
        regime_confidence,
        regime_crio_driver,
        regime_snapshot_timestamp,
        defcon_level,
        -- Backtest hooks
        falsification_criteria,
        backtest_requirements,
        -- Governance
        g2_exam_session_id,
        chain_of_query_hash,
        target_asset  -- NEW: Canonical target asset
    ) VALUES (
        p_hypothesis_id,
        p_hunt_session_id,
        p_cycle_id,
        p_eqs_score,
        -- Parse confluence factors array
        'PRICE_TECHNICAL' = ANY(p_confluence_factors),
        'VOLUME_CONFIRMATION' = ANY(p_confluence_factors),
        'REGIME_ALIGNMENT' = ANY(p_confluence_factors),
        'TEMPORAL_COHERENCE' = ANY(p_confluence_factors),
        'CATALYST_PRESENT' = ANY(p_confluence_factors),
        'SPECIFIC_TESTABLE' = ANY(p_confluence_factors),
        'TESTABLE_CRITERIA' = ANY(p_confluence_factors),
        -- Extract weights from JSONB
        (p_eqs_components->>'price_technical')::NUMERIC,
        (p_eqs_components->>'volume_confirmation')::NUMERIC,
        (p_eqs_components->>'regime_alignment')::NUMERIC,
        (p_eqs_components->>'temporal_coherence')::NUMERIC,
        (p_eqs_components->>'catalyst_present')::NUMERIC,
        (p_eqs_components->>'specificity_bonus')::NUMERIC,
        (p_eqs_components->>'testability_bonus')::NUMERIC,
        COALESCE((p_eqs_components->>'stress_modifier')::NUMERIC, 1.0),
        p_hypothesis_title,
        p_hypothesis_statement,
        p_hypothesis_category,
        p_executive_summary,
        p_sitc_plan_id,
        p_sitc_confidence,
        p_sitc_nodes_completed,
        p_sitc_nodes_total,
        p_asrp_hash,
        p_asrp_timestamp,
        p_state_vector_id,
        p_state_hash,
        p_price_witness_id,
        p_price_witness_symbol,
        p_price_witness_value,
        p_price_witness_source,
        p_price_witness_timestamp,
        p_regime_asset_id,
        p_regime_technical,
        p_regime_sovereign,
        p_regime_confidence,
        p_regime_crio_driver,
        p_regime_snapshot_timestamp,
        p_defcon_level,
        p_falsification_criteria,
        p_backtest_requirements,
        p_g2_exam_session_id,
        p_chain_of_query_hash,
        v_target_asset  -- Derived or explicit target asset
    ) RETURNING needle_id INTO v_needle_id;

    RETURN v_needle_id;
END;
$$;


--
-- Name: populate_sitc_chain_hash(uuid, text); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.populate_sitc_chain_hash(p_needle_id uuid, p_chain_hash text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE fhq_canonical.golden_needles
    SET chain_of_query_hash = p_chain_hash
    WHERE needle_id = p_needle_id;
END;
$$;


--
-- Name: postgres_fts_search(text, integer, regconfig); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.postgres_fts_search(p_query_text text, p_top_k integer DEFAULT 20, p_lang_config regconfig DEFAULT 'simple'::regconfig) RETURNS TABLE(evidence_id uuid, fts_rank real, content text, domain text, entity_type text)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        e.evidence_id,
        ts_rank_cd(e.content_tsvector, plainto_tsquery(p_lang_config, p_query_text)) as fts_rank,
        e.content,
        e.domain,
        e.entity_type
    FROM fhq_canonical.evidence_nodes e
    WHERE e.content_tsvector @@ plainto_tsquery(p_lang_config, p_query_text)
      AND (e.expires_at IS NULL OR e.expires_at > NOW())
      AND e.verification_status != 'FABRICATION'
    ORDER BY fts_rank DESC
    LIMIT p_top_k;
END;
$$;


--
-- Name: FUNCTION postgres_fts_search(p_query_text text, p_top_k integer, p_lang_config regconfig); Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON FUNCTION fhq_canonical.postgres_fts_search(p_query_text text, p_top_k integer, p_lang_config regconfig) IS '[C5] Postgres FTS search using ts_rank_cd (cover density ranking). NOT actual BM25, but similar heuristic. Use simple config for financial terms (C6).';


--
-- Name: protect_g4_2_parameters(); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.protect_g4_2_parameters() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF OLD.immutable = TRUE THEN
        RAISE EXCEPTION 'G4.2 parameter % is immutable (CEO Directive WAVE 16C)', OLD.parameter_name;
    END IF;
    RETURN NEW;
END;
$$;


--
-- Name: reconstruct_needle_audit(uuid); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.reconstruct_needle_audit(p_needle_id uuid) RETURNS TABLE(section text, question text, answer text)
    LANGUAGE plpgsql
    AS $_$
BEGIN
    RETURN QUERY
    WITH needle AS (
        SELECT * FROM fhq_canonical.golden_needles WHERE needle_id = p_needle_id
    )
    SELECT
        'DATA_OBSERVED'::TEXT,
        'What data was observed?'::TEXT,
        format('Price Witness: %s = $%s at %s (source: %s)',
               n.price_witness_symbol, n.price_witness_value,
               n.price_witness_timestamp, n.price_witness_source)
    FROM needle n

    UNION ALL

    SELECT
        'TIMING',
        'When was it observed?',
        format('Validation: %s | Created: %s | ASRP: %s',
               n.validation_timestamp, n.created_at, n.asrp_timestamp)
    FROM needle n

    UNION ALL

    SELECT
        'REGIME_CONTEXT',
        'Which regime context applied?',
        format('Regime: %s/%s (confidence: %s) | CRIO Driver: %s | DEFCON: %s',
               n.regime_sovereign, n.regime_technical, n.regime_confidence,
               n.regime_crio_driver, n.defcon_level)
    FROM needle n

    UNION ALL

    SELECT
        'ACCEPTANCE_REASON',
        'Why was this hypothesis accepted?',
        format('EQS: %s (threshold: %s) | Confluence Factors: %s/7 | SitC Confidence: %s',
               n.eqs_score, n.eqs_threshold_applied, n.confluence_factor_count,
               n.sitc_confidence_level)
    FROM needle n

    UNION ALL

    SELECT
        'CHECKS_PASSED',
        'Which checks passed?',
        format('Factors: %s',
               array_to_string(ARRAY_REMOVE(ARRAY[
                   CASE WHEN n.factor_price_technical THEN 'PRICE_TECHNICAL' END,
                   CASE WHEN n.factor_volume_confirmation THEN 'VOLUME_CONFIRMATION' END,
                   CASE WHEN n.factor_regime_alignment THEN 'REGIME_ALIGNMENT' END,
                   CASE WHEN n.factor_temporal_coherence THEN 'TEMPORAL_COHERENCE' END,
                   CASE WHEN n.factor_catalyst_present THEN 'CATALYST_PRESENT' END,
                   CASE WHEN n.factor_specific_testable THEN 'SPECIFIC_TESTABLE' END,
                   CASE WHEN n.factor_testable_criteria THEN 'TESTABLE_CRITERIA' END
               ], NULL), ', '))
    FROM needle n

    UNION ALL

    SELECT
        'INTEGRITY',
        'Canonical integrity hash?',
        n.canonical_hash
    FROM needle n;
END;
$_$;


--
-- Name: update_evidence_tsvector(); Type: FUNCTION; Schema: fhq_canonical; Owner: -
--

CREATE FUNCTION fhq_canonical.update_evidence_tsvector() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.content_tsvector := to_tsvector('simple', NEW.content);
    RETURN NEW;
END;
$$;


--
-- Name: calculate_cds(numeric, numeric); Type: FUNCTION; Schema: fhq_finn; Owner: -
--

CREATE FUNCTION fhq_finn.calculate_cds(p_narrative_score numeric, p_ssi_score numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$

DECLARE

    v_cds NUMERIC;

BEGIN

    -- CDS = Correlation coefficient between narrative overhype and structural fragility

    -- High positive narrative + High SSI = Extreme dissonance (structural top risk)



    -- Simplified: CDS = narrative_score  SSI_score (both normalized 0-1)

    v_cds := p_narrative_score * p_ssi_score;



    RETURN v_cds;

END;

$$;


--
-- Name: log_serper_event_insert(); Type: FUNCTION; Schema: fhq_finn; Owner: -
--

CREATE FUNCTION fhq_finn.log_serper_event_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

BEGIN

    INSERT INTO fhq_monitoring.system_event_log (

        event_type,

        severity,

        source_system,

        event_message,

        metadata

    ) VALUES (

        'SERPER_EVENT_INGESTED',

        'INFO',

        'serper_ingestor',

        'New external event detected: ' || NEW.title,

        jsonb_build_object(

            'event_id', NEW.event_id,

            'query_name', NEW.query_name,

            'event_type', NEW.event_type,

            'sentiment_score', NEW.sentiment_score,

            'url', NEW.url

        )

    );

    RETURN NEW;

END;

$$;


--
-- Name: FUNCTION log_serper_event_insert(); Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON FUNCTION fhq_finn.log_serper_event_insert() IS 'Audit trigger: Logs all Serper event insertions to system_event_log for BCBS 239 compliance.';


--
-- Name: trigger_serper_ingestion(); Type: FUNCTION; Schema: fhq_finn; Owner: -
--

CREATE FUNCTION fhq_finn.trigger_serper_ingestion() RETURNS TABLE(status text, message text)
    LANGUAGE plpgsql
    AS $$

BEGIN

    -- Log the manual trigger

    INSERT INTO fhq_monitoring.system_event_log (

        event_type,

        severity,

        source_system,

        event_message,

        metadata

    ) VALUES (

        'SERPER_INGESTION_TRIGGERED',

        'INFO',

        'manual_trigger',

        'Serper ingestion manually triggered',

        jsonb_build_object(

            'triggered_at', NOW(),

            'trigger_method', 'SQL function'

        )

    );



    -- Return status

    RETURN QUERY SELECT

        'SUCCESS'::TEXT as status,

        'Serper ingestion trigger logged. Run ingestor service externally.'::TEXT as message;

END;

$$;


--
-- Name: FUNCTION trigger_serper_ingestion(); Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON FUNCTION fhq_finn.trigger_serper_ingestion() IS 'Manual trigger for Serper ingestion. Logs event to system_event_log. Actual ingestion must be executed by external service.';


--
-- Name: validate_briefing_completeness(uuid); Type: FUNCTION; Schema: fhq_finn; Owner: -
--

CREATE FUNCTION fhq_finn.validate_briefing_completeness(briefing_uuid uuid) RETURNS TABLE(field_name text, is_complete boolean, issue text)
    LANGUAGE plpgsql
    AS $$

BEGIN

    RETURN QUERY

    SELECT

        'macro_summary'::TEXT,

        (macro_summary IS NOT NULL AND LENGTH(macro_summary) > 50),

        CASE WHEN macro_summary IS NULL THEN 'Missing macro summary'

             WHEN LENGTH(macro_summary) <= 50 THEN 'Macro summary too short'

             ELSE NULL END

    FROM fhq_finn.daily_briefings WHERE briefing_id = briefing_uuid



    UNION ALL



    SELECT

        'crypto_summary'::TEXT,

        (crypto_summary IS NOT NULL AND LENGTH(crypto_summary) > 50),

        CASE WHEN crypto_summary IS NULL THEN 'Missing crypto summary'

             WHEN LENGTH(crypto_summary) <= 50 THEN 'Crypto summary too short'

             ELSE NULL END

    FROM fhq_finn.daily_briefings WHERE briefing_id = briefing_uuid



    UNION ALL



    SELECT

        'top_signals'::TEXT,

        (jsonb_array_length(top_signals) >= 3),

        CASE WHEN jsonb_array_length(top_signals) < 3 THEN 'Insufficient top signals (min 3)'

             ELSE NULL END

    FROM fhq_finn.daily_briefings WHERE briefing_id = briefing_uuid;

END;

$$;


--
-- Name: FUNCTION validate_briefing_completeness(briefing_uuid uuid); Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON FUNCTION fhq_finn.validate_briefing_completeness(briefing_uuid uuid) IS 'ISO 8000-110 data quality validation for daily briefings';


--
-- Name: validate_input_contract(jsonb, text); Type: FUNCTION; Schema: fhq_finn; Owner: -
--

CREATE FUNCTION fhq_finn.validate_input_contract(input_data jsonb, contract_version text DEFAULT 'v1.0'::text) RETURNS TABLE(is_valid boolean, errors jsonb)
    LANGUAGE plpgsql
    AS $$
DECLARE
    required_fields TEXT[] := ARRAY['asset_id', 'timestamp', 'price', 'volume', 'indicators', 'sentiment', 'onchain', 'macro', 'metadata'];
    missing_fields TEXT[];
    validation_errors JSONB := '[]'::jsonb;
BEGIN
    -- Check required top-level fields
    SELECT ARRAY_AGG(field)
    INTO missing_fields
    FROM UNNEST(required_fields) AS field
    WHERE NOT (input_data ? field);
    
    IF missing_fields IS NOT NULL THEN
        validation_errors := validation_errors || jsonb_build_object(
            'error_type', 'missing_required_field',
            'fields', missing_fields
        );
    END IF;
    
    -- Check indicators required fields
    IF input_data ? 'indicators' THEN
        DECLARE
            required_indicators TEXT[] := ARRAY['rsi_14', 'macd', 'macd_signal', 'macd_hist', 'bb_upper', 'bb_middle', 'bb_lower', 'ema_20', 'sma_50'];
            missing_indicators TEXT[];
        BEGIN
            SELECT ARRAY_AGG(ind)
            INTO missing_indicators
            FROM UNNEST(required_indicators) AS ind
            WHERE NOT (input_data->'indicators' ? ind);
            
            IF missing_indicators IS NOT NULL THEN
                validation_errors := validation_errors || jsonb_build_object(
                    'error_type', 'missing_required_indicators',
                    'indicators', missing_indicators
                );
            END IF;
        END;
    END IF;
    
    RETURN QUERY SELECT 
        (validation_errors = '[]'::jsonb) AS is_valid,
        validation_errors AS errors;
END;
$$;


--
-- Name: FUNCTION validate_input_contract(input_data jsonb, contract_version text); Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON FUNCTION fhq_finn.validate_input_contract(input_data jsonb, contract_version text) IS 'ADR-052 Input Contract Validator - Validates FINN input data against schema';


--
-- Name: validate_output_contract(jsonb, text); Type: FUNCTION; Schema: fhq_finn; Owner: -
--

CREATE FUNCTION fhq_finn.validate_output_contract(output_data jsonb, contract_version text DEFAULT 'v1.0'::text) RETURNS TABLE(is_valid boolean, errors jsonb)
    LANGUAGE plpgsql
    AS $$
DECLARE
    required_fields TEXT[] := ARRAY['timestamp', 'asset_id', 'regime', 'prediction', 'anomaly', 'ensemble_decision', 'confidence', 'explanation'];
    missing_fields TEXT[];
    validation_errors JSONB := '[]'::jsonb;
    valid_decisions TEXT[] := ARRAY['BUY', 'SELL', 'HOLD', 'WATCH'];
BEGIN
    -- Check required fields
    SELECT ARRAY_AGG(field)
    INTO missing_fields
    FROM UNNEST(required_fields) AS field
    WHERE NOT (output_data ? field);
    
    IF missing_fields IS NOT NULL THEN
        validation_errors := validation_errors || jsonb_build_object(
            'error_type', 'missing_required_field',
            'fields', missing_fields
        );
    END IF;
    
    -- Validate ensemble_decision enum
    IF output_data ? 'ensemble_decision' THEN
        IF NOT (output_data->>'ensemble_decision' = ANY(valid_decisions)) THEN
            validation_errors := validation_errors || jsonb_build_object(
                'error_type', 'invalid_enum_value',
                'field', 'ensemble_decision',
                'value', output_data->>'ensemble_decision',
                'allowed', valid_decisions
            );
        END IF;
    END IF;
    
    -- Validate confidence range
    IF output_data ? 'confidence' THEN
        DECLARE
            conf NUMERIC := (output_data->>'confidence')::NUMERIC;
        BEGIN
            IF conf < 0 OR conf > 1 THEN
                validation_errors := validation_errors || jsonb_build_object(
                    'error_type', 'value_out_of_range',
                    'field', 'confidence',
                    'value', conf,
                    'allowed_range', '[0, 1]'
                );
            END IF;
        END;
    END IF;
    
    RETURN QUERY SELECT 
        (validation_errors = '[]'::jsonb) AS is_valid,
        validation_errors AS errors;
END;
$$;


--
-- Name: FUNCTION validate_output_contract(output_data jsonb, contract_version text); Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON FUNCTION fhq_finn.validate_output_contract(output_data jsonb, contract_version text) IS 'ADR-052 Output Contract Validator - Validates FINN output data against schema';


--
-- Name: activate_calibration(text, text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.activate_calibration(p_parameter_name text, p_version text, p_activated_by text DEFAULT 'STIG'::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_id INTEGER;
    v_value NUMERIC;
    v_old_version TEXT;
BEGIN
    -- Validate calibration is frozen and approved
    SELECT id, value INTO v_id, v_value
    FROM fhq_governance.calibration_versions
    WHERE parameter_name = p_parameter_name
      AND version = p_version
      AND frozen_at IS NOT NULL
      AND vega_approval_ref IS NOT NULL;

    IF v_id IS NULL THEN
        RAISE EXCEPTION 'Calibration must be frozen and VEGA-approved before activation';
    END IF;

    -- Get old active version
    SELECT version INTO v_old_version
    FROM fhq_governance.calibration_versions
    WHERE parameter_name = p_parameter_name
      AND is_active = TRUE;

    -- Deactivate old version
    UPDATE fhq_governance.calibration_versions
    SET is_active = FALSE,
        deactivated_at = NOW(),
        updated_at = NOW()
    WHERE parameter_name = p_parameter_name
      AND is_active = TRUE;

    -- Activate new version
    UPDATE fhq_governance.calibration_versions
    SET is_active = TRUE,
        activated_at = NOW(),
        updated_at = NOW()
    WHERE id = v_id;

    -- Log activation
    INSERT INTO fhq_governance.calibration_audit_log (
        calibration_id, parameter_name, version, action,
        new_value, actor, metadata
    ) VALUES (
        v_id, p_parameter_name, p_version, 'ACTIVATED',
        v_value, p_activated_by,
        jsonb_build_object('previous_version', v_old_version)
    );

    RETURN TRUE;
END;
$$;


--
-- Name: advance_fmcl_stage(uuid, text, jsonb); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.advance_fmcl_stage(p_failure_mode_id uuid, p_new_stage text, p_evidence jsonb DEFAULT '{}'::jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_current_stage TEXT;
    v_current_entered TIMESTAMPTZ;
    v_hours_in_stage NUMERIC;
    v_result JSONB;
BEGIN
    -- Get current stage
    SELECT fmcl_stage, fmcl_stage_entered_at
    INTO v_current_stage, v_current_entered
    FROM fhq_governance.failure_mode_registry
    WHERE failure_mode_id = p_failure_mode_id;

    IF NOT FOUND THEN
        RETURN jsonb_build_object('success', false, 'error', 'Failure mode not found');
    END IF;

    -- Calculate time in current stage
    v_hours_in_stage := EXTRACT(EPOCH FROM (NOW() - v_current_entered)) / 3600;

    -- Validate stage transition (must be sequential)
    IF NOT (
        (v_current_stage = 'CAPTURE' AND p_new_stage = 'DIAGNOSIS') OR
        (v_current_stage = 'DIAGNOSIS' AND p_new_stage = 'ACTION_DEFINITION') OR
        (v_current_stage = 'ACTION_DEFINITION' AND p_new_stage = 'RETEST') OR
        (v_current_stage = 'RETEST' AND p_new_stage = 'CLOSED') OR
        (v_current_stage = 'RETEST' AND p_new_stage = 'ACTION_DEFINITION')  -- Allow regression for failed retest
    ) THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', format('Invalid transition: %s  %s', v_current_stage, p_new_stage)
        );
    END IF;

    -- Update stage and timing
    UPDATE fhq_governance.failure_mode_registry
    SET
        fmcl_stage = p_new_stage,
        fmcl_stage_entered_at = NOW(),
        updated_at = NOW(),
        -- Update stage-specific timestamps
        diagnosis_started_at = CASE WHEN p_new_stage = 'DIAGNOSIS' THEN NOW() ELSE diagnosis_started_at END,
        diagnosis_completed_at = CASE WHEN v_current_stage = 'DIAGNOSIS' AND p_new_stage = 'ACTION_DEFINITION' THEN NOW() ELSE diagnosis_completed_at END,
        action_defined_at = CASE WHEN p_new_stage = 'ACTION_DEFINITION' THEN NOW() ELSE action_defined_at END,
        retest_started_at = CASE WHEN p_new_stage = 'RETEST' THEN NOW() ELSE retest_started_at END,
        retest_completed_at = CASE WHEN v_current_stage = 'RETEST' AND p_new_stage = 'CLOSED' THEN NOW() ELSE retest_completed_at END,
        closed_at = CASE WHEN p_new_stage = 'CLOSED' THEN NOW() ELSE closed_at END,
        -- Update time tracking
        time_in_capture_hours = CASE WHEN v_current_stage = 'CAPTURE' THEN v_hours_in_stage ELSE time_in_capture_hours END,
        time_in_diagnosis_hours = CASE WHEN v_current_stage = 'DIAGNOSIS' THEN v_hours_in_stage ELSE time_in_diagnosis_hours END,
        time_in_action_hours = CASE WHEN v_current_stage = 'ACTION_DEFINITION' THEN v_hours_in_stage ELSE time_in_action_hours END,
        time_in_retest_hours = CASE WHEN v_current_stage = 'RETEST' THEN v_hours_in_stage ELSE time_in_retest_hours END,
        -- Update evidence
        diagnosis_result = CASE WHEN p_new_stage = 'ACTION_DEFINITION' THEN COALESCE(p_evidence, diagnosis_result) ELSE diagnosis_result END,
        action_evidence = CASE WHEN p_new_stage = 'RETEST' THEN COALESCE(p_evidence, action_evidence) ELSE action_evidence END,
        retest_evidence = CASE WHEN p_new_stage = 'CLOSED' OR (v_current_stage = 'RETEST' AND p_new_stage = 'ACTION_DEFINITION') THEN COALESCE(p_evidence, retest_evidence) ELSE retest_evidence END,
        closure_evidence = CASE WHEN p_new_stage = 'CLOSED' THEN p_evidence ELSE closure_evidence END
    WHERE failure_mode_id = p_failure_mode_id;

    -- Calculate total resolution time if closed
    IF p_new_stage = 'CLOSED' THEN
        UPDATE fhq_governance.failure_mode_registry
        SET total_resolution_hours = COALESCE(time_in_capture_hours, 0) +
                                     COALESCE(time_in_diagnosis_hours, 0) +
                                     COALESCE(time_in_action_hours, 0) +
                                     COALESCE(time_in_retest_hours, 0)
        WHERE failure_mode_id = p_failure_mode_id;
    END IF;

    RETURN jsonb_build_object(
        'success', true,
        'failure_mode_id', p_failure_mode_id,
        'previous_stage', v_current_stage,
        'new_stage', p_new_stage,
        'hours_in_previous_stage', ROUND(v_hours_in_stage, 2)
    );
END;
$$;


--
-- Name: FUNCTION advance_fmcl_stage(p_failure_mode_id uuid, p_new_stage text, p_evidence jsonb); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.advance_fmcl_stage(p_failure_mode_id uuid, p_new_stage text, p_evidence jsonb) IS 'CEO-DIR-2026-052: Advance failure mode through FMCL lifecycle.
Validates sequential transitions and tracks timing metrics.';


--
-- Name: append_agent_memory(text, text, text, text, timestamp with time zone, text, jsonb); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.append_agent_memory(p_agent_id text, p_agent_tier text, p_memory_type text, p_state_hash text, p_state_timestamp timestamp with time zone, p_summary text, p_payload jsonb DEFAULT NULL::jsonb) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_memory_id UUID;
    v_sequence BIGINT;
    v_prev_hash TEXT;
    v_memory_hash TEXT;
BEGIN
    -- Get next sequence number and previous hash
    SELECT
        COALESCE(MAX(sequence_number), 0) + 1,
        memory_hash
    INTO v_sequence, v_prev_hash
    FROM fhq_governance.agent_memory_ledger
    WHERE agent_id = p_agent_id
    ORDER BY sequence_number DESC
    LIMIT 1;

    IF v_sequence IS NULL THEN
        v_sequence := 1;
    END IF;

    -- Compute memory hash (chain link)
    v_memory_hash := encode(sha256((
        p_agent_id || ':' ||
        v_sequence::TEXT || ':' ||
        p_memory_type || ':' ||
        p_state_hash || ':' ||
        COALESCE(v_prev_hash, 'GENESIS') || ':' ||
        NOW()::TEXT
    )::bytea), 'hex');

    -- Insert memory entry
    INSERT INTO fhq_governance.agent_memory_ledger (
        agent_id,
        agent_tier,
        memory_type,
        state_vector_hash,
        state_timestamp,
        memory_summary,
        memory_payload,
        sequence_number,
        previous_memory_hash,
        memory_hash
    ) VALUES (
        p_agent_id,
        p_agent_tier,
        p_memory_type,
        p_state_hash,
        p_state_timestamp,
        p_summary,
        p_payload,
        v_sequence,
        v_prev_hash,
        v_memory_hash
    ) RETURNING memory_id INTO v_memory_id;

    RETURN v_memory_id;
END;
$$;


--
-- Name: FUNCTION append_agent_memory(p_agent_id text, p_agent_tier text, p_memory_type text, p_state_hash text, p_state_timestamp timestamp with time zone, p_summary text, p_payload jsonb); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.append_agent_memory(p_agent_id text, p_agent_tier text, p_memory_type text, p_state_hash text, p_state_timestamp timestamp with time zone, p_summary text, p_payload jsonb) IS 'Append entry to agent memory ledger with hash chain integrity.
Per CEO Directive v2.0: All agent actions must be logged with state context.';


--
-- Name: attest_ldow_failure_correction(uuid, text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.attest_ldow_failure_correction(p_incident_id uuid, p_attested_by text, p_attestation_notes text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_current_status TEXT;
BEGIN
    -- Check current status
    SELECT incident_status INTO v_current_status
    FROM fhq_governance.ldow_failure_incidents
    WHERE incident_id = p_incident_id;

    IF v_current_status IS NULL THEN
        RAISE EXCEPTION 'Incident % not found', p_incident_id;
    END IF;

    IF v_current_status != 'CORRECTION_APPLIED' THEN
        RAISE EXCEPTION 'Incident must be in CORRECTION_APPLIED status (current: %)', v_current_status;
    END IF;

    -- Update with attestation
    UPDATE fhq_governance.ldow_failure_incidents
    SET
        vega_attestation_id = gen_random_uuid(),
        vega_attested_at = NOW(),
        vega_attestation_notes = p_attestation_notes,
        incident_status = 'VEGA_ATTESTED'
    WHERE incident_id = p_incident_id;

    -- Log attestation
    INSERT INTO fhq_governance.governance_actions_log (
        action_type,
        action_target,
        action_target_type,
        initiated_by,
        decision,
        decision_rationale,
        metadata
    ) VALUES (
        'LDOW_FAILURE_ATTESTATION',
        p_incident_id::TEXT,
        'FAILURE_INCIDENT',
        p_attested_by,
        'ATTESTED',
        'VEGA attestation: Correction validated, retry may be authorized',
        jsonb_build_object(
            'incident_id', p_incident_id,
            'attestation_notes', p_attestation_notes,
            'timestamp', NOW()
        )
    );

    RETURN TRUE;
END;
$$;


--
-- Name: authorize_ael_intervention(uuid, text, uuid); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.authorize_ael_intervention(p_intervention_id uuid, p_authorized_by text, p_evidence_id uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_current_status TEXT;
    v_category TEXT;
BEGIN
    -- Get current status
    SELECT intervention_status, intervention_category
    INTO v_current_status, v_category
    FROM fhq_governance.ael_intervention_registry
    WHERE intervention_id = p_intervention_id;

    IF v_current_status IS NULL THEN
        RAISE EXCEPTION 'Intervention % not found', p_intervention_id;
    END IF;

    IF v_current_status != 'PROPOSED' THEN
        RAISE EXCEPTION 'Intervention % is not in PROPOSED status (current: %)', p_intervention_id, v_current_status;
    END IF;

    -- Update to APPROVED
    UPDATE fhq_governance.ael_intervention_registry
    SET
        intervention_status = 'APPROVED',
        approved_by = p_authorized_by,
        approved_at = NOW(),
        evidence_id = p_evidence_id,
        ael_phase = 2  -- Phase 2: Authorized
    WHERE intervention_id = p_intervention_id;

    -- Log authorization
    INSERT INTO fhq_governance.governance_actions_log (
        action_type,
        action_target,
        action_target_type,
        initiated_by,
        decision,
        decision_rationale,
        metadata
    ) VALUES (
        'AEL_INTERVENTION_AUTHORIZED',
        p_intervention_id::TEXT,
        'INTERVENTION',
        p_authorized_by,
        'APPROVED',
        'ADR-024 Rung D: Human authorization granted',
        jsonb_build_object(
            'evidence_id', p_evidence_id,
            'timestamp', NOW()
        )
    );

    RETURN TRUE;
END;
$$;


--
-- Name: authorize_ldow_retry(uuid, text, boolean); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.authorize_ldow_retry(p_incident_id uuid, p_authorized_by text, p_reset_counter boolean DEFAULT true) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_current_status TEXT;
    v_cycle_number INTEGER;
BEGIN
    -- Check current status
    SELECT incident_status, cycle_number
    INTO v_current_status, v_cycle_number
    FROM fhq_governance.ldow_failure_incidents
    WHERE incident_id = p_incident_id;

    IF v_current_status IS NULL THEN
        RAISE EXCEPTION 'Incident % not found', p_incident_id;
    END IF;

    IF v_current_status != 'VEGA_ATTESTED' THEN
        RAISE EXCEPTION 'Incident must be VEGA_ATTESTED before retry authorization (current: %)', v_current_status;
    END IF;

    -- Authorize retry
    UPDATE fhq_governance.ldow_failure_incidents
    SET
        retry_authorized = TRUE,
        retry_authorized_at = NOW(),
        retry_resets_counter = p_reset_counter,
        incident_status = 'RETRY_AUTHORIZED'
    WHERE incident_id = p_incident_id;

    -- If counter reset required, reset all cycles to SCHEDULED
    IF p_reset_counter THEN
        UPDATE fhq_governance.ldow_cycle_completion
        SET
            completion_status = 'SCHEDULED',
            started_at = NULL,
            completed_at = NULL,
            forecasts_eligible = 0,
            forecasts_paired = 0,
            forecasts_expired = 0,
            brier_score_run1 = NULL,
            brier_score_run2 = NULL,
            calibration_error = NULL,
            hit_rate = NULL,
            damper_hash_at_end = NULL,
            evidence_id = NULL,
            vega_attestation_id = NULL,
            vega_attested_at = NULL
        WHERE cycle_number >= v_cycle_number;

        -- Log counter reset
        INSERT INTO fhq_governance.governance_actions_log (
            action_type,
            action_target,
            action_target_type,
            initiated_by,
            decision,
            decision_rationale,
            metadata
        ) VALUES (
            'LDOW_COUNTER_RESET',
            'ldow_cycle_completion',
            'TABLE',
            p_authorized_by,
            'EXECUTED',
            'CEO Directive: Correction resets LDOW counter. Cycles must be re-run from scratch.',
            jsonb_build_object(
                'incident_id', p_incident_id,
                'reset_from_cycle', v_cycle_number,
                'timestamp', NOW()
            )
        );
    END IF;

    RETURN TRUE;
END;
$$;


--
-- Name: calculate_asymmetric_safety_margin(numeric); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.calculate_asymmetric_safety_margin(p_historical_accuracy numeric) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
    -- Asymmetric safety margin: keeps humility longer than optimism
    -- +5% when accuracy < 50%
    -- +2% when accuracy >= 50% and < 60%
    -- +0% when accuracy >= 60%
    CASE
        WHEN p_historical_accuracy < 0.50 THEN RETURN 0.05;
        WHEN p_historical_accuracy < 0.60 THEN RETURN 0.02;
        ELSE RETURN 0.00;
    END CASE;
END;
$$;


--
-- Name: FUNCTION calculate_asymmetric_safety_margin(p_historical_accuracy numeric); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.calculate_asymmetric_safety_margin(p_historical_accuracy numeric) IS 'Hardening #2: Asymmetric safety margin prevents confidence from outrunning truth during recovery.
     +5% below 50%, +2% at 50-60%, +0% above 60%.';


--
-- Name: calculate_dynamic_slippage(text, numeric); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.calculate_dynamic_slippage(p_canonical_id text, p_base_slippage numeric DEFAULT 0.0005) RETURNS TABLE(effective_slippage numeric, volatility_multiplier numeric, liquidity_multiplier numeric, rule_applied text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_volatility NUMERIC;
    v_liquidity_tier TEXT;
    v_vol_mult NUMERIC := 1.0;
    v_liq_mult NUMERIC := 1.0;
    v_slippage NUMERIC;
    v_rule TEXT;
BEGIN
    -- Get recent volatility using subquery
    SELECT COALESCE(STDDEV(returns), 0.02)
    INTO v_volatility
    FROM (
        SELECT (close - LAG(close) OVER (ORDER BY timestamp)) / NULLIF(LAG(close) OVER (ORDER BY timestamp), 0) as returns
        FROM fhq_market.prices
        WHERE canonical_id = p_canonical_id
        AND timestamp >= NOW() - INTERVAL '5 days'
    ) sub
    WHERE returns IS NOT NULL;

    -- Get liquidity tier from asset metadata
    SELECT COALESCE(liquidity_tier, 'TIER_2')
    INTO v_liquidity_tier
    FROM fhq_meta.assets
    WHERE canonical_id = p_canonical_id;

    -- VOLATILITY MULTIPLIER
    IF v_volatility > 0.04 THEN
        v_vol_mult := 2.0;
        v_rule := 'HIGH_VOLATILITY';
    ELSIF v_volatility > 0.025 THEN
        v_vol_mult := 1.5;
        v_rule := 'ELEVATED_VOLATILITY';
    ELSE
        v_vol_mult := 1.0;
        v_rule := 'NORMAL_VOLATILITY';
    END IF;

    -- LIQUIDITY MULTIPLIER
    CASE v_liquidity_tier
        WHEN 'TIER_1' THEN v_liq_mult := 1.0;
        WHEN 'TIER_2' THEN v_liq_mult := 1.5;
        WHEN 'TIER_3' THEN v_liq_mult := 2.5;
        ELSE v_liq_mult := 2.0;
    END CASE;

    v_rule := v_rule || '_' || COALESCE(v_liquidity_tier, 'TIER_2');
    v_slippage := LEAST(0.01, GREATEST(p_base_slippage, p_base_slippage * v_vol_mult * v_liq_mult));

    RETURN QUERY SELECT v_slippage, v_vol_mult, v_liq_mult, v_rule;
END;
$$;


--
-- Name: calculate_info_weighted_size(numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.calculate_info_weighted_size(p_base_size numeric, p_calibrated_confidence numeric, p_novelty_score numeric DEFAULT 0.5, p_max_position_pct numeric DEFAULT 0.10) RETURNS TABLE(weighted_size numeric, confidence_factor numeric, novelty_factor numeric, info_gain_estimate numeric)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_conf_factor NUMERIC;
    v_novelty_factor NUMERIC;
    v_info_gain NUMERIC;
    v_weighted_size NUMERIC;
BEGIN
    -- Confidence factor: higher confidence = larger position (linear)
    v_conf_factor := p_calibrated_confidence;

    -- Novelty factor: higher novelty = we want to learn more = slightly larger position
    -- But capped to avoid overexposure to unknown situations
    v_novelty_factor := LEAST(1.2, 0.8 + (p_novelty_score * 0.4));

    -- Information gain estimate: combination of confidence and novelty
    v_info_gain := v_conf_factor * v_novelty_factor;

    -- Calculate weighted size (capped at max position %)
    v_weighted_size := LEAST(
        p_base_size * v_conf_factor * v_novelty_factor,
        p_max_position_pct
    );

    RETURN QUERY SELECT v_weighted_size, v_conf_factor, v_novelty_factor, v_info_gain;
END;
$$;


--
-- Name: calculate_novelty_score(text, text, text, uuid); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.calculate_novelty_score(p_canonical_id text, p_direction text, p_current_regime text, p_trade_id uuid DEFAULT NULL::uuid) RETURNS TABLE(novelty_score numeric, regime_shift_component numeric, asset_novelty_component numeric, signal_disagreement_component numeric, explanation jsonb)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_regime_score NUMERIC := 0;
    v_regime_reason TEXT;
    v_asset_score NUMERIC := 0;
    v_asset_reason TEXT;
    v_signal_score NUMERIC := 0;
    v_signal_reason TEXT;
    v_last_regime TEXT;
    v_asset_trade_count INTEGER;
    v_recent_same_direction INTEGER;
    v_recent_opposite_direction INTEGER;
    v_explanation JSONB;
BEGIN
    -- COMPONENT 1: Regime Shift (0-0.4)
    -- Check if regime changed since last belief state
    SELECT dominant_regime INTO v_last_regime
    FROM fhq_perception.model_belief_state
    WHERE created_at < NOW()
    ORDER BY created_at DESC
    OFFSET 1 LIMIT 1;

    IF v_last_regime IS NOT NULL AND v_last_regime != p_current_regime THEN
        v_regime_score := 0.4;
        v_regime_reason := format('Regime shift: %s  %s', v_last_regime, p_current_regime);
    ELSIF v_last_regime IS NULL THEN
        v_regime_score := 0.2;
        v_regime_reason := 'No prior regime data (exploratory)';
    ELSE
        v_regime_score := 0.0;
        v_regime_reason := format('Stable regime: %s', p_current_regime);
    END IF;

    -- COMPONENT 2: Asset Novelty (0-0.3)
    -- How many times have we traded this asset in last 7 days?
    SELECT COUNT(*) INTO v_asset_trade_count
    FROM fhq_governance.paper_ledger
    WHERE canonical_id = p_canonical_id
    AND decision_timestamp >= NOW() - INTERVAL '7 days';

    IF v_asset_trade_count = 0 THEN
        v_asset_score := 0.3;
        v_asset_reason := 'First trade on this asset in 7 days';
    ELSIF v_asset_trade_count < 3 THEN
        v_asset_score := 0.15;
        v_asset_reason := format('Limited history: %s trades in 7 days', v_asset_trade_count);
    ELSE
        v_asset_score := 0.0;
        v_asset_reason := format('Well-traded asset: %s trades in 7 days', v_asset_trade_count);
    END IF;

    -- COMPONENT 3: Signal Disagreement (0-0.3)
    -- Are we going against recent direction for this asset?
    SELECT
        COUNT(*) FILTER (WHERE direction = p_direction),
        COUNT(*) FILTER (WHERE direction != p_direction)
    INTO v_recent_same_direction, v_recent_opposite_direction
    FROM fhq_governance.paper_ledger
    WHERE canonical_id = p_canonical_id
    AND decision_timestamp >= NOW() - INTERVAL '48 hours';

    IF v_recent_opposite_direction > v_recent_same_direction AND v_recent_same_direction > 0 THEN
        v_signal_score := 0.3;
        v_signal_reason := format('Contrarian signal: %s opposite vs %s same in 48h',
                                   v_recent_opposite_direction, v_recent_same_direction);
    ELSIF v_recent_same_direction = 0 AND v_recent_opposite_direction = 0 THEN
        v_signal_score := 0.15;
        v_signal_reason := 'No recent signals for comparison';
    ELSE
        v_signal_score := 0.0;
        v_signal_reason := format('Consensus signal: %s same vs %s opposite in 48h',
                                   v_recent_same_direction, v_recent_opposite_direction);
    END IF;

    v_explanation := jsonb_build_object(
        'regime_shift', jsonb_build_object('score', v_regime_score, 'reason', v_regime_reason),
        'asset_novelty', jsonb_build_object('score', v_asset_score, 'reason', v_asset_reason),
        'signal_disagreement', jsonb_build_object('score', v_signal_score, 'reason', v_signal_reason),
        'total', v_regime_score + v_asset_score + v_signal_score
    );

    -- Log components if trade_id provided
    IF p_trade_id IS NOT NULL THEN
        INSERT INTO fhq_governance.novelty_score_components (
            trade_id, regime_shift_score, regime_shift_reason,
            asset_novelty_score, asset_novelty_reason,
            signal_disagreement_score, signal_disagreement_reason
        ) VALUES (
            p_trade_id, v_regime_score, v_regime_reason,
            v_asset_score, v_asset_reason,
            v_signal_score, v_signal_reason
        );
    END IF;

    RETURN QUERY SELECT
        v_regime_score + v_asset_score + v_signal_score,
        v_regime_score,
        v_asset_score,
        v_signal_score,
        v_explanation;
END;
$$;


--
-- Name: can_exit_cognitive_fasting(numeric, numeric, boolean, boolean); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.can_exit_cognitive_fasting(p_data_freshness_hours numeric, p_belief_confidence numeric, p_evidence_attachment_ok boolean, p_cnrp_completed boolean) RETURNS TABLE(can_exit boolean, exit_reason text, blocking_conditions jsonb)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_conditions JSONB;
BEGIN
    -- Build conditions object
    v_conditions := jsonb_build_object(
        'data_freshness_ok', p_data_freshness_hours <= 12,
        'confidence_ok', p_belief_confidence >= 0.70,
        'evidence_ok', p_evidence_attachment_ok,
        'cnrp_ok', p_cnrp_completed,
        'data_freshness_hours', p_data_freshness_hours,
        'belief_confidence', p_belief_confidence
    );

    -- CEO Presisering 4: ALL conditions must be TRUE to exit
    IF p_data_freshness_hours <= 12
       AND p_belief_confidence >= 0.70
       AND p_evidence_attachment_ok = TRUE
       AND p_cnrp_completed = TRUE
    THEN
        RETURN QUERY SELECT
            TRUE,
            'All exit conditions met - can resume execution'::TEXT,
            v_conditions;
    ELSE
        RETURN QUERY SELECT
            FALSE,
            CASE
                WHEN p_data_freshness_hours > 12 THEN 'Data freshness exceeds 12h threshold'
                WHEN p_belief_confidence < 0.70 THEN 'Confidence below 0.70 threshold'
                WHEN NOT p_evidence_attachment_ok THEN 'Evidence attachment failed'
                WHEN NOT p_cnrp_completed THEN 'CNRP not completed'
                ELSE 'Unknown blocking condition'
            END::TEXT,
            v_conditions;
    END IF;
END;
$$;


--
-- Name: FUNCTION can_exit_cognitive_fasting(p_data_freshness_hours numeric, p_belief_confidence numeric, p_evidence_attachment_ok boolean, p_cnrp_completed boolean); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.can_exit_cognitive_fasting(p_data_freshness_hours numeric, p_belief_confidence numeric, p_evidence_attachment_ok boolean, p_cnrp_completed boolean) IS 'CEO-DIR-2026-019 Presisering 4: Mekanisk presis exit condition for cognitive fasting.
ALL conditions must be TRUE: freshness<=12h, confidence>=0.70, evidence_ok, cnrp_completed';


--
-- Name: capture_temporal_snapshot(text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.capture_temporal_snapshot(p_event_type text, p_event_trigger text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_snapshot_id UUID;
    v_defcon_level TEXT;
    v_regime_label TEXT;
    v_regime_confidence NUMERIC(5,4);
    v_needle_count INT;
    v_snapshot_data JSONB;
    v_snapshot_hash TEXT;
BEGIN
    -- Capture current state
    SELECT current_level INTO v_defcon_level
    FROM fhq_monitoring.defcon_status
    ORDER BY activated_at DESC LIMIT 1;

    SELECT regime_label, regime_confidence
    INTO v_regime_label, v_regime_confidence
    FROM fhq_finn.v_btc_regime_current LIMIT 1;

    SELECT COUNT(*) INTO v_needle_count
    FROM fhq_canonical.golden_needles
    WHERE is_current = TRUE;

    -- Build snapshot data for hashing
    v_snapshot_data := jsonb_build_object(
        'event_type', p_event_type,
        'event_trigger', p_event_trigger,
        'defcon_level', v_defcon_level,
        'regime_label', v_regime_label,
        'regime_confidence', v_regime_confidence,
        'needle_count', v_needle_count,
        'timestamp', NOW()
    );

    -- Compute hash
    v_snapshot_hash := encode(sha256(v_snapshot_data::TEXT::BYTEA), 'hex');

    -- Insert snapshot
    INSERT INTO fhq_governance.ceo_temporal_snapshots (
        event_type,
        event_trigger,
        event_timestamp,
        defcon_level,
        regime_label,
        regime_confidence,
        active_needle_count,
        snapshot_hash
    ) VALUES (
        p_event_type,
        p_event_trigger,
        NOW(),
        v_defcon_level,
        v_regime_label,
        v_regime_confidence,
        v_needle_count,
        v_snapshot_hash
    ) RETURNING snapshot_id INTO v_snapshot_id;

    RETURN v_snapshot_id;
END;
$$;


--
-- Name: FUNCTION capture_temporal_snapshot(p_event_type text, p_event_trigger text); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.capture_temporal_snapshot(p_event_type text, p_event_trigger text) IS 'CEO-DIR-2026-01-03-PHASE-B: Captures system state snapshot at significant events';


--
-- Name: categorize_regret_magnitude(numeric); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.categorize_regret_magnitude(p_regret_magnitude numeric) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
  CASE
    WHEN p_regret_magnitude < 0.02 THEN RETURN 'LOW';
    WHEN p_regret_magnitude < 0.05 THEN RETURN 'MEDIUM';
    WHEN p_regret_magnitude < 0.10 THEN RETURN 'HIGH';
    ELSE RETURN 'EXTREME';
  END CASE;
END;
$$;


--
-- Name: check_aiqf_pass(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.check_aiqf_pass() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    threshold FLOAT;
BEGIN
    SELECT pass_threshold INTO threshold
    FROM fhq_governance.aiqf_benchmark_registry
    WHERE benchmark_id = NEW.benchmark_id;

    NEW.passed := NEW.aiqf_score >= COALESCE(threshold, 0.95);

    IF NEW.gate_decision IS NULL THEN
        NEW.gate_decision := CASE
            WHEN NEW.passed THEN 'PASS'
            ELSE 'FAIL'
        END;
    END IF;

    RETURN NEW;
END;
$$;


--
-- Name: check_api_budget(text, text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.check_api_budget(p_agent_id text, p_provider text, p_priority text DEFAULT 'NORMAL'::text) RETURNS TABLE(allowed boolean, remaining_quota integer, tier_name text, reason text)
    LANGUAGE plpgsql
    AS $$

DECLARE

    v_policy RECORD;

    v_provider_info RECORD;

    v_used_today INTEGER;

    v_tier TEXT;

BEGIN

    -- Get provider info

    SELECT * INTO v_provider_info

    FROM fhq_governance.api_provider_registry

    WHERE provider_name = UPPER(p_provider) AND is_active = TRUE;



    IF NOT FOUND THEN

        RETURN QUERY SELECT FALSE, 0, 'UNKNOWN'::TEXT, 'Provider not registered or inactive';

        RETURN;

    END IF;



    v_tier := v_provider_info.usage_tier;



    -- Get agent policy for this tier

    SELECT * INTO v_policy

    FROM fhq_governance.data_provider_policy dpp

    WHERE dpp.agent_id = p_agent_id

      AND dpp.usage_tier = v_tier

      AND UPPER(p_provider) = ANY(dpp.authorized_providers);



    IF NOT FOUND THEN

        RETURN QUERY SELECT FALSE, 0, v_tier, 'Agent not authorized for this provider';

        RETURN;

    END IF;



    -- Check priority requirements for SNIPER tier

    IF v_tier = 'SNIPER' AND p_priority != 'CRITICAL' THEN

        RETURN QUERY SELECT FALSE, v_policy.daily_quota, v_tier,

            'SNIPER tier requires CRITICAL priority (VEGA Guardrail)';

        RETURN;

    END IF;



    -- Calculate usage today

    SELECT COALESCE(SUM(abl.credits_used), 0) INTO v_used_today

    FROM fhq_monitoring.api_budget_log abl

    WHERE abl.agent_id = p_agent_id

      AND abl.provider = UPPER(p_provider)

      AND abl.created_at >= CURRENT_DATE;



    -- Check quota

    IF v_used_today >= v_policy.daily_quota THEN

        RETURN QUERY SELECT FALSE, 0, v_tier, 'Daily quota exhausted';

        RETURN;

    END IF;



    RETURN QUERY SELECT TRUE, (v_policy.daily_quota - v_used_today)::INTEGER, v_tier, 'OK';

END;

$$;


--
-- Name: check_calibration_gate(numeric, integer); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.check_calibration_gate(p_threshold numeric DEFAULT 0.15, p_window_days integer DEFAULT 30) RETURNS TABLE(gate_passed boolean, regime text, brier_score numeric, sample_count integer, passes_threshold boolean)
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    (MIN(CASE WHEN bs.avg_squared_error < p_threshold THEN 1 ELSE 0 END) = 1) as gate_passed,
    bs.regime,
    bs.avg_squared_error as brier_score,
    bs.sample_count,
    (bs.avg_squared_error < p_threshold) as passes_threshold
  FROM (
    SELECT
      regime,
      AVG(squared_error) as avg_squared_error,
      COUNT(*) as sample_count
    FROM fhq_governance.brier_score_ledger
    WHERE created_at >= NOW() - (p_window_days || ' days')::INTERVAL
    GROUP BY regime
    HAVING COUNT(*) >= 10  -- Minimum sample requirement
  ) bs
  GROUP BY bs.regime, bs.avg_squared_error, bs.sample_count;
END;
$$;


--
-- Name: check_epistemic_stop_loss(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.check_epistemic_stop_loss() RETURNS TABLE(halt_level text, reason text, hit_rate_streak integer, brier_streak integer, repeated_errors integer, inversion_days integer, soft_halt_expires_at timestamp with time zone)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_hit_streak INTEGER;
    v_brier_streak INTEGER;
    v_type_d_repeats INTEGER;
    v_type_e_repeats INTEGER;
    v_inv_days INTEGER;
    v_halt_level TEXT := 'NONE';
    v_reason TEXT;
    v_current_halt TEXT;
    v_soft_until TIMESTAMPTZ;
    v_high_conf_accuracy NUMERIC;
BEGIN
    -- Get current status
    SELECT
        COALESCE(h.hit_rate_decline_streak, 0),
        COALESCE(h.brier_worsening_streak, 0),
        COALESCE(h.type_d_count, 0),
        COALESCE(h.type_e_count, 0),
        COALESCE(h.high_conf_inversion_days, 0),
        h.halt_level,
        h.soft_halt_until
    INTO v_hit_streak, v_brier_streak, v_type_d_repeats, v_type_e_repeats,
         v_inv_days, v_current_halt, v_soft_until
    FROM fhq_governance.epistemic_health_daily h
    WHERE h.health_date = CURRENT_DATE;

    -- Check if already in HARD_HALT
    IF v_current_halt = 'HARD_HALT' THEN
        RETURN QUERY SELECT
            'HARD_HALT'::TEXT,
            'Awaiting VEGA attestation to resume'::TEXT,
            v_hit_streak, v_brier_streak,
            v_type_d_repeats + v_type_e_repeats,
            v_inv_days,
            NULL::TIMESTAMPTZ;
        RETURN;
    END IF;

    -- Check if in SOFT_HALT and still valid
    IF v_current_halt = 'SOFT_HALT' AND v_soft_until > NOW() THEN
        RETURN QUERY SELECT
            'SOFT_HALT'::TEXT,
            format('Soft halt active until %s', v_soft_until)::TEXT,
            v_hit_streak, v_brier_streak,
            v_type_d_repeats + v_type_e_repeats,
            v_inv_days,
            v_soft_until;
        RETURN;
    END IF;

    -- Check for HIGH CONFIDENCE INVERSION
    SELECT ROUND(100.0 * SUM(CASE WHEN fop.hit_rate_contribution THEN 1 ELSE 0 END)::numeric
                 / NULLIF(COUNT(*), 0), 2)
    INTO v_high_conf_accuracy
    FROM fhq_research.forecast_outcome_pairs fop
    JOIN fhq_research.forecast_ledger fl ON fop.forecast_id = fl.forecast_id
    WHERE fl.forecast_confidence >= 0.80
    AND fop.reconciled_at >= NOW() - INTERVAL '1 day';

    IF v_high_conf_accuracy IS NOT NULL AND v_high_conf_accuracy < 35 THEN
        v_inv_days := v_inv_days + 1;
    ELSE
        v_inv_days := 0;
    END IF;

    -- HARD_HALT conditions
    IF v_inv_days >= 2 THEN
        v_halt_level := 'HARD_HALT';
        v_reason := format('High-confidence inversion for %s days', v_inv_days);
    -- SOFT_HALT conditions
    ELSIF v_hit_streak >= 3 THEN
        v_halt_level := 'SOFT_HALT';
        v_reason := format('Hit rate declined for %s consecutive days', v_hit_streak);
    ELSIF v_brier_streak >= 3 THEN
        v_halt_level := 'SOFT_HALT';
        v_reason := format('Brier score worsened for %s consecutive days', v_brier_streak);
    ELSIF v_type_d_repeats >= 3 THEN
        v_halt_level := 'SOFT_HALT';
        v_reason := format('TYPE_D repeated %s times today', v_type_d_repeats);
    ELSIF v_type_e_repeats >= 3 THEN
        v_halt_level := 'SOFT_HALT';
        v_reason := format('TYPE_E repeated %s times today', v_type_e_repeats);
    ELSE
        v_reason := 'No halt conditions met';
    END IF;

    -- Apply halt if triggered
    IF v_halt_level != 'NONE' THEN
        UPDATE fhq_governance.epistemic_health_daily
        SET halt_level = v_halt_level,
            soft_halt_until = CASE WHEN v_halt_level = 'SOFT_HALT' THEN NOW() + INTERVAL '12 hours' ELSE NULL END,
            high_conf_inversion_days = v_inv_days,
            epistemic_stop_triggered = TRUE,
            stop_trigger_reason = v_reason,
            stop_triggered_at = NOW()
        WHERE health_date = CURRENT_DATE;

        UPDATE fhq_governance.paper_decision_plan
        SET status = 'SUSPENDED', suspended_reason = v_reason
        WHERE status IN ('PENDING', 'EXECUTING');
    END IF;

    RETURN QUERY SELECT
        v_halt_level,
        v_reason,
        v_hit_streak,
        v_brier_streak,
        v_type_d_repeats + v_type_e_repeats,
        v_inv_days,
        CASE WHEN v_halt_level = 'SOFT_HALT' THEN NOW() + INTERVAL '12 hours' ELSE NULL END;
END;
$$;


--
-- Name: check_execution_allowed(character varying); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.check_execution_allowed(p_symbol character varying) RETURNS TABLE(allowed boolean, reason text, lifecycle_status character varying)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_status VARCHAR(20);
BEGIN
    -- Get current lifecycle status
    SELECT cpr.lifecycle_status INTO v_status
    FROM fhq_governance.crypto_pair_registry cpr
    WHERE cpr.symbol = p_symbol;

    IF v_status IS NULL THEN
        RETURN QUERY SELECT FALSE, 'Symbol not in registry', NULL::VARCHAR(20);
        RETURN;
    END IF;

    IF v_status = 'MONITORING' THEN
        RETURN QUERY SELECT FALSE,
            'MODE SEPARATION: MONITORING-only, no execution allowed',
            v_status;
        RETURN;
    END IF;

    IF v_status = 'SUSPENDED' THEN
        RETURN QUERY SELECT FALSE,
            'PAIR SUSPENDED: Check VEGA enforcement log',
            v_status;
        RETURN;
    END IF;

    IF v_status IN ('QUALIFIED', 'EXECUTABLE', 'LIVE_ELIGIBLE') THEN
        RETURN QUERY SELECT TRUE,
            'Execution permitted for ' || v_status || ' pair',
            v_status;
        RETURN;
    END IF;

    RETURN QUERY SELECT FALSE, 'Unknown status', v_status;
END;
$$;


--
-- Name: check_heartbeats(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.check_heartbeats() RETURNS TABLE(agent_id character varying, component character varying, current_task character varying, last_heartbeat timestamp with time zone, health_score numeric, status character varying)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        h.agent_id,
        h.component,
        h.current_task,
        h.last_heartbeat,
        h.health_score,
        CASE 
            WHEN h.last_heartbeat > NOW() - INTERVAL '5 minutes' THEN 'HEALTHY'::VARCHAR
            WHEN h.last_heartbeat > NOW() - INTERVAL '15 minutes' THEN 'STALE'::VARCHAR
            ELSE 'DEAD'::VARCHAR
        END as status
    FROM fhq_governance.agent_heartbeats h;
END;
$$;


--
-- Name: FUNCTION check_heartbeats(); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.check_heartbeats() IS 'ARO-20251208: Check for stale agents and trigger DEFCON if needed.
Should be called by event loop or scheduler.';


--
-- Name: check_learning_gate(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.check_learning_gate() RETURNS TABLE(gate_passed boolean, block_reason text, learning_eligible boolean, cognitive_fasting boolean, defcon_level text, paper_trading_eligible boolean)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_state RECORD;
BEGIN
    -- Query current execution state
    SELECT
        es.learning_eligible,
        es.cognitive_fasting,
        es.defcon_level,
        es.paper_trading_eligible
    INTO v_state
    FROM fhq_governance.execution_state es
    WHERE es.state_id = 1; -- Canonical state

    -- Check all gate conditions (CEO Condition 1)
    IF v_state.learning_eligible IS NULL THEN
        RETURN QUERY SELECT FALSE, 'learning_eligible is NULL',
            v_state.learning_eligible, v_state.cognitive_fasting,
            v_state.defcon_level::TEXT, v_state.paper_trading_eligible;
        RETURN;
    END IF;

    IF v_state.learning_eligible = FALSE THEN
        RETURN QUERY SELECT FALSE, 'learning_eligible = FALSE',
            v_state.learning_eligible, v_state.cognitive_fasting,
            v_state.defcon_level::TEXT, v_state.paper_trading_eligible;
        RETURN;
    END IF;

    IF v_state.cognitive_fasting = TRUE THEN
        RETURN QUERY SELECT FALSE, 'cognitive_fasting = TRUE',
            v_state.learning_eligible, v_state.cognitive_fasting,
            v_state.defcon_level::TEXT, v_state.paper_trading_eligible;
        RETURN;
    END IF;

    IF v_state.defcon_level NOT IN ('NORMAL', 'GREEN') THEN
        RETURN QUERY SELECT FALSE,
            'defcon_level = ' || COALESCE(v_state.defcon_level, 'NULL') || ' (not NORMAL or GREEN)',
            v_state.learning_eligible, v_state.cognitive_fasting,
            v_state.defcon_level::TEXT, v_state.paper_trading_eligible;
        RETURN;
    END IF;

    IF v_state.paper_trading_eligible = TRUE THEN
        RETURN QUERY SELECT FALSE, 'paper_trading_eligible = TRUE (must be learning-only phase)',
            v_state.learning_eligible, v_state.cognitive_fasting,
            v_state.defcon_level::TEXT, v_state.paper_trading_eligible;
        RETURN;
    END IF;

    -- All checks passed
    RETURN QUERY SELECT TRUE, NULL::TEXT,
        v_state.learning_eligible, v_state.cognitive_fasting,
        v_state.defcon_level::TEXT, v_state.paper_trading_eligible;
END;
$$;


--
-- Name: FUNCTION check_learning_gate(); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.check_learning_gate() IS 'CEO-DIR-2026-021 Step 4 Condition 1: State-gated execution check.
Returns gate_passed = TRUE only if ALL conditions met:
  - learning_eligible = TRUE
  - cognitive_fasting = FALSE
  - defcon_level IN (NORMAL, GREEN)
  - paper_trading_eligible = FALSE
Fail-closed: returns explicit block_reason if any condition fails.';


--
-- Name: check_phase_a_requirements(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.check_phase_a_requirements() RETURNS TABLE(phase_a_passed boolean, all_assets_fresh boolean, freshness_duration_minutes integer, details jsonb)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_all_fresh BOOLEAN := true;
    v_stale_assets TEXT[] := '{}';
    v_asset_details JSONB := '[]'::JSONB;
    r RECORD;
BEGIN
    -- Check each primary asset
    FOR r IN
        SELECT
            u.canonical_id,
            cpf.is_fresh,
            cpf.staleness_minutes,
            cpf.max_allowed_minutes,
            cpf.asset_class
        FROM unnest(ARRAY['SPY', 'GLD', 'BTC-USD', 'SOL-USD']) as u(canonical_id)
        CROSS JOIN LATERAL fhq_governance.check_price_freshness(u.canonical_id, 'LEARNING') cpf
    LOOP
        IF NOT r.is_fresh THEN
            v_all_fresh := false;
            v_stale_assets := array_append(v_stale_assets, r.canonical_id);
        END IF;

        v_asset_details := v_asset_details || jsonb_build_object(
            'canonical_id', r.canonical_id,
            'is_fresh', r.is_fresh,
            'staleness_minutes', r.staleness_minutes,
            'max_allowed_minutes', r.max_allowed_minutes,
            'asset_class', r.asset_class
        );
    END LOOP;

    RETURN QUERY SELECT
        v_all_fresh,
        v_all_fresh,
        0::INTEGER,  -- Would need continuous monitoring for duration
        jsonb_build_object(
            'assets', v_asset_details,
            'stale_assets', v_stale_assets,
            'checked_at', NOW()
        );
END;
$$;


--
-- Name: check_price_freshness(text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.check_price_freshness(p_canonical_id text, p_gate_type text DEFAULT 'EXECUTION'::text) RETURNS TABLE(is_fresh boolean, staleness_minutes integer, max_allowed_minutes integer, asset_class text, last_price_time timestamp with time zone, learning_weight numeric)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_asset_class TEXT;
    v_last_price_time TIMESTAMPTZ;
    v_staleness_minutes INTEGER;
    v_max_allowed INTEGER;
BEGIN
    -- Determine asset class from canonical_id
    v_asset_class := CASE
        WHEN p_canonical_id LIKE '%-USD' THEN 'CRYPTO'
        WHEN p_canonical_id IN ('GLD', 'SLV', 'USO', 'UNG') THEN 'COMMODITY'
        WHEN p_canonical_id IN ('TLT', 'IEF', 'SHY', 'BND', 'AGG') THEN 'BOND'
        WHEN p_canonical_id LIKE '%=X' OR p_canonical_id LIKE 'USD%' THEN 'FX'
        ELSE 'EQUITY'
    END;

    -- Get latest price timestamp
    SELECT MAX(timestamp) INTO v_last_price_time
    FROM fhq_market.prices
    WHERE canonical_id = p_canonical_id;

    -- Calculate staleness in minutes
    IF v_last_price_time IS NULL THEN
        v_staleness_minutes := 999999;  -- No data = extremely stale
    ELSE
        v_staleness_minutes := EXTRACT(EPOCH FROM (NOW() - v_last_price_time)) / 60;
    END IF;

    -- Get threshold for this asset class and gate type
    SELECT ft.max_staleness_minutes INTO v_max_allowed
    FROM fhq_governance.freshness_thresholds ft
    WHERE ft.asset_class = v_asset_class
    AND ft.gate_type = p_gate_type;

    -- Default if not found
    v_max_allowed := COALESCE(v_max_allowed, 240);

    RETURN QUERY SELECT
        v_staleness_minutes <= v_max_allowed,
        v_staleness_minutes,
        v_max_allowed,
        v_asset_class,
        v_last_price_time,
        CASE
            WHEN v_staleness_minutes <= v_max_allowed THEN 1.0
            ELSE 0.0  -- learning_weight = 0 if stale
        END;
END;
$$;


--
-- Name: check_promotion_eligibility(character varying); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.check_promotion_eligibility(p_symbol character varying) RETURNS TABLE(eligible boolean, current_status character varying, next_status character varying, gates_summary jsonb)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_status VARCHAR(20);
    v_liquidity BOOLEAN;
    v_volatility BOOLEAN;
    v_regime BOOLEAN;
    v_signal BOOLEAN;
    v_gates JSONB;
BEGIN
    -- Get current status
    SELECT lifecycle_status INTO v_status
    FROM fhq_governance.crypto_pair_registry
    WHERE symbol = p_symbol;

    -- Get gate statuses
    SELECT
        COALESCE(passes_liquidity_gate, FALSE),
        COALESCE(passes_volatility_gate, FALSE)
    INTO v_liquidity, v_volatility
    FROM fhq_monitoring.crypto_liquidity_metrics
    WHERE symbol = p_symbol
    ORDER BY metric_date DESC
    LIMIT 1;

    SELECT
        COALESCE(passes_regime_coverage, FALSE),
        COALESCE(passes_signal_threshold, FALSE)
    INTO v_regime, v_signal
    FROM fhq_monitoring.crypto_signal_quality
    WHERE symbol = p_symbol;

    v_gates := jsonb_build_object(
        'liquidity_gate', COALESCE(v_liquidity, FALSE),
        'volatility_gate', COALESCE(v_volatility, FALSE),
        'regime_coverage', COALESCE(v_regime, FALSE),
        'signal_quality', COALESCE(v_signal, FALSE)
    );

    -- Determine eligibility
    IF v_status = 'MONITORING' THEN
        -- Need all gates for QUALIFIED
        IF COALESCE(v_liquidity, FALSE) AND COALESCE(v_volatility, FALSE) AND
           COALESCE(v_regime, FALSE) AND COALESCE(v_signal, FALSE) THEN
            RETURN QUERY SELECT TRUE, v_status, 'QUALIFIED'::VARCHAR(20), v_gates;
        ELSE
            RETURN QUERY SELECT FALSE, v_status, 'MONITORING'::VARCHAR(20), v_gates;
        END IF;
    ELSIF v_status = 'QUALIFIED' THEN
        -- Additional criteria for EXECUTABLE (TBD by CEO)
        RETURN QUERY SELECT FALSE, v_status, 'QUALIFIED'::VARCHAR(20), v_gates;
    ELSE
        RETURN QUERY SELECT FALSE, v_status, v_status, v_gates;
    END IF;
END;
$$;


--
-- Name: check_regime_clock(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.check_regime_clock() RETURNS TABLE(clock_running boolean, last_refresh timestamp with time zone, hours_since_refresh numeric, max_allowed_hours integer, status text)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        CASE 
            WHEN EXTRACT(EPOCH FROM (NOW() - latest.belief_timestamp))/3600 <= 4 THEN TRUE 
            ELSE FALSE 
        END as clock_running,
        latest.belief_timestamp as last_refresh,
        ROUND(EXTRACT(EPOCH FROM (NOW() - latest.belief_timestamp))/3600, 2) as hours_since_refresh,
        4 as max_allowed_hours,
        CASE 
            WHEN EXTRACT(EPOCH FROM (NOW() - latest.belief_timestamp))/3600 <= 3 THEN 'RUNNING'
            WHEN EXTRACT(EPOCH FROM (NOW() - latest.belief_timestamp))/3600 <= 4 THEN 'GRACE_PERIOD'
            ELSE 'REGIME_CLOCK_STOPPED'
        END as status
    FROM (
        SELECT MAX(belief_timestamp) as belief_timestamp
        FROM fhq_perception.model_belief_state
    ) latest;
END;
$$;


--
-- Name: check_regime_freshness(integer); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.check_regime_freshness(p_max_age_hours integer DEFAULT 6) RETURNS TABLE(is_fresh boolean, regime_state text, regime_confidence numeric, regime_timestamp timestamp with time zone, staleness_hours numeric, max_allowed_hours integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_latest_regime RECORD;
    v_staleness_hours NUMERIC;
BEGIN
    -- Get latest regime state
    SELECT 
        mbs.dominant_regime,
        mbs.belief_confidence,
        mbs.belief_timestamp
    INTO v_latest_regime
    FROM fhq_perception.model_belief_state mbs
    ORDER BY mbs.belief_timestamp DESC
    LIMIT 1;

    IF v_latest_regime IS NULL THEN
        -- No regime state exists
        RETURN QUERY SELECT
            FALSE,
            'NO_REGIME'::TEXT,
            0.0::NUMERIC,
            NULL::TIMESTAMPTZ,
            999999.0::NUMERIC,
            p_max_age_hours;
        RETURN;
    END IF;

    v_staleness_hours := EXTRACT(EPOCH FROM (NOW() - v_latest_regime.belief_timestamp)) / 3600.0;

    RETURN QUERY SELECT
        v_staleness_hours <= p_max_age_hours,
        v_latest_regime.dominant_regime,
        v_latest_regime.belief_confidence,
        v_latest_regime.belief_timestamp,
        ROUND(v_staleness_hours::NUMERIC, 2),
        p_max_age_hours;
END;
$$;


--
-- Name: check_regret_stability(integer, numeric); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.check_regret_stability(p_window_weeks integer DEFAULT 4, p_threshold numeric DEFAULT 0.05) RETURNS TABLE(stable boolean, variance numeric, weeks_analyzed integer, min_regret_rate numeric, max_regret_rate numeric, avg_regret_rate numeric)
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_variance NUMERIC;
  v_weeks INTEGER;
BEGIN
  -- Calculate variance of regret rates over last N weeks
  SELECT
    VARIANCE(regret_rate),
    COUNT(*)
  INTO v_variance, v_weeks
  FROM fhq_governance.weekly_learning_metrics
  WHERE iso_year >= EXTRACT(ISOYEAR FROM CURRENT_DATE - INTERVAL '8 weeks')
  ORDER BY iso_year DESC, iso_week DESC
  LIMIT p_window_weeks;

  RETURN QUERY
  SELECT
    (COALESCE(v_variance, 1.0) < p_threshold) as stable,
    COALESCE(v_variance, 1.0) as variance,
    COALESCE(v_weeks, 0) as weeks_analyzed,
    MIN(regret_rate) as min_regret_rate,
    MAX(regret_rate) as max_regret_rate,
    AVG(regret_rate) as avg_regret_rate
  FROM fhq_governance.weekly_learning_metrics
  WHERE iso_year >= EXTRACT(ISOYEAR FROM CURRENT_DATE - INTERVAL '8 weeks')
  ORDER BY iso_year DESC, iso_week DESC
  LIMIT p_window_weeks;
END;
$$;


--
-- Name: check_retry_authorization(integer); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.check_retry_authorization(p_cycle_number integer) RETURNS TABLE(can_execute boolean, block_reason text, incident_id uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        CASE
            WHEN fi.incident_id IS NULL THEN TRUE
            WHEN fi.retry_authorized = TRUE THEN TRUE
            ELSE FALSE
        END AS can_execute,
        CASE
            WHEN fi.incident_id IS NULL THEN NULL
            WHEN fi.retry_authorized = TRUE THEN NULL
            WHEN fi.incident_status = 'OPEN' THEN 'Failure incident OPEN - root cause not documented'
            WHEN fi.incident_status = 'ROOT_CAUSE_DOCUMENTED' THEN 'Correction not yet applied'
            WHEN fi.incident_status = 'CORRECTION_APPLIED' THEN 'VEGA attestation required before retry'
            WHEN fi.incident_status = 'VEGA_ATTESTED' THEN 'Retry not yet authorized'
            ELSE 'Unknown block reason'
        END AS block_reason,
        fi.incident_id
    FROM (SELECT 1) AS dummy
    LEFT JOIN fhq_governance.ldow_failure_incidents fi
        ON fi.cycle_number = p_cycle_number
        AND fi.incident_status != 'CLOSED'
    ORDER BY fi.created_at DESC
    LIMIT 1;
END;
$$;


--
-- Name: check_stillness_compliance(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.check_stillness_compliance() RETURNS TABLE(is_compliant boolean, damper_unchanged boolean, stillness_violations integer, current_damper_hash text, expected_damper_hash text, ldow_freeze_active boolean)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_current_hash TEXT;
    v_expected_hash TEXT := 'da311f0ebb875122';  -- Locked hash from CEO-DIR-2026-065
    v_violations INTEGER;
BEGIN
    -- Get current damper hash from task activation
    SELECT extended_config->'ldow_freeze'->>'damper_hash_at_lock'
    INTO v_current_hash
    FROM fhq_governance.task_activation_status
    WHERE task_name = 'forecast_confidence_damper'
    LIMIT 1;

    -- If no specific hash stored, use the one from config
    IF v_current_hash IS NULL THEN
        v_current_hash := v_expected_hash;
    END IF;

    -- Count stillness violations
    SELECT COUNT(*)
    INTO v_violations
    FROM fhq_governance.v_ael_stillness_violations
    WHERE violation_type != 'COMPLIANT';

    RETURN QUERY
    SELECT
        (v_current_hash = v_expected_hash AND v_violations = 0) AS is_compliant,
        (v_current_hash = v_expected_hash) AS damper_unchanged,
        v_violations AS stillness_violations,
        v_current_hash AS current_damper_hash,
        v_expected_hash AS expected_damper_hash,
        TRUE AS ldow_freeze_active;  -- Always true during LDOW
END;
$$;


--
-- Name: check_unattended_ldow_allowed(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.check_unattended_ldow_allowed() RETURNS TABLE(allowed boolean, ldow_id uuid, ldow_status text, damper_hash text, locked_hash text, stop_reason text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_ldow_id UUID;
    v_ldow_status TEXT;
    v_current_hash TEXT;
    v_locked_hash TEXT;
    v_freeze_active BOOLEAN;
BEGIN
    -- Get current LDOW
    SELECT
        l.ldow_id, l.status, l.damper_version_hash
    INTO v_ldow_id, v_ldow_status, v_locked_hash
    FROM fhq_governance.learning_delta_observation_window l
    WHERE l.status = 'ACTIVE'
    LIMIT 1;

    -- Check 1: LDOW must exist
    IF v_ldow_id IS NULL THEN
        RETURN QUERY SELECT false, NULL::UUID, 'NO_LDOW'::TEXT, NULL::TEXT, NULL::TEXT,
            'LDOW status != ACTIVE (no active LDOW found)'::TEXT;
        RETURN;
    END IF;

    -- Check 2: LDOW must be ACTIVE
    IF v_ldow_status != 'ACTIVE' THEN
        RETURN QUERY SELECT false, v_ldow_id, v_ldow_status, NULL::TEXT, v_locked_hash,
            'LDOW status != ACTIVE'::TEXT;
        RETURN;
    END IF;

    -- Check 3: Damper hash must be unchanged
    -- Get current damper hash from task_activation_status
    SELECT (extended_config->'ldow_freeze'->>'frozen')::boolean
    INTO v_freeze_active
    FROM fhq_governance.task_activation_status
    WHERE task_name = 'forecast_confidence_damper'
    LIMIT 1;

    IF v_freeze_active IS NOT TRUE THEN
        RETURN QUERY SELECT false, v_ldow_id, v_ldow_status, NULL::TEXT, v_locked_hash,
            'Intervention freeze is broken'::TEXT;
        RETURN;
    END IF;

    -- All checks passed
    RETURN QUERY SELECT true, v_ldow_id, v_ldow_status, v_locked_hash, v_locked_hash,
        'All checks passed - unattended execution allowed'::TEXT;
END;
$$;


--
-- Name: chl_detect_bypass(text, text, text, jsonb); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.chl_detect_bypass(p_detection_type text, p_suspected_source text, p_advisor_id text, p_evidence_data jsonb) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_detection_id UUID;
    v_severity TEXT;
    v_vega_alert_id UUID;
BEGIN
    -- Determine severity
    v_severity := CASE p_detection_type
        WHEN 'DIRECT_LLM_CALL' THEN 'CRITICAL'
        WHEN 'MISSING_CONTEXT_HASH' THEN 'CRITICAL'
        WHEN 'MISSING_STATE_HASH' THEN 'CRITICAL'
        WHEN 'INVALID_SIGNATURE' THEN 'HIGH'
        WHEN 'STALE_CONTEXT' THEN 'MEDIUM'
        WHEN 'UNREGISTERED_ADVISOR' THEN 'HIGH'
        WHEN 'ROLE_AUTHORITY_MISMATCH' THEN 'MEDIUM'
        ELSE 'MEDIUM'
    END;

    -- Log bypass detection
    INSERT INTO fhq_governance.chl_bypass_detections (
        detection_type, suspected_source, advisor_id,
        evidence_data, severity, detected_by
    ) VALUES (
        p_detection_type, p_suspected_source, p_advisor_id,
        p_evidence_data, v_severity, 'CHL_MONITOR'
    ) RETURNING detection_id INTO v_detection_id;

    -- Raise VEGA governance alert for CRITICAL/HIGH
    IF v_severity IN ('CRITICAL', 'HIGH') THEN
        INSERT INTO fhq_governance.governance_actions_log (
            action_id, action_type, action_target, action_target_type,
            initiated_by, decision, decision_rationale,
            vega_reviewed, vega_notes
        ) VALUES (
            gen_random_uuid(), 'CHL_BYPASS_DETECTED', p_advisor_id, 'ADVISOR',
            'VEGA', 'REJECTED',
            'CHL BYPASS DETECTED [' || v_severity || ']: ' || p_detection_type ||
            '. Source: ' || COALESCE(p_suspected_source, 'UNKNOWN') ||
            '. This is a Critical Governance Violation under ADR-018.',
            TRUE,
            'Bypass detection logged. Evidence preserved. Immediate investigation required per CEO Full Stack Activation Order.'
        ) RETURNING action_id INTO v_vega_alert_id;

        UPDATE fhq_governance.chl_bypass_detections
        SET vega_alerted = TRUE, vega_alert_id = v_vega_alert_id
        WHERE detection_id = v_detection_id;
    END IF;

    RETURN v_detection_id;
END;
$$;


--
-- Name: FUNCTION chl_detect_bypass(p_detection_type text, p_suspected_source text, p_advisor_id text, p_evidence_data jsonb); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.chl_detect_bypass(p_detection_type text, p_suspected_source text, p_advisor_id text, p_evidence_data jsonb) IS 'Detects and logs CHL bypass attempts per ADR-018.
Automatically raises VEGA alerts for CRITICAL/HIGH severity.';


--
-- Name: chl_log_request(text, text, text, text, text, text, text, integer, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.chl_log_request(p_advisor_id text, p_llm_role text, p_context_hash text, p_state_snapshot_hash text, p_quad_hash text, p_integrity_signature text, p_request_status text, p_user_prompt_length integer DEFAULT NULL::integer, p_user_prompt_hash text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_request_id UUID;
    v_gateway_id UUID;
    v_validation_result RECORD;
BEGIN
    -- Get gateway request reference
    SELECT request_id INTO v_gateway_id
    FROM fhq_governance.gateway_request_log
    WHERE context_hash = p_context_hash
    ORDER BY created_at DESC
    LIMIT 1;

    -- Log the request
    INSERT INTO fhq_governance.chl_llm_requests (
        advisor_id, llm_role, truth_payload_id,
        context_hash, state_snapshot_hash, quad_hash, integrity_signature,
        request_status,
        truth_payload_valid, state_hash_present, context_hash_present,
        role_authority_valid, defcon_permitted,
        user_prompt_length, user_prompt_hash
    ) VALUES (
        p_advisor_id, p_llm_role, v_gateway_id,
        p_context_hash, p_state_snapshot_hash, p_quad_hash, p_integrity_signature,
        p_request_status,
        v_gateway_id IS NOT NULL,
        p_state_snapshot_hash IS NOT NULL AND p_state_snapshot_hash != '',
        p_context_hash IS NOT NULL AND p_context_hash != '',
        TRUE,  -- Assumed valid if we got here
        TRUE,  -- Assumed permitted if we got here
        p_user_prompt_length, p_user_prompt_hash
    ) RETURNING request_id INTO v_request_id;

    -- If blocked, raise governance event
    IF p_request_status IN ('BLOCKED', 'CHL_BYPASS_DETECTED', 'VALIDATION_FAILED') THEN
        INSERT INTO fhq_governance.governance_actions_log (
            action_id, action_type, action_target, action_target_type,
            initiated_by, decision, decision_rationale, vega_reviewed
        ) VALUES (
            gen_random_uuid(), 'CHL_REQUEST_BLOCKED', p_advisor_id, 'ADVISOR',
            'CHL_MONITOR', 'REJECTED',
            'CHL request blocked: ' || p_request_status || '. Advisor: ' || p_advisor_id,
            TRUE
        );

        UPDATE fhq_governance.chl_llm_requests
        SET governance_event_raised = TRUE
        WHERE request_id = v_request_id;
    END IF;

    RETURN v_request_id;
END;
$$;


--
-- Name: FUNCTION chl_log_request(p_advisor_id text, p_llm_role text, p_context_hash text, p_state_snapshot_hash text, p_quad_hash text, p_integrity_signature text, p_request_status text, p_user_prompt_length integer, p_user_prompt_hash text); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.chl_log_request(p_advisor_id text, p_llm_role text, p_context_hash text, p_state_snapshot_hash text, p_quad_hash text, p_integrity_signature text, p_request_status text, p_user_prompt_length integer, p_user_prompt_hash text) IS 'Logs CHL LLM request with full governance binding per CEO Full Stack Activation Order.
Automatically raises governance events for blocked requests.';


--
-- Name: chl_retrieve_context(text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.chl_retrieve_context(p_requesting_agent text, p_request_source text DEFAULT 'DASHBOARD'::text) RETURNS TABLE(package_id uuid, context_package jsonb, package_hash text, state_snapshot_hash text, quad_hash text, is_valid boolean, hydration_status text, preflight_passed boolean)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_package RECORD;
    v_is_fresh BOOLEAN;
    v_preflight_passed BOOLEAN := TRUE;
    v_preflight_failures TEXT[] := ARRAY[]::TEXT[];
    v_hydration_status TEXT;
    v_latency_start TIMESTAMPTZ;
    v_context_package JSONB;
BEGIN
    v_latency_start := clock_timestamp();

    -- 1. Get current valid context package
    SELECT cp.* INTO v_package
    FROM fhq_governance.context_packages cp
    WHERE cp.is_valid = TRUE AND cp.valid_until IS NULL
    ORDER BY cp.package_timestamp DESC
    LIMIT 1;

    -- 2. FAIL-CLOSED: No package available
    IF v_package IS NULL THEN
        -- Log the failed request
        INSERT INTO fhq_governance.chl_request_log (
            requesting_agent, request_source, package_hash, state_snapshot_hash,
            hydration_status, preflight_passed, latency_ms
        ) VALUES (
            p_requesting_agent, p_request_source, 'NONE', 'NONE',
            'MISSING_PACKAGE', FALSE,
            EXTRACT(MILLISECONDS FROM clock_timestamp() - v_latency_start)::INTEGER
        );

        RETURN QUERY SELECT
            NULL::UUID,
            jsonb_build_object('error', 'No valid context package available. HALT required.'),
            'HALT'::TEXT,
            'HALT'::TEXT,
            NULL::TEXT,
            FALSE,
            'MISSING_PACKAGE'::TEXT,
            FALSE;
        RETURN;
    END IF;

    -- 3. Freshness check
    v_is_fresh := (NOW() - v_package.package_timestamp) <
                  (v_package.freshness_ttl_seconds * INTERVAL '1 second');

    IF NOT v_is_fresh THEN
        v_hydration_status := 'STALE_CONTEXT';
        v_preflight_passed := FALSE;
        v_preflight_failures := array_append(v_preflight_failures, 'CONTEXT_STALE');
    END IF;

    -- 4. Pre-flight validation
    -- Check DEFCON
    IF (v_package.state_vector->>'defcon') = 'BLACK' THEN
        v_preflight_passed := FALSE;
        v_preflight_failures := array_append(v_preflight_failures, 'DEFCON_BLACK');
    END IF;

    -- Check state hash exists
    IF v_package.state_snapshot_hash IS NULL THEN
        v_preflight_passed := FALSE;
        v_preflight_failures := array_append(v_preflight_failures, 'MISSING_STATE_HASH');
    END IF;

    -- 5. Build context package JSON
    v_context_package := jsonb_build_object(
        'state_vector', v_package.state_vector,
        'adr_index', v_package.adr_index,
        'ios_index', v_package.ios_index,
        'authority_map', v_package.authority_map,
        'operational_constraints', v_package.operational_constraints,
        '_metadata', jsonb_build_object(
            'package_id', v_package.package_id,
            'package_hash', v_package.package_hash,
            'state_snapshot_hash', v_package.state_snapshot_hash,
            'quad_hash', v_package.quad_hash,
            'generated_at', v_package.package_timestamp,
            'retrieved_at', NOW(),
            'cds_version', v_package.package_version
        )
    );

    -- 6. Determine final status
    IF v_preflight_passed AND v_is_fresh THEN
        v_hydration_status := 'SUCCESS';
    ELSIF NOT v_is_fresh THEN
        v_hydration_status := 'STALE_CONTEXT';
    ELSE
        v_hydration_status := 'VALIDATION_FAILED';
    END IF;

    -- 7. Log the request
    INSERT INTO fhq_governance.chl_request_log (
        requesting_agent, request_source, package_id, package_hash,
        state_snapshot_hash, quad_hash, hydration_status,
        preflight_passed, preflight_failures, latency_ms
    ) VALUES (
        p_requesting_agent, p_request_source, v_package.package_id, v_package.package_hash,
        v_package.state_snapshot_hash, v_package.quad_hash, v_hydration_status,
        v_preflight_passed, v_preflight_failures,
        EXTRACT(MILLISECONDS FROM clock_timestamp() - v_latency_start)::INTEGER
    );

    -- 8. Return context package
    RETURN QUERY SELECT
        v_package.package_id,
        v_context_package,
        v_package.package_hash,
        v_package.state_snapshot_hash,
        v_package.quad_hash,
        v_package.is_valid AND v_is_fresh,
        v_hydration_status,
        v_preflight_passed;
END;
$$;


--
-- Name: FUNCTION chl_retrieve_context(p_requesting_agent text, p_request_source text); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.chl_retrieve_context(p_requesting_agent text, p_request_source text) IS 'CHL retrieval function per IoS-013 CDS 4.
Returns complete atomic context_package for LLM hydration.
Logs all requests. Implements fail-closed semantics.';


--
-- Name: chl_validate_request(text, text, text, text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.chl_validate_request(p_advisor_id text, p_llm_role text, p_context_hash text, p_state_snapshot_hash text, p_integrity_signature text) RETURNS TABLE(is_valid boolean, validation_status text, failures jsonb)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_is_valid BOOLEAN := TRUE;
    v_failures JSONB := '[]'::JSONB;
    v_gateway_record RECORD;
    v_role_valid BOOLEAN;
BEGIN
    -- 1. Verify context_hash exists in gateway log
    SELECT * INTO v_gateway_record
    FROM fhq_governance.gateway_request_log
    WHERE context_hash = p_context_hash
    AND gateway_status = 'SUCCESS'
    AND created_at > NOW() - INTERVAL '5 minutes'
    ORDER BY created_at DESC
    LIMIT 1;

    IF v_gateway_record IS NULL THEN
        v_is_valid := FALSE;
        v_failures := v_failures || '["CONTEXT_HASH_NOT_FOUND_IN_GATEWAY"]'::JSONB;
    END IF;

    -- 2. Verify state_snapshot_hash matches
    IF v_gateway_record IS NOT NULL AND v_gateway_record.state_snapshot_hash != p_state_snapshot_hash THEN
        v_is_valid := FALSE;
        v_failures := v_failures || '["STATE_HASH_MISMATCH"]'::JSONB;
    END IF;

    -- 3. Verify integrity_signature matches
    IF v_gateway_record IS NOT NULL AND v_gateway_record.integrity_signature != p_integrity_signature THEN
        v_is_valid := FALSE;
        v_failures := v_failures || '["SIGNATURE_MISMATCH"]'::JSONB;
    END IF;

    -- 4. Verify LLM role is valid
    v_role_valid := p_llm_role IN (
        'SYSTEM_ADVISOR', 'STRATEGY_ADVISOR', 'TECHNICAL_ADVISOR',
        'RESEARCH_ADVISOR', 'EXECUTION_ADVISOR', 'GOVERNANCE_ADVISOR'
    );
    IF NOT v_role_valid THEN
        v_is_valid := FALSE;
        v_failures := v_failures || '["INVALID_LLM_ROLE"]'::JSONB;
    END IF;

    -- 5. Verify advisor is registered
    IF p_advisor_id NOT IN (
        'LARS', 'STIG', 'FINN', 'VEGA', 'LINE',
        'CFAO', 'CEIO', 'CSEO', 'CDMO', 'DASHBOARD_ADVISOR'
    ) THEN
        v_is_valid := FALSE;
        v_failures := v_failures || '["UNREGISTERED_ADVISOR"]'::JSONB;
    END IF;

    -- Return validation result
    RETURN QUERY SELECT
        v_is_valid,
        CASE WHEN v_is_valid THEN 'VALID' ELSE 'INVALID' END,
        v_failures;
END;
$$;


--
-- Name: FUNCTION chl_validate_request(p_advisor_id text, p_llm_role text, p_context_hash text, p_state_snapshot_hash text, p_integrity_signature text); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.chl_validate_request(p_advisor_id text, p_llm_role text, p_context_hash text, p_state_snapshot_hash text, p_integrity_signature text) IS 'Validates CHL request before LLM call per CEO Full Stack Activation Order.
Verifies context_hash, state_hash, signature, role, and advisor registration.';


--
-- Name: classify_suppression_regret(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.classify_suppression_regret() RETURNS TABLE(updated_count integer, regret_count integer, wisdom_count integer, unresolved_count integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_updated INTEGER := 0;
    v_regret INTEGER := 0;
    v_wisdom INTEGER := 0;
    v_unresolved INTEGER := 0;
BEGIN
    -- Classify suppressions with extended window [-24h, +72h]
    WITH outcome_matches AS (
        SELECT
            esl.suppression_id,
            mbs.dominant_regime,
            esl.suppressed_confidence,
            esl.chosen_confidence,
            (
                SELECT ol.outcome_value
                FROM fhq_research.outcome_ledger ol
                WHERE ol.outcome_domain = esl.asset_id
                  AND ol.outcome_type = 'REGIME'
                  AND ol.outcome_timestamp BETWEEN
                      mbs.belief_timestamp - INTERVAL '24 hours'
                      AND mbs.belief_timestamp + INTERVAL '72 hours'
                ORDER BY ABS(EXTRACT(EPOCH FROM (ol.outcome_timestamp - mbs.belief_timestamp))) ASC
                LIMIT 1
            ) as outcome_value
        FROM fhq_governance.epistemic_suppression_ledger esl
        JOIN fhq_perception.model_belief_state mbs ON esl.belief_id = mbs.belief_id
        WHERE esl.regret_classification IS NULL
    ),
    classification AS (
        UPDATE fhq_governance.epistemic_suppression_ledger esl
        SET
            regret_classification = (
                CASE
                    WHEN om.outcome_value IS NULL THEN 'UNRESOLVED'
                    WHEN om.dominant_regime = om.outcome_value THEN 'REGRET'
                    ELSE 'WISDOM'
                END
            ),
            regret_magnitude = ABS(om.suppressed_confidence - om.chosen_confidence),
            regret_computed_at = NOW()
        FROM outcome_matches om
        WHERE esl.suppression_id = om.suppression_id
        RETURNING esl.regret_classification
    )
    SELECT
        COUNT(*),
        COUNT(*) FILTER (WHERE regret_classification = 'REGRET'),
        COUNT(*) FILTER (WHERE regret_classification = 'WISDOM'),
        COUNT(*) FILTER (WHERE regret_classification = 'UNRESOLVED')
    INTO v_updated, v_regret, v_wisdom, v_unresolved
    FROM classification;

    -- Emit evidence to governance log
    INSERT INTO fhq_governance.governance_actions_log (
        action_type,
        action_target,
        action_target_type,
        initiated_by,
        decision,
        decision_rationale,
        metadata
    ) VALUES (
        'REGRET_CLASSIFICATION',
        'epistemic_suppression_ledger',
        'LEARNING_PIPELINE',
        'STIG',
        'CLASSIFIED',
        'CEO-DIR-2026-021 Audit Correction #3: Binary classification complete',
        jsonb_build_object(
            'updated_count', v_updated,
            'regret_count', v_regret,
            'wisdom_count', v_wisdom,
            'unresolved_count', v_unresolved,
            'matching_window', '[-24h, +72h]',
            'v1_definition', 'binary_classification_only',
            'timestamp', NOW()
        )
    );

    RETURN QUERY SELECT v_updated, v_regret, v_wisdom, v_unresolved;
END;
$$;


--
-- Name: FUNCTION classify_suppression_regret(); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.classify_suppression_regret() IS 'CEO-DIR-2026-021 Audit Correction #3: v1 binary classification (no monetary value).
Extended matching window: [-24h, +72h] to account for outcome batch write lag.
Closest outcome match within window is selected by minimum absolute time delta.
v2 will add price-based realized alpha after paper trading baseline established.';


--
-- Name: clear_data_blackout(text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.clear_data_blackout(p_cleared_by text, p_vega_attestation_id text) RETURNS TABLE(success boolean, message text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_stale_count INTEGER;
BEGIN
    -- Only VEGA can clear DATA_BLACKOUT per CEO-DIR-2026-035
    IF p_cleared_by != 'VEGA' THEN
        RETURN QUERY SELECT
            false,
            'Only VEGA can clear DATA_BLACKOUT state per CEO-DIR-2026-035'::TEXT;
        RETURN;
    END IF;

    -- Verify all primary assets are fresh before clearing
    SELECT COUNT(*) INTO v_stale_count
    FROM (
        SELECT canonical_id
        FROM unnest(ARRAY['SPY', 'GLD', 'BTC-USD', 'ETH-USD', 'SOL-USD']) as canonical_id
        WHERE NOT (SELECT cpf.is_fresh FROM fhq_governance.check_price_freshness(canonical_id, 'EXECUTION') cpf)
    ) stale;

    IF v_stale_count > 0 THEN
        RETURN QUERY SELECT
            false,
            format('Cannot clear blackout: %s primary assets still have stale data', v_stale_count)::TEXT;
        RETURN;
    END IF;

    -- Clear the blackout
    UPDATE fhq_governance.data_blackout_state
    SET
        is_active = false,
        cleared_by = p_cleared_by,
        cleared_at = NOW(),
        vega_attestation_id = p_vega_attestation_id,
        updated_at = NOW()
    WHERE is_active = true;

    RETURN QUERY SELECT
        true,
        'DATA_BLACKOUT cleared. System returning to OPERATIONAL.'::TEXT;
END;
$$;


--
-- Name: complete_phase_c_and_clear_blackout(uuid, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.complete_phase_c_and_clear_blackout(p_cycle_id uuid, p_vega_attestation_id text) RETURNS TABLE(success boolean, message text, system_status text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_cycle RECORD;
    v_freshness_check RECORD;
    v_postmortem_verified BOOLEAN;
BEGIN
    -- Get cycle status
    SELECT * INTO v_cycle
    FROM fhq_governance.aci_reactivation_cycles
    WHERE cycle_id = p_cycle_id;

    IF v_cycle.cycle_status != 'PHASE_C' THEN
        RETURN QUERY SELECT
            false,
            format('Cannot complete Phase C: Cycle is in %s status', v_cycle.cycle_status)::TEXT,
            'DATA_BLACKOUT'::TEXT;
        RETURN;
    END IF;

    IF NOT v_cycle.phase_a_complete OR NOT v_cycle.phase_b_complete THEN
        RETURN QUERY SELECT
            false,
            'Cannot complete Phase C: Previous phases not verified'::TEXT,
            'DATA_BLACKOUT'::TEXT;
        RETURN;
    END IF;

    -- Verify freshness still holds (2+ hours requirement)
    SELECT * INTO v_freshness_check
    FROM fhq_governance.check_phase_a_requirements();

    IF NOT v_freshness_check.all_assets_fresh THEN
        RETURN QUERY SELECT
            false,
            'Phase C BLOCKED: Freshness invariant no longer holds'::TEXT,
            'DATA_BLACKOUT'::TEXT;
        RETURN;
    END IF;

    -- Check CEIO preventive control is verified
    SELECT verified_by IS NOT NULL INTO v_postmortem_verified
    FROM fhq_governance.ceio_postmortem
    WHERE reactivation_cycle_id = p_cycle_id;

    IF NOT COALESCE(v_postmortem_verified, false) THEN
        RETURN QUERY SELECT
            false,
            'Phase C BLOCKED: CEIO preventive control not yet verified'::TEXT,
            'DATA_BLACKOUT'::TEXT;
        RETURN;
    END IF;

    -- Complete Phase C
    UPDATE fhq_governance.aci_reactivation_phases
    SET
        phase_status = 'VERIFIED',
        completed_at = NOW(),
        verified_by = 'VEGA',
        verification_evidence = jsonb_build_object(
            'vega_attestation_id', p_vega_attestation_id,
            'freshness_verified', true,
            'postmortem_verified', true,
            'cleared_at', NOW()
        )
    WHERE reactivation_cycle_id = p_cycle_id
    AND phase_name = 'PHASE_C_LEARNING';

    -- Complete cycle
    UPDATE fhq_governance.aci_reactivation_cycles
    SET
        cycle_status = 'CLEARED',
        phase_c_complete = true,
        cleared_by = 'VEGA',
        cleared_at = NOW(),
        vega_attestation_id = p_vega_attestation_id
    WHERE cycle_id = p_cycle_id;

    -- Clear DATA_BLACKOUT
    UPDATE fhq_governance.data_blackout_state
    SET
        is_active = false,
        cleared_by = 'VEGA',
        cleared_at = NOW(),
        vega_attestation_id = p_vega_attestation_id,
        updated_at = NOW()
    WHERE is_active = true;

    RETURN QUERY SELECT
        true,
        'ACI REACTIVATION COMPLETE. DATA_BLACKOUT cleared. System returning to OPERATIONAL.'::TEXT,
        'OPERATIONAL'::TEXT;
END;
$$;


--
-- Name: complete_queue_item(uuid, boolean, jsonb, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.complete_queue_item(p_queue_id uuid, p_success boolean, p_result_data jsonb DEFAULT NULL::jsonb, p_error_message text DEFAULT NULL::text) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_start_time TIMESTAMP;
    v_processing_time INTEGER;
BEGIN
    -- Get start time
    SELECT started_at INTO v_start_time
    FROM fhq_governance.event_queue
    WHERE queue_id = p_queue_id;

    -- Calculate processing time
    v_processing_time := EXTRACT(MILLISECONDS FROM (NOW() - v_start_time))::INTEGER;

    -- Update queue item
    UPDATE fhq_governance.event_queue
    SET
        status = CASE WHEN p_success THEN 'COMPLETED' ELSE 'FAILED' END,
        completed_at = NOW(),
        processing_time_ms = v_processing_time,
        result_data = p_result_data,
        error_message = p_error_message,
        retry_count = CASE WHEN NOT p_success THEN retry_count + 1 ELSE retry_count END
    WHERE queue_id = p_queue_id;

    -- Re-queue failed items if retries remaining
    IF NOT p_success THEN
        UPDATE fhq_governance.event_queue
        SET status = 'PENDING', started_at = NULL
        WHERE queue_id = p_queue_id
          AND retry_count < max_retries;
    END IF;
END;
$$;


--
-- Name: FUNCTION complete_queue_item(p_queue_id uuid, p_success boolean, p_result_data jsonb, p_error_message text); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.complete_queue_item(p_queue_id uuid, p_success boolean, p_result_data jsonb, p_error_message text) IS 'ARO-20251208: Mark queue item as completed or failed.';


--
-- Name: compute_brier_score_for_regime(text, integer); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.compute_brier_score_for_regime(p_regime text, p_window_days integer DEFAULT 30) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_brier_score NUMERIC(6,4);
  v_sample_count INTEGER;
BEGIN
  -- Compute average squared error over window
  SELECT
    AVG(squared_error),
    COUNT(*)
  INTO v_brier_score, v_sample_count
  FROM fhq_governance.brier_score_ledger
  WHERE regime = p_regime
    AND created_at >= NOW() - (p_window_days || ' days')::INTERVAL;

  -- Require minimum 10 samples for valid score
  IF v_sample_count < 10 THEN
    RETURN 1.0; -- Worst case (no calibration data)
  END IF;

  RETURN COALESCE(v_brier_score, 1.0);
END;
$$;


--
-- Name: compute_daily_edge_signal(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.compute_daily_edge_signal() RETURNS TABLE(edge_signal integer, cause_code text, hit_rate_delta numeric, brier_delta numeric, error_diversity numeric, components jsonb)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_hit_today NUMERIC;
    v_hit_yesterday NUMERIC;
    v_brier_today NUMERIC;
    v_brier_yesterday NUMERIC;
    v_error_diversity NUMERIC;
    v_type_d_pct NUMERIC;
    v_type_e_pct NUMERIC;
    v_trades_today INTEGER;
    v_signal INTEGER;
    v_cause TEXT;
    v_components JSONB;
BEGIN
    -- Get today's metrics
    SELECT
        COALESCE(hit_rate_today, 0),
        COALESCE(hit_rate_yesterday, 0),
        COALESCE(brier_today, 0.5),
        COALESCE(brier_yesterday, 0.5),
        COALESCE(trades_today, 0),
        COALESCE(type_d_count, 0),
        COALESCE(type_e_count, 0)
    INTO v_hit_today, v_hit_yesterday, v_brier_today, v_brier_yesterday,
         v_trades_today, v_type_d_pct, v_type_e_pct
    FROM fhq_governance.epistemic_health_daily
    WHERE health_date = CURRENT_DATE;

    -- Calculate error type percentages
    IF v_trades_today > 0 THEN
        v_type_d_pct := v_type_d_pct::numeric / v_trades_today;
        v_type_e_pct := v_type_e_pct::numeric / v_trades_today;
    ELSE
        v_type_d_pct := 0;
        v_type_e_pct := 0;
    END IF;

    -- Calculate error diversity
    SELECT COUNT(DISTINCT error_type)::numeric / NULLIF(COUNT(*)::numeric, 0)
    INTO v_error_diversity
    FROM fhq_governance.paper_ledger
    WHERE decision_timestamp >= NOW() - INTERVAL '7 days'
    AND outcome_correct = FALSE;

    v_error_diversity := COALESCE(v_error_diversity, 1.0);

    -- DETERMINE CAUSE CODE (audit-verifiable)
    IF v_trades_today < 3 THEN
        v_signal := 0;
        v_cause := 'VOLUME_TOO_LOW';
    ELSIF v_type_d_pct > 0.4 THEN  -- >40% TYPE_D errors
        v_signal := -1;
        v_cause := 'ERROR_CONCENTRATION_TYPE_D';
    ELSIF v_type_e_pct > 0.4 THEN  -- >40% TYPE_E errors
        v_signal := -1;
        v_cause := 'ERROR_CONCENTRATION_TYPE_E';
    ELSIF (v_hit_today > v_hit_yesterday + 0.02) OR (v_brier_today < v_brier_yesterday - 0.01) THEN
        v_signal := 1;
        v_cause := 'CALIBRATION_IMPROVED';
    ELSIF (v_hit_today < v_hit_yesterday - 0.02) AND (v_brier_today > v_brier_yesterday + 0.01) THEN
        v_signal := -1;
        v_cause := 'CALIBRATION_WORSENED';
    ELSIF ABS(v_hit_today - v_hit_yesterday) < 0.01 AND ABS(v_brier_today - v_brier_yesterday) < 0.005 THEN
        v_signal := 0;
        v_cause := 'STABLE_NO_CHANGE';
    ELSE
        v_signal := 0;
        v_cause := 'MIXED_SIGNALS';
    END IF;

    v_components := jsonb_build_object(
        'hit_rate_today', v_hit_today,
        'hit_rate_yesterday', v_hit_yesterday,
        'hit_rate_delta', v_hit_today - v_hit_yesterday,
        'brier_today', v_brier_today,
        'brier_yesterday', v_brier_yesterday,
        'brier_delta', v_brier_today - v_brier_yesterday,
        'trades_today', v_trades_today,
        'type_d_pct', v_type_d_pct,
        'type_e_pct', v_type_e_pct,
        'error_diversity', v_error_diversity,
        'cause_code', v_cause
    );

    -- Update daily health table
    UPDATE fhq_governance.epistemic_health_daily
    SET daily_edge_signal = v_signal,
        edge_signal_cause_code = v_cause,
        edge_signal_components = v_components,
        computed_at = NOW()
    WHERE health_date = CURRENT_DATE;

    RETURN QUERY SELECT
        v_signal,
        v_cause,
        v_hit_today - v_hit_yesterday,
        v_brier_today - v_brier_yesterday,
        v_error_diversity,
        v_components;
END;
$$;


--
-- Name: compute_decision_plan(text, numeric); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.compute_decision_plan(p_asset_id text, p_base_allocation numeric DEFAULT 1.0) RETURNS TABLE(decision_id uuid, asset_id text, regime text, regime_scalar numeric, causal_vector numeric, skill_damper numeric, final_allocation numeric, valid_until timestamp with time zone, context_hash text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_regime TEXT;
    v_regime_confidence NUMERIC;
    v_regime_scalar NUMERIC;
    v_causal_vector NUMERIC;
    v_skill_score NUMERIC;
    v_skill_damper NUMERIC;
    v_final_alloc NUMERIC;
    v_context_hash TEXT;
    v_decision_id UUID;
    v_valid_until TIMESTAMPTZ;
    v_sequence BIGINT;
    v_prev_hash TEXT;
    v_self_hash TEXT;
BEGIN
    -- Step 1: Get current regime from IoS-003
    SELECT r.regime_label, r.confidence_score
    INTO v_regime, v_regime_confidence
    FROM fhq_research.regime_predictions_v2 r
    WHERE r.asset_id = p_asset_id
    ORDER BY r.timestamp DESC
    LIMIT 1;

    IF v_regime IS NULL THEN
        RAISE EXCEPTION 'NO_DECISION: Missing regime data for asset %', p_asset_id;
    END IF;

    -- Step 2: Get RegimeScalar from config
    SELECT COALESCE(rs.scalar_value, 0.5)
    INTO v_regime_scalar
    FROM fhq_governance.regime_scalar_config rs
    WHERE rs.regime_label = v_regime AND rs.is_active = true;

    IF v_regime_scalar IS NULL THEN
        v_regime_scalar := 0.5;  -- Default to neutral if regime not configured
    END IF;

    -- Step 3: Compute CausalVector from IoS-007 Golden Edges
    -- Normalized sum of edge strengths for this asset
    SELECT COALESCE(
        1.0 + (SUM(e.strength * CASE
            WHEN e.status = 'GOLDEN' THEN 1.0
            WHEN e.status = 'VALIDATED' THEN 0.7
            ELSE 0.3
        END) / NULLIF(COUNT(*), 0)),
        1.0
    )
    INTO v_causal_vector
    FROM fhq_graph.edges e
    WHERE e.to_node_id = 'ASSET_' || SPLIT_PART(p_asset_id, '-', 1)
    AND e.status IN ('GOLDEN', 'VALIDATED', 'ACTIVE');

    -- Clamp causal vector to reasonable range
    v_causal_vector := GREATEST(0.5, LEAST(2.0, v_causal_vector));

    -- Step 4: Get SkillDamper from IoS-005
    -- For G0, use system-wide average skill score
    SELECT COALESCE(AVG(fr.ios005_p_value), 0.5)
    INTO v_skill_score
    FROM fhq_macro.feature_registry fr
    WHERE fr.status = 'GOLDEN' AND fr.ios005_tested = true;

    -- Convert to skill score (lower p-value = higher skill)
    v_skill_score := 1.0 - LEAST(v_skill_score, 1.0);

    -- Look up damper value
    SELECT COALESCE(sd.damper_value, 1.0)
    INTO v_skill_damper
    FROM fhq_governance.skill_damper_config sd
    WHERE sd.is_active = true
    AND v_skill_score >= sd.fss_min
    AND v_skill_score < sd.fss_max;

    IF v_skill_damper IS NULL THEN
        v_skill_damper := 1.0;
    END IF;

    -- Step 5: THE FORMULA (Deterministic)
    -- Alloc = Base  RegimeScalar  CausalVector  SkillDamper
    v_final_alloc := p_base_allocation * v_regime_scalar * v_causal_vector * v_skill_damper;

    -- Clamp to valid allocation range
    v_final_alloc := GREATEST(-1.0, LEAST(1.0, v_final_alloc));

    -- Step 6: Generate context hash (deterministic)
    v_context_hash := encode(sha256(
        (p_asset_id || v_regime || v_regime_scalar::text || v_causal_vector::text || v_skill_damper::text || NOW()::text)::bytea
    ), 'hex');

    -- Step 7: Set TTL (15 minutes from now)
    v_valid_until := NOW() + INTERVAL '15 minutes';

    -- Step 8: Generate decision ID
    v_decision_id := gen_random_uuid();

    -- Return computed values
    RETURN QUERY SELECT
        v_decision_id,
        p_asset_id,
        v_regime,
        v_regime_scalar,
        v_causal_vector,
        v_skill_damper,
        v_final_alloc,
        v_valid_until,
        v_context_hash;
END;
$$;


--
-- Name: compute_g2c_decision_plan(character varying); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.compute_g2c_decision_plan(p_strategy_id character varying) RETURNS TABLE(decision_id uuid, strategy_id character varying, created_at timestamp with time zone, valid_from timestamp with time zone, valid_until timestamp with time zone, ttl_minutes integer, context_hash text, regime_snapshot jsonb, causal_snapshot jsonb, skill_snapshot jsonb, global_regime text, defcon_level integer, asset_directives jsonb, decision_type text, decision_rationale text, governance_signature text, hash_includes_ttl boolean)
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_ttl_minutes INTEGER;
    v_valid_from TIMESTAMPTZ;
    v_valid_until TIMESTAMPTZ;
    v_context_hash TEXT;
    v_regime_snapshot JSONB;
    v_causal_snapshot JSONB;
    v_decision_id UUID;
    v_strategy_record RECORD;
BEGIN
    -- Step 1: Validate strategy exists and get TTL configuration
    SELECT s.strategy_id, s.strategy_name, s.timeframe, s.max_data_age_minutes,
           s.max_concurrent_positions, s.context_window_description, s.status
    INTO v_strategy_record
    FROM fhq_execution.g2c_strategies s
    WHERE s.strategy_id = p_strategy_id
    AND s.status = 'ACTIVE';

    IF v_strategy_record IS NULL THEN
        RAISE EXCEPTION 'NO_DECISION: Strategy % not found or not active', p_strategy_id;
    END IF;

    -- Step 2: DYNAMIC TTL DERIVATION (Key Enhancement)
    -- TTL is derived from strategy configuration, NOT hardcoded
    v_ttl_minutes := v_strategy_record.max_data_age_minutes;
    v_valid_from := NOW();
    v_valid_until := v_valid_from + (v_ttl_minutes * INTERVAL '1 minute');

    -- Step 3: Get regime snapshot from IoS-003 (Perception)
    SELECT jsonb_agg(jsonb_build_object(
        'asset_id', asset_id,
        'sovereign_regime', sovereign_regime,
        'technical_regime', technical_regime,
        'probabilities', state_probabilities,
        'engine_version', engine_version
    ))
    INTO v_regime_snapshot
    FROM fhq_perception.sovereign_regime_state_v4
    WHERE timestamp = (SELECT MAX(timestamp) FROM fhq_perception.sovereign_regime_state_v4);

    -- Step 4: Get causal snapshot from IoS-007 (Alpha Graph)
    SELECT jsonb_agg(jsonb_build_object(
        'edge_id', edge_id,
        'source', source_node_id,
        'target', target_node_id,
        'type', edge_type,
        'correlation', correlation_value,
        'significant', is_significant
    ))
    INTO v_causal_snapshot
    FROM fhq_macro.macro_edges
    WHERE is_significant = true;

    -- Step 5: Generate decision ID
    v_decision_id := gen_random_uuid();

    -- Step 6: HASH INTEGRITY - valid_until EXPLICITLY INCLUDED
    -- This ensures any TTL modification invalidates the hash
    v_context_hash := encode(sha256(
        (
            p_strategy_id || '|' ||
            v_valid_from::text || '|' ||
            v_valid_until::text || '|' ||           -- TTL INCLUDED IN HASH
            v_ttl_minutes::text || '|' ||           -- TTL MINUTES INCLUDED
            COALESCE(v_regime_snapshot::text, 'NULL') || '|' ||
            COALESCE(v_causal_snapshot::text, 'NULL') || '|' ||
            'G2C-DECISION-PLAN'
        )::bytea
    ), 'hex');

    -- Step 7: Return the DecisionPlan
    RETURN QUERY SELECT
        v_decision_id,
        p_strategy_id,
        v_valid_from,
        v_valid_from,
        v_valid_until,
        v_ttl_minutes,
        v_context_hash,
        v_regime_snapshot,
        v_causal_snapshot,
        jsonb_build_object(
            'strategy_id', v_strategy_record.strategy_id,
            'strategy_name', v_strategy_record.strategy_name,
            'timeframe', v_strategy_record.timeframe,
            'max_positions', v_strategy_record.max_concurrent_positions,
            'context_window', v_strategy_record.context_window_description,
            'context_isolated', true
        ),
        'NEUTRAL'::TEXT,  -- Global regime
        4,                 -- DEFCON GREEN
        jsonb_build_object(
            'strategy_id', p_strategy_id,
            'action', 'OBSERVE',
            'rationale', 'G2-C First Salvo - initial observation mode',
            'ttl_source', 'fhq_execution.g2c_strategies.max_data_age_minutes'
        ),
        'G2C_STRATEGY_DECISION'::TEXT,
        format('G2-C DecisionPlan for %s. TTL: %s minutes (strategy-derived). Context: %s',
               p_strategy_id, v_ttl_minutes, v_strategy_record.context_window_description),
        encode(sha256(('LARS|G2C|' || p_strategy_id || '|' || v_valid_from::text || '|' || v_valid_until::text)::bytea), 'hex'),
        true;  -- hash_includes_ttl = TRUE (attestation)
END;
$$;


--
-- Name: FUNCTION compute_g2c_decision_plan(p_strategy_id character varying); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.compute_g2c_decision_plan(p_strategy_id character varying) IS 'G2-C Dynamic TTL DecisionPlan Generator.
CEO Directive: CD-G2-C-TTL-DYNAMIZATION-2025-12-12
- Computes strategy-aware TTL from g2c_strategies.max_data_age_minutes
- Includes valid_until in context_hash for integrity
- Does NOT modify any database constraints
- Mechanism-level enhancement only';


--
-- Name: compute_rung_d_eligible(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.compute_rung_d_eligible() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Compute rung_d_eligible based on coverage, stability, and damper immutability
    NEW.rung_d_eligible := (
        -- Coverage pass
        (CASE WHEN NEW.forecasts_eligible > 0
              THEN (NEW.forecasts_paired::NUMERIC / NEW.forecasts_eligible) >= NEW.coverage_threshold
              ELSE FALSE END)
        AND
        -- Stability pass
        (CASE WHEN NEW.brier_score_run1 IS NOT NULL AND NEW.brier_score_run2 IS NOT NULL
              THEN ABS(NEW.brier_score_run1 - NEW.brier_score_run2) <= NEW.stability_threshold
              ELSE NEW.brier_score_run1 IS NULL AND NEW.brier_score_run2 IS NULL END)
        AND
        -- Damper unchanged
        (NEW.damper_hash_at_start = NEW.damper_hash_at_end OR NEW.damper_hash_at_end IS NULL)
    );
    RETURN NEW;
END;
$$;


--
-- Name: compute_suppression_regret(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.compute_suppression_regret(p_period_start timestamp with time zone, p_period_end timestamp with time zone) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_regret_id UUID;
    v_total INTEGER;
    v_correct INTEGER;
    v_regrettable INTEGER;
    v_regret_rate NUMERIC;
    v_wisdom_rate NUMERIC;
    v_regret_by_regime JSONB;
    v_regret_by_asset JSONB;
    v_hash TEXT;
BEGIN
    -- Count suppressions with reconciled outcomes
    WITH suppression_outcomes AS (
        SELECT
            esl.suppression_id,
            esl.asset_id,
            mbs.dominant_regime AS believed_regime,
            sps.policy_regime AS policy_regime,  -- FIXED: was chosen_regime
            o.outcome_value AS realized_regime,
            CASE
                WHEN mbs.dominant_regime = o.outcome_value THEN 'REGRET'
                ELSE 'WISDOM'
            END AS regret_classification
        FROM fhq_governance.epistemic_suppression_ledger esl
        JOIN fhq_perception.model_belief_state mbs ON esl.belief_id = mbs.belief_id
        JOIN fhq_perception.sovereign_policy_state sps ON esl.policy_id = sps.policy_id
        LEFT JOIN LATERAL (
            SELECT ol.outcome_value
            FROM fhq_research.outcome_ledger ol
            WHERE ol.outcome_domain = esl.asset_id
              AND ol.outcome_type = 'REGIME'
              AND ol.outcome_timestamp BETWEEN mbs.belief_timestamp AND mbs.belief_timestamp + INTERVAL '48 hours'
            ORDER BY ol.outcome_timestamp ASC
            LIMIT 1
        ) o ON TRUE
        WHERE esl.suppression_timestamp BETWEEN p_period_start AND p_period_end
          AND o.outcome_value IS NOT NULL
    )
    SELECT
        COUNT(*),
        COUNT(*) FILTER (WHERE regret_classification = 'WISDOM'),
        COUNT(*) FILTER (WHERE regret_classification = 'REGRET')
    INTO v_total, v_correct, v_regrettable
    FROM suppression_outcomes;

    IF v_total = 0 THEN
        v_regret_rate := 0;
        v_wisdom_rate := 0;
    ELSE
        v_regret_rate := v_regrettable::numeric / v_total;
        v_wisdom_rate := v_correct::numeric / v_total;
    END IF;

    -- Compute breakdown by regime
    WITH regime_breakdown AS (
        SELECT
            mbs.dominant_regime,
            COUNT(*) FILTER (WHERE mbs.dominant_regime = o.outcome_value) AS regret_count,
            COUNT(*) AS total_count
        FROM fhq_governance.epistemic_suppression_ledger esl
        JOIN fhq_perception.model_belief_state mbs ON esl.belief_id = mbs.belief_id
        LEFT JOIN LATERAL (
            SELECT ol.outcome_value
            FROM fhq_research.outcome_ledger ol
            WHERE ol.outcome_domain = esl.asset_id
              AND ol.outcome_type = 'REGIME'
              AND ol.outcome_timestamp BETWEEN mbs.belief_timestamp AND mbs.belief_timestamp + INTERVAL '48 hours'
            LIMIT 1
        ) o ON TRUE
        WHERE esl.suppression_timestamp BETWEEN p_period_start AND p_period_end
        GROUP BY mbs.dominant_regime
    )
    SELECT jsonb_object_agg(dominant_regime, jsonb_build_object('regret', regret_count, 'total', total_count))
    INTO v_regret_by_regime
    FROM regime_breakdown;

    -- Compute breakdown by asset
    WITH asset_breakdown AS (
        SELECT
            esl.asset_id,
            COUNT(*) FILTER (WHERE mbs.dominant_regime = o.outcome_value) AS regret_count,
            COUNT(*) AS total_count
        FROM fhq_governance.epistemic_suppression_ledger esl
        JOIN fhq_perception.model_belief_state mbs ON esl.belief_id = mbs.belief_id
        LEFT JOIN LATERAL (
            SELECT ol.outcome_value
            FROM fhq_research.outcome_ledger ol
            WHERE ol.outcome_domain = esl.asset_id
              AND ol.outcome_type = 'REGIME'
            LIMIT 1
        ) o ON TRUE
        WHERE esl.suppression_timestamp BETWEEN p_period_start AND p_period_end
        GROUP BY esl.asset_id
        ORDER BY regret_count DESC
        LIMIT 20
    )
    SELECT jsonb_object_agg(asset_id, jsonb_build_object('regret', regret_count, 'total', total_count))
    INTO v_regret_by_asset
    FROM asset_breakdown;

    -- Compute hash
    v_hash := encode(sha256(
        (p_period_start::text || p_period_end::text || v_total::text ||
         v_regret_rate::text || v_wisdom_rate::text)::bytea
    ), 'hex');

    -- Insert record
    INSERT INTO fhq_governance.suppression_regret_index (
        period_start, period_end,
        total_suppressions, correct_suppressions, regrettable_suppressions,
        suppression_regret_rate, suppression_wisdom_rate,
        regret_by_regime, regret_by_asset,
        computation_hash
    ) VALUES (
        p_period_start, p_period_end,
        v_total, v_correct, v_regrettable,
        v_regret_rate, v_wisdom_rate,
        COALESCE(v_regret_by_regime, '{}'::jsonb),
        COALESCE(v_regret_by_asset, '{}'::jsonb),
        v_hash
    )
    RETURNING regret_id INTO v_regret_id;

    RETURN v_regret_id;
END;
$$;


--
-- Name: FUNCTION compute_suppression_regret(p_period_start timestamp with time zone, p_period_end timestamp with time zone); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.compute_suppression_regret(p_period_start timestamp with time zone, p_period_end timestamp with time zone) IS 'CEO-DIR-2026-019 P0-1: Compute regret metrics for suppressions in a time period.
REGRET = belief was correct (suppression was a mistake)
WISDOM = belief was wrong (suppression was wise)
Fixed 2026-01-07: outcome_type REGIME_CLASSIFICATION -> REGIME';


--
-- Name: create_state_snapshot(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.create_state_snapshot() RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_snapshot_id UUID;
    v_defcon_state RECORD;
    v_btc_regime RECORD;
    v_strategy RECORD;
    v_state_hash TEXT;
    v_hash_prev TEXT;
BEGIN
    -- Get previous hash for chain
    SELECT hash_self INTO v_hash_prev
    FROM fhq_governance.shared_state_snapshots
    WHERE is_valid = TRUE
    ORDER BY snapshot_timestamp DESC
    LIMIT 1;

    -- 1. Atomically capture DEFCON state
    SELECT state_id, current_defcon::TEXT, reason, triggered_at
    INTO v_defcon_state
    FROM fhq_governance.system_state
    WHERE is_active = TRUE
    LIMIT 1;

    IF v_defcon_state IS NULL THEN
        RAISE EXCEPTION 'ASRP_FAIL: No active DEFCON state found. System HALT required.';
    END IF;

    -- 2. Atomically capture BTC regime
    SELECT regime_label, confidence_score, timestamp
    INTO v_btc_regime
    FROM fhq_research.regime_predictions_v2
    WHERE asset_id = 'BTC-USD'
    ORDER BY timestamp DESC
    LIMIT 1;

    IF v_btc_regime IS NULL THEN
        -- Use UNTRUSTED if no regime available
        v_btc_regime := ROW('UNTRUSTED', 0.0, CURRENT_DATE);
    END IF;

    -- 3. Atomically capture canonical strategy
    SELECT strategy_snapshot_id, posture, target_exposure
    INTO v_strategy
    FROM fhq_governance.canonical_strategy
    WHERE is_active = TRUE
    LIMIT 1;

    IF v_strategy IS NULL THEN
        -- Default to NEUTRAL/CASH if no active strategy
        v_strategy := ROW(NULL, 'NEUTRAL', 0.0);
    END IF;

    -- 4. Compute composite hash (ADR-018 4.1)
    v_state_hash := encode(sha256((
        v_defcon_state.current_defcon || ':' ||
        v_btc_regime.regime_label || ':' ||
        COALESCE(v_strategy.posture, 'NEUTRAL') || ':' ||
        NOW()::TEXT
    )::bytea), 'hex');

    -- 5. Insert atomic snapshot
    INSERT INTO fhq_governance.shared_state_snapshots (
        snapshot_id,
        snapshot_timestamp,
        defcon_level,
        defcon_state_id,
        defcon_reason,
        defcon_triggered_at,
        btc_regime_label,
        btc_regime_confidence,
        btc_regime_timestamp,
        strategy_snapshot_id,
        strategy_posture,
        strategy_exposure,
        state_vector_hash,
        hash_prev,
        hash_self,
        created_by
    ) VALUES (
        gen_random_uuid(),
        NOW(),
        v_defcon_state.current_defcon,
        v_defcon_state.state_id,
        v_defcon_state.reason,
        v_defcon_state.triggered_at,
        v_btc_regime.regime_label,
        v_btc_regime.confidence_score,
        v_btc_regime.timestamp,
        v_strategy.strategy_snapshot_id,
        COALESCE(v_strategy.posture, 'NEUTRAL'),
        COALESCE(v_strategy.target_exposure, 0.0),
        v_state_hash,
        v_hash_prev,
        v_state_hash,
        'STIG'
    ) RETURNING snapshot_id INTO v_snapshot_id;

    -- 6. Invalidate previous snapshots (only one valid at a time)
    UPDATE fhq_governance.shared_state_snapshots
    SET
        valid_until = NOW(),
        is_valid = FALSE,
        invalidation_reason = 'Superseded by new snapshot',
        invalidated_at = NOW(),
        invalidated_by = 'STIG'
    WHERE snapshot_id != v_snapshot_id
    AND is_valid = TRUE;

    RETURN v_snapshot_id;
END;
$$;


--
-- Name: FUNCTION create_state_snapshot(); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.create_state_snapshot() IS 'Atomically captures current state vector per ADR-018 4.1.
Combines DEFCON, BTC regime, and canonical strategy into single atomic snapshot.
Implements torn-read prohibition: all components captured in same transaction.';


--
-- Name: detect_asrp_violation(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.detect_asrp_violation() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_current_hash TEXT;
    v_expected_hash TEXT;
BEGIN
    -- Get current valid state hash
    SELECT state_vector_hash INTO v_expected_hash
    FROM fhq_governance.shared_state_snapshots
    WHERE is_valid = TRUE
    ORDER BY snapshot_timestamp DESC
    LIMIT 1;

    -- Check if output is bound to valid state
    IF NEW.state_snapshot_hash IS NULL THEN
        -- VIOLATION: Output without state binding
        INSERT INTO fhq_governance.asrp_violations (
            violation_type,
            violation_class,
            agent_id,
            attempted_action,
            state_hash_expected,
            state_hash_provided,
            enforcement_action,
            evidence_bundle
        ) VALUES (
            'MISSING_HASH',
            'CLASS_A',
            NEW.agent_id,
            NEW.output_type,
            v_expected_hash,
            'NONE',
            'BLOCKED',
            jsonb_build_object(
                'binding_id', NEW.binding_id,
                'timestamp', NOW(),
                'reason', 'Output attempted without state hash binding'
            )
        );

        RAISE EXCEPTION 'ASRP VIOLATION: Output must be bound to valid state hash';
    END IF;

    -- Check if state hash matches current valid state
    IF NEW.state_snapshot_hash != v_expected_hash THEN
        -- Warning: Using stale state (may be allowed in some cases)
        INSERT INTO fhq_governance.asrp_violations (
            violation_type,
            violation_class,
            agent_id,
            attempted_action,
            state_hash_expected,
            state_hash_provided,
            enforcement_action,
            evidence_bundle
        ) VALUES (
            'STALE_STATE_USE',
            'CLASS_A',
            NEW.agent_id,
            NEW.output_type,
            v_expected_hash,
            NEW.state_snapshot_hash,
            'ESCALATED',
            jsonb_build_object(
                'binding_id', NEW.binding_id,
                'timestamp', NOW(),
                'reason', 'Output uses stale state hash - escalating for review'
            )
        );
    END IF;

    RETURN NEW;
END;
$$;


--
-- Name: FUNCTION detect_asrp_violation(); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.detect_asrp_violation() IS 'Trigger function to detect ASRP violations on output bindings.
Per CEO Directive v2.0: Violation detection + auto-halt.';


--
-- Name: dispatch_event(uuid); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.dispatch_event(p_event_id uuid) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_event RECORD;
    v_trigger RECORD;
    v_queue_count INTEGER := 0;
    v_current_regime VARCHAR(20);
    v_current_defcon INTEGER;
BEGIN
    -- Get event details
    SELECT * INTO v_event
    FROM fhq_governance.system_events
    WHERE event_id = p_event_id;

    IF v_event IS NULL THEN
        RAISE WARNING 'Event not found: %', p_event_id;
        RETURN 0;
    END IF;

    -- Get current context
    SELECT current_regime INTO v_current_regime
    FROM fhq_meta.regime_state LIMIT 1;

    SELECT defcon_level INTO v_current_defcon
    FROM fhq_governance.defcon_state
    WHERE is_current = TRUE LIMIT 1;

    -- Find matching triggers
    FOR v_trigger IN
        SELECT *
        FROM fhq_governance.event_trigger_registry
        WHERE source_event_type = v_event.event_type
          AND is_active = TRUE
          AND (source_agent IS NULL OR source_agent = v_event.source_agent)
          AND (source_ios_layer IS NULL OR source_ios_layer = v_event.source_ios_layer)
          AND (defcon_max IS NULL OR COALESCE(v_current_defcon, 5) <= defcon_max)
          AND (regime_filter IS NULL OR v_current_regime = ANY(regime_filter))
          AND (cooldown_seconds = 0 OR last_triggered_at IS NULL
               OR last_triggered_at < NOW() - (cooldown_seconds || ' seconds')::INTERVAL)
    LOOP
        -- Queue the event for processing
        INSERT INTO fhq_governance.event_queue (
            event_id, event_type, trigger_id,
            target_agent, target_action, priority,
            regime_at_queue, defcon_at_queue
        ) VALUES (
            p_event_id, v_event.event_type, v_trigger.trigger_id,
            v_trigger.target_agent, v_trigger.target_action, v_trigger.target_priority,
            v_current_regime, v_current_defcon
        );

        -- Update trigger stats
        UPDATE fhq_governance.event_trigger_registry
        SET
            last_triggered_at = NOW(),
            trigger_count = trigger_count + 1,
            updated_at = NOW()
        WHERE trigger_id = v_trigger.trigger_id;

        v_queue_count := v_queue_count + 1;
    END LOOP;

    RETURN v_queue_count;
END;
$$;


--
-- Name: FUNCTION dispatch_event(p_event_id uuid); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.dispatch_event(p_event_id uuid) IS 'ARO-20251208 Section 4: Dispatches event to matching triggers, queues actions.
This is the core of event-driven architecture.';


--
-- Name: enforce_calibration_gate(uuid, numeric, text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.enforce_calibration_gate(p_forecast_id uuid, p_confidence numeric, p_forecast_type text, p_regime text DEFAULT 'ALL'::text) RETURNS TABLE(adjusted_confidence numeric, was_capped boolean, gate_id uuid, match_type text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_ceiling_rec RECORD;
BEGIN
    -- Get the active ceiling using band-based lookup (pass confidence to find correct band)
    SELECT * INTO v_ceiling_rec
    FROM fhq_governance.get_active_confidence_ceiling(p_forecast_type, p_confidence, p_regime);

    IF p_confidence > v_ceiling_rec.ceiling THEN
        -- Log violation
        INSERT INTO fhq_governance.gate_violation_log (
            forecast_id, original_confidence, applied_ceiling,
            gate_id, forecast_type, regime, enforced_by
        ) VALUES (
            p_forecast_id, p_confidence, v_ceiling_rec.ceiling,
            v_ceiling_rec.gate_id, p_forecast_type, p_regime, 'STIG'
        );

        RETURN QUERY SELECT
            v_ceiling_rec.ceiling,
            TRUE,
            v_ceiling_rec.gate_id,
            v_ceiling_rec.match_type;
    ELSE
        RETURN QUERY SELECT
            p_confidence,
            FALSE,
            v_ceiling_rec.gate_id,
            v_ceiling_rec.match_type;
    END IF;
END;
$$;


--
-- Name: enforce_ddatp_integrity(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.enforce_ddatp_integrity() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- ========================================================================
    -- Rule 1: SENTIMENT claim requires sentiment_used = true
    -- CEO Correction B: "feed used" not just "feed exists"
    -- ========================================================================
    IF NEW.driver_claim = 'SENTIMENT' THEN
        IF NOT COALESCE((NEW.input_coverage->>'sentiment_used')::boolean, false) THEN
            RAISE EXCEPTION 'DDATP VIOLATION [Rule 1]: SENTIMENT claim requires sentiment_used=true. Got input_coverage=%',
                NEW.input_coverage;
        END IF;
    END IF;

    -- ========================================================================
    -- Rule 2: OBSERVED_DATA basis requires at least one external feed USED
    -- CEO Correction B: Check *_used not just *_available
    -- ========================================================================
    IF NEW.driver_basis = 'OBSERVED_DATA' THEN
        IF NOT (
            COALESCE((NEW.input_coverage->>'macro_used')::boolean, false) OR
            COALESCE((NEW.input_coverage->>'sentiment_used')::boolean, false) OR
            COALESCE((NEW.input_coverage->>'onchain_used')::boolean, false)
        ) THEN
            RAISE EXCEPTION 'DDATP VIOLATION [Rule 2]: OBSERVED_DATA basis requires at least one *_used=true. Got input_coverage=%',
                NEW.input_coverage;
        END IF;
    END IF;

    -- ========================================================================
    -- Rule 3: Fallback reason required when basis != OBSERVED_DATA
    -- ========================================================================
    IF NEW.driver_basis IS NOT NULL AND NEW.driver_basis != 'OBSERVED_DATA' THEN
        IF NEW.fallback_reason IS NULL OR NEW.fallback_reason = '' THEN
            RAISE EXCEPTION 'DDATP VIOLATION [Rule 3]: fallback_reason required when driver_basis=%. Got NULL',
                NEW.driver_basis;
        END IF;
    END IF;

    -- ========================================================================
    -- Rule 4: TECHNICAL claim must specify technical_feature_set
    -- CEO Correction A: Disambiguate TECHNICAL vs PRICE_ACTION
    -- ========================================================================
    IF NEW.driver_claim = 'TECHNICAL' THEN
        IF NEW.technical_feature_set IS NULL THEN
            RAISE EXCEPTION 'DDATP VIOLATION [Rule 4]: TECHNICAL claim requires technical_feature_set. Got NULL';
        END IF;
    END IF;

    -- ========================================================================
    -- Rule 5: PRICE_ACTION only allowed with RETURNS_VOL_ONLY or absent indicators
    -- CEO Correction A: Enforce semantic consistency
    -- ========================================================================
    IF NEW.driver_claim = 'PRICE_ACTION' THEN
        IF NEW.technical_feature_set IS NOT NULL
           AND NEW.technical_feature_set NOT IN ('RETURNS_VOL_ONLY', 'UNKNOWN') THEN
            RAISE EXCEPTION 'DDATP VIOLATION [Rule 5]: PRICE_ACTION incompatible with technical_feature_set=%. Must be RETURNS_VOL_ONLY or UNKNOWN',
                NEW.technical_feature_set;
        END IF;
    END IF;

    RETURN NEW;
END;
$$;


--
-- Name: enforce_defcon_circuit_breaker(text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.enforce_defcon_circuit_breaker(p_action_type text, p_asset_id text DEFAULT NULL::text) RETURNS fhq_governance.defcon_enforcement_result
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_result fhq_governance.defcon_enforcement_result;
    v_current_defcon INTEGER;
    v_defcon_text TEXT;
BEGIN
    -- Initialize result (FAIL-CLOSED default)
    v_result.action_permitted := FALSE;
    v_result.action_type := p_action_type;

    -- Try to get DEFCON from decision_log first (integer)
    SELECT defcon_level INTO v_current_defcon
    FROM fhq_governance.decision_log
    WHERE defcon_level IS NOT NULL
    ORDER BY created_at DESC LIMIT 1;

    -- If not found, check shared_state_snapshots (text -> integer mapping)
    IF v_current_defcon IS NULL THEN
        SELECT defcon_level INTO v_defcon_text
        FROM fhq_governance.shared_state_snapshots
        WHERE is_valid = TRUE
        ORDER BY created_at DESC LIMIT 1;

        -- Map text DEFCON to integer per ADR-016
        v_current_defcon := CASE v_defcon_text
            WHEN 'CRITICAL' THEN 1
            WHEN 'RED' THEN 2
            WHEN 'ORANGE' THEN 3
            WHEN 'YELLOW' THEN 4
            WHEN 'GREEN' THEN 5
            ELSE 5  -- Default safe
        END;
    END IF;

    v_current_defcon := COALESCE(v_current_defcon, 5);
    v_result.current_defcon := v_current_defcon;

    -- DEFCON enforcement rules per ADR-016
    -- DEFCON 1: CRITICAL - No execution permitted
    -- DEFCON 2: HIGH - No new positions, only risk reduction
    -- DEFCON 3-5: Normal operations permitted

    IF v_current_defcon = 1 THEN
        -- DEFCON 1: Complete halt
        v_result.action_permitted := FALSE;
        v_result.enforcement_rule := 'DEFCON_1_TOTAL_HALT';
        v_result.blocked_reason := 'DEFCON 1 ACTIVE: All execution halted';

        -- Log circuit breaker activation
        INSERT INTO fhq_governance.security_alerts (
            alert_type, alert_severity, source_module, description, evidence
        ) VALUES (
            'DEFCON_CIRCUIT_BREAKER',
            'CRITICAL',
            'IoS-012',
            'DEFCON 1 circuit breaker activated - execution blocked',
            jsonb_build_object(
                'defcon_level', v_current_defcon,
                'blocked_action', p_action_type,
                'asset_id', p_asset_id,
                'timestamp', NOW()
            )
        );

        RETURN v_result;

    ELSIF v_current_defcon = 2 THEN
        -- DEFCON 2: Only risk reduction permitted
        IF p_action_type IN ('ACQUIRE', 'BUY') THEN
            v_result.action_permitted := FALSE;
            v_result.enforcement_rule := 'DEFCON_2_NO_NEW_POSITIONS';
            v_result.blocked_reason := 'DEFCON 2 ACTIVE: New positions blocked';

            INSERT INTO fhq_governance.security_alerts (
                alert_type, alert_severity, source_module, description, evidence
            ) VALUES (
                'DEFCON_CIRCUIT_BREAKER',
                'HIGH',
                'IoS-012',
                'DEFCON 2 circuit breaker - new position blocked',
                jsonb_build_object(
                    'defcon_level', v_current_defcon,
                    'blocked_action', p_action_type,
                    'asset_id', p_asset_id
                )
            );

            RETURN v_result;
        ELSE
            -- SELL/HOLD/REBALANCE permitted for risk reduction
            v_result.action_permitted := TRUE;
            v_result.enforcement_rule := 'DEFCON_2_RISK_REDUCTION_ONLY';
            v_result.blocked_reason := NULL;
        END IF;

    ELSE
        -- DEFCON 3-5: Normal operations
        v_result.action_permitted := TRUE;
        v_result.enforcement_rule := 'DEFCON_NORMAL_OPERATIONS';
        v_result.blocked_reason := NULL;
    END IF;

    RETURN v_result;
END;
$$;


--
-- Name: enforce_immutability(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.enforce_immutability() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'UPDATE' THEN
        RAISE EXCEPTION 'GOVERNANCE VIOLATION (ADR-013): UPDATE on fhq_governance.% is prohibited. Governance logs are immutable. Table: %, Operation: %',
            TG_TABLE_NAME, TG_TABLE_NAME, TG_OP;
    END IF;

    IF TG_OP = 'DELETE' THEN
        RAISE EXCEPTION 'GOVERNANCE VIOLATION (ADR-013): DELETE on fhq_governance.% is prohibited. Governance logs are immutable. Table: %, Operation: %',
            TG_TABLE_NAME, TG_TABLE_NAME, TG_OP;
    END IF;

    IF TG_OP = 'TRUNCATE' THEN
        RAISE EXCEPTION 'GOVERNANCE VIOLATION (ADR-013): TRUNCATE on fhq_governance.% is prohibited. Governance logs are immutable. Table: %, Operation: %',
            TG_TABLE_NAME, TG_TABLE_NAME, TG_OP;
    END IF;

    RETURN NULL;
END;
$$;


--
-- Name: FUNCTION enforce_immutability(); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.enforce_immutability() IS 'ADR-013 Immutability Enforcement: Blocks UPDATE/DELETE/TRUNCATE on governance tables.
All governance changes are historical layers, never edits to history.';


--
-- Name: enforce_ios008_mandate(uuid, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.enforce_ios008_mandate(p_decision_id uuid, p_plan_hash text) RETURNS fhq_governance.mandate_validation_result
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_result fhq_governance.mandate_validation_result;
    v_decision RECORD;
    v_authorized_signers TEXT[] := ARRAY['IoS-008'];  -- Only IoS-008 can sign execution mandates
BEGIN
    -- Initialize result (FAIL-CLOSED default)
    v_result.mandate_valid := FALSE;
    v_result.mandate_id := p_decision_id;
    v_result.plan_hash := p_plan_hash;
    v_result.validation_timestamp := NOW();
    v_result.authorized_signer := FALSE;
    v_result.hash_verified := FALSE;

    -- Validate inputs exist (FAIL-CLOSED on NULL)
    IF p_decision_id IS NULL THEN
        v_result.failure_reason := 'NULL_MANDATE_ID';
        INSERT INTO fhq_governance.security_alerts (
            alert_type, alert_severity, source_module, description, evidence
        ) VALUES (
            'MANDATE_ENFORCEMENT_FAILURE', 'CRITICAL', 'IoS-012',
            'HV-001: Mandate enforcement failed - NULL mandate_id',
            jsonb_build_object('failure_reason', 'NULL_MANDATE_ID', 'timestamp', NOW())
        );
        RETURN v_result;
    END IF;

    IF p_plan_hash IS NULL THEN
        v_result.failure_reason := 'NULL_PLAN_HASH';
        INSERT INTO fhq_governance.security_alerts (
            alert_type, alert_severity, source_module, description, evidence
        ) VALUES (
            'MANDATE_ENFORCEMENT_FAILURE', 'CRITICAL', 'IoS-012',
            'HV-001: Mandate enforcement failed - NULL plan_hash',
            jsonb_build_object('mandate_id', p_decision_id, 'failure_reason', 'NULL_PLAN_HASH', 'timestamp', NOW())
        );
        RETURN v_result;
    END IF;

    -- Fetch the DecisionPlan from decision_log
    SELECT decision_id, signature_agent, governance_signature, hash_self
    INTO v_decision
    FROM fhq_governance.decision_log
    WHERE decision_id = p_decision_id;

    -- Check 1: Decision exists
    IF v_decision IS NULL THEN
        v_result.failure_reason := 'MANDATE_NOT_FOUND';
        INSERT INTO fhq_governance.security_alerts (
            alert_type, alert_severity, source_module, description, evidence
        ) VALUES (
            'MANDATE_ENFORCEMENT_FAILURE', 'CRITICAL', 'IoS-012',
            'HV-001: Mandate enforcement failed - decision not found',
            jsonb_build_object('mandate_id', p_decision_id, 'failure_reason', 'MANDATE_NOT_FOUND', 'timestamp', NOW())
        );
        RETURN v_result;
    END IF;

    v_result.signature_agent := v_decision.signature_agent;

    -- Check 2: Signature agent is authorized (IoS-008 only)
    IF v_decision.signature_agent IS NULL OR NOT (v_decision.signature_agent = ANY(v_authorized_signers)) THEN
        v_result.failure_reason := 'UNAUTHORIZED_SIGNER: ' || COALESCE(v_decision.signature_agent, 'NULL');
        v_result.authorized_signer := FALSE;
        INSERT INTO fhq_governance.security_alerts (
            alert_type, alert_severity, source_module, decision_id, description, evidence
        ) VALUES (
            'MANDATE_ENFORCEMENT_FAILURE', 'CRITICAL', 'IoS-012', p_decision_id,
            'HV-001: Mandate enforcement failed - unauthorized signer',
            jsonb_build_object(
                'mandate_id', p_decision_id, 'signature_agent', v_decision.signature_agent,
                'authorized_signers', v_authorized_signers, 'failure_reason', 'UNAUTHORIZED_SIGNER', 'timestamp', NOW()
            )
        );
        RETURN v_result;
    END IF;

    v_result.authorized_signer := TRUE;

    -- Check 3: Decision has signature (Ed25519 signed)
    IF v_decision.governance_signature IS NULL OR LENGTH(v_decision.governance_signature) < 64 THEN
        v_result.failure_reason := 'MISSING_OR_INVALID_SIGNATURE';
        INSERT INTO fhq_governance.security_alerts (
            alert_type, alert_severity, source_module, decision_id, description, evidence
        ) VALUES (
            'MANDATE_ENFORCEMENT_FAILURE', 'CRITICAL', 'IoS-012', p_decision_id,
            'HV-001: Mandate enforcement failed - missing or invalid Ed25519 signature',
            jsonb_build_object(
                'mandate_id', p_decision_id, 'signature_agent', v_decision.signature_agent,
                'failure_reason', 'MISSING_OR_INVALID_SIGNATURE', 'timestamp', NOW()
            )
        );
        RETURN v_result;
    END IF;

    -- Check 4: Plan hash matches decision hash_self
    IF v_decision.hash_self IS NULL OR v_decision.hash_self != p_plan_hash THEN
        v_result.failure_reason := 'PLAN_HASH_MISMATCH';
        v_result.hash_verified := FALSE;
        INSERT INTO fhq_governance.security_alerts (
            alert_type, alert_severity, source_module, decision_id, description, evidence
        ) VALUES (
            'MANDATE_ENFORCEMENT_FAILURE', 'CRITICAL', 'IoS-012', p_decision_id,
            'HV-001: Mandate enforcement failed - plan hash mismatch',
            jsonb_build_object(
                'mandate_id', p_decision_id, 'expected_hash', v_decision.hash_self,
                'provided_hash', p_plan_hash, 'signature_agent', v_decision.signature_agent,
                'failure_reason', 'PLAN_HASH_MISMATCH', 'timestamp', NOW()
            )
        );
        RETURN v_result;
    END IF;

    v_result.hash_verified := TRUE;

    -- All checks passed
    v_result.mandate_valid := TRUE;
    v_result.failure_reason := NULL;

    RETURN v_result;
END;
$$;


--
-- Name: enforce_stillness_protocol(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.enforce_stillness_protocol() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    violation_type TEXT;
BEGIN
    -- Skip enforcement for OBSERVATION_ONLY category
    IF NEW.intervention_category = 'OBSERVATION_ONLY' THEN
        RETURN NEW;
    END IF;

    -- Skip enforcement for REJECTED or EXPIRED status
    IF NEW.intervention_status IN ('REJECTED', 'EXPIRED') THEN
        RETURN NEW;
    END IF;

    -- Check for mandatory intervention_hash
    IF NEW.intervention_hash IS NULL OR NEW.intervention_hash = '' THEN
        RAISE EXCEPTION 'STILLNESS PROTOCOL VIOLATION: intervention_hash is required (ADR-024 Rung C)';
    END IF;

    -- Check for mandatory hypothesis_statement
    IF NEW.hypothesis_statement IS NULL OR NEW.hypothesis_statement = '' THEN
        RAISE EXCEPTION 'STILLNESS PROTOCOL VIOLATION: hypothesis_statement is required (ADR-024 Rung C)';
    END IF;

    -- Check for mandatory scope
    IF NEW.scope_target_tables = '{}' OR NEW.scope_target_tables IS NULL THEN
        RAISE EXCEPTION 'STILLNESS PROTOCOL VIOLATION: scope_target_tables must be defined (ADR-024 Rung C)';
    END IF;

    -- Check for mandatory rollback_strategy
    IF NEW.rollback_strategy IS NULL THEN
        RAISE EXCEPTION 'STILLNESS PROTOCOL VIOLATION: rollback_strategy is required (ADR-024 Rung C)';
    END IF;

    -- For status beyond PROPOSED, require evidence_id
    IF NEW.intervention_status IN ('APPROVED', 'EXECUTING', 'COMPLETED') THEN
        IF NEW.evidence_id IS NULL THEN
            RAISE EXCEPTION 'STILLNESS PROTOCOL VIOLATION: evidence_id required for status % (ADR-024 Rung C)', NEW.intervention_status;
        END IF;
    END IF;

    -- For COMPLETED status, require rollback verification (unless NOT_APPLICABLE)
    IF NEW.intervention_status = 'COMPLETED' AND NEW.rollback_strategy != 'NOT_APPLICABLE' THEN
        IF NEW.rollback_verified = FALSE OR NEW.rollback_verified IS NULL THEN
            RAISE EXCEPTION 'STILLNESS PROTOCOL VIOLATION: rollback_verified must be TRUE before COMPLETED status (ADR-024 Rung C)';
        END IF;
    END IF;

    RETURN NEW;
END;
$$;


--
-- Name: evidence_rejection_gate(text, text, text, timestamp with time zone, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.evidence_rejection_gate(p_artifact_id text, p_artifact_type text, p_artifact_source text, p_claimed_timestamp timestamp with time zone DEFAULT NULL::timestamp with time zone, p_artifact_hash text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_canonical_now TIMESTAMPTZ;
    v_db_txid BIGINT;
    v_time_drift_seconds NUMERIC;
    v_max_drift_seconds NUMERIC := 60;  -- Max 60 seconds drift allowed
    v_result JSONB;
    v_status TEXT;
    v_reason TEXT;
BEGIN
    -- Get canonical time from database
    SELECT NOW() INTO v_canonical_now;
    SELECT txid_current() INTO v_db_txid;
    
    -- Rule 1: Timestamp must be provided
    IF p_claimed_timestamp IS NULL THEN
        v_status := 'INVALID_TIME_CONTEXT';
        v_reason := 'Missing timestamp - artifact must have canonical_created_at';
        
        -- Log rejection
        INSERT INTO fhq_governance.artifact_time_registry (
            artifact_id, artifact_type, artifact_source,
            canonical_created_at, canonical_verified_at,
            canonical_clock_version, source_db_txid,
            time_integrity_status, time_integrity_reason,
            artifact_hash, verified_by
        ) VALUES (
            p_artifact_id, p_artifact_type, p_artifact_source,
            v_canonical_now, v_canonical_now,
            'v1.0', v_db_txid,
            v_status, v_reason,
            p_artifact_hash, 'STIG_REJECTION_GATE'
        ) ON CONFLICT (artifact_id) DO UPDATE SET
            time_integrity_status = v_status,
            time_integrity_reason = v_reason,
            canonical_verified_at = v_canonical_now;
            
        RETURN jsonb_build_object(
            'valid', false,
            'status', v_status,
            'reason', v_reason,
            'artifact_id', p_artifact_id,
            'canonical_now', v_canonical_now,
            'can_use_in_reporting', false,
            'can_use_in_market_learning', false,
            'can_use_in_qgf6', false
        );
    END IF;
    
    -- Rule 2: Timestamp cannot be in the future
    IF p_claimed_timestamp > v_canonical_now THEN
        v_status := 'INVALID_TIME_CONTEXT';
        v_reason := 'Future timestamp detected - artifact timestamp is ahead of canonical clock';
        
        INSERT INTO fhq_governance.artifact_time_registry (
            artifact_id, artifact_type, artifact_source,
            canonical_created_at, canonical_verified_at,
            canonical_clock_version, source_db_txid,
            time_integrity_status, time_integrity_reason,
            artifact_hash, verified_by
        ) VALUES (
            p_artifact_id, p_artifact_type, p_artifact_source,
            p_claimed_timestamp, v_canonical_now,
            'v1.0', v_db_txid,
            v_status, v_reason,
            p_artifact_hash, 'STIG_REJECTION_GATE'
        ) ON CONFLICT (artifact_id) DO UPDATE SET
            time_integrity_status = v_status,
            time_integrity_reason = v_reason,
            canonical_verified_at = v_canonical_now;
            
        RETURN jsonb_build_object(
            'valid', false,
            'status', v_status,
            'reason', v_reason,
            'artifact_id', p_artifact_id,
            'claimed_timestamp', p_claimed_timestamp,
            'canonical_now', v_canonical_now,
            'drift_seconds', EXTRACT(EPOCH FROM (p_claimed_timestamp - v_canonical_now)),
            'can_use_in_reporting', false,
            'can_use_in_market_learning', false,
            'can_use_in_qgf6', false
        );
    END IF;
    
    -- Rule 3: Check for excessive time drift (artifact created way before verification)
    v_time_drift_seconds := EXTRACT(EPOCH FROM (v_canonical_now - p_claimed_timestamp));
    
    -- Artifacts older than 24 hours require special handling
    IF v_time_drift_seconds > 86400 THEN
        v_status := 'VALID';
        v_reason := 'Historical artifact - verified against canonical clock with drift warning';
    ELSE
        v_status := 'VALID';
        v_reason := 'Time integrity verified against canonical clock';
    END IF;
    
    -- Record valid artifact
    INSERT INTO fhq_governance.artifact_time_registry (
        artifact_id, artifact_type, artifact_source,
        canonical_created_at, canonical_verified_at,
        canonical_clock_version, source_db_txid,
        time_integrity_status, time_integrity_reason,
        artifact_hash, verified_by
    ) VALUES (
        p_artifact_id, p_artifact_type, p_artifact_source,
        p_claimed_timestamp, v_canonical_now,
        'v1.0', v_db_txid,
        v_status, v_reason,
        p_artifact_hash, 'STIG_REJECTION_GATE'
    ) ON CONFLICT (artifact_id) DO UPDATE SET
        time_integrity_status = v_status,
        time_integrity_reason = v_reason,
        canonical_verified_at = v_canonical_now;
    
    RETURN jsonb_build_object(
        'valid', true,
        'status', v_status,
        'reason', v_reason,
        'artifact_id', p_artifact_id,
        'claimed_timestamp', p_claimed_timestamp,
        'canonical_now', v_canonical_now,
        'verified_at', v_canonical_now,
        'db_txid', v_db_txid,
        'drift_seconds', v_time_drift_seconds,
        'can_use_in_reporting', true,
        'can_use_in_market_learning', true,
        'can_use_in_qgf6', true
    );
END;
$$;


--
-- Name: execute_paper_trade(text, text, text, numeric, numeric, numeric, uuid, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.execute_paper_trade(p_asset_id text, p_canonical_id text, p_direction text, p_raw_confidence numeric, p_entry_price numeric, p_base_size numeric, p_forecast_id uuid DEFAULT NULL::uuid, p_regime text DEFAULT 'NEUTRAL'::text) RETURNS TABLE(trade_id uuid, executed boolean, blocked_reason text, calibrated_confidence numeric, effective_size numeric, gate_id uuid, novelty_score numeric, effective_slippage numeric)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_trade_id UUID;
    v_ceiling NUMERIC;
    v_gate_id UUID;
    v_calibrated_conf NUMERIC;
    v_novelty NUMERIC;
    v_info_weight NUMERIC;
    v_effective_size NUMERIC;
    v_slippage NUMERIC;
    v_slippage_rule TEXT;
    v_effective_entry NUMERIC;
    v_freshness_check RECORD;
    v_blackout_check RECORD;
    v_threshold_result RECORD;
BEGIN
    -- ========================================================================
    -- CEO-DIR-2026-035: DATA_BLACKOUT CHECK
    -- ========================================================================
    SELECT * INTO v_blackout_check
    FROM fhq_governance.is_data_blackout_active();

    IF v_blackout_check.is_active THEN
        RETURN QUERY SELECT
            NULL::UUID,
            false,
            'BLOCKED: DATA_BLACKOUT active. ' || COALESCE(v_blackout_check.trigger_reason, 'System in blackout mode'),
            NULL::NUMERIC,
            NULL::NUMERIC,
            NULL::UUID,
            NULL::NUMERIC,
            NULL::NUMERIC;
        RETURN;
    END IF;

    -- ========================================================================
    -- CEO-DIR-2026-035: EXECUTION FRESHNESS GATE
    -- ========================================================================
    SELECT * INTO v_freshness_check
    FROM fhq_governance.check_price_freshness(p_canonical_id, 'EXECUTION');

    IF NOT v_freshness_check.is_fresh THEN
        RETURN QUERY SELECT
            NULL::UUID,
            false,
            format('BLOCKED: Price data stale. %s minutes old, max allowed %s minutes for %s.',
                   v_freshness_check.staleness_minutes,
                   v_freshness_check.max_allowed_minutes,
                   v_freshness_check.asset_class),
            NULL::NUMERIC,
            NULL::NUMERIC,
            NULL::UUID,
            NULL::NUMERIC,
            NULL::NUMERIC;
        RETURN;
    END IF;

    -- ========================================================================
    -- EXISTING LOGIC: Calibration gate
    -- ========================================================================
    SELECT ccg.gate_id, ccg.confidence_ceiling
    INTO v_gate_id, v_ceiling
    FROM fhq_governance.confidence_calibration_gates ccg
    WHERE ccg.forecast_type = 'PRICE_DIRECTION'
    AND (ccg.regime = p_regime OR ccg.regime = 'ALL')
    AND (ccg.effective_until IS NULL OR ccg.effective_until > NOW())
    ORDER BY
        CASE WHEN ccg.regime = p_regime THEN 0 ELSE 1 END,
        ccg.effective_from DESC
    LIMIT 1;

    v_ceiling := COALESCE(v_ceiling, 0.50);
    v_calibrated_conf := LEAST(p_raw_confidence, v_ceiling);

    -- Get effective threshold (with cadence floor)
    SELECT * INTO v_threshold_result
    FROM fhq_governance.get_effective_confidence_threshold(0.25, 5);

    IF v_calibrated_conf < v_threshold_result.effective_threshold THEN
        RETURN QUERY SELECT
            NULL::UUID,
            false,
            format('BLOCKED: Calibrated confidence %.4f below threshold %.4f',
                   v_calibrated_conf, v_threshold_result.effective_threshold),
            v_calibrated_conf,
            NULL::NUMERIC,
            v_gate_id,
            NULL::NUMERIC,
            NULL::NUMERIC;
        RETURN;
    END IF;

    -- Calculate novelty score
    SELECT ns.novelty_score INTO v_novelty
    FROM fhq_governance.calculate_novelty_score(p_canonical_id, p_direction, p_regime) ns;

    v_novelty := COALESCE(v_novelty, 0.5);

    -- Calculate info-weighted size
    v_info_weight := v_calibrated_conf * (0.8 + 0.4 * v_novelty);
    v_effective_size := p_base_size * v_info_weight;
    v_effective_size := LEAST(v_effective_size, 0.10);

    -- Calculate dynamic slippage
    SELECT ds.effective_slippage, ds.rule_applied
    INTO v_slippage, v_slippage_rule
    FROM fhq_governance.calculate_dynamic_slippage(p_canonical_id, 0.0005) ds;

    v_slippage := COALESCE(v_slippage, 0.0005);

    -- Calculate effective entry price with slippage
    IF p_direction = 'LONG' THEN
        v_effective_entry := p_entry_price * (1 + v_slippage);
    ELSE
        v_effective_entry := p_entry_price * (1 - v_slippage);
    END IF;

    -- Generate trade ID
    v_trade_id := gen_random_uuid();

    -- Insert paper trade
    INSERT INTO fhq_governance.paper_ledger (
        trade_id,
        decision_timestamp,
        asset_id,
        canonical_id,
        direction,
        raw_position_size,
        calibrated_position_size,
        information_weight,
        raw_confidence,
        calibrated_confidence,
        calibration_gate_id,
        confidence_reduction,
        entry_price,
        simulated_slippage,
        effective_entry_price,
        forecast_id,
        regime_at_entry,
        novelty_score,
        slippage_rule_applied,
        created_by,
        executed_by
    ) VALUES (
        v_trade_id,
        NOW(),
        p_asset_id,
        p_canonical_id,
        p_direction,
        p_base_size,
        v_effective_size,
        v_info_weight,
        p_raw_confidence,
        v_calibrated_conf,
        v_gate_id,
        p_raw_confidence - v_calibrated_conf,
        p_entry_price,
        v_slippage,
        v_effective_entry,
        p_forecast_id,
        p_regime,
        v_novelty,
        v_slippage_rule,
        'LARS',
        'LINE'
    );

    -- Log novelty components
    INSERT INTO fhq_governance.novelty_score_components (
        trade_id,
        regime_shift_score,
        regime_shift_reason,
        asset_novelty_score,
        asset_novelty_reason,
        signal_disagreement_score,
        signal_disagreement_reason,
        total_novelty_score
    )
    SELECT
        v_trade_id,
        ns.regime_shift_component,
        'Regime: ' || p_regime,
        ns.asset_novelty_component,
        'Asset: ' || p_canonical_id,
        ns.signal_disagreement_component,
        'Direction: ' || p_direction,
        ns.novelty_score
    FROM fhq_governance.calculate_novelty_score(p_canonical_id, p_direction, p_regime) ns;

    RETURN QUERY SELECT
        v_trade_id,
        true,
        NULL::TEXT,
        v_calibrated_conf,
        v_effective_size,
        v_gate_id,
        v_novelty,
        v_slippage;
END;
$$;


--
-- Name: execution_guard_check(uuid, text, text, numeric); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.execution_guard_check(p_decision_id uuid, p_asset_id text, p_order_side text, p_order_value numeric) RETURNS fhq_governance.execution_guard_result
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_result fhq_governance.execution_guard_result;
    v_decision RECORD;
    v_skill_score NUMERIC;
    v_min_skill NUMERIC := 0.30; -- ADR-012 minimum skill threshold
    v_max_position_pct NUMERIC := 0.10; -- Max 10% per position
BEGIN
    -- Initialize result (FAIL-CLOSED default)
    v_result.execution_permitted := FALSE;
    v_result.guard_timestamp := NOW();
    v_result.min_required_skill := v_min_skill;

    -- Get decision details
    SELECT * INTO v_decision
    FROM fhq_governance.decision_log
    WHERE decision_id = p_decision_id;

    IF v_decision IS NULL THEN
        v_result.rejection_reason := 'DECISION_NOT_FOUND';
        v_result.economic_safety_check := 'BLOCKED';
        RETURN v_result;
    END IF;

    -- Get skill score from decision record (version-bound)
    v_skill_score := COALESCE(
        v_decision.system_skill_score,
        (v_decision.skill_snapshot->>'fss')::NUMERIC,
        (v_decision.skill_snapshot->>'skill_damper')::NUMERIC,
        0
    );

    v_result.skill_score := v_skill_score;
    v_result.skill_version_id := 'DECISION_' || p_decision_id::TEXT;

    -- Economic Safety Check 1: Minimum Skill Score
    IF v_skill_score < v_min_skill THEN
        v_result.rejection_reason := 'SKILL_BELOW_MINIMUM';
        v_result.economic_safety_check := 'BLOCKED_LOW_SKILL';

        -- Log rejection
        INSERT INTO fhq_governance.security_alerts (
            alert_type, alert_severity, source_module, decision_id, description, evidence
        ) VALUES (
            'EXECUTION_GUARD_REJECTION',
            'HIGH',
            'IoS-012',
            p_decision_id,
            'ExecutionGuard blocked execution: skill score below minimum threshold',
            jsonb_build_object(
                'skill_score', v_skill_score,
                'min_required', v_min_skill,
                'asset_id', p_asset_id,
                'order_side', p_order_side
            )
        );

        RETURN v_result;
    END IF;

    -- Economic Safety Check 2: Position Size Limit
    IF COALESCE(p_order_value, 0) > v_max_position_pct THEN
        v_result.rejection_reason := 'POSITION_SIZE_EXCEEDED';
        v_result.economic_safety_check := 'BLOCKED_POSITION_LIMIT';
        RETURN v_result;
    END IF;

    -- Economic Safety Check 3: Decision TTL
    IF NOW() > v_decision.valid_until THEN
        v_result.rejection_reason := 'DECISION_TTL_EXPIRED';
        v_result.economic_safety_check := 'BLOCKED_TTL';
        RETURN v_result;
    END IF;

    -- All checks passed
    v_result.execution_permitted := TRUE;
    v_result.economic_safety_check := 'PASSED';
    v_result.rejection_reason := NULL;

    RETURN v_result;
END;
$$;


--
-- Name: fn_analyze_calibration_opportunities(integer, integer); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.fn_analyze_calibration_opportunities(p_window_days integer DEFAULT 30, p_min_sample_size integer DEFAULT 10) RETURNS TABLE(parameter_name text, current_value numeric, optimal_value numeric, improvement_pct numeric, sample_size integer, p_value numeric, recommendation text)
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    WITH outcome_analysis AS (
        SELECT
            co.entry_regime,
            COUNT(*) as n,
            AVG(CASE WHEN co.pnl_absolute > 0 THEN 1.0 ELSE 0.0 END) as win_rate,
            AVG(co.pnl_percent) as avg_return,
            STDDEV(co.pnl_percent) as return_stddev
        FROM fhq_canonical.canonical_outcomes co
        WHERE co.exit_timestamp >= NOW() - (p_window_days || ' days')::INTERVAL
        GROUP BY co.entry_regime
        HAVING COUNT(*) >= p_min_sample_size
    ),
    current_calibrations AS (
        SELECT
            cv.parameter_name as param_name,
            cv.value as current_val
        FROM fhq_governance.calibration_versions cv
        WHERE cv.is_active = TRUE
        AND cv.parameter_name LIKE 'TTL_%'
    )
    SELECT
        cc.param_name,
        cc.current_val,
        CASE
            WHEN oa.win_rate > 0.6 THEN LEAST(cc.current_val * 1.5, 1.0)
            WHEN oa.win_rate < 0.4 THEN GREATEST(cc.current_val * 0.5, 0.1)
            ELSE cc.current_val
        END as optimal_val,
        ROUND(((CASE
            WHEN oa.win_rate > 0.6 THEN LEAST(cc.current_val * 1.5, 1.0)
            WHEN oa.win_rate < 0.4 THEN GREATEST(cc.current_val * 0.5, 0.1)
            ELSE cc.current_val
        END - cc.current_val) / NULLIF(cc.current_val, 0) * 100)::NUMERIC, 2),
        oa.n::INTEGER,
        ROUND((1.0 - (oa.win_rate - 0.5)::NUMERIC / 0.5)::NUMERIC, 4),
        CASE
            WHEN oa.win_rate > 0.6 THEN 'CONSIDER INCREASING - High win rate suggests longer TTL is safe'
            WHEN oa.win_rate < 0.4 THEN 'CONSIDER DECREASING - Low win rate suggests faster exits'
            ELSE 'MAINTAIN - Current setting appears appropriate'
        END
    FROM current_calibrations cc
    CROSS JOIN outcome_analysis oa
    WHERE
        (cc.param_name = 'TTL_VOLATILE' AND oa.entry_regime = 'VOLATILE')
        OR (cc.param_name = 'TTL_NEUTRAL' AND oa.entry_regime = 'NEUTRAL')
        OR (cc.param_name = 'TTL_BROKEN' AND oa.entry_regime = 'BROKEN');
END;
$$;


--
-- Name: fn_analyze_confidence_calibration(integer); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.fn_analyze_confidence_calibration(p_window_days integer DEFAULT 14) RETURNS TABLE(confidence_bucket text, predicted_win_rate numeric, actual_win_rate numeric, sample_size integer, brier_score numeric, calibration_error numeric, recommendation text)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    WITH bucketed_outcomes AS (
        SELECT
            -- Bucket confidence into 10% intervals
            CASE
                WHEN co.needle_eqs_score >= 0.9 THEN '90-100%'
                WHEN co.needle_eqs_score >= 0.8 THEN '80-90%'
                WHEN co.needle_eqs_score >= 0.7 THEN '70-80%'
                WHEN co.needle_eqs_score >= 0.6 THEN '60-70%'
                WHEN co.needle_eqs_score >= 0.5 THEN '50-60%'
                ELSE 'Below 50%'
            END as bucket,
            co.needle_eqs_score,
            CASE WHEN co.pnl_absolute > 0 THEN 1.0 ELSE 0.0 END as outcome
        FROM fhq_canonical.canonical_outcomes co
        WHERE co.exit_timestamp >= NOW() - (p_window_days || ' days')::INTERVAL
        AND co.needle_eqs_score IS NOT NULL
    )
    SELECT
        bo.bucket as confidence_bucket,
        ROUND(AVG(bo.needle_eqs_score) * 100, 1) as predicted_win_rate,
        ROUND(AVG(bo.outcome) * 100, 1) as actual_win_rate,
        COUNT(*)::INTEGER as sample_size,
        ROUND(AVG(POWER(bo.needle_eqs_score - bo.outcome, 2)), 4) as brier_score,
        ROUND(ABS(AVG(bo.needle_eqs_score) - AVG(bo.outcome)) * 100, 1) as calibration_error,
        CASE
            WHEN AVG(bo.needle_eqs_score) > AVG(bo.outcome) + 0.1
                THEN 'OVERCONFIDENT - Reduce confidence or tighten filters'
            WHEN AVG(bo.needle_eqs_score) < AVG(bo.outcome) - 0.1
                THEN 'UNDERCONFIDENT - System is better than it thinks'
            ELSE 'WELL CALIBRATED - Confidence matches reality'
        END as recommendation
    FROM bucketed_outcomes bo
    GROUP BY bo.bucket
    HAVING COUNT(*) >= 10
    ORDER BY bo.bucket DESC;
END;
$$;


--
-- Name: fn_approve_epistemic_proposal(uuid, text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.fn_approve_epistemic_proposal(p_proposal_id uuid, p_reviewer text, p_review_notes text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_proposal RECORD;
BEGIN
    SELECT * INTO v_proposal
    FROM fhq_governance.epistemic_proposals
    WHERE proposal_id = p_proposal_id AND status = 'GENERATED';

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Proposal not found or not in GENERATED status';
    END IF;

    -- Update proposal
    UPDATE fhq_governance.epistemic_proposals SET
        status = 'APPROVED',
        reviewed_by = p_reviewer,
        reviewed_at = NOW(),
        review_notes = p_review_notes,
        review_decision_reason = 'Approved for implementation',
        updated_at = NOW()
    WHERE proposal_id = p_proposal_id;

    -- Create corresponding learning_proposal for implementation
    INSERT INTO fhq_governance.learning_proposals (
        engine_id,
        proposal_type,
        current_value,
        proposed_value,
        evidence_bundle,
        submitted_by,
        delta_description
    ) VALUES (
        'CALIBRATION',
        v_proposal.proposal_type,
        v_proposal.current_value,
        v_proposal.proposed_value,
        v_proposal.evidence_outcomes,
        'EPISTEMIC_ENGINE',
        v_proposal.delta_description
    );

    RETURN TRUE;
END;
$$;


--
-- Name: fn_approve_learning_proposal(uuid, character varying, uuid, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.fn_approve_learning_proposal(p_proposal_id uuid, p_reviewed_by character varying, p_vega_attestation_id uuid, p_review_notes text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_engine_id VARCHAR(10);
    v_proposal_type VARCHAR(50);
    v_proposed_value JSONB;
    v_current_version INTEGER;
BEGIN
    -- Validate proposal exists and is pending
    IF NOT EXISTS (
        SELECT 1 FROM fhq_governance.learning_proposals
        WHERE proposal_id = p_proposal_id
        AND status IN ('PENDING', 'UNDER_REVIEW')
    ) THEN
        RAISE EXCEPTION 'Proposal not found or not in reviewable state';
    END IF;

    -- Get proposal details
    SELECT engine_id, proposal_type, proposed_value
    INTO v_engine_id, v_proposal_type, v_proposed_value
    FROM fhq_governance.learning_proposals
    WHERE proposal_id = p_proposal_id;

    -- Get current max version
    SELECT COALESCE(MAX(version_number), 0) INTO v_current_version
    FROM fhq_governance.learning_versions
    WHERE engine_id = v_engine_id AND parameter_type = v_proposal_type;

    -- Update proposal status
    UPDATE fhq_governance.learning_proposals SET
        status = 'APPROVED',
        reviewed_by = p_reviewed_by,
        reviewed_at = NOW(),
        review_notes = p_review_notes,
        vega_attestation_id = p_vega_attestation_id,
        updated_at = NOW()
    WHERE proposal_id = p_proposal_id;

    -- Deactivate current version if exists
    UPDATE fhq_governance.learning_versions SET
        is_active = false,
        deactivated_at = NOW()
    WHERE engine_id = v_engine_id
    AND parameter_type = v_proposal_type
    AND is_active = true;

    -- Create new active version
    INSERT INTO fhq_governance.learning_versions (
        engine_id,
        parameter_type,
        version_number,
        parameter_value,
        source_proposal_id,
        vega_attestation_id,
        is_active,
        activated_at,
        created_by
    ) VALUES (
        v_engine_id,
        v_proposal_type,
        v_current_version + 1,
        v_proposed_value,
        p_proposal_id,
        p_vega_attestation_id,
        true,
        NOW(),
        p_reviewed_by
    );

    -- Log approval
    INSERT INTO fhq_governance.learning_proposal_audit (
        proposal_id,
        action,
        previous_status,
        new_status,
        actor,
        action_reason
    ) VALUES (
        p_proposal_id,
        'APPROVED',
        'PENDING',
        'APPROVED',
        p_reviewed_by,
        COALESCE(p_review_notes, 'VEGA attestation verified')
    );

    RETURN true;
END;
$$;


--
-- Name: fn_expire_old_proposals(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.fn_expire_old_proposals() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_expired_count INTEGER;
BEGIN
    WITH expired AS (
        UPDATE fhq_governance.learning_proposals SET
            status = 'EXPIRED',
            updated_at = NOW()
        WHERE status = 'PENDING'
        AND expires_at < NOW()
        RETURNING proposal_id
    )
    SELECT COUNT(*) INTO v_expired_count FROM expired;

    -- Log expirations
    INSERT INTO fhq_governance.learning_proposal_audit (
        proposal_id, action, previous_status, new_status, actor, action_reason
    )
    SELECT
        proposal_id,
        'EXPIRED',
        'PENDING',
        'EXPIRED',
        'SYSTEM',
        'Proposal expired after 7 days without review'
    FROM fhq_governance.learning_proposals
    WHERE status = 'EXPIRED'
    AND updated_at > NOW() - INTERVAL '1 minute';

    RETURN v_expired_count;
END;
$$;


--
-- Name: fn_generate_epistemic_proposals(text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.fn_generate_epistemic_proposals(p_run_type text DEFAULT 'SCHEDULED'::text, p_triggered_by text DEFAULT 'SCHEDULER'::text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_run_id UUID;
    v_window_start TIMESTAMPTZ;
    v_window_end TIMESTAMPTZ;
    v_proposals_generated INTEGER := 0;
    v_proposals_skipped INTEGER := 0;
    v_outcomes_analyzed INTEGER := 0;
    v_proposal_code TEXT;
    v_proposal_id UUID;
    v_rec RECORD;
BEGIN
    -- Create run record
    v_window_end := NOW();
    v_window_start := NOW() - INTERVAL '30 days';

    INSERT INTO fhq_governance.epistemic_proposal_runs (
        run_type, analysis_window_start, analysis_window_end, triggered_by
    ) VALUES (
        p_run_type, v_window_start, v_window_end, p_triggered_by
    ) RETURNING run_id INTO v_run_id;

    -- Count outcomes in window
    SELECT COUNT(*) INTO v_outcomes_analyzed
    FROM fhq_canonical.canonical_outcomes
    WHERE exit_timestamp BETWEEN v_window_start AND v_window_end;

    -- Generate calibration proposals
    FOR v_rec IN SELECT * FROM fhq_governance.fn_analyze_calibration_opportunities(30, 50) LOOP
        -- Only generate if improvement is significant
        IF ABS(v_rec.improvement_pct) >= 10 AND v_rec.p_value < 0.10 THEN
            -- Generate proposal code
            v_proposal_code := 'EP-' || TO_CHAR(NOW(), 'YYYY-MM-DD') || '-' ||
                LPAD((SELECT COUNT(*) + 1 FROM fhq_governance.epistemic_proposals
                      WHERE generated_at::DATE = CURRENT_DATE)::TEXT, 3, '0');

            INSERT INTO fhq_governance.epistemic_proposals (
                proposal_code,
                proposal_type,
                target_parameter,
                target_schema,
                target_table,
                current_value,
                proposed_value,
                delta_description,
                evidence_sample_size,
                evidence_time_window,
                evidence_win_rate,
                evidence_p_value,
                evidence_outcomes,
                reasoning_summary,
                reasoning_detailed,
                reasoning_methodology,
                expected_improvement,
                expected_magnitude,
                confidence_in_proposal,
                risk_assessment,
                risk_severity,
                rollback_plan,
                generation_run_id
            ) VALUES (
                v_proposal_code,
                'CALIBRATION_ADJUSTMENT',
                v_rec.parameter_name,
                'fhq_governance',
                'calibration_versions',
                jsonb_build_object('value', v_rec.current_value),
                jsonb_build_object('value', v_rec.optimal_value),
                'Adjust ' || v_rec.parameter_name || ' from ' ||
                    v_rec.current_value || ' to ' || v_rec.optimal_value,
                v_rec.sample_size,
                '30 days',
                NULL,  -- Would compute from outcomes
                v_rec.p_value,
                '[]'::JSONB,  -- Would include actual outcome IDs
                v_rec.recommendation,
                'Analysis of ' || v_rec.sample_size || ' outcomes over 30 days suggests ' ||
                    v_rec.parameter_name || ' should be adjusted. ' || v_rec.recommendation ||
                    '. Statistical significance: p=' || v_rec.p_value,
                'Win rate analysis by regime with statistical significance testing',
                'Improved risk-adjusted returns in ' ||
                    REPLACE(v_rec.parameter_name, 'TTL_', '') || ' regime',
                v_rec.improvement_pct || '% improvement in parameter efficiency',
                GREATEST(0.5, 1.0 - v_rec.p_value),  -- Higher confidence for lower p-value
                'Parameter change affects TTL calculation for signals in this regime. ' ||
                    'If prediction is wrong, signals may expire too early or late.',
                CASE
                    WHEN ABS(v_rec.improvement_pct) > 50 THEN 'HIGH'
                    WHEN ABS(v_rec.improvement_pct) > 25 THEN 'MEDIUM'
                    ELSE 'LOW'
                END,
                'Immediate rollback available via fhq_governance.rollback_calibration(). ' ||
                    'Previous version stored in calibration_versions.',
                v_run_id
            );

            v_proposals_generated := v_proposals_generated + 1;
        ELSE
            v_proposals_skipped := v_proposals_skipped + 1;
        END IF;
    END LOOP;

    -- Generate confidence calibration proposals
    FOR v_rec IN SELECT * FROM fhq_governance.fn_analyze_confidence_calibration(14) LOOP
        IF v_rec.calibration_error > 10 AND v_rec.sample_size >= 20 THEN
            v_proposal_code := 'EP-' || TO_CHAR(NOW(), 'YYYY-MM-DD') || '-' ||
                LPAD((SELECT COUNT(*) + 1 FROM fhq_governance.epistemic_proposals
                      WHERE generated_at::DATE = CURRENT_DATE)::TEXT, 3, '0');

            INSERT INTO fhq_governance.epistemic_proposals (
                proposal_code,
                proposal_type,
                target_parameter,
                target_schema,
                target_table,
                current_value,
                proposed_value,
                delta_description,
                evidence_sample_size,
                evidence_time_window,
                evidence_win_rate,
                evidence_p_value,
                evidence_outcomes,
                reasoning_summary,
                reasoning_detailed,
                reasoning_methodology,
                expected_improvement,
                expected_magnitude,
                confidence_in_proposal,
                risk_assessment,
                risk_severity,
                rollback_plan,
                generation_run_id
            ) VALUES (
                v_proposal_code,
                'CONFIDENCE_RECALIBRATION',
                'EQS_CONFIDENCE_' || REPLACE(v_rec.confidence_bucket, '-', '_'),
                'fhq_governance',
                'calibration_versions',
                jsonb_build_object(
                    'bucket', v_rec.confidence_bucket,
                    'predicted', v_rec.predicted_win_rate,
                    'actual', v_rec.actual_win_rate
                ),
                jsonb_build_object(
                    'adjustment', v_rec.recommendation,
                    'brier_score', v_rec.brier_score
                ),
                v_rec.recommendation,
                v_rec.sample_size,
                '14 days',
                v_rec.actual_win_rate / 100.0,
                NULL,
                '[]'::JSONB,
                'Confidence bucket ' || v_rec.confidence_bucket || ' is ' ||
                    CASE WHEN v_rec.predicted_win_rate > v_rec.actual_win_rate
                         THEN 'OVERCONFIDENT' ELSE 'UNDERCONFIDENT' END,
                'In the ' || v_rec.confidence_bucket || ' confidence bucket, ' ||
                    'the system predicted a ' || v_rec.predicted_win_rate || '% win rate ' ||
                    'but actual outcomes showed ' || v_rec.actual_win_rate || '%. ' ||
                    'Brier score: ' || v_rec.brier_score || '. ' ||
                    'Calibration error: ' || v_rec.calibration_error || '%. ' ||
                    v_rec.recommendation,
                'Brier score analysis with confidence bucketing',
                'Better calibrated confidence scores',
                'Reduce calibration error by ' || v_rec.calibration_error || '%',
                0.70,
                'Adjusting confidence interpretation may affect signal filtering. ' ||
                    'Could increase or decrease signal volume.',
                'MEDIUM',
                'Confidence thresholds can be immediately reverted in calibration_versions.',
                v_run_id
            );

            v_proposals_generated := v_proposals_generated + 1;
        ELSE
            v_proposals_skipped := v_proposals_skipped + 1;
        END IF;
    END LOOP;

    -- Update run record
    UPDATE fhq_governance.epistemic_proposal_runs SET
        run_completed_at = NOW(),
        run_status = 'COMPLETED',
        outcomes_analyzed = v_outcomes_analyzed,
        proposals_generated = v_proposals_generated,
        proposals_skipped = v_proposals_skipped
    WHERE run_id = v_run_id;

    -- Log to governance
    INSERT INTO fhq_governance.governance_actions_log (
        action_type,
        action_target,
        action_target_type,
        initiated_by,
        decision,
        decision_rationale,
        agent_id,
        metadata
    ) VALUES (
        'EPISTEMIC_PROPOSAL_GENERATION',
        v_run_id::TEXT,
        'PROPOSAL_RUN',
        p_triggered_by,
        'COMPLETED',
        'Generated ' || v_proposals_generated || ' proposals from ' ||
            v_outcomes_analyzed || ' outcomes',
        'STIG',
        jsonb_build_object(
            'run_id', v_run_id,
            'proposals_generated', v_proposals_generated,
            'proposals_skipped', v_proposals_skipped,
            'outcomes_analyzed', v_outcomes_analyzed,
            'window_days', 30
        )
    );

    RETURN v_run_id;
END;
$$;


--
-- Name: fn_get_active_learning_version(character varying, character varying); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.fn_get_active_learning_version(p_engine_id character varying, p_parameter_type character varying) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_result JSONB;
BEGIN
    SELECT parameter_value INTO v_result
    FROM fhq_governance.learning_versions
    WHERE engine_id = p_engine_id
    AND parameter_type = p_parameter_type
    AND is_active = true;

    RETURN v_result;
END;
$$;


--
-- Name: fn_increment_api_budget(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.fn_increment_api_budget() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.routed_provider IS NOT NULL AND NEW.routed_provider != '' THEN
        INSERT INTO fhq_governance.api_budget_log (
            provider_name,
            usage_date,
            requests_made,
            daily_limit,
            last_request_at
        ) VALUES (
            NEW.routed_provider,
            CURRENT_DATE,
            1,
            COALESCE(
                (SELECT daily_limit FROM fhq_governance.api_budget_log
                 WHERE provider_name = NEW.routed_provider ORDER BY usage_date DESC LIMIT 1),
                1000
            ),
            NOW()
        )
        ON CONFLICT (provider_name, usage_date) DO UPDATE SET
            requests_made = fhq_governance.api_budget_log.requests_made + 1,
            last_request_at = NOW(),
            updated_at = NOW();
    END IF;
    RETURN NEW;
END;
$$;


--
-- Name: fn_reject_epistemic_proposal(uuid, text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.fn_reject_epistemic_proposal(p_proposal_id uuid, p_reviewer text, p_rejection_reason text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE fhq_governance.epistemic_proposals SET
        status = 'REJECTED',
        reviewed_by = p_reviewer,
        reviewed_at = NOW(),
        review_notes = p_rejection_reason,
        review_decision_reason = p_rejection_reason,
        updated_at = NOW()
    WHERE proposal_id = p_proposal_id AND status = 'GENERATED';

    IF NOT FOUND THEN
        RETURN FALSE;
    END IF;

    RETURN TRUE;
END;
$$;


--
-- Name: fn_reject_learning_proposal(uuid, character varying, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.fn_reject_learning_proposal(p_proposal_id uuid, p_reviewed_by character varying, p_rejection_reason text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE fhq_governance.learning_proposals SET
        status = 'REJECTED',
        reviewed_by = p_reviewed_by,
        reviewed_at = NOW(),
        review_notes = p_rejection_reason,
        updated_at = NOW()
    WHERE proposal_id = p_proposal_id
    AND status IN ('PENDING', 'UNDER_REVIEW');

    IF NOT FOUND THEN
        RETURN false;
    END IF;

    -- Log rejection
    INSERT INTO fhq_governance.learning_proposal_audit (
        proposal_id,
        action,
        previous_status,
        new_status,
        actor,
        action_reason
    ) VALUES (
        p_proposal_id,
        'REJECTED',
        'PENDING',
        'REJECTED',
        p_reviewed_by,
        p_rejection_reason
    );

    RETURN true;
END;
$$;


--
-- Name: fn_submit_learning_proposal(character varying, character varying, jsonb, jsonb, jsonb, character varying, character varying); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.fn_submit_learning_proposal(p_engine_id character varying, p_proposal_type character varying, p_current_value jsonb, p_proposed_value jsonb, p_evidence_bundle jsonb, p_submitted_by character varying, p_state_hash character varying DEFAULT NULL::character varying) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_proposal_id UUID;
    v_evidence_count INTEGER;
BEGIN
    -- Calculate evidence metrics
    v_evidence_count := jsonb_array_length(p_evidence_bundle);

    -- Insert proposal
    INSERT INTO fhq_governance.learning_proposals (
        engine_id,
        proposal_type,
        current_value,
        proposed_value,
        evidence_bundle,
        evidence_count,
        submitted_by,
        state_snapshot_hash,
        state_timestamp
    ) VALUES (
        p_engine_id,
        p_proposal_type,
        p_current_value,
        p_proposed_value,
        p_evidence_bundle,
        v_evidence_count,
        p_submitted_by,
        p_state_hash,
        NOW()
    ) RETURNING proposal_id INTO v_proposal_id;

    -- Log submission
    INSERT INTO fhq_governance.learning_proposal_audit (
        proposal_id,
        action,
        previous_status,
        new_status,
        actor,
        action_reason
    ) VALUES (
        v_proposal_id,
        'SUBMITTED',
        NULL,
        'PENDING',
        p_submitted_by,
        'Learning proposal submitted for governance review'
    );

    RETURN v_proposal_id;
END;
$$;


--
-- Name: fn_update_cost_ledger(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.fn_update_cost_ledger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Upsert daily cost ledger entry
    INSERT INTO fhq_governance.telemetry_cost_ledger (
        ledger_id,
        agent_id,
        ledger_date,
        llm_requests,
        llm_tokens_in,
        llm_tokens_out,
        llm_cost_usd,
        total_cost_usd,
        total_requests,
        created_at,
        updated_at
    ) VALUES (
        gen_random_uuid(),
        NEW.agent_id,
        CURRENT_DATE,
        1,
        COALESCE(NEW.tokens_in, 0),
        COALESCE(NEW.tokens_out, 0),
        COALESCE(NEW.cost_usd, 0),
        COALESCE(NEW.cost_usd, 0),
        1,
        NOW(),
        NOW()
    )
    ON CONFLICT (agent_id, ledger_date) DO UPDATE SET
        llm_requests = fhq_governance.telemetry_cost_ledger.llm_requests + 1,
        llm_tokens_in = fhq_governance.telemetry_cost_ledger.llm_tokens_in + COALESCE(NEW.tokens_in, 0),
        llm_tokens_out = fhq_governance.telemetry_cost_ledger.llm_tokens_out + COALESCE(NEW.tokens_out, 0),
        llm_cost_usd = fhq_governance.telemetry_cost_ledger.llm_cost_usd + COALESCE(NEW.cost_usd, 0),
        total_cost_usd = fhq_governance.telemetry_cost_ledger.total_cost_usd + COALESCE(NEW.cost_usd, 0),
        total_requests = fhq_governance.telemetry_cost_ledger.total_requests + 1,
        updated_at = NOW();

    RETURN NEW;
END;
$$;


--
-- Name: freeze_calibration(text, text, text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.freeze_calibration(p_parameter_name text, p_version text, p_vega_approval_ref text, p_frozen_by text DEFAULT 'VEGA'::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_id INTEGER;
    v_value NUMERIC;
BEGIN
    -- Validate approval ref format (G3-YYYY-NNN)
    IF p_vega_approval_ref !~ '^G3-[0-9]{4}-[0-9]{3}$' THEN
        RAISE EXCEPTION 'Invalid VEGA approval reference format. Expected G3-YYYY-NNN';
    END IF;

    -- Update the calibration
    UPDATE fhq_governance.calibration_versions
    SET frozen_at = NOW(),
        frozen_by = p_frozen_by,
        vega_approval_ref = p_vega_approval_ref,
        updated_at = NOW()
    WHERE parameter_name = p_parameter_name
      AND version = p_version
      AND frozen_at IS NULL
    RETURNING id, value INTO v_id, v_value;

    IF v_id IS NULL THEN
        RAISE EXCEPTION 'Calibration not found or already frozen: % %', p_parameter_name, p_version;
    END IF;

    -- Log the freeze
    INSERT INTO fhq_governance.calibration_audit_log (
        calibration_id, parameter_name, version, action,
        new_value, actor, reason, metadata
    ) VALUES (
        v_id, p_parameter_name, p_version, 'FROZEN',
        v_value, p_frozen_by, 'VEGA G3 Approval',
        jsonb_build_object('approval_ref', p_vega_approval_ref)
    );

    RETURN TRUE;
END;
$_$;


--
-- Name: generate_context_package(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.generate_context_package() RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_package_id UUID;
    v_state_snapshot RECORD;
    v_state_vector JSONB;
    v_adr_index JSONB;
    v_ios_index JSONB;
    v_authority_map JSONB;
    v_operational_constraints JSONB;
    v_package_hash TEXT;
    v_quad_hash TEXT;
BEGIN
    -- 1. Get current valid state snapshot (ASRP)
    SELECT
        snapshot_id,
        state_vector_hash,
        snapshot_timestamp,
        defcon_level,
        btc_regime_label,
        btc_regime_confidence,
        strategy_posture,
        strategy_exposure
    INTO v_state_snapshot
    FROM fhq_governance.shared_state_snapshots
    WHERE is_valid = TRUE AND valid_until IS NULL
    ORDER BY snapshot_timestamp DESC
    LIMIT 1;

    IF v_state_snapshot IS NULL THEN
        RAISE EXCEPTION 'CDS_FAIL: No valid state snapshot available. HALT required.';
    END IF;

    -- 2. Build state_vector (CDS 2.1)
    v_state_vector := jsonb_build_object(
        'defcon', v_state_snapshot.defcon_level,
        'regime', v_state_snapshot.btc_regime_label,
        'regime_confidence', v_state_snapshot.btc_regime_confidence,
        'strategy', v_state_snapshot.strategy_posture,
        'strategy_exposure', v_state_snapshot.strategy_exposure,
        'state_snapshot_hash', v_state_snapshot.state_vector_hash,
        'timestamp', v_state_snapshot.snapshot_timestamp
    );

    -- 3. Build ADR index (CDS 2.2)
    SELECT jsonb_agg(jsonb_build_object(
        'id', adr_id,
        'title', adr_title,
        'version', current_version,
        'tier', governance_tier,
        'status', adr_status,
        'sha256', encode(sha256((adr_id || ':' || current_version)::bytea), 'hex')
    ) ORDER BY adr_id)
    INTO v_adr_index
    FROM fhq_meta.adr_registry
    WHERE adr_status IN ('APPROVED', 'ACTIVE');

    -- 4. Build IoS index (CDS 2.3)
    SELECT jsonb_agg(jsonb_build_object(
        'id', r.ios_id,
        'purpose', r.title,
        'owner', r.owner_role,
        'pillar', COALESCE(m.pillar_id, 'UNASSIGNED'),
        'status', r.status,
        'version', r.version
    ) ORDER BY r.ios_id)
    INTO v_ios_index
    FROM fhq_meta.ios_registry r
    LEFT JOIN fhq_governance.ios_quad_mapping m ON r.ios_id = m.ios_id AND m.is_primary = TRUE;

    -- 5. Build authority_map (CDS 2.4)
    v_authority_map := jsonb_build_object(
        'tier_1', jsonb_build_object(
            'agents', ARRAY['LARS', 'STIG', 'FINN', 'VEGA'],
            'description', 'Executive Agents'
        ),
        'tier_2', jsonb_build_object(
            'agents', ARRAY['CFAO', 'CEIO', 'CSEO', 'CDMO', 'LINE'],
            'description', 'Sub-Executive Agents'
        ),
        'object_ownership', jsonb_build_object(
            'defcon', 'STIG',
            'regime', 'FINN',
            'strategy', 'LARS',
            'governance', 'VEGA',
            'execution', 'LINE'
        )
    );

    -- 6. Build operational_constraints (CDS 2.5)
    v_operational_constraints := jsonb_build_object(
        'lids_threshold', jsonb_build_object(
            'value', 0.85,
            'description', 'LIDS P(Truth) must exceed 0.85 for allocation',
            'basis', 'ADR-017 3.1'
        ),
        'quad_hash_required', jsonb_build_object(
            'value', TRUE,
            'description', 'Quad-Hash required for all execution actions',
            'basis', 'ADR-017 4'
        ),
        'state_hash_required', jsonb_build_object(
            'value', TRUE,
            'description', 'State hash required for all agent outputs',
            'basis', 'ADR-018 4'
        ),
        'preflight_checklist', jsonb_build_object(
            'steps', 5,
            'checks', ARRAY[
                'ASRP_STATE_VALID',
                'MIT_QUAD_HASH_PRESENT',
                'LIDS_THRESHOLD_MET',
                'RISL_NOT_HALTED',
                'DUAL_HASH_VALIDATION'
            ]
        ),
        'risl_halt_conditions', jsonb_build_object(
            'triggers', ARRAY['DATA_DRIFT', 'AGENT_HALLUCINATION', 'CONSENSUS_FAILURE'],
            'basis', 'ADR-017 3.4 + ADR-016'
        ),
        'defcon_restrictions', jsonb_build_object(
            'BLACK', 'ALL_OPERATIONS_HALTED',
            'RED', 'EXECUTION_SUSPENDED',
            'ORANGE', 'PAPER_TRADING_ONLY',
            'YELLOW', 'TIER2_RESTRICTED',
            'GREEN', 'NORMAL_OPERATIONS'
        )
    );

    -- 7. Compute package hash
    v_package_hash := encode(sha256((
        v_state_vector::TEXT || ':' ||
        v_adr_index::TEXT || ':' ||
        v_ios_index::TEXT || ':' ||
        v_authority_map::TEXT || ':' ||
        v_operational_constraints::TEXT || ':' ||
        NOW()::TEXT
    )::bytea), 'hex');

    -- 8. Get latest quad_hash if available
    SELECT quad_hash INTO v_quad_hash
    FROM fhq_governance.quad_hash_registry
    WHERE state_snapshot_hash = v_state_snapshot.state_vector_hash
    AND is_valid = TRUE
    ORDER BY created_at DESC
    LIMIT 1;

    -- 9. Invalidate previous packages
    UPDATE fhq_governance.context_packages
    SET
        valid_until = NOW(),
        is_valid = FALSE
    WHERE is_valid = TRUE AND valid_until IS NULL;

    -- 10. Insert new context package
    INSERT INTO fhq_governance.context_packages (
        package_id,
        state_vector,
        state_snapshot_hash,
        adr_index,
        ios_index,
        authority_map,
        operational_constraints,
        quad_hash,
        package_hash,
        created_by
    ) VALUES (
        gen_random_uuid(),
        v_state_vector,
        v_state_snapshot.state_vector_hash,
        v_adr_index,
        v_ios_index,
        v_authority_map,
        v_operational_constraints,
        v_quad_hash,
        v_package_hash,
        'STIG'
    ) RETURNING package_id INTO v_package_id;

    RETURN v_package_id;
END;
$$;


--
-- Name: FUNCTION generate_context_package(); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.generate_context_package() IS 'Generates atomic context package per IoS-013 CDS 2.
Combines state_vector, adr_index, ios_index, authority_map, operational_constraints.
Invalidates previous packages (single valid package at any time).';


--
-- Name: generate_mock_execution_report(uuid, text, numeric, numeric); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.generate_mock_execution_report(p_decision_id uuid, p_asset_id text, p_target_allocation numeric, p_current_position numeric DEFAULT 0) RETURNS TABLE(execution_id uuid, decision_id uuid, asset_id text, order_side text, position_diff numeric, execution_status text, mock_fill_price numeric, mock_fill_qty numeric)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_execution_id UUID;
    v_diff NUMERIC;
    v_side TEXT;
    v_mock_price NUMERIC;
BEGIN
    -- Calculate position difference
    v_diff := p_target_allocation - p_current_position;

    -- Determine order side
    IF v_diff > 0.01 THEN
        v_side := 'BUY';
    ELSIF v_diff < -0.01 THEN
        v_side := 'SELL';
    ELSE
        v_side := 'HOLD';
    END IF;

    -- Mock price (would come from market data in live)
    v_mock_price := CASE p_asset_id
        WHEN 'BTC-USD' THEN 95000
        WHEN 'ETH-USD' THEN 3500
        WHEN 'SOL-USD' THEN 230
        ELSE 100
    END;

    -- Generate execution ID
    v_execution_id := gen_random_uuid();

    RETURN QUERY SELECT
        v_execution_id,
        p_decision_id,
        p_asset_id,
        v_side,
        v_diff,
        'MOCK_FILLED'::TEXT,
        v_mock_price,
        ABS(v_diff);
END;
$$;


--
-- Name: generate_quad_hash(numeric, text, text, text, text, timestamp with time zone, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.generate_quad_hash(p_lids_score numeric, p_acl_agent text, p_dsl_model text, p_risl_status text, p_state_hash text, p_state_timestamp timestamp with time zone, p_created_by text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_quad_hash TEXT;
    v_lids_threshold_met BOOLEAN;
    v_is_valid BOOLEAN;
    v_hash_self TEXT;
BEGIN
    -- Generate the Quad-Hash string
    v_quad_hash := ROUND(p_lids_score, 4)::TEXT || '_' ||
                   p_acl_agent || '_' ||
                   p_dsl_model || '_' ||
                   p_risl_status;

    -- Check LIDS threshold (P(Truth) > 0.85 per ADR-017 3.1)
    v_lids_threshold_met := p_lids_score > 0.85;

    -- Quad-Hash is valid if LIDS threshold met and RISL not halted
    v_is_valid := v_lids_threshold_met AND p_risl_status != 'HALTED';

    -- Compute hash_self
    v_hash_self := encode(sha256((v_quad_hash || ':' || p_state_hash || ':' || NOW()::TEXT)::bytea), 'hex');

    -- Insert into registry
    INSERT INTO fhq_governance.quad_hash_registry (
        lids_score, acl_agent, dsl_model, risl_status,
        quad_hash, state_snapshot_hash, state_timestamp,
        lids_threshold_met, is_valid, created_by, hash_self
    ) VALUES (
        p_lids_score, p_acl_agent, p_dsl_model, p_risl_status,
        v_quad_hash, p_state_hash, p_state_timestamp,
        v_lids_threshold_met, v_is_valid, p_created_by, v_hash_self
    )
    ON CONFLICT (quad_hash) DO UPDATE SET
        state_snapshot_hash = p_state_hash,
        state_timestamp = p_state_timestamp;

    RETURN v_quad_hash;
END;
$$;


--
-- Name: FUNCTION generate_quad_hash(p_lids_score numeric, p_acl_agent text, p_dsl_model text, p_risl_status text, p_state_hash text, p_state_timestamp timestamp with time zone, p_created_by text); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.generate_quad_hash(p_lids_score numeric, p_acl_agent text, p_dsl_model text, p_risl_status text, p_state_hash text, p_state_timestamp timestamp with time zone, p_created_by text) IS 'Generates and registers a Quad-Hash per ADR-017 4.
Validates LIDS threshold (>0.85) and RISL status.
Returns the Quad-Hash string for audit trail binding.';


--
-- Name: get_active_calibration(text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.get_active_calibration(p_parameter_name text) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_value NUMERIC;
BEGIN
    SELECT value INTO v_value
    FROM fhq_governance.calibration_versions
    WHERE parameter_name = p_parameter_name
      AND is_active = TRUE
      AND frozen_at IS NOT NULL
      AND vega_approval_ref IS NOT NULL
    ORDER BY frozen_at DESC
    LIMIT 1;

    IF v_value IS NULL THEN
        RAISE WARNING 'No active calibration found for %', p_parameter_name;
    END IF;

    RETURN v_value;
END;
$$;


--
-- Name: get_active_confidence_ceiling(text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.get_active_confidence_ceiling(p_forecast_type text, p_regime text DEFAULT 'ALL'::text) RETURNS TABLE(ceiling numeric, gate_id uuid, match_type text, historical_accuracy numeric, sample_size integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- PRECEDENCE ORDER (Hardening #3):
    -- 1. Exact match: (forecast_type, regime)
    -- 2. Type + ALL: (forecast_type, 'ALL')
    -- 3. Global fallback: conservative 0.45

    -- Try exact match first
    RETURN QUERY
    SELECT
        g.confidence_ceiling,
        g.gate_id,
        'EXACT'::TEXT as match_type,
        g.historical_accuracy,
        g.sample_size
    FROM fhq_governance.confidence_calibration_gates g
    WHERE g.forecast_type = p_forecast_type
    AND g.regime = p_regime
    AND g.effective_from <= NOW()
    AND (g.effective_until IS NULL OR g.effective_until > NOW())
    ORDER BY g.confidence_ceiling ASC
    LIMIT 1;

    IF FOUND THEN RETURN; END IF;

    -- Try forecast_type + ALL
    RETURN QUERY
    SELECT
        g.confidence_ceiling,
        g.gate_id,
        'TYPE_ALL'::TEXT as match_type,
        g.historical_accuracy,
        g.sample_size
    FROM fhq_governance.confidence_calibration_gates g
    WHERE g.forecast_type = p_forecast_type
    AND g.regime = 'ALL'
    AND g.effective_from <= NOW()
    AND (g.effective_until IS NULL OR g.effective_until > NOW())
    ORDER BY g.confidence_ceiling ASC
    LIMIT 1;

    IF FOUND THEN RETURN; END IF;

    -- Global fallback: conservative 0.45 (no gate found)
    RETURN QUERY
    SELECT
        0.45::NUMERIC as ceiling,
        NULL::UUID as gate_id,
        'GLOBAL_FALLBACK'::TEXT as match_type,
        NULL::NUMERIC as historical_accuracy,
        NULL::INTEGER as sample_size;
END;
$$;


--
-- Name: FUNCTION get_active_confidence_ceiling(p_forecast_type text, p_regime text); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.get_active_confidence_ceiling(p_forecast_type text, p_regime text) IS 'Hardening #3: Regime-conditional override precedence.
     Resolution order: exact (type+regime) > type+ALL > global fallback (0.45)';


--
-- Name: get_active_confidence_ceiling(text, numeric, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.get_active_confidence_ceiling(p_forecast_type text, p_raw_confidence numeric, p_regime text DEFAULT 'ALL'::text) RETURNS TABLE(ceiling numeric, gate_id uuid, match_type text, historical_accuracy numeric, sample_size integer, band_matched text)
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Find the gate that matches the raw_confidence band
    RETURN QUERY
    SELECT
        g.confidence_ceiling,
        g.gate_id,
        'BAND_MATCH'::TEXT,
        g.historical_accuracy,
        g.sample_size,
        (g.confidence_band_min::TEXT || '-' || g.confidence_band_max::TEXT)::TEXT as band_matched
    FROM fhq_governance.confidence_calibration_gates g
    WHERE g.forecast_type = p_forecast_type
      AND (g.regime = p_regime OR g.regime = 'ALL')
      AND g.effective_from <= NOW()
      AND (g.effective_until IS NULL OR g.effective_until > NOW())
      AND g.approved_by = 'VEGA'  -- Only VEGA-attested gates are enforceable
      AND p_raw_confidence >= g.confidence_band_min
      AND p_raw_confidence < g.confidence_band_max
    LIMIT 1;

    -- If found, return
    IF FOUND THEN RETURN; END IF;

    -- Check for any VEGA-attested gate for this forecast type (fallback to most conservative)
    RETURN QUERY
    SELECT
        MIN(g.confidence_ceiling),
        NULL::UUID,
        'TYPE_FALLBACK'::TEXT,
        NULL::NUMERIC,
        NULL::INTEGER,
        'FALLBACK'::TEXT
    FROM fhq_governance.confidence_calibration_gates g
    WHERE g.forecast_type = p_forecast_type
      AND g.approved_by = 'VEGA'
      AND g.effective_until IS NULL;

    IF FOUND THEN RETURN; END IF;

    -- Global fallback: conservative 0.50 (no gate found)
    RETURN QUERY
    SELECT
        0.50::NUMERIC as ceiling,
        NULL::UUID as gate_id,
        'GLOBAL_FALLBACK'::TEXT as match_type,
        NULL::NUMERIC as historical_accuracy,
        NULL::INTEGER as sample_size,
        'NO_GATE'::TEXT as band_matched;
END;
$$;


--
-- Name: get_agent_suspension_status(text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.get_agent_suspension_status(p_agent_id text) RETURNS TABLE(agent_id text, is_suspended boolean, has_pending_request boolean, pending_request_id uuid, last_suspension_request_at timestamp with time zone, discrepancy_score numeric)
    LANGUAGE plpgsql STABLE
    AS $$

BEGIN

    RETURN QUERY

    SELECT

        a.agent_id,

        a.is_suspended,

        EXISTS (

            SELECT 1 FROM fhq_governance.agent_suspension_requests r

            WHERE r.agent_id = a.agent_id AND r.status = 'PENDING'

        ) AS has_pending_request,

        (

            SELECT r.request_id FROM fhq_governance.agent_suspension_requests r

            WHERE r.agent_id = a.agent_id AND r.status = 'PENDING'

            ORDER BY r.created_at DESC LIMIT 1

        ) AS pending_request_id,

        (

            SELECT MAX(r.created_at) FROM fhq_governance.agent_suspension_requests r

            WHERE r.agent_id = a.agent_id

        ) AS last_suspension_request_at,

        (

            SELECT r.discrepancy_score FROM fhq_governance.agent_suspension_requests r

            WHERE r.agent_id = a.agent_id AND r.status = 'PENDING'

            ORDER BY r.created_at DESC LIMIT 1

        ) AS discrepancy_score

    FROM fhq_org.org_agents a

    WHERE a.agent_id = p_agent_id;

END;

$$;


--
-- Name: FUNCTION get_agent_suspension_status(p_agent_id text); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.get_agent_suspension_status(p_agent_id text) IS 'ADR-009: Get comprehensive suspension status for an agent';


--
-- Name: get_current_week_metrics(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.get_current_week_metrics() RETURNS TABLE(iso_year integer, iso_week integer, total_suppressions bigint, regret_count bigint, wisdom_count bigint, regret_rate numeric, type_a_count bigint, type_b_count bigint, type_c_count bigint, avg_regret_magnitude numeric)
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_current_year INTEGER;
  v_current_week INTEGER;
BEGIN
  -- Get current ISO week
  v_current_year := EXTRACT(ISOYEAR FROM CURRENT_DATE);
  v_current_week := EXTRACT(WEEK FROM CURRENT_DATE);

  RETURN QUERY
  SELECT
    v_current_year as iso_year,
    v_current_week as iso_week,
    COUNT(*) as total_suppressions,
    COUNT(*) FILTER (WHERE regret_classification = 'REGRET') as regret_count,
    COUNT(*) FILTER (WHERE regret_classification = 'WISDOM') as wisdom_count,
    ROUND(
      COUNT(*) FILTER (WHERE regret_classification = 'REGRET')::NUMERIC / NULLIF(COUNT(*), 0),
      4
    ) as regret_rate,
    COUNT(*) FILTER (WHERE regret_attribution_type = 'TYPE_A_HYSTERESIS_LAG') as type_a_count,
    COUNT(*) FILTER (WHERE regret_attribution_type = 'TYPE_B_CONFIDENCE_FLOOR') as type_b_count,
    COUNT(*) FILTER (WHERE regret_attribution_type = 'TYPE_C_DATA_BLINDNESS') as type_c_count,
    AVG(regret_magnitude) FILTER (WHERE regret_classification = 'REGRET') as avg_regret_magnitude
  FROM fhq_governance.epistemic_suppression_ledger
  WHERE EXTRACT(ISOYEAR FROM suppression_timestamp) = v_current_year
    AND EXTRACT(WEEK FROM suppression_timestamp) = v_current_week;
END;
$$;


--
-- Name: get_effective_confidence_threshold(numeric, integer); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.get_effective_confidence_threshold(p_base_threshold numeric DEFAULT 0.25, p_min_daily_trades integer DEFAULT 5) RETURNS TABLE(effective_threshold numeric, adjustment_applied boolean, adjustment_reason text, trades_today integer, vega_exception_active boolean)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_trades_today INTEGER;
    v_threshold NUMERIC;
    v_adjustment_reason TEXT;
    v_exception_threshold NUMERIC;
    v_exception_active BOOLEAN := FALSE;
    v_hard_floor NUMERIC := 0.22;  -- HARDENING 1: Hard floor
BEGIN
    -- Count trades today
    SELECT COUNT(*) INTO v_trades_today
    FROM fhq_governance.paper_ledger
    WHERE decision_timestamp::date = CURRENT_DATE;

    -- Check for active VEGA-approved exception
    SELECT approved_threshold INTO v_exception_threshold
    FROM fhq_governance.cadence_exception_log
    WHERE exception_date = CURRENT_DATE
    AND status = 'APPROVED'
    AND expires_at > NOW()
    LIMIT 1;

    IF v_exception_threshold IS NOT NULL THEN
        v_exception_active := TRUE;
        v_hard_floor := v_exception_threshold;  -- VEGA can lower floor
    END IF;

    -- Adjust threshold if below minimum cadence
    IF v_trades_today < p_min_daily_trades THEN
        -- Calculate proposed reduction
        v_threshold := p_base_threshold - (0.01 * (p_min_daily_trades - v_trades_today));

        -- HARDENING 1: Enforce hard floor (22% unless VEGA exception)
        IF v_threshold < v_hard_floor THEN
            v_threshold := v_hard_floor;
            v_adjustment_reason := format(
                'Threshold lowered to floor %s (VEGA exception: %s). Cadence: %s/%s trades',
                v_hard_floor, v_exception_active, v_trades_today, p_min_daily_trades
            );
        ELSE
            v_adjustment_reason := format(
                'Threshold lowered from %s to %s due to cadence (%s/%s trades)',
                p_base_threshold, v_threshold, v_trades_today, p_min_daily_trades
            );
        END IF;

        RETURN QUERY SELECT v_threshold, TRUE, v_adjustment_reason, v_trades_today, v_exception_active;
    ELSE
        RETURN QUERY SELECT p_base_threshold, FALSE, 'Cadence met'::TEXT, v_trades_today, v_exception_active;
    END IF;
END;
$$;


--
-- Name: has_pending_suspension(text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.has_pending_suspension(p_agent_id text) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$

BEGIN

    RETURN EXISTS (

        SELECT 1 FROM fhq_governance.agent_suspension_requests

        WHERE agent_id = p_agent_id AND status = 'PENDING'

    );

END;

$$;


--
-- Name: FUNCTION has_pending_suspension(p_agent_id text); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.has_pending_suspension(p_agent_id text) IS 'ADR-009: Check if an agent has a pending suspension request awaiting CEO review';


--
-- Name: init_weekly_learning_run(text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.init_weekly_learning_run(p_initiated_by text DEFAULT 'LARS_ORCHESTRATOR'::text) RETURNS TABLE(run_id uuid, iso_year integer, iso_week integer, gate_passed boolean, block_reason text, already_ran_this_week boolean)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_run_id UUID;
    v_iso_year INTEGER;
    v_iso_week INTEGER;
    v_gate_result RECORD;
    v_existing_run UUID;
BEGIN
    -- Get current ISO week (idempotency check - CEO Condition 3)
    SELECT EXTRACT(ISOYEAR FROM NOW()) INTO v_iso_year;
    SELECT EXTRACT(WEEK FROM NOW()) INTO v_iso_week;

    -- Check if run already exists for this ISO week
    SELECT wlr.run_id INTO v_existing_run
    FROM fhq_governance.weekly_learning_runs wlr
    WHERE wlr.iso_year = v_iso_year
      AND wlr.iso_week = v_iso_week;

    IF v_existing_run IS NOT NULL THEN
        -- Already ran this week, return existing run details
        SELECT
            wlr.run_id,
            wlr.iso_year,
            wlr.iso_week,
            wlr.gate_check_passed,
            wlr.gate_block_reason,
            TRUE as already_ran_this_week
        INTO run_id, iso_year, iso_week, gate_passed, block_reason, already_ran_this_week
        FROM fhq_governance.weekly_learning_runs wlr
        WHERE wlr.run_id = v_existing_run;

        RETURN NEXT;
        RETURN;
    END IF;

    -- Check learning gate (CEO Condition 1)
    SELECT * INTO v_gate_result
    FROM fhq_governance.check_learning_gate();

    -- Create run record
    INSERT INTO fhq_governance.weekly_learning_runs (
        run_id,
        iso_year,
        iso_week,
        run_status,
        initiated_by,
        learning_eligible,
        cognitive_fasting,
        defcon_level,
        paper_trading_eligible,
        gate_check_passed,
        gate_block_reason
    ) VALUES (
        gen_random_uuid(),
        v_iso_year,
        v_iso_week,
        CASE WHEN v_gate_result.gate_passed THEN 'GATE_CHECK_PASSED' ELSE 'GATE_CHECK_BLOCKED' END,
        p_initiated_by,
        v_gate_result.learning_eligible,
        v_gate_result.cognitive_fasting,
        v_gate_result.defcon_level,
        v_gate_result.paper_trading_eligible,
        v_gate_result.gate_passed,
        v_gate_result.block_reason
    )
    RETURNING weekly_learning_runs.run_id INTO v_run_id;

    -- Log to governance (CEO Condition 1: must be logged)
    INSERT INTO fhq_governance.governance_actions_log (
        action_type,
        action_target,
        action_target_type,
        initiated_by,
        decision,
        decision_rationale,
        metadata
    ) VALUES (
        'WEEKLY_LEARNING_CYCLE_INIT',
        v_run_id::text,
        'LEARNING_ORCHESTRATION',
        p_initiated_by,
        CASE WHEN v_gate_result.gate_passed THEN 'GATE_PASSED' ELSE 'GATE_BLOCKED' END,
        COALESCE(
            v_gate_result.block_reason,
            'All gate conditions passed - learning cycle authorized'
        ),
        jsonb_build_object(
            'directive', 'CEO-DIR-2026-021',
            'step', 'STEP_4',
            'iso_year', v_iso_year,
            'iso_week', v_iso_week,
            'learning_eligible', v_gate_result.learning_eligible,
            'cognitive_fasting', v_gate_result.cognitive_fasting,
            'defcon_level', v_gate_result.defcon_level,
            'paper_trading_eligible', v_gate_result.paper_trading_eligible,
            'gate_passed', v_gate_result.gate_passed,
            'block_reason', v_gate_result.block_reason
        )
    );

    -- Return run details
    RETURN QUERY SELECT
        v_run_id,
        v_iso_year,
        v_iso_week,
        v_gate_result.gate_passed,
        v_gate_result.block_reason,
        FALSE as already_ran_this_week;
END;
$$;


--
-- Name: FUNCTION init_weekly_learning_run(p_initiated_by text); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.init_weekly_learning_run(p_initiated_by text) IS 'CEO-DIR-2026-021 Step 4: Initialize weekly learning run with state gate check.
Enforces idempotency: returns existing run if already executed this ISO week.
Logs gate check result to governance_actions_log (Condition 1).
Fail-closed: blocks execution if any gate condition fails.';


--
-- Name: initiate_reactivation_cycle(text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.initiate_reactivation_cycle(p_initiated_by text DEFAULT 'STIG'::text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_cycle_id UUID;
    v_blackout_id UUID;
BEGIN
    -- Get current blackout ID
    SELECT blackout_id INTO v_blackout_id
    FROM fhq_governance.data_blackout_state
    WHERE is_active = true
    ORDER BY created_at DESC
    LIMIT 1;

    -- Create reactivation cycle
    INSERT INTO fhq_governance.aci_reactivation_cycles (
        triggered_from_blackout_id,
        cycle_status,
        initiated_by
    ) VALUES (
        v_blackout_id,
        'INITIATED',
        p_initiated_by
    )
    RETURNING cycle_id INTO v_cycle_id;

    -- Create phase records
    INSERT INTO fhq_governance.aci_reactivation_phases (reactivation_cycle_id, phase_name, phase_status)
    VALUES
        (v_cycle_id, 'PHASE_A_DATA', 'PENDING'),
        (v_cycle_id, 'PHASE_B_PERCEPTION', 'PENDING'),
        (v_cycle_id, 'PHASE_C_LEARNING', 'PENDING');

    RETURN v_cycle_id;
END;
$$;


--
-- Name: is_data_blackout_active(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.is_data_blackout_active() RETURNS TABLE(is_active boolean, trigger_reason text, triggered_at timestamp with time zone, stale_assets text[])
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        dbs.is_active,
        dbs.trigger_reason,
        dbs.triggered_at,
        dbs.stale_assets
    FROM fhq_governance.data_blackout_state dbs
    ORDER BY dbs.created_at DESC
    LIMIT 1;
END;
$$;


--
-- Name: list_pending_suspension_requests(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.list_pending_suspension_requests() RETURNS TABLE(request_id uuid, agent_id text, agent_name text, requested_by text, reason text, discrepancy_score numeric, created_at timestamp with time zone, evidence_summary jsonb)
    LANGUAGE plpgsql STABLE
    AS $$

BEGIN

    RETURN QUERY

    SELECT

        r.request_id,

        r.agent_id,

        a.agent_name,

        r.requested_by,

        r.reason,

        r.discrepancy_score,

        r.created_at,

        jsonb_build_object(

            'threshold_exceeded', r.discrepancy_score > r.discrepancy_threshold,

            'threshold', r.discrepancy_threshold,

            'adr_reference', r.adr_reference

        ) AS evidence_summary

    FROM fhq_governance.agent_suspension_requests r

    JOIN fhq_org.org_agents a ON r.agent_id = a.agent_id

    WHERE r.status = 'PENDING'

    ORDER BY r.created_at DESC;

END;

$$;


--
-- Name: FUNCTION list_pending_suspension_requests(); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.list_pending_suspension_requests() IS 'ADR-009 Section 5.3: List all pending suspension requests for CEO review';


--
-- Name: log_api_usage(text, text, text, text, integer); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.log_api_usage(p_agent_id text, p_provider text, p_priority text DEFAULT 'NORMAL'::text, p_justification text DEFAULT NULL::text, p_credits integer DEFAULT 1) RETURNS uuid
    LANGUAGE plpgsql
    AS $$

DECLARE

    v_log_id UUID;

    v_tier TEXT;

    v_check RECORD;

BEGIN

    -- Check budget first

    SELECT * INTO v_check FROM fhq_governance.check_api_budget(p_agent_id, p_provider, p_priority);



    IF NOT v_check.allowed THEN

        RAISE EXCEPTION 'API call blocked: %', v_check.reason;

    END IF;



    v_tier := v_check.tier_name;



    -- SNIPER tier requires justification

    IF v_tier = 'SNIPER' AND p_justification IS NULL THEN

        RAISE EXCEPTION 'SNIPER tier requires justification (ADR-002 compliance)';

    END IF;



    -- Log the usage

    INSERT INTO fhq_monitoring.api_budget_log (

        agent_id, provider, usage_tier, credits_used, priority_level, justification

    ) VALUES (

        p_agent_id, UPPER(p_provider), v_tier, p_credits, p_priority, p_justification

    ) RETURNING log_id INTO v_log_id;



    RETURN v_log_id;

END;

$$;


--
-- Name: log_bpav_computation(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.log_bpav_computation() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.bpav IS DISTINCT FROM OLD.bpav AND NEW.bpav IS NOT NULL THEN
        INSERT INTO fhq_governance.oracle_event_log (
            vector_id,
            operator,
            action,
            bpav_used,
            context
        ) VALUES (
            NEW.vector_id,
            COALESCE(NEW.bpav_computed_by, 'IoS-009'),
            'BPAV_COMPUTE',
            NEW.bpav,
            jsonb_build_object(
                'computed_at', NEW.bpav_computed_at,
                'previous_bpav', OLD.bpav
            )
        );
    END IF;
    RETURN NEW;
END;
$$;


--
-- Name: log_execution_state_change(character varying, text, character varying); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.log_execution_state_change(p_change_type character varying, p_change_reason text, p_initiated_by character varying) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_state_before JSONB;
    v_state_after JSONB;
    v_version_before INTEGER;
    v_version_after INTEGER;
    v_state_id INTEGER;
    v_change_id UUID;
BEGIN
    -- Get current state as snapshot
    SELECT
        state_id,
        state_version,
        jsonb_build_object(
            'cognitive_fasting', cognitive_fasting,
            'defcon_level', defcon_level,
            'revalidation_required', revalidation_required,
            'fasting_reason', fasting_reason,
            'fasting_started_at', fasting_started_at,
            'last_lids_block_at', last_lids_block_at,
            'last_lids_block_type', last_lids_block_type,
            'lids_blocks_today', lids_blocks_today,
            'lids_passes_today', lids_passes_today,
            'paper_trading_eligible', paper_trading_eligible,
            'learning_eligible', learning_eligible,
            'last_cnrp_completion', last_cnrp_completion
        )
    INTO v_state_id, v_version_before, v_state_before
    FROM fhq_governance.execution_state
    ORDER BY state_id DESC
    LIMIT 1;

    -- Increment version
    v_version_after := v_version_before + 1;

    -- Update execution_state
    UPDATE fhq_governance.execution_state
    SET state_version = v_version_after,
        last_updated_at = NOW(),
        last_updated_by = p_initiated_by,
        last_update_reason = p_change_reason
    WHERE state_id = v_state_id;

    -- Get new state snapshot
    SELECT jsonb_build_object(
        'cognitive_fasting', cognitive_fasting,
        'defcon_level', defcon_level,
        'revalidation_required', revalidation_required,
        'fasting_reason', fasting_reason,
        'fasting_started_at', fasting_started_at,
        'last_lids_block_at', last_lids_block_at,
        'last_lids_block_type', last_lids_block_type,
        'lids_blocks_today', lids_blocks_today,
        'lids_passes_today', lids_passes_today,
        'paper_trading_eligible', paper_trading_eligible,
        'learning_eligible', learning_eligible,
        'last_cnrp_completion', last_cnrp_completion
    )
    INTO v_state_after
    FROM fhq_governance.execution_state
    WHERE state_id = v_state_id;

    -- Insert change log (APPEND-ONLY)
    INSERT INTO fhq_governance.execution_state_change_log (
        state_id,
        state_version_before,
        state_version_after,
        previous_state,
        new_state,
        change_type,
        change_reason,
        initiated_by
    ) VALUES (
        v_state_id,
        v_version_before,
        v_version_after,
        v_state_before,
        v_state_after,
        p_change_type,
        p_change_reason,
        p_initiated_by
    )
    RETURNING change_id INTO v_change_id;

    RETURN v_change_id;
END;
$$;


--
-- Name: log_narrative_vector_create(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.log_narrative_vector_create() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO fhq_governance.oracle_event_log (
        vector_id,
        operator,
        action,
        context
    ) VALUES (
        NEW.vector_id,
        NEW.created_by,
        'CREATE',
        jsonb_build_object(
            'domain', NEW.domain,
            'probability', NEW.probability,
            'confidence', NEW.confidence,
            'half_life_hours', NEW.half_life_hours
        )
    );
    RETURN NEW;
END;
$$;


--
-- Name: prevent_change_log_modification(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.prevent_change_log_modification() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    RAISE EXCEPTION 'CEO-DIR-2026-020 D4: execution_state_change_log is APPEND-ONLY. Updates and deletes are forbidden.';
    RETURN NULL;
END;
$$;


--
-- Name: prevent_decision_log_modification(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.prevent_decision_log_modification() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'UPDATE' THEN
        -- Only allow execution_state updates (and related fields)
        IF OLD.context_hash != NEW.context_hash OR
           OLD.asset_directives != NEW.asset_directives OR
           OLD.final_allocation != NEW.final_allocation OR
           OLD.hash_self != NEW.hash_self THEN
            RAISE EXCEPTION 'GOVERNANCE VIOLATION: decision_log is append-only. Core fields cannot be modified.';
        END IF;
    ELSIF TG_OP = 'DELETE' THEN
        RAISE EXCEPTION 'GOVERNANCE VIOLATION: decision_log records cannot be deleted.';
    END IF;
    RETURN NEW;
END;
$$;


--
-- Name: process_event_queue(character varying, integer); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.process_event_queue(p_target_agent character varying DEFAULT NULL::character varying, p_max_items integer DEFAULT 10) RETURNS TABLE(queue_id uuid, target_agent character varying, target_action character varying, status character varying)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_item RECORD;
    v_start_time TIMESTAMP;
BEGIN
    -- Get pending items for processing
    FOR v_item IN
        SELECT q.*
        FROM fhq_governance.event_queue q
        WHERE q.status = 'PENDING'
          AND (p_target_agent IS NULL OR q.target_agent = p_target_agent)
        ORDER BY q.priority ASC, q.queued_at ASC
        LIMIT p_max_items
        FOR UPDATE SKIP LOCKED
    LOOP
        v_start_time := clock_timestamp();

        -- Mark as processing
        UPDATE fhq_governance.event_queue
        SET status = 'PROCESSING', started_at = NOW()
        WHERE event_queue.queue_id = v_item.queue_id;

        -- Return the item for external processing
        -- Note: Actual action execution happens outside SQL (in Python)
        queue_id := v_item.queue_id;
        target_agent := v_item.target_agent;
        target_action := v_item.target_action;
        status := 'PROCESSING';

        RETURN NEXT;
    END LOOP;
END;
$$;


--
-- Name: FUNCTION process_event_queue(p_target_agent character varying, p_max_items integer); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.process_event_queue(p_target_agent character varying, p_max_items integer) IS 'ARO-20251208: Retrieves pending events from queue for processing.
Agents call this to get their pending actions.';


--
-- Name: promote_oracle_submission(uuid, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.promote_oracle_submission(p_submission_id uuid, p_reviewer text DEFAULT 'VEGA'::text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_submission RECORD;
    v_vector_id UUID;
BEGIN
    -- Get the submission
    SELECT * INTO v_submission
    FROM fhq_governance.oracle_staging
    WHERE submission_id = p_submission_id
      AND review_status = 'APPROVED';

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Submission not found or not in APPROVED status';
    END IF;

    -- Insert into narrative_vectors
    INSERT INTO fhq_meta.narrative_vectors (
        domain,
        narrative,
        probability,
        confidence,
        half_life_hours,
        created_by,
        is_expired
    ) VALUES (
        v_submission.domain,
        v_submission.narrative,
        v_submission.probability,
        v_submission.confidence,
        v_submission.half_life_hours,
        v_submission.submitted_by,
        FALSE
    )
    RETURNING vector_id INTO v_vector_id;

    -- Update staging record
    UPDATE fhq_governance.oracle_staging
    SET review_status = 'PROMOTED',
        promoted_to_vector_id = v_vector_id,
        promoted_at = NOW()
    WHERE submission_id = p_submission_id;

    -- Log the promotion
    INSERT INTO fhq_governance.governance_actions_log (
        action_type, action_target, action_target_type, initiated_by,
        decision, decision_rationale, hash_chain_id
    ) VALUES (
        'ORACLE_PROMOTION',
        v_vector_id::TEXT,
        'NARRATIVE_VECTOR',
        p_reviewer,
        'PROMOTED',
        format('Promoted submission %s to vector %s', p_submission_id, v_vector_id),
        format('HC-PROMOTE-%s', CURRENT_DATE)
    );

    RETURN v_vector_id;
END;
$$;


--
-- Name: propose_ael_intervention(text, text, text, text, text[], text, text, text, text, text, text, jsonb); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.propose_ael_intervention(p_name text, p_category text, p_hypothesis text, p_target_schema text, p_target_tables text[], p_expected_direction text, p_expected_magnitude text, p_blast_radius text, p_isolation_window text, p_rollback_strategy text, p_proposed_by text, p_parameter_bounds jsonb DEFAULT '{}'::jsonb) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_intervention_id UUID;
    v_hash TEXT;
BEGIN
    -- Generate deterministic hash
    v_hash := md5(
        p_name || '|' ||
        p_category || '|' ||
        p_hypothesis || '|' ||
        p_target_schema || '|' ||
        array_to_string(p_target_tables, ',') || '|' ||
        NOW()::TEXT
    );

    INSERT INTO fhq_governance.ael_intervention_registry (
        intervention_hash,
        intervention_name,
        intervention_category,
        scope_target_schema,
        scope_target_tables,
        scope_parameter_bounds,
        scope_blast_radius,
        hypothesis_statement,
        expected_direction,
        expected_magnitude,
        isolation_window_type,
        rollback_strategy,
        proposed_by,
        intervention_status,
        ael_phase
    ) VALUES (
        v_hash,
        p_name,
        p_category,
        p_target_schema,
        p_target_tables,
        p_parameter_bounds,
        p_blast_radius,
        p_hypothesis,
        p_expected_direction,
        p_expected_magnitude,
        p_isolation_window,
        p_rollback_strategy,
        p_proposed_by,
        'PROPOSED',
        1  -- Phase 1: Proposal
    )
    RETURNING intervention_id INTO v_intervention_id;

    -- Log to governance
    INSERT INTO fhq_governance.governance_actions_log (
        action_type,
        action_target,
        action_target_type,
        initiated_by,
        decision,
        decision_rationale,
        metadata
    ) VALUES (
        'AEL_INTERVENTION_PROPOSED',
        v_intervention_id::TEXT,
        'INTERVENTION',
        p_proposed_by,
        'PENDING',
        'ADR-024 Rung D: Intervention proposed for human authorization',
        jsonb_build_object(
            'intervention_name', p_name,
            'category', p_category,
            'hash', v_hash,
            'timestamp', NOW()
        )
    );

    RETURN v_intervention_id;
END;
$$;


--
-- Name: propose_calibration(text, text, numeric, text, jsonb, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.propose_calibration(p_parameter_name text, p_version text, p_value numeric, p_description text DEFAULT NULL::text, p_source_metrics jsonb DEFAULT '{}'::jsonb, p_proposed_by text DEFAULT 'FINN'::text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_id INTEGER;
    v_previous_version TEXT;
BEGIN
    -- Get current active version for reference
    SELECT version INTO v_previous_version
    FROM fhq_governance.calibration_versions
    WHERE parameter_name = p_parameter_name
      AND is_active = TRUE
    LIMIT 1;

    -- Insert new proposal
    INSERT INTO fhq_governance.calibration_versions (
        parameter_name, version, value, description,
        calibration_window, source_metrics, proposed_by,
        previous_version
    ) VALUES (
        p_parameter_name, p_version, p_value, p_description,
        date_trunc('week', NOW() AT TIME ZONE 'UTC') + interval '7 days',
        p_source_metrics, p_proposed_by,
        v_previous_version
    ) RETURNING id INTO v_id;

    -- Log the proposal
    INSERT INTO fhq_governance.calibration_audit_log (
        calibration_id, parameter_name, version, action,
        new_value, actor, metadata
    ) VALUES (
        v_id, p_parameter_name, p_version, 'PROPOSED',
        p_value, p_proposed_by, p_source_metrics
    );

    RETURN v_id;
END;
$$;


--
-- Name: publish_event(character varying, character varying, character varying, text, jsonb, character varying, character varying, uuid, character varying); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.publish_event(p_event_type character varying, p_source_agent character varying, p_title character varying, p_description text DEFAULT NULL::text, p_data jsonb DEFAULT NULL::jsonb, p_source_component character varying DEFAULT NULL::character varying, p_source_ios_layer character varying DEFAULT NULL::character varying, p_correlation_id uuid DEFAULT NULL::uuid, p_severity character varying DEFAULT NULL::character varying) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_event_id UUID;
    v_category VARCHAR(30);
    v_default_severity VARCHAR(20);
    v_current_regime VARCHAR(20);
    v_defcon_text TEXT;
    v_defcon_level INTEGER;
BEGIN
    -- Get event metadata from registry
    SELECT event_category, severity_default
    INTO v_category, v_default_severity
    FROM fhq_governance.event_type_registry
    WHERE event_type = p_event_type;

    -- Default if not in registry
    IF v_category IS NULL THEN
        v_category := 'GOVERNANCE';
        v_default_severity := 'INFO';
    END IF;

    -- Get current regime
    SELECT current_regime INTO v_current_regime
    FROM fhq_meta.regime_state
    LIMIT 1;

    -- Get current DEFCON (text) and convert to integer
    SELECT defcon_level INTO v_defcon_text
    FROM fhq_governance.defcon_state
    WHERE is_current = TRUE
    LIMIT 1;
    
    -- Convert DEFCON text to integer
    v_defcon_level := CASE v_defcon_text
        WHEN 'GREEN' THEN 5
        WHEN 'YELLOW' THEN 4
        WHEN 'ORANGE' THEN 3
        WHEN 'RED' THEN 2
        WHEN 'BLACK' THEN 1
        ELSE 5
    END;

    -- Insert event
    INSERT INTO fhq_governance.system_events (
        event_type, event_category, event_severity,
        source_agent, source_component, source_ios_layer,
        event_title, event_description, event_data,
        regime, defcon_level, correlation_id
    ) VALUES (
        p_event_type, v_category, COALESCE(p_severity, v_default_severity),
        p_source_agent, p_source_component, p_source_ios_layer,
        p_title, p_description, p_data,
        v_current_regime, v_defcon_level, p_correlation_id
    ) RETURNING event_id INTO v_event_id;

    RETURN v_event_id;
END;
$$;


--
-- Name: FUNCTION publish_event(p_event_type character varying, p_source_agent character varying, p_title character varying, p_description text, p_data jsonb, p_source_component character varying, p_source_ios_layer character varying, p_correlation_id uuid, p_severity character varying); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.publish_event(p_event_type character varying, p_source_agent character varying, p_title character varying, p_description text, p_data jsonb, p_source_component character varying, p_source_ios_layer character varying, p_correlation_id uuid, p_severity character varying) IS 'ARO-20251208 Section 2.1: Central function for publishing events to system_events.';


--
-- Name: publish_heartbeat(character varying, character varying, character varying, numeric, integer, integer); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.publish_heartbeat(p_agent_id character varying, p_component character varying, p_current_task character varying, p_health_score numeric DEFAULT 1.0, p_events_processed integer DEFAULT 0, p_errors_count integer DEFAULT 0) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_heartbeat_id UUID := gen_random_uuid();
BEGIN
    INSERT INTO fhq_governance.agent_heartbeats (
        agent_id, component, current_task, health_score, 
        events_processed, errors_count, last_heartbeat
    ) VALUES (
        p_agent_id, p_component, p_current_task, p_health_score,
        p_events_processed, p_errors_count, NOW()
    )
    ON CONFLICT (agent_id, component) DO UPDATE SET
        current_task = EXCLUDED.current_task,
        health_score = EXCLUDED.health_score,
        events_processed = EXCLUDED.events_processed,
        errors_count = EXCLUDED.errors_count,
        last_heartbeat = NOW();
    
    RETURN v_heartbeat_id;
END;
$$;


--
-- Name: FUNCTION publish_heartbeat(p_agent_id character varying, p_component character varying, p_current_task character varying, p_health_score numeric, p_events_processed integer, p_errors_count integer); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.publish_heartbeat(p_agent_id character varying, p_component character varying, p_current_task character varying, p_health_score numeric, p_events_processed integer, p_errors_count integer) IS 'ARO-20251208 Section 2.2: Agents must call this every 30 seconds.';


--
-- Name: recalculate_calibration_gates(integer, integer, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.recalculate_calibration_gates(p_window_days integer DEFAULT 30, p_min_sample_size integer DEFAULT 100, p_approver text DEFAULT 'STIG'::text) RETURNS TABLE(forecast_type text, regime text, historical_accuracy numeric, sample_size integer, safety_margin numeric, new_ceiling numeric, status text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_rec RECORD;
    v_safety NUMERIC;
    v_ceiling NUMERIC;
BEGIN
    -- Calculate accuracy per band from forecast_outcome_pairs
    FOR v_rec IN (
        SELECT
            fl.forecast_type,
            COALESCE(bs.dominant_regime, 'ALL') as regime,
            ROUND(AVG(CASE WHEN fop.hit_rate_contribution THEN 1 ELSE 0 END)::numeric, 4) as accuracy,
            COUNT(*) as n
        FROM fhq_research.forecast_outcome_pairs fop
        JOIN fhq_research.forecast_ledger fl ON fop.forecast_id = fl.forecast_id
        LEFT JOIN fhq_perception.model_belief_state bs
            ON bs.created_at::date = fl.forecast_made_at::date
        WHERE fop.reconciled_at >= NOW() - (p_window_days || ' days')::interval
        GROUP BY fl.forecast_type, COALESCE(bs.dominant_regime, 'ALL')
        HAVING COUNT(*) >= p_min_sample_size
    )
    LOOP
        -- Calculate asymmetric safety margin
        v_safety := fhq_governance.calculate_asymmetric_safety_margin(v_rec.accuracy);
        v_ceiling := LEAST(0.95, v_rec.accuracy + v_safety);

        -- Deactivate old gate
        UPDATE fhq_governance.confidence_calibration_gates
        SET effective_until = NOW()
        WHERE forecast_type = v_rec.forecast_type
        AND regime = v_rec.regime
        AND effective_until IS NULL;

        -- Insert new gate
        INSERT INTO fhq_governance.confidence_calibration_gates (
            forecast_type, regime, confidence_band_min, confidence_band_max,
            historical_accuracy, sample_size, confidence_ceiling, safety_margin,
            calculation_window_days, approved_by
        ) VALUES (
            v_rec.forecast_type, v_rec.regime, 0.0, 1.0,
            v_rec.accuracy, v_rec.n, v_ceiling, v_safety,
            p_window_days, p_approver
        );

        -- Log history
        INSERT INTO fhq_governance.calibration_gate_history (
            gate_id, action, new_ceiling, new_accuracy, change_reason, changed_by
        ) VALUES (
            (SELECT gate_id FROM fhq_governance.confidence_calibration_gates
             WHERE forecast_type = v_rec.forecast_type AND regime = v_rec.regime
             AND effective_until IS NULL LIMIT 1),
            'RECALIBRATED',
            v_ceiling,
            v_rec.accuracy,
            'Weekly recalibration from ' || p_window_days || ' day window',
            p_approver
        );

        RETURN QUERY SELECT
            v_rec.forecast_type,
            v_rec.regime,
            v_rec.accuracy,
            v_rec.n,
            v_safety,
            v_ceiling,
            'UPDATED'::TEXT;
    END LOOP;
END;
$$;


--
-- Name: record_brier_score(uuid, text, text, text, text, numeric, boolean, timestamp with time zone, timestamp with time zone, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.record_brier_score(p_belief_id uuid, p_forecast_type text, p_asset_id text, p_regime text, p_asset_class text, p_forecast_probability numeric, p_actual_outcome boolean, p_forecast_timestamp timestamp with time zone, p_outcome_timestamp timestamp with time zone, p_generated_by text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_squared_error NUMERIC(6,4);
  v_score_id UUID;
  v_forecast_horizon_hours INTEGER;
BEGIN
  -- Compute squared error
  v_squared_error := POWER(p_forecast_probability - CASE WHEN p_actual_outcome THEN 1.0 ELSE 0.0 END, 2);

  -- Compute forecast horizon
  v_forecast_horizon_hours := EXTRACT(EPOCH FROM (p_outcome_timestamp - p_forecast_timestamp)) / 3600;

  -- Insert score
  INSERT INTO fhq_governance.brier_score_ledger (
    belief_id,
    forecast_type,
    asset_id,
    regime,
    asset_class,
    forecast_probability,
    actual_outcome,
    squared_error,
    forecast_timestamp,
    outcome_timestamp,
    forecast_horizon_hours,
    generated_by
  ) VALUES (
    p_belief_id,
    p_forecast_type,
    p_asset_id,
    p_regime,
    p_asset_class,
    p_forecast_probability,
    p_actual_outcome,
    v_squared_error,
    p_forecast_timestamp,
    p_outcome_timestamp,
    v_forecast_horizon_hours,
    p_generated_by
  )
  RETURNING score_id INTO v_score_id;

  RETURN v_score_id;
END;
$$;


--
-- Name: record_goal_completion(uuid, text, jsonb, boolean, numeric, numeric, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.record_goal_completion(p_goal_id uuid, p_verification_query text, p_verification_result jsonb, p_threshold_met boolean, p_threshold_value numeric, p_actual_value numeric, p_verified_by text DEFAULT 'STIG'::text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_evidence_id UUID;
    v_query_hash TEXT;
    v_previous_hash TEXT;
BEGIN
    -- Compute SHA-256 hash of verification result
    v_query_hash := encode(sha256((p_verification_result::text)::bytea), 'hex');

    -- Get previous hash for chain integrity
    SELECT query_result_hash INTO v_previous_hash
    FROM fhq_governance.goal_completion_evidence
    ORDER BY created_at DESC
    LIMIT 1;

    -- Insert evidence record
    INSERT INTO fhq_governance.goal_completion_evidence (
        goal_id,
        verification_query,
        verification_result,
        query_result_hash,
        previous_hash,
        threshold_met,
        threshold_value,
        actual_value,
        verified_by
    ) VALUES (
        p_goal_id,
        p_verification_query,
        p_verification_result,
        v_query_hash,
        v_previous_hash,
        p_threshold_met,
        p_threshold_value,
        p_actual_value,
        p_verified_by
    )
    RETURNING evidence_id INTO v_evidence_id;

    -- Update goal status if threshold met
    IF p_threshold_met THEN
        UPDATE fhq_governance.daily_goal_calendar
        SET status = 'COMPLETED',
            completed_at = NOW(),
            evidence_id = v_evidence_id,
            evidence_hash = v_query_hash,
            completion_percentage = 100,
            updated_at = NOW()
        WHERE goal_id = p_goal_id;
    ELSE
        UPDATE fhq_governance.daily_goal_calendar
        SET completion_percentage = LEAST(100, (p_actual_value / NULLIF(p_threshold_value, 0)) * 100),
            updated_at = NOW()
        WHERE goal_id = p_goal_id;
    END IF;

    -- Log to governance (ADR-002)
    INSERT INTO fhq_governance.governance_actions_log (
        action_type,
        action_target,
        action_target_type,
        initiated_by,
        decision,
        decision_rationale,
        metadata
    ) VALUES (
        'GOAL_VERIFICATION',
        p_goal_id::TEXT,
        'DAILY_GOAL',
        p_verified_by,
        CASE WHEN p_threshold_met THEN 'COMPLETED' ELSE 'PROGRESS_RECORDED' END,
        format('Goal verification: threshold=%s, actual=%s, met=%s',
               p_threshold_value, p_actual_value, p_threshold_met),
        jsonb_build_object(
            'evidence_id', v_evidence_id,
            'query_hash', v_query_hash,
            'threshold_met', p_threshold_met,
            'directive', 'CEO-DIR-2026-0ZD'
        )
    );

    RETURN v_evidence_id;
END;
$$;


--
-- Name: record_stillness_checkpoint(text, uuid); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.record_stillness_checkpoint(p_checkpoint_type text, p_day_goal_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_checkpoint_id UUID;
    v_damper_hash TEXT;
    v_violations INTEGER;
BEGIN
    -- Get current damper hash
    SELECT COALESCE(
        (SELECT damper_hash_at_start FROM fhq_governance.ldow_cycle_completion
         WHERE completion_status IN ('SCHEDULED', 'RUNNING')
         ORDER BY cycle_number LIMIT 1),
        'da311f0ebb875122'
    ) INTO v_damper_hash;

    -- Get violation count
    SELECT COUNT(*) INTO v_violations
    FROM fhq_governance.v_ael_stillness_violations
    WHERE violation_type != 'COMPLIANT';

    -- Insert checkpoint
    INSERT INTO fhq_governance.stillness_checkpoint_log (
        checkpoint_type,
        day_goal_id,
        damper_hash_current,
        damper_hash_expected,
        stillness_violations,
        ldow_status,
        ldow_freeze_active
    ) VALUES (
        p_checkpoint_type,
        p_day_goal_id,
        v_damper_hash,
        'da311f0ebb875122',
        v_violations,
        'ACTIVE',
        TRUE
    )
    RETURNING checkpoint_id INTO v_checkpoint_id;

    RETURN v_checkpoint_id;
END;
$$;


--
-- Name: refresh_aol_telemetry(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.refresh_aol_telemetry() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY fhq_governance.mv_aol_agent_metrics;
END;
$$;


--
-- Name: refresh_aol_views(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.refresh_aol_views() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY fhq_governance.mv_agent_metrics;
  REFRESH MATERIALIZED VIEW fhq_governance.mv_agent_integrity_ledger;
  REFRESH MATERIALIZED VIEW fhq_governance.mv_system_health_summary;
END;
$$;


--
-- Name: refresh_calibration_dashboard(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.refresh_calibration_dashboard() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  REFRESH MATERIALIZED VIEW fhq_governance.calibration_dashboard;

  -- Log refresh
  INSERT INTO fhq_governance.governance_actions_log (
    action_type,
    action_target,
    action_target_type,
    initiated_by,
    decision,
    decision_rationale
  ) VALUES (
    'METRICS_REFRESH',
    'calibration_dashboard',
    'MATERIALIZED_VIEW',
    'SYSTEM',
    'REFRESHED',
    'Weekly calibration metrics updated'
  );
END;
$$;


--
-- Name: refresh_metacognitive_views(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.refresh_metacognitive_views() RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    refresh_result jsonb;
    start_time timestamptz;
    evpi_refreshed boolean := false;
    weekly_refreshed boolean := false;
    calibration_refreshed boolean := false;
BEGIN
    start_time := clock_timestamp();

    -- Refresh EVPI proxy
    BEGIN
        REFRESH MATERIALIZED VIEW CONCURRENTLY fhq_governance.mv_evpi_proxy;
        evpi_refreshed := true;
    EXCEPTION WHEN OTHERS THEN
        evpi_refreshed := false;
    END;

    -- Refresh weekly learning metrics
    BEGIN
        REFRESH MATERIALIZED VIEW fhq_governance.weekly_learning_metrics;
        weekly_refreshed := true;
    EXCEPTION WHEN OTHERS THEN
        weekly_refreshed := false;
    END;

    -- Refresh calibration dashboard
    BEGIN
        REFRESH MATERIALIZED VIEW fhq_governance.calibration_dashboard;
        calibration_refreshed := true;
    EXCEPTION WHEN OTHERS THEN
        calibration_refreshed := false;
    END;

    -- Build result
    refresh_result := jsonb_build_object(
        'refreshed_at', clock_timestamp(),
        'duration_ms', EXTRACT(MILLISECONDS FROM clock_timestamp() - start_time),
        'views_refreshed', jsonb_build_object(
            'mv_evpi_proxy', evpi_refreshed,
            'weekly_learning_metrics', weekly_refreshed,
            'calibration_dashboard', calibration_refreshed
        )
    );

    -- Log to governance
    INSERT INTO fhq_governance.governance_actions_log (
        action_type,
        action_target,
        decision,
        decision_rationale,
        initiated_by,
        metadata
    ) VALUES (
        'METACOGNITIVE_REFRESH',
        'fhq_governance.mv_*',
        'EXECUTED',
        'Scheduled refresh of metacognitive materialized views',
        'STIG',
        refresh_result
    );

    RETURN refresh_result;
END;
$$;


--
-- Name: FUNCTION refresh_metacognitive_views(); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.refresh_metacognitive_views() IS 'Refreshes all metacognitive materialized views.
Should be scheduled for daily refresh (24h) per STIG recommendation.';


--
-- Name: refresh_regret_attribution_summary(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.refresh_regret_attribution_summary() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  REFRESH MATERIALIZED VIEW fhq_governance.regret_attribution_summary;

  -- Log refresh
  INSERT INTO fhq_governance.governance_actions_log (
    action_type,
    action_target,
    action_target_type,
    initiated_by,
    decision,
    decision_rationale
  ) VALUES (
    'METRICS_REFRESH',
    'regret_attribution_summary',
    'MATERIALIZED_VIEW',
    'SYSTEM',
    'REFRESHED',
    'Weekly regret attribution metrics updated'
  );
END;
$$;


--
-- Name: refresh_state_snapshot(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.refresh_state_snapshot() RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_new_snapshot_id UUID;
    v_old_snapshot_id UUID;
BEGIN
    SELECT snapshot_id INTO v_old_snapshot_id
    FROM fhq_governance.shared_state_snapshots
    WHERE is_valid = TRUE
    ORDER BY snapshot_timestamp DESC
    LIMIT 1;

    SELECT fhq_governance.create_state_snapshot() INTO v_new_snapshot_id;

    INSERT INTO fhq_governance.governance_actions_log (
        action_type, action_target, action_target_type, initiated_by,
        decision, decision_rationale, hash_chain_id
    ) VALUES (
        'STATE_REFRESH', 'shared_state_snapshots', 'STATE_VECTOR', 'STIG',
        'COMPLETED', 'State snapshot refreshed. Old: ' || COALESCE(v_old_snapshot_id::TEXT, 'NONE') || ' ? New: ' || v_new_snapshot_id::TEXT,
        'HC-STATE-REFRESH-' || NOW()::DATE
    );

    RETURN v_new_snapshot_id;
END;
$$;


--
-- Name: FUNCTION refresh_state_snapshot(); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.refresh_state_snapshot() IS 'Refresh state snapshot for freshness compliance.
Per CEO Directive v2.0: Verified state freshness.';


--
-- Name: refresh_weekly_learning_metrics(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.refresh_weekly_learning_metrics() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  REFRESH MATERIALIZED VIEW fhq_governance.weekly_learning_metrics;

  -- Log refresh
  INSERT INTO fhq_governance.governance_actions_log (
    action_type,
    action_target,
    action_target_type,
    initiated_by,
    decision,
    decision_rationale
  ) VALUES (
    'METRICS_REFRESH',
    'weekly_learning_metrics',
    'MATERIALIZED_VIEW',
    'SYSTEM',
    'REFRESHED',
    'Weekly learning metrics dashboard updated'
  );
END;
$$;


--
-- Name: register_ldow_failure(integer, text, jsonb, numeric, numeric, numeric, numeric, text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.register_ldow_failure(p_cycle_number integer, p_failure_type text, p_failure_details jsonb, p_coverage_achieved numeric DEFAULT NULL::numeric, p_coverage_required numeric DEFAULT NULL::numeric, p_brier_variance_achieved numeric DEFAULT NULL::numeric, p_brier_variance_required numeric DEFAULT NULL::numeric, p_damper_hash_expected text DEFAULT NULL::text, p_damper_hash_actual text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_incident_id UUID;
BEGIN
    INSERT INTO fhq_governance.ldow_failure_incidents (
        cycle_number,
        failure_type,
        failure_details,
        coverage_achieved,
        coverage_required,
        brier_variance_achieved,
        brier_variance_required,
        damper_hash_expected,
        damper_hash_actual
    ) VALUES (
        p_cycle_number,
        p_failure_type,
        p_failure_details,
        p_coverage_achieved,
        p_coverage_required,
        p_brier_variance_achieved,
        p_brier_variance_required,
        p_damper_hash_expected,
        p_damper_hash_actual
    )
    RETURNING incident_id INTO v_incident_id;

    -- Log to governance
    INSERT INTO fhq_governance.governance_actions_log (
        action_type,
        action_target,
        action_target_type,
        initiated_by,
        decision,
        decision_rationale,
        metadata
    ) VALUES (
        'LDOW_CYCLE_FAILURE',
        v_incident_id::TEXT,
        'FAILURE_INCIDENT',
        'LDOW_CYCLE_DAEMON',
        'BLOCKED',
        'CEO Directive: Failed cycle does not count. Retry requires root cause + VEGA attestation.',
        jsonb_build_object(
            'cycle_number', p_cycle_number,
            'failure_type', p_failure_type,
            'incident_id', v_incident_id,
            'retry_resets_counter', TRUE,
            'timestamp', NOW()
        )
    );

    RETURN v_incident_id;
END;
$$;


--
-- Name: retrieve_state_vector(text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.retrieve_state_vector(p_agent_id text, p_agent_tier text DEFAULT 'TIER-2'::text) RETURNS TABLE(snapshot_id uuid, state_vector_hash text, snapshot_timestamp timestamp with time zone, defcon_level text, btc_regime_label text, btc_regime_confidence numeric, strategy_posture text, strategy_exposure numeric, is_fresh boolean, retrieval_status text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_snapshot RECORD;
    v_retrieval_id UUID;
    v_is_fresh BOOLEAN;
    v_latency_start TIMESTAMPTZ;
    v_latency_ms INTEGER;
    v_recomputed_hash TEXT;
    v_hash_valid BOOLEAN;
BEGIN
    v_latency_start := clock_timestamp();

    -- 1. Get current valid snapshot
    SELECT s.* INTO v_snapshot
    FROM fhq_governance.shared_state_snapshots s
    WHERE s.is_valid = TRUE
    AND s.valid_until IS NULL
    ORDER BY s.snapshot_timestamp DESC
    LIMIT 1;

    -- 2. FAIL-CLOSED: No snapshot available
    IF v_snapshot IS NULL THEN
        -- Log failed retrieval
        INSERT INTO fhq_governance.state_retrieval_log (
            agent_id, agent_tier, state_vector_hash, retrieval_status,
            freshness_check_passed, hash_validation_passed, defcon_gating_passed,
            error_code, error_message, latency_ms
        ) VALUES (
            p_agent_id, p_agent_tier, 'NONE', 'NOT_FOUND',
            FALSE, FALSE, FALSE,
            'ASRP_001', 'No valid state snapshot available. HALT required.',
            EXTRACT(MILLISECONDS FROM clock_timestamp() - v_latency_start)::INTEGER
        );

        -- Return empty with HALT status
        RETURN QUERY SELECT
            NULL::UUID, 'HALT'::TEXT, NOW(), 'BLACK'::TEXT,
            'UNTRUSTED'::TEXT, 0.0::NUMERIC, 'CASH'::TEXT, 0.0::NUMERIC,
            FALSE, 'HALT_REQUIRED'::TEXT;
        RETURN;
    END IF;

    -- 3. Freshness check
    v_is_fresh := (NOW() - v_snapshot.snapshot_timestamp) <
                  (v_snapshot.freshness_ttl_seconds * INTERVAL '1 second');

    -- 4. Hash validation (recompute and compare)
    v_recomputed_hash := encode(sha256((
        v_snapshot.defcon_level || ':' ||
        v_snapshot.btc_regime_label || ':' ||
        v_snapshot.strategy_posture || ':' ||
        v_snapshot.snapshot_timestamp::TEXT
    )::bytea), 'hex');

    v_hash_valid := (v_recomputed_hash = v_snapshot.state_vector_hash);

    -- 5. Calculate latency
    v_latency_ms := EXTRACT(MILLISECONDS FROM clock_timestamp() - v_latency_start)::INTEGER;

    -- 6. Log retrieval (success or stale)
    INSERT INTO fhq_governance.state_retrieval_log (
        agent_id, agent_tier, snapshot_id, state_vector_hash, retrieval_status,
        freshness_check_passed, hash_validation_passed, defcon_gating_passed,
        vega_approval_status, latency_ms
    ) VALUES (
        p_agent_id, p_agent_tier, v_snapshot.snapshot_id, v_snapshot.state_vector_hash,
        CASE
            WHEN NOT v_hash_valid THEN 'HASH_MISMATCH'
            WHEN NOT v_is_fresh THEN 'STALE'
            ELSE 'SUCCESS'
        END,
        v_is_fresh, v_hash_valid, TRUE,
        'APPROVED', v_latency_ms
    );

    -- 7. Return state vector
    RETURN QUERY SELECT
        v_snapshot.snapshot_id,
        v_snapshot.state_vector_hash,
        v_snapshot.snapshot_timestamp,
        v_snapshot.defcon_level,
        v_snapshot.btc_regime_label,
        v_snapshot.btc_regime_confidence,
        v_snapshot.strategy_posture,
        v_snapshot.strategy_exposure,
        v_is_fresh,
        CASE
            WHEN NOT v_hash_valid THEN 'HASH_MISMATCH'
            WHEN NOT v_is_fresh THEN 'STALE'
            ELSE 'SUCCESS'
        END::TEXT;
END;
$$;


--
-- Name: FUNCTION retrieve_state_vector(p_agent_id text, p_agent_tier text); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.retrieve_state_vector(p_agent_id text, p_agent_tier text) IS 'Atomically retrieves current state vector per ADR-018 6.
Implements fail-closed semantics: returns HALT status if no valid state.
All retrievals are logged for audit compliance.';


--
-- Name: risl_escalate_immunity(text, text, jsonb); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.risl_escalate_immunity(p_trigger_type text, p_agent_id text, p_evidence jsonb) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_current_defcon TEXT;
    v_new_defcon TEXT;
    v_action TEXT;
BEGIN
    -- Get current DEFCON
    SELECT current_defcon::TEXT INTO v_current_defcon
    FROM fhq_governance.system_state
    WHERE is_active = TRUE;

    -- Determine escalation based on trigger type
    CASE p_trigger_type
        WHEN 'DATA_DRIFT' THEN
            v_new_defcon := CASE
                WHEN v_current_defcon = 'GREEN' THEN 'YELLOW'
                WHEN v_current_defcon = 'YELLOW' THEN 'ORANGE'
                ELSE v_current_defcon
            END;
            v_action := 'MONITOR';

        WHEN 'AGENT_HALLUCINATION' THEN
            v_new_defcon := CASE
                WHEN v_current_defcon IN ('GREEN', 'YELLOW') THEN 'ORANGE'
                WHEN v_current_defcon = 'ORANGE' THEN 'RED'
                ELSE v_current_defcon
            END;
            v_action := 'ISOLATE';

        WHEN 'PREDICTION_FAILURE' THEN
            v_new_defcon := 'YELLOW';
            v_action := 'REVIEW';

        WHEN 'LIDS_THRESHOLD_BREACH' THEN
            v_new_defcon := 'YELLOW';
            v_action := 'PAUSE_ALLOCATION';

        WHEN 'CONSENSUS_FAILURE' THEN
            v_new_defcon := 'ORANGE';
            v_action := 'HALT_EXECUTION';

        ELSE
            v_new_defcon := v_current_defcon;
            v_action := 'LOG';
    END CASE;

    -- Log the RISL escalation
    INSERT INTO fhq_governance.asrp_violations (
        violation_type,
        agent_id,
        attempted_action,
        enforcement_action,
        evidence_bundle
    ) VALUES (
        'BYPASS_ATTEMPT',
        p_agent_id,
        'RISL_ESCALATION: ' || p_trigger_type,
        v_action,
        p_evidence || jsonb_build_object(
            'current_defcon', v_current_defcon,
            'recommended_defcon', v_new_defcon,
            'risl_trigger', p_trigger_type,
            'timestamp', NOW()
        )
    );

    -- Return the recommended action
    RETURN v_action || ':' || v_new_defcon;
END;
$$;


--
-- Name: FUNCTION risl_escalate_immunity(p_trigger_type text, p_agent_id text, p_evidence jsonb); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.risl_escalate_immunity(p_trigger_type text, p_agent_id text, p_evidence jsonb) IS 'RISL immunity escalation per ADR-017 3.4 and ADR-016.
Triggers DEFCON escalation based on threat type.
Implements fail-safe over fail-open principle.';


--
-- Name: rollback_calibration(text, text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.rollback_calibration(p_parameter_name text, p_reason text, p_rolled_back_by text DEFAULT 'STIG'::text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_current_version TEXT;
    v_previous_version TEXT;
    v_previous_id INTEGER;
BEGIN
    -- Get current active and its previous
    SELECT version, previous_version INTO v_current_version, v_previous_version
    FROM fhq_governance.calibration_versions
    WHERE parameter_name = p_parameter_name
      AND is_active = TRUE;

    IF v_previous_version IS NULL THEN
        RAISE EXCEPTION 'No previous version to rollback to for %', p_parameter_name;
    END IF;

    -- Deactivate current
    UPDATE fhq_governance.calibration_versions
    SET is_active = FALSE,
        deactivated_at = NOW(),
        rollback_reason = p_reason,
        updated_at = NOW()
    WHERE parameter_name = p_parameter_name
      AND is_active = TRUE;

    -- Activate previous
    UPDATE fhq_governance.calibration_versions
    SET is_active = TRUE,
        activated_at = NOW(),
        updated_at = NOW()
    WHERE parameter_name = p_parameter_name
      AND version = v_previous_version
    RETURNING id INTO v_previous_id;

    -- Log rollback
    INSERT INTO fhq_governance.calibration_audit_log (
        calibration_id, parameter_name, version, action,
        actor, reason, metadata
    ) VALUES (
        v_previous_id, p_parameter_name, v_previous_version, 'ROLLBACK',
        p_rolled_back_by, p_reason,
        jsonb_build_object('rolled_back_from', v_current_version)
    );

    RETURN v_previous_version;
END;
$$;


--
-- Name: run_phase_b_sanity_check(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.run_phase_b_sanity_check() RETURNS TABLE(phase_b_passed boolean, hit_rate_paper numeric, current_brier_score numeric, type_d_count integer, type_e_count integer, anomalies_detected boolean, details jsonb)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_hit_rate NUMERIC;
    v_brier NUMERIC;
    v_type_d INTEGER;
    v_type_e INTEGER;
    v_anomalies BOOLEAN := false;
    v_paper_trades INTEGER;
    v_paper_hits INTEGER;
BEGIN
    -- Count paper trades with outcomes
    SELECT
        COUNT(*),
        SUM(CASE WHEN outcome_correct THEN 1 ELSE 0 END)
    INTO v_paper_trades, v_paper_hits
    FROM fhq_governance.paper_ledger
    WHERE outcome_correct IS NOT NULL;

    -- Calculate hit rate
    v_hit_rate := CASE WHEN v_paper_trades > 0
        THEN ROUND(v_paper_hits::NUMERIC / v_paper_trades * 100, 2)
        ELSE NULL
    END;

    -- Get Brier score from forecast_outcome_pairs (last 7 days)
    SELECT ROUND(AVG(fop.brier_score)::NUMERIC, 4) INTO v_brier
    FROM fhq_research.forecast_outcome_pairs fop
    WHERE fop.reconciled_at > NOW() - INTERVAL '7 days';

    -- Count error types from paper ledger
    SELECT
        SUM(CASE WHEN error_type = 'TYPE_D' THEN 1 ELSE 0 END),
        SUM(CASE WHEN error_type = 'TYPE_E' THEN 1 ELSE 0 END)
    INTO v_type_d, v_type_e
    FROM fhq_governance.paper_ledger
    WHERE error_type IS NOT NULL;

    v_type_d := COALESCE(v_type_d, 0);
    v_type_e := COALESCE(v_type_e, 0);

    -- Anomaly detection: unexpected discontinuities
    -- For now, flag if Brier > 0.5 or hit rate < 30%
    IF v_brier > 0.5 OR (v_hit_rate IS NOT NULL AND v_hit_rate < 30) THEN
        v_anomalies := true;
    END IF;

    RETURN QUERY SELECT
        NOT v_anomalies,
        v_hit_rate,
        v_brier,
        v_type_d,
        v_type_e,
        v_anomalies,
        jsonb_build_object(
            'paper_trades_scored', v_paper_trades,
            'paper_hits', v_paper_hits,
            'hit_rate_pct', v_hit_rate,
            'brier_score', v_brier,
            'type_d_count', v_type_d,
            'type_e_count', v_type_e,
            'anomalies_detected', v_anomalies,
            'checked_at', NOW()
        );
END;
$$;


--
-- Name: store_lesson_with_evidence(text, text, text, text, text, text, jsonb, numeric, text, text, text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.store_lesson_with_evidence(p_lesson_source text, p_lesson_category text, p_lesson_severity text, p_lesson_description text, p_lesson_hash text, p_raw_query text, p_query_result jsonb, p_error_magnitude numeric DEFAULT NULL::numeric, p_error_direction text DEFAULT NULL::text, p_affected_regime text DEFAULT NULL::text, p_recommended_action text DEFAULT NULL::text, p_created_by text DEFAULT 'STIG'::text) RETURNS TABLE(lesson_id uuid, evidence_id uuid, lesson_hash text, evidence_hash text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_lesson_id UUID;
    v_evidence_id UUID;
    v_query_result_hash TEXT;
    v_existing_lesson UUID;
    v_existing_evidence UUID;
BEGIN
    -- Idempotency: Check if lesson with this hash already exists
    SELECT el.lesson_id, el.evidence_id INTO v_existing_lesson, v_existing_evidence
    FROM fhq_governance.epistemic_lessons el
    WHERE el.lesson_hash = p_lesson_hash;

    IF v_existing_lesson IS NOT NULL THEN
        SELECT ele.query_result_hash INTO v_query_result_hash
        FROM fhq_governance.epistemic_lesson_evidence ele
        WHERE ele.evidence_id = v_existing_evidence;
        RETURN QUERY SELECT v_existing_lesson, v_existing_evidence, p_lesson_hash, v_query_result_hash;
        RETURN;
    END IF;

    v_query_result_hash := encode(sha256(p_query_result::text::bytea), 'hex');
    v_evidence_id := gen_random_uuid();

    INSERT INTO fhq_governance.epistemic_lesson_evidence (
        evidence_id, raw_query, query_result_hash, query_result_snapshot,
        extraction_context, created_by, created_at
    ) VALUES (
        v_evidence_id, p_raw_query, v_query_result_hash, p_query_result,
        jsonb_build_object(
            'directive', 'CEO-DIR-2026-021',
            'audit_correction', 'AUDIT_CORRECTION_4',
            'ios', 'IoS-010',
            'daemon', 'ios010_lesson_extraction_engine',
            'binding_mode', 'ATOMIC_TRANSACTIONAL',
            'lesson_category', p_lesson_category,
            'lesson_severity', p_lesson_severity
        ),
        p_created_by, NOW()
    );

    v_lesson_id := gen_random_uuid();
    
    INSERT INTO fhq_governance.epistemic_lessons (
        lesson_id, lesson_source, lesson_category, lesson_severity,
        error_magnitude, error_direction, affected_regime,
        lesson_description, recommended_action, lesson_hash,
        evidence_id, evidence_bound_at, created_by, created_at
    ) VALUES (
        v_lesson_id, p_lesson_source, p_lesson_category, p_lesson_severity,
        p_error_magnitude, p_error_direction, p_affected_regime,
        p_lesson_description, p_recommended_action, p_lesson_hash,
        v_evidence_id, NOW(), p_created_by, NOW()
    );

    UPDATE fhq_governance.epistemic_lesson_evidence
    SET lesson_id = v_lesson_id
    WHERE fhq_governance.epistemic_lesson_evidence.evidence_id = v_evidence_id;

    RETURN QUERY SELECT v_lesson_id, v_evidence_id, p_lesson_hash, v_query_result_hash;
END;
$$;


--
-- Name: FUNCTION store_lesson_with_evidence(p_lesson_source text, p_lesson_category text, p_lesson_severity text, p_lesson_description text, p_lesson_hash text, p_raw_query text, p_query_result jsonb, p_error_magnitude numeric, p_error_direction text, p_affected_regime text, p_recommended_action text, p_created_by text); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.store_lesson_with_evidence(p_lesson_source text, p_lesson_category text, p_lesson_severity text, p_lesson_description text, p_lesson_hash text, p_raw_query text, p_query_result jsonb, p_error_magnitude numeric, p_error_direction text, p_affected_regime text, p_recommended_action text, p_created_by text) IS 'CEO-DIR-2026-021 Audit Correction #4: Atomic lesson+evidence insertion.
Ensures lessons and their source evidence are created transactionally.
Implements idempotency via lesson_hash deduplication.
Court-proof: Every lesson has verifiable raw query + result hash + result snapshot.';


--
-- Name: submit_health_attestation(text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.submit_health_attestation(p_agent_id text, p_agent_tier text DEFAULT 'TIER-2'::text) RETURNS TABLE(out_attestation_id uuid, out_health_status text, out_state_vector_hash text, out_state_age_seconds integer, out_next_attestation_due timestamp with time zone)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_attestation_id UUID;
    v_state RECORD;
    v_health_status TEXT;
    v_state_age INTEGER;
    v_freshness_ok BOOLEAN;
    v_hash_ok BOOLEAN;
BEGIN
    SELECT * INTO v_state FROM fhq_governance.retrieve_state_vector(p_agent_id, p_agent_tier);
    v_state_age := COALESCE(EXTRACT(EPOCH FROM (NOW() - v_state.snapshot_timestamp))::INTEGER, 9999);
    v_freshness_ok := v_state_age < 300;
    v_hash_ok := v_state.state_vector_hash IS NOT NULL AND v_state.state_vector_hash != 'HALT';
    IF v_state.retrieval_status = 'HALT_REQUIRED' THEN v_health_status := 'HALTED';
    ELSIF NOT v_freshness_ok THEN v_health_status := 'STALE';
    ELSIF NOT v_hash_ok THEN v_health_status := 'DISCONNECTED';
    ELSE v_health_status := 'HEALTHY'; END IF;

    INSERT INTO fhq_governance.agent_health_attestations (
        agent_id, agent_tier, state_snapshot_id, state_vector_hash,
        health_status, state_freshness_ok, hash_integrity_ok, memory_coherent,
        last_retrieval_ok, last_state_retrieval_ms, state_age_seconds,
        next_attestation_due, hash_chain_id
    ) VALUES (
        p_agent_id, p_agent_tier, v_state.snapshot_id,
        COALESCE(v_state.state_vector_hash, 'NONE'), v_health_status,
        v_freshness_ok, v_hash_ok, TRUE,
        v_state.retrieval_status = 'SUCCESS', 10, v_state_age,
        NOW() + INTERVAL '5 minutes', 'HC-HEALTH-ATT-' || p_agent_id
    ) RETURNING agent_health_attestations.attestation_id INTO v_attestation_id;

    RETURN QUERY SELECT v_attestation_id, v_health_status, COALESCE(v_state.state_vector_hash, 'NONE'), v_state_age, NOW() + INTERVAL '5 minutes';
END;
$$;


--
-- Name: sync_attestation_gov_to_registry(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.sync_attestation_gov_to_registry() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- fhq_governance.vega_attestations uses target_id column
    -- Sync to ADR registry if target is an ADR
    IF NEW.target_id LIKE 'ADR-%' THEN
        UPDATE fhq_meta.adr_registry
        SET vega_attested = true,
            updated_at = NOW()
        WHERE adr_id = NEW.target_id
          AND vega_attested = false;
    END IF;

    -- Sync to IoS registry if target is an IoS
    IF NEW.target_id LIKE 'IoS-%' OR NEW.target_id LIKE 'IOS-%' THEN
        UPDATE fhq_meta.ios_registry
        SET vega_signature_id = NEW.attestation_id,
            updated_at = NOW()
        WHERE ios_id = NEW.target_id;
    END IF;

    -- Sync to canonical_documents
    UPDATE fhq_meta.canonical_documents
    SET vega_attested = true,
        vega_attestation_id = NEW.attestation_id,
        updated_at = NOW()
    WHERE document_code = NEW.target_id
      AND vega_attested = false;

    RETURN NEW;
END;
$$;


--
-- Name: sync_attestation_meta_to_registry(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.sync_attestation_meta_to_registry() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- fhq_meta.vega_attestations uses attestation_target column
    -- Sync to ADR registry if target is an ADR
    IF NEW.attestation_target LIKE 'ADR-%' THEN
        UPDATE fhq_meta.adr_registry
        SET vega_attested = true,
            updated_at = NOW()
        WHERE adr_id = NEW.attestation_target
          AND vega_attested = false;
    END IF;

    -- Sync to IoS registry if target is an IoS
    IF NEW.attestation_target LIKE 'IoS-%' OR NEW.attestation_target LIKE 'IOS-%' THEN
        UPDATE fhq_meta.ios_registry
        SET vega_signature_id = NEW.attestation_id,
            updated_at = NOW()
        WHERE ios_id = NEW.attestation_target;
    END IF;

    -- Sync to canonical_documents
    UPDATE fhq_meta.canonical_documents
    SET vega_attested = true,
        vega_attestation_id = NEW.attestation_id,
        updated_at = NOW()
    WHERE document_code = NEW.attestation_target
      AND vega_attested = false;

    RETURN NEW;
END;
$$;


--
-- Name: trigger_agent_halt(text, text, uuid); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.trigger_agent_halt(p_agent_id text, p_reason text, p_violation_id uuid DEFAULT NULL::uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_violation_count INTEGER;
BEGIN
    -- Count recent violations for this agent
    SELECT COUNT(*) INTO v_violation_count
    FROM fhq_governance.asrp_violations
    WHERE agent_id = p_agent_id
    AND created_at > NOW() - INTERVAL '1 hour';

    -- If more than 3 violations in 1 hour, escalate to DEFCON ORANGE
    IF v_violation_count >= 3 THEN
        -- Update system state to ORANGE
        UPDATE fhq_governance.system_state
        SET
            current_defcon = 'ORANGE',
            reason = 'ASRP Violation cascade for agent: ' || p_agent_id,
            triggered_at = NOW(),
            triggered_by = 'VEGA',
            updated_at = NOW()
        WHERE is_active = TRUE;

        -- Log escalation
        INSERT INTO fhq_governance.governance_actions_log (
            action_type,
            action_target,
            action_target_type,
            initiated_by,
            decision,
            decision_rationale,
            hash_chain_id
        ) VALUES (
            'DEFCON_ESCALATION',
            p_agent_id,
            'AGENT',
            'VEGA',
            'EXECUTED',
            'ASRP violation cascade (' || v_violation_count || ' violations). Agent halted. DEFCON escalated to ORANGE.',
            'HC-HALT-' || p_agent_id || '-' || NOW()::DATE
        );
    END IF;

    -- Log halt event
    INSERT INTO fhq_governance.agent_health_attestations (
        agent_id,
        agent_tier,
        state_vector_hash,
        health_status,
        state_freshness_ok,
        hash_integrity_ok,
        memory_coherent,
        last_retrieval_ok,
        hash_chain_id
    ) VALUES (
        p_agent_id,
        'TIER-2',
        'HALTED',
        'HALTED',
        FALSE,
        FALSE,
        FALSE,
        FALSE,
        'HC-HALT-' || p_agent_id
    );
END;
$$;


--
-- Name: FUNCTION trigger_agent_halt(p_agent_id text, p_reason text, p_violation_id uuid); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.trigger_agent_halt(p_agent_id text, p_reason text, p_violation_id uuid) IS 'Trigger agent halt and potential DEFCON escalation.
Per CEO Directive v2.0: Auto-halt on violation detection.';


--
-- Name: trigger_data_blackout(text, text, text[]); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.trigger_data_blackout(p_reason text, p_triggered_by text, p_stale_assets text[]) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_blackout_id UUID;
BEGIN
    -- Deactivate any existing blackout first
    UPDATE fhq_governance.data_blackout_state
    SET is_active = false, updated_at = NOW()
    WHERE is_active = true;

    -- Create new blackout
    INSERT INTO fhq_governance.data_blackout_state (
        is_active,
        trigger_reason,
        triggered_by,
        stale_assets
    ) VALUES (
        true,
        p_reason,
        p_triggered_by,
        p_stale_assets
    )
    RETURNING blackout_id INTO v_blackout_id;

    RETURN v_blackout_id;
END;
$$;


--
-- Name: trigger_defcon_change(integer, character varying, character varying); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.trigger_defcon_change(p_new_level integer, p_trigger_type character varying, p_reason character varying) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_current_level_text TEXT;
    v_current_level INTEGER;
    v_new_status VARCHAR(20);
    v_state_id UUID;
BEGIN
    -- Get current level (stored as text, convert to integer for comparison)
    SELECT defcon_level INTO v_current_level_text
    FROM fhq_governance.defcon_state
    WHERE is_current = TRUE;

    -- Convert text to integer level
    v_current_level := CASE v_current_level_text
        WHEN 'GREEN' THEN 5
        WHEN 'YELLOW' THEN 3
        WHEN 'ORANGE' THEN 2
        WHEN 'RED' THEN 1
        WHEN 'BLACK' THEN 0
        ELSE 5  -- default to GREEN
    END;

    -- Don't downgrade automatically (only manual resolution can lower DEFCON)
    -- Lower number = higher alert, so we check if new_level > current (less severe)
    IF v_current_level IS NOT NULL AND p_new_level > v_current_level THEN
        RETURN NULL;
    END IF;

    -- Map level to status
    v_new_status := CASE p_new_level
        WHEN 5 THEN 'GREEN'
        WHEN 4 THEN 'GREEN'
        WHEN 3 THEN 'YELLOW'
        WHEN 2 THEN 'ORANGE'
        WHEN 1 THEN 'RED'
        ELSE 'BLACK'
    END;

    -- Mark previous as not current
    UPDATE fhq_governance.defcon_state
    SET is_current = FALSE
    WHERE is_current = TRUE;

    -- Insert new state (defcon_level stored as text)
    INSERT INTO fhq_governance.defcon_state (
        state_id, defcon_level, triggered_at, triggered_by,
        trigger_reason, is_current, created_at
    ) VALUES (
        gen_random_uuid(), v_new_status, NOW(), 'SYSTEM',
        p_reason, TRUE, NOW()
    ) RETURNING state_id INTO v_state_id;

    -- Log DEFCON change event
    INSERT INTO fhq_governance.system_events (
        event_type, event_category, event_severity,
        source_agent, event_title, event_data
    ) VALUES (
        'DEFCON_CHANGE', 'GOVERNANCE',
        CASE WHEN p_new_level <= 2 THEN 'CRITICAL' ELSE 'WARNING' END,
        'SYSTEM',
        'DEFCON changed to ' || v_new_status || ' (Level ' || p_new_level || ')',
        jsonb_build_object(
            'new_level', p_new_level,
            'previous_level', v_current_level,
            'new_status', v_new_status,
            'trigger_type', p_trigger_type,
            'reason', p_reason
        )
    );

    RETURN v_state_id;
END;
$$;


--
-- Name: FUNCTION trigger_defcon_change(p_new_level integer, p_trigger_type character varying, p_reason character varying); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.trigger_defcon_change(p_new_level integer, p_trigger_type character varying, p_reason character varying) IS 'ARO-20251208 + ADR-016: Trigger DEFCON level change.';


--
-- Name: trigger_regime_blackout(numeric, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.trigger_regime_blackout(p_staleness_hours numeric, p_triggered_by text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_blackout_id UUID;
BEGIN
    INSERT INTO fhq_governance.data_blackout_state (
        trigger_reason,
        triggered_by,
        triggered_at,
        is_active
    ) VALUES (
        'REGIME_REALITY_VIOLATION: Regime state is ' || ROUND(p_staleness_hours, 1)::TEXT || 'h stale (max: 6h). System is epistemically blind.',
        p_triggered_by,
        NOW(),
        TRUE
    )
    RETURNING blackout_id INTO v_blackout_id;
    
    RETURN v_blackout_id;
END;
$$;


--
-- Name: truth_gateway_retrieve(text, text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.truth_gateway_retrieve(p_requesting_agent text, p_agent_tier text DEFAULT 'TIER-2'::text, p_request_source text DEFAULT 'DASHBOARD'::text) RETURNS TABLE(out_context_package jsonb, out_context_hash text, out_issued_at timestamp with time zone, out_integrity_signature text, out_gateway_status text, out_validations_passed jsonb)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_context_pkg RECORD;
    v_computed_context_hash TEXT;
    v_integrity_sig TEXT;
    v_gateway_status TEXT := 'SUCCESS';
    v_latency_start TIMESTAMPTZ;
    v_validation_failures JSONB := '[]'::JSONB;
    v_validations JSONB;
    v_adr018_valid BOOLEAN := TRUE;
    v_adr017_valid BOOLEAN := TRUE;
    v_ec_role_valid BOOLEAN := TRUE;
    v_risl_valid BOOLEAN := TRUE;
    v_defcon_valid BOOLEAN := TRUE;
    v_all_valid BOOLEAN := TRUE;
    v_current_defcon TEXT;
    v_risl_status TEXT;
BEGIN
    v_latency_start := clock_timestamp();

    -- Get current context package
    SELECT cp.* INTO v_context_pkg
    FROM fhq_governance.context_packages cp
    WHERE cp.is_valid = TRUE AND cp.valid_until IS NULL
    ORDER BY cp.package_timestamp DESC LIMIT 1;

    -- FAIL-CLOSED: No context available
    IF v_context_pkg IS NULL THEN
        v_gateway_status := 'MISSING_CONTEXT';
        INSERT INTO fhq_governance.gateway_request_log (
            requesting_agent, agent_tier, request_source, gateway_status,
            adr018_validated, adr017_validated, ec_role_validated,
            risl_validated, defcon_validated, validation_failures, latency_ms
        ) VALUES (
            p_requesting_agent, p_agent_tier, p_request_source, v_gateway_status,
            FALSE, FALSE, FALSE, FALSE, FALSE, '["NO_VALID_CONTEXT_PACKAGE"]'::JSONB,
            EXTRACT(MILLISECONDS FROM clock_timestamp() - v_latency_start)::INTEGER
        );
        RETURN QUERY SELECT
            jsonb_build_object('error', 'GATEWAY_HALT: No valid context package available'),
            'HALT'::TEXT, NOW(), 'NONE'::TEXT, v_gateway_status,
            jsonb_build_object('all_passed', FALSE, 'reason', 'MISSING_CONTEXT');
        RETURN;
    END IF;

    -- Validate ADR-018 state integrity
    IF v_context_pkg.state_snapshot_hash IS NULL THEN
        v_adr018_valid := FALSE; v_all_valid := FALSE;
        v_validation_failures := v_validation_failures || '["ADR018_MISSING_STATE_HASH"]'::JSONB;
    END IF;

    IF (NOW() - v_context_pkg.package_timestamp) > (v_context_pkg.freshness_ttl_seconds * INTERVAL '1 second') THEN
        v_adr018_valid := FALSE; v_all_valid := FALSE;
        v_gateway_status := 'STALE_CONTEXT';
        v_validation_failures := v_validation_failures || '["ADR018_CONTEXT_STALE"]'::JSONB;
    END IF;

    -- Validate ADR-017 quad_hash for execution contexts
    IF p_request_source IN ('ORCHESTRATOR', 'AGENT_DIRECT') AND v_context_pkg.quad_hash IS NULL THEN
        v_adr017_valid := FALSE; v_all_valid := FALSE;
        v_validation_failures := v_validation_failures || '["ADR017_MISSING_QUAD_HASH"]'::JSONB;
    END IF;

    -- Validate EC role boundaries
    IF p_agent_tier = 'TIER-1' AND p_requesting_agent NOT IN ('LARS', 'STIG', 'FINN', 'VEGA') THEN
        v_ec_role_valid := FALSE; v_all_valid := FALSE;
        v_validation_failures := v_validation_failures || '["EC_INVALID_TIER1_AGENT"]'::JSONB;
    END IF;

    -- Validate RISL status
    SELECT risl_status INTO v_risl_status FROM fhq_governance.mit_quad_pillars WHERE pillar_id = 'RISL';
    IF v_risl_status = 'HALTED' THEN
        v_risl_valid := FALSE; v_all_valid := FALSE;
        v_gateway_status := 'RISL_BLOCKED';
        v_validation_failures := v_validation_failures || '["RISL_HALTED"]'::JSONB;
    END IF;

    -- Validate DEFCON gating
    v_current_defcon := v_context_pkg.state_vector->>'defcon';
    IF v_current_defcon = 'BLACK' THEN
        v_defcon_valid := FALSE; v_all_valid := FALSE;
        v_gateway_status := 'DEFCON_BLOCKED';
        v_validation_failures := v_validation_failures || '["DEFCON_BLACK_HALT"]'::JSONB;
    ELSIF v_current_defcon = 'RED' AND p_request_source = 'ORCHESTRATOR' THEN
        v_defcon_valid := FALSE; v_all_valid := FALSE;
        v_gateway_status := 'DEFCON_BLOCKED';
        v_validation_failures := v_validation_failures || '["DEFCON_RED_EXECUTION_BLOCKED"]'::JSONB;
    END IF;

    -- FAIL-CLOSED on validation failure
    IF NOT v_all_valid THEN
        IF v_gateway_status = 'SUCCESS' THEN v_gateway_status := 'VALIDATION_FAILED'; END IF;
        INSERT INTO fhq_governance.gateway_request_log (
            requesting_agent, agent_tier, request_source, gateway_status,
            state_snapshot_hash, quad_hash,
            adr018_validated, adr017_validated, ec_role_validated,
            risl_validated, defcon_validated, validation_failures, latency_ms
        ) VALUES (
            p_requesting_agent, p_agent_tier, p_request_source, v_gateway_status,
            v_context_pkg.state_snapshot_hash, v_context_pkg.quad_hash,
            v_adr018_valid, v_adr017_valid, v_ec_role_valid,
            v_risl_valid, v_defcon_valid, v_validation_failures,
            EXTRACT(MILLISECONDS FROM clock_timestamp() - v_latency_start)::INTEGER
        );
        RETURN QUERY SELECT
            jsonb_build_object('error', 'GATEWAY_REJECT', 'status', v_gateway_status, 'failures', v_validation_failures),
            'REJECTED'::TEXT, NOW(), 'NONE'::TEXT, v_gateway_status,
            jsonb_build_object('all_passed', FALSE, 'adr018', v_adr018_valid, 'adr017', v_adr017_valid,
                'ec_role', v_ec_role_valid, 'risl', v_risl_valid, 'defcon', v_defcon_valid);
        RETURN;
    END IF;

    -- Compute cryptographic lineage
    v_computed_context_hash := encode(sha256((
        v_context_pkg.state_vector::TEXT || ':' || v_context_pkg.adr_index::TEXT || ':' ||
        v_context_pkg.ios_index::TEXT || ':' || v_context_pkg.authority_map::TEXT || ':' ||
        v_context_pkg.operational_constraints::TEXT || ':' || NOW()::TEXT
    )::bytea), 'hex');

    v_integrity_sig := 'STIG-GW-' || encode(sha256((
        v_computed_context_hash || ':' || v_context_pkg.state_snapshot_hash || ':' ||
        COALESCE(v_context_pkg.quad_hash, 'NULL') || ':' || p_requesting_agent || ':' || NOW()::TEXT
    )::bytea), 'hex');

    -- Store integrity signature
    INSERT INTO fhq_governance.gateway_integrity_signatures (
        context_hash, state_snapshot_hash, quad_hash,
        signature_value, package_version, issued_at
    ) VALUES (
        v_computed_context_hash, v_context_pkg.state_snapshot_hash, v_context_pkg.quad_hash,
        v_integrity_sig, v_context_pkg.package_version, NOW()
    ) ON CONFLICT (context_hash) DO UPDATE SET
        is_valid = TRUE,
        issued_at = NOW();

    v_validations := jsonb_build_object(
        'all_passed', TRUE, 'adr018_asrp', TRUE, 'adr017_quad', TRUE,
        'ec_role_boundary', TRUE, 'risl_safety', TRUE, 'defcon_gating', TRUE
    );

    -- Log successful request
    INSERT INTO fhq_governance.gateway_request_log (
        requesting_agent, agent_tier, request_source, gateway_status,
        context_hash, state_snapshot_hash, quad_hash, integrity_signature,
        adr018_validated, adr017_validated, ec_role_validated,
        risl_validated, defcon_validated, latency_ms
    ) VALUES (
        p_requesting_agent, p_agent_tier, p_request_source, 'SUCCESS',
        v_computed_context_hash, v_context_pkg.state_snapshot_hash, v_context_pkg.quad_hash,
        v_integrity_sig, TRUE, TRUE, TRUE, TRUE, TRUE,
        EXTRACT(MILLISECONDS FROM clock_timestamp() - v_latency_start)::INTEGER
    );

    -- Return atomic response
    RETURN QUERY SELECT
        jsonb_build_object(
            'state_vector', v_context_pkg.state_vector,
            'adr_index', v_context_pkg.adr_index,
            'ios_index', v_context_pkg.ios_index,
            'authority_map', v_context_pkg.authority_map,
            'operational_constraints', v_context_pkg.operational_constraints,
            '_metadata', jsonb_build_object(
                'package_id', v_context_pkg.package_id,
                'package_hash', v_context_pkg.package_hash,
                'state_snapshot_hash', v_context_pkg.state_snapshot_hash,
                'quad_hash', v_context_pkg.quad_hash,
                'gateway_version', '2026.DRAFT.2'
            )
        ),
        v_computed_context_hash,
        NOW(),
        v_integrity_sig,
        'SUCCESS'::TEXT,
        v_validations;
END;
$$;


--
-- Name: update_ael_intervention_timestamp(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.update_ael_intervention_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


--
-- Name: update_suspension_request_timestamp(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.update_suspension_request_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

BEGIN

    NEW.updated_at = NOW();

    RETURN NEW;

END;

$$;


--
-- Name: validate_execution_request(uuid, text, text, numeric); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.validate_execution_request(p_decision_id uuid, p_asset_id text, p_action_type text, p_order_value numeric DEFAULT 0) RETURNS TABLE(execution_authorized boolean, cv001_signature_valid boolean, cv002_guard_passed boolean, hv002_defcon_permitted boolean, rejection_reasons text[], skill_version_binding text, validation_timestamp timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_decision RECORD;
    v_sig_result fhq_governance.signature_validation_result;
    v_guard_result fhq_governance.execution_guard_result;
    v_defcon_result fhq_governance.defcon_enforcement_result;
    v_reasons TEXT[] := ARRAY[]::TEXT[];
    v_all_passed BOOLEAN := TRUE;
BEGIN
    -- Get decision details
    SELECT * INTO v_decision
    FROM fhq_governance.decision_log
    WHERE decision_id = p_decision_id;

    IF v_decision IS NULL THEN
        RETURN QUERY SELECT
            FALSE, FALSE, FALSE, FALSE,
            ARRAY['DECISION_NOT_FOUND']::TEXT[],
            NULL::TEXT,
            NOW();
        RETURN;
    END IF;

    -- CV-001: Ed25519 Signature Validation
    v_sig_result := fhq_governance.verify_ed25519_signature(
        v_decision.hash_self,
        v_decision.governance_signature,
        v_decision.signature_agent
    );

    IF NOT v_sig_result.is_valid THEN
        v_all_passed := FALSE;
        v_reasons := array_append(v_reasons, 'CV001_SIGNATURE_INVALID: ' || COALESCE(v_sig_result.failure_reason, 'UNKNOWN'));
    END IF;

    -- CV-002: ExecutionGuard with Economic Safety
    v_guard_result := fhq_governance.execution_guard_check(
        p_decision_id,
        p_asset_id,
        p_action_type,
        p_order_value
    );

    IF NOT v_guard_result.execution_permitted THEN
        v_all_passed := FALSE;
        v_reasons := array_append(v_reasons, 'CV002_GUARD_BLOCKED: ' || COALESCE(v_guard_result.rejection_reason, 'UNKNOWN'));
    END IF;

    -- HV-002: DEFCON Circuit Breaker
    v_defcon_result := fhq_governance.enforce_defcon_circuit_breaker(
        p_action_type,
        p_asset_id
    );

    IF NOT v_defcon_result.action_permitted THEN
        v_all_passed := FALSE;
        v_reasons := array_append(v_reasons, 'HV002_DEFCON_BLOCKED: ' || COALESCE(v_defcon_result.blocked_reason, 'UNKNOWN'));
    END IF;

    -- Return unified result
    RETURN QUERY SELECT
        v_all_passed,
        v_sig_result.is_valid,
        v_guard_result.execution_permitted,
        v_defcon_result.action_permitted,
        v_reasons,
        v_guard_result.skill_version_id,
        NOW();
END;
$$;


--
-- Name: validate_quad_compliance(text, text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.validate_quad_compliance(p_agent_id text, p_action_type text, p_quad_hash text DEFAULT NULL::text) RETURNS TABLE(is_compliant boolean, lids_status text, acl_status text, dsl_status text, risl_status text, rejection_reason text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_quad RECORD;
    v_defcon TEXT;
BEGIN
    -- Get current DEFCON
    SELECT current_defcon::TEXT INTO v_defcon
    FROM fhq_governance.system_state
    WHERE is_active = TRUE
    LIMIT 1;

    -- If Quad-Hash provided, validate it
    IF p_quad_hash IS NOT NULL THEN
        SELECT * INTO v_quad
        FROM fhq_governance.quad_hash_registry
        WHERE quad_hash = p_quad_hash;

        IF v_quad IS NULL THEN
            RETURN QUERY SELECT
                FALSE,
                'UNKNOWN'::TEXT,
                'UNKNOWN'::TEXT,
                'UNKNOWN'::TEXT,
                'UNKNOWN'::TEXT,
                'Quad-Hash not found in registry'::TEXT;
            RETURN;
        END IF;

        IF NOT v_quad.is_valid THEN
            RETURN QUERY SELECT
                FALSE,
                CASE WHEN v_quad.lids_threshold_met THEN 'PASS' ELSE 'FAIL' END,
                'UNKNOWN'::TEXT,
                'UNKNOWN'::TEXT,
                v_quad.risl_status,
                'Quad-Hash invalid: LIDS threshold not met or RISL halted'::TEXT;
            RETURN;
        END IF;

        -- Valid Quad-Hash
        RETURN QUERY SELECT
            TRUE,
            'PASS'::TEXT,
            v_quad.acl_agent,
            v_quad.dsl_model,
            v_quad.risl_status,
            NULL::TEXT;
        RETURN;
    END IF;

    -- No Quad-Hash provided - check if action requires one
    IF p_action_type IN ('TRADE', 'EXECUTION_PLAN', 'ALLOCATION', 'STRATEGY_PROPOSAL') THEN
        RETURN QUERY SELECT
            FALSE,
            'UNKNOWN'::TEXT,
            'UNKNOWN'::TEXT,
            'UNKNOWN'::TEXT,
            'UNKNOWN'::TEXT,
            'Quad-Hash required for action type: ' || p_action_type;
        RETURN;
    END IF;

    -- Action doesn't require Quad-Hash
    RETURN QUERY SELECT
        TRUE,
        'N/A'::TEXT,
        'N/A'::TEXT,
        'N/A'::TEXT,
        COALESCE(v_defcon, 'GREEN'),
        NULL::TEXT;
END;
$$;


--
-- Name: FUNCTION validate_quad_compliance(p_agent_id text, p_action_type text, p_quad_hash text); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.validate_quad_compliance(p_agent_id text, p_action_type text, p_quad_hash text) IS 'Validates MIT Quad compliance per ADR-017 4.
Checks Quad-Hash validity for trades and strategy outputs.
Returns compliance status for each pillar.';


--
-- Name: validate_retest_closure(uuid); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.validate_retest_closure(p_failure_mode_id uuid) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_corrective_active BOOLEAN;
    v_failure_reappeared BOOLEAN;
    v_new_failure_introduced BOOLEAN;
    v_metrics_improved BOOLEAN;
    v_cycle_count INTEGER;
    v_can_close BOOLEAN;
    v_result JSONB;
BEGIN
    -- Count validation cycles
    SELECT COUNT(*),
           BOOL_AND(corrective_mechanism_active),
           BOOL_OR(original_failure_reappeared),
           BOOL_OR(new_failure_introduced),
           BOOL_AND(metrics_improved)
    INTO v_cycle_count, v_corrective_active, v_failure_reappeared, v_new_failure_introduced, v_metrics_improved
    FROM fhq_governance.retest_validation_cycles
    WHERE failure_mode_id = p_failure_mode_id
      AND cycle_result = 'PASS';

    -- Check all 4 criteria
    v_can_close := (
        COALESCE(v_cycle_count, 0) >= 1 AND  -- At least 1 validation cycle (7 for full compliance)
        COALESCE(v_corrective_active, FALSE) = TRUE AND
        COALESCE(v_failure_reappeared, TRUE) = FALSE AND
        COALESCE(v_new_failure_introduced, TRUE) = FALSE AND
        COALESCE(v_metrics_improved, FALSE) = TRUE
    );

    v_result := jsonb_build_object(
        'failure_mode_id', p_failure_mode_id,
        'can_close', v_can_close,
        'validation_cycles', COALESCE(v_cycle_count, 0),
        'required_cycles', 7,
        'criteria', jsonb_build_object(
            'corrective_mechanism_active', COALESCE(v_corrective_active, FALSE),
            'original_failure_reappeared', COALESCE(v_failure_reappeared, TRUE),
            'new_failure_introduced', COALESCE(v_new_failure_introduced, TRUE),
            'metrics_improved', COALESCE(v_metrics_improved, FALSE)
        ),
        'directive', 'CEO-DIR-2026-054',
        'validated_at', NOW()
    );

    RETURN v_result;
END;
$$;


--
-- Name: FUNCTION validate_retest_closure(p_failure_mode_id uuid); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.validate_retest_closure(p_failure_mode_id uuid) IS 'CEO-DIR-2026-054: Validate if a RETEST failure mode can be closed.
Enforces all 4 criteria from directive Section 4.1.';


--
-- Name: validate_stig_operation(text, text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.validate_stig_operation(p_operation_type text, p_target_schema text, p_target_table text) RETURNS TABLE(is_valid boolean, rejection_reason text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_op_config RECORD;
BEGIN
    -- Check if operation type is allowed
    SELECT * INTO v_op_config
    FROM fhq_meta.stig_allowed_operations
    WHERE operation_type = p_operation_type AND is_active = TRUE;

    IF v_op_config IS NULL THEN
        RETURN QUERY SELECT FALSE, format('Operation type "%s" is not in whitelist', p_operation_type);
        RETURN;
    END IF;

    -- Check if target schema is allowed
    IF NOT (p_target_schema = ANY(v_op_config.allowed_schemas)) THEN
        RETURN QUERY SELECT FALSE, format('Schema "%s" is not allowed for operation "%s". Allowed: %s',
            p_target_schema, p_operation_type, array_to_string(v_op_config.allowed_schemas, ', '));
        RETURN;
    END IF;

    -- Check if target table is allowed (if specific tables are defined)
    IF v_op_config.allowed_tables IS NOT NULL AND
       NOT (p_target_table = ANY(v_op_config.allowed_tables)) THEN
        RETURN QUERY SELECT FALSE, format('Table "%s" is not allowed for operation "%s". Allowed: %s',
            p_target_table, p_operation_type, array_to_string(v_op_config.allowed_tables, ', '));
        RETURN;
    END IF;

    -- Check execution plane air gap
    IF p_target_schema IN ('fhq_positions', 'fhq_market', 'fhq_orders', 'fhq_execution') THEN
        RETURN QUERY SELECT FALSE, format('AIR GAP VIOLATION: Schema "%s" is execution plane. Access denied.',
            p_target_schema);
        RETURN;
    END IF;

    -- All checks passed
    RETURN QUERY SELECT TRUE, NULL::TEXT;
END;
$$;


--
-- Name: FUNCTION validate_stig_operation(p_operation_type text, p_target_schema text, p_target_table text); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.validate_stig_operation(p_operation_type text, p_target_schema text, p_target_table text) IS 'Validates STIG Engineering API operations against whitelist and air gap rules.
Returns (is_valid, rejection_reason). Used by API endpoint before execution.';


--
-- Name: validate_time_window(text, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.validate_time_window(p_dataset_name text, p_window_start timestamp with time zone, p_window_end timestamp with time zone) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_dataset RECORD;
    v_is_valid BOOLEAN;
    v_reason TEXT;
BEGIN
    -- Get dataset availability
    SELECT * INTO v_dataset 
    FROM fhq_governance.data_availability_registry 
    WHERE dataset_name = p_dataset_name;
    
    IF NOT FOUND THEN
        RETURN jsonb_build_object(
            'valid', false,
            'reason', 'UNKNOWN_DATASET',
            'message', 'Dataset not found in availability registry',
            'dataset', p_dataset_name
        );
    END IF;
    
    -- Check if window is within availability
    IF p_window_start < v_dataset.earliest_timestamp THEN
        v_is_valid := false;
        v_reason := 'WINDOW_BEFORE_DATA';
    ELSIF p_window_end > v_dataset.latest_timestamp THEN
        v_is_valid := false;
        v_reason := 'WINDOW_AFTER_DATA';
    ELSIF p_window_start >= p_window_end THEN
        v_is_valid := false;
        v_reason := 'INVALID_RANGE';
    ELSE
        v_is_valid := true;
        v_reason := 'VALID';
    END IF;
    
    RETURN jsonb_build_object(
        'valid', v_is_valid,
        'reason', v_reason,
        'dataset', p_dataset_name,
        'requested_window', jsonb_build_object(
            'start', p_window_start,
            'end', p_window_end
        ),
        'available_window', jsonb_build_object(
            'earliest', v_dataset.earliest_timestamp,
            'latest', v_dataset.latest_timestamp
        ),
        'validated_at', NOW()
    );
END;
$$;


--
-- Name: FUNCTION validate_time_window(p_dataset_name text, p_window_start timestamp with time zone, p_window_end timestamp with time zone); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.validate_time_window(p_dataset_name text, p_window_start timestamp with time zone, p_window_end timestamp with time zone) IS 'CEO-DIR-2026-059 Section 3.3: Time Window Validation Gate.
Returns INVALID_WINDOW if window falls outside data availability.';


--
-- Name: vega_calculate_sovereignty_score(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.vega_calculate_sovereignty_score() RETURNS TABLE(score_id uuid, calculation_timestamp timestamp with time zone, adr_compliance_score numeric, model_certification_score numeric, lineage_integrity_score numeric, operational_stability_score numeric, composite_sovereignty_score numeric, classification character varying, shadow_mode_note text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_adr_score NUMERIC(5,2);
    v_model_score NUMERIC(5,2);
    v_lineage_score NUMERIC(5,2);
    v_ops_score NUMERIC(5,2);
    v_composite NUMERIC(5,2);
BEGIN
    -- Calculate component scores (simplified for shadow mode)
    SELECT 
        CASE WHEN COUNT(*) > 0 
             THEN (COUNT(*) FILTER (WHERE adr_status = 'APPROVED')::NUMERIC / COUNT(*)::NUMERIC) * 100 
             ELSE 0 
        END INTO v_adr_score
    FROM fhq_meta.adr_registry;
    
    -- Model certification score (placeholder - based on existing certifications)
    SELECT COALESCE(COUNT(*)::NUMERIC * 10, 50) INTO v_model_score
    FROM fhq_meta.model_certifications
    WHERE certification_status = 'ACTIVE'
    LIMIT 10;
    v_model_score := LEAST(v_model_score, 100);
    
    -- Lineage integrity (based on audit log completeness)
    SELECT CASE WHEN COUNT(*) > 0 THEN 80 ELSE 60 END INTO v_lineage_score
    FROM fhq_meta.adr_audit_log
    WHERE timestamp > NOW() - INTERVAL '30 days';
    
    -- Operational stability (based on error rates)
    SELECT 100 - LEAST(COUNT(*) * 5, 50) INTO v_ops_score
    FROM fhq_meta.adr_audit_log
    WHERE error_class IS NOT NULL
      AND timestamp > NOW() - INTERVAL '30 days';
    
    -- Composite score (weighted average)
    v_composite := (v_adr_score * 0.3 + v_model_score * 0.25 + v_lineage_score * 0.25 + v_ops_score * 0.2);
    
    -- SHADOW MODE: Returns score without persisting
    RETURN QUERY SELECT 
        gen_random_uuid(),
        NOW(),
        v_adr_score,
        v_model_score,
        v_lineage_score,
        v_ops_score,
        v_composite,
        CASE 
            WHEN v_composite >= 80 THEN 'SOVEREIGN'::VARCHAR(20)
            WHEN v_composite >= 60 THEN 'COMPLIANT'::VARCHAR(20)
            WHEN v_composite >= 40 THEN 'AT_RISK'::VARCHAR(20)
            ELSE 'CRITICAL'::VARCHAR(20)
        END,
        'G2-A SHADOW MODE: Score calculated but not persisted. Application-layer enforcement primary.'::TEXT;
END;
$$;


--
-- Name: FUNCTION vega_calculate_sovereignty_score(); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.vega_calculate_sovereignty_score() IS 'ADR-006 VEGA Function 9/9: Shadow-only sovereignty score calculation. Returns score without persistence.';


--
-- Name: vega_compare_registry(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.vega_compare_registry() RETURNS TABLE(adr_id character varying, registry_status character varying, local_status character varying, archive_exists boolean, comparison_result character varying, comparison_timestamp timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- SHADOW MODE: Returns comparison without modification
    RETURN QUERY
    SELECT 
        r.adr_id,
        r.adr_status,
        COALESCE(l.sync_status, 'NOT_TRACKED'::VARCHAR(20)) AS local_status,
        EXISTS(SELECT 1 FROM fhq_meta.adr_archive a WHERE a.adr_id = r.adr_id) AS archive_exists,
        CASE
            WHEN l.sync_status = 'SYNCED' THEN 'ALIGNED'::VARCHAR(30)
            WHEN l.sync_status = 'DIVERGENT' THEN 'DIVERGENT'::VARCHAR(30)
            WHEN l.sync_status IS NULL THEN 'LOCAL_MISSING'::VARCHAR(30)
            ELSE 'PENDING_CHECK'::VARCHAR(30)
        END AS comparison_result,
        NOW() AS comparison_timestamp
    FROM fhq_meta.adr_registry r
    LEFT JOIN fhq_meta.adr_registry_local l ON r.adr_id = l.adr_id;
END;
$$;


--
-- Name: FUNCTION vega_compare_registry(); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.vega_compare_registry() IS 'ADR-006 VEGA Function 2/9: Shadow-only registry comparison. Returns sync status without modification.';


--
-- Name: vega_enforce_class_b_threshold(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.vega_enforce_class_b_threshold() RETURNS TABLE(check_id uuid, check_timestamp timestamp with time zone, rolling_window_days integer, class_b_count integer, threshold integer, threshold_exceeded boolean, crp_recommendation character varying, shadow_mode_note text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_class_b_count INTEGER;
BEGIN
    -- Count Class B errors in rolling 7-day window
    SELECT COUNT(*) INTO v_class_b_count
    FROM fhq_meta.adr_audit_log
    WHERE error_class = 'CLASS_B'
      AND timestamp > NOW() - INTERVAL '7 days';
    
    -- SHADOW MODE: Returns threshold status without triggering CRP
    RETURN QUERY SELECT 
        gen_random_uuid(),
        NOW(),
        7,
        v_class_b_count,
        5,
        v_class_b_count >= 5,
        CASE WHEN v_class_b_count >= 5 THEN 'CRP_RECOMMENDED'::VARCHAR(30) ELSE 'BELOW_THRESHOLD'::VARCHAR(30) END,
        'G2-A SHADOW MODE: Threshold checked but CRP not automatically triggered. Application-layer enforcement primary.'::TEXT;
END;
$$;


--
-- Name: FUNCTION vega_enforce_class_b_threshold(); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.vega_enforce_class_b_threshold() IS 'ADR-006 VEGA Function 8/9: Shadow-only Class B threshold enforcement. Returns status without triggering CRP.';


--
-- Name: vega_issue_certificate(character varying, character varying, character varying); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.vega_issue_certificate(p_model_id character varying, p_model_version character varying, p_certification_type character varying) RETURNS TABLE(certificate_id uuid, model_id character varying, model_version character varying, certification_type character varying, certification_status character varying, certification_timestamp timestamp with time zone, certificate_hash character varying, shadow_mode_note text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- SHADOW MODE: Returns certificate data without issuing
    RETURN QUERY SELECT 
        gen_random_uuid(),
        p_model_id,
        p_model_version,
        p_certification_type,
        'SHADOW_GENERATED'::VARCHAR(20),
        NOW(),
        ENCODE(SHA256(CONCAT(p_model_id, p_model_version, NOW()::TEXT)::bytea), 'hex'),
        'G2-A SHADOW MODE: Certificate generated but not issued. Application-layer enforcement primary.'::TEXT;
END;
$$;


--
-- Name: FUNCTION vega_issue_certificate(p_model_id character varying, p_model_version character varying, p_certification_type character varying); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.vega_issue_certificate(p_model_id character varying, p_model_version character varying, p_certification_type character varying) IS 'ADR-006 VEGA Function 4/9: Shadow-only certificate generation. Returns certificate data without issuance.';


--
-- Name: vega_log_bias_drift(character varying, character varying, numeric, numeric); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.vega_log_bias_drift(p_model_id character varying, p_drift_type character varying, p_drift_magnitude numeric, p_threshold numeric) RETURNS TABLE(drift_id uuid, model_id character varying, drift_type character varying, drift_magnitude numeric, threshold numeric, threshold_exceeded boolean, detection_timestamp timestamp with time zone, action_required character varying, shadow_mode_note text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- SHADOW MODE: Returns drift analysis without blocking model
    RETURN QUERY SELECT 
        gen_random_uuid(),
        p_model_id,
        p_drift_type,
        p_drift_magnitude,
        p_threshold,
        p_drift_magnitude > p_threshold,
        NOW(),
        CASE WHEN p_drift_magnitude > p_threshold THEN 'REVIEW_REQUIRED'::VARCHAR(30) ELSE 'WITHIN_TOLERANCE'::VARCHAR(30) END,
        'G2-A SHADOW MODE: Drift logged but model not blocked. Application-layer enforcement primary.'::TEXT;
END;
$$;


--
-- Name: FUNCTION vega_log_bias_drift(p_model_id character varying, p_drift_type character varying, p_drift_magnitude numeric, p_threshold numeric); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.vega_log_bias_drift(p_model_id character varying, p_drift_type character varying, p_drift_magnitude numeric, p_threshold numeric) IS 'ADR-006 VEGA Function 7/9: Shadow-only bias/drift logging. Returns analysis without blocking models.';


--
-- Name: vega_record_adversarial_event(character varying, character varying, text, character varying); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.vega_record_adversarial_event(p_event_type character varying, p_source character varying, p_description text, p_severity character varying) RETURNS TABLE(event_id uuid, event_type character varying, source character varying, description text, severity character varying, detection_timestamp timestamp with time zone, response_status character varying, shadow_mode_note text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- SHADOW MODE: Returns event record without triggering CRP or DEFCON
    RETURN QUERY SELECT 
        gen_random_uuid(),
        p_event_type,
        p_source,
        p_description,
        p_severity,
        NOW(),
        'SHADOW_LOGGED'::VARCHAR(30),
        'G2-A SHADOW MODE: Event recorded but no automatic response triggered. Application-layer enforcement primary.'::TEXT;
END;
$$;


--
-- Name: FUNCTION vega_record_adversarial_event(p_event_type character varying, p_source character varying, p_description text, p_severity character varying); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.vega_record_adversarial_event(p_event_type character varying, p_source character varying, p_description text, p_severity character varying) IS 'ADR-006 VEGA Function 5/9: Shadow-only adversarial event recording. Logs events without triggering responses.';


--
-- Name: vega_snapshot_canonical(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.vega_snapshot_canonical() RETURNS TABLE(snapshot_id uuid, snapshot_timestamp timestamp with time zone, total_adrs integer, approved_count integer, draft_count integer, superseded_count integer, snapshot_hash character varying)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_total INTEGER;
    v_approved INTEGER;
    v_draft INTEGER;
    v_superseded INTEGER;
    v_hash VARCHAR(64);
BEGIN
    -- SHADOW MODE: Returns snapshot without persisting
    SELECT COUNT(*) INTO v_total FROM fhq_meta.adr_registry;
    SELECT COUNT(*) INTO v_approved FROM fhq_meta.adr_registry WHERE adr_status = 'APPROVED';
    SELECT COUNT(*) INTO v_draft FROM fhq_meta.adr_registry WHERE adr_status = 'DRAFT';
    SELECT COUNT(*) INTO v_superseded FROM fhq_meta.adr_registry WHERE adr_status = 'SUPERSEDED';
    
    v_hash := ENCODE(SHA256(CONCAT(v_total::TEXT, v_approved::TEXT, NOW()::TEXT)::bytea), 'hex');
    
    RETURN QUERY SELECT 
        gen_random_uuid(),
        NOW(),
        v_total,
        v_approved,
        v_draft,
        v_superseded,
        v_hash;
END;
$$;


--
-- Name: FUNCTION vega_snapshot_canonical(); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.vega_snapshot_canonical() IS 'ADR-006 VEGA Function 3/9: Shadow-only canonical snapshot. Returns current state without persisting.';


--
-- Name: vega_trigger_dora_assessment(character varying, text[]); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.vega_trigger_dora_assessment(p_incident_type character varying, p_affected_systems text[]) RETURNS TABLE(assessment_id uuid, incident_type character varying, dora_article character varying, classification character varying, affected_systems text[], assessment_timestamp timestamp with time zone, response_required boolean, shadow_mode_note text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- SHADOW MODE: Returns DORA assessment without triggering incident flow
    RETURN QUERY SELECT 
        gen_random_uuid(),
        p_incident_type,
        'Article 17'::VARCHAR(20),
        CASE 
            WHEN p_incident_type LIKE '%CRITICAL%' THEN 'MAJOR_INCIDENT'::VARCHAR(30)
            ELSE 'MINOR_INCIDENT'::VARCHAR(30)
        END,
        p_affected_systems,
        NOW(),
        TRUE,
        'G2-A SHADOW MODE: DORA assessment generated but incident flow not triggered. Application-layer enforcement primary.'::TEXT;
END;
$$;


--
-- Name: FUNCTION vega_trigger_dora_assessment(p_incident_type character varying, p_affected_systems text[]); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.vega_trigger_dora_assessment(p_incident_type character varying, p_affected_systems text[]) IS 'ADR-006 VEGA Function 6/9: Shadow-only DORA assessment. Returns compliance assessment without triggering incident flow.';


--
-- Name: vega_validate_state_request(text, text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.vega_validate_state_request(p_agent_id text, p_state_hash text, p_intended_action text) RETURNS TABLE(is_approved boolean, rejection_reason text, enforcement_action text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_snapshot RECORD;
    v_defcon TEXT;
BEGIN
    -- 1. Verify state hash exists and is valid
    SELECT s.* INTO v_snapshot
    FROM fhq_governance.shared_state_snapshots s
    WHERE s.state_vector_hash = p_state_hash
    AND s.is_valid = TRUE;

    IF v_snapshot IS NULL THEN
        -- Log violation
        INSERT INTO fhq_governance.asrp_violations (
            violation_type, agent_id, attempted_action,
            state_hash_expected, state_hash_provided,
            enforcement_action, evidence_bundle
        ) VALUES (
            'INVALID_READ', p_agent_id, p_intended_action,
            'VALID_HASH', p_state_hash,
            'BLOCKED', jsonb_build_object(
                'reason', 'State hash not found or invalid',
                'timestamp', NOW()
            )
        );

        RETURN QUERY SELECT FALSE, 'Invalid state hash', 'BLOCKED'::TEXT;
        RETURN;
    END IF;

    -- 2. Check DEFCON gating
    v_defcon := v_snapshot.defcon_level;

    IF v_defcon = 'BLACK' THEN
        RETURN QUERY SELECT FALSE, 'DEFCON BLACK: All operations suspended', 'BLOCKED'::TEXT;
        RETURN;
    END IF;

    IF v_defcon = 'RED' AND p_intended_action IN ('TRADE', 'EXECUTION_PLAN', 'ALLOCATION') THEN
        RETURN QUERY SELECT FALSE, 'DEFCON RED: Execution operations suspended', 'BLOCKED'::TEXT;
        RETURN;
    END IF;

    -- 3. Freshness check
    IF (NOW() - v_snapshot.snapshot_timestamp) > (v_snapshot.freshness_ttl_seconds * INTERVAL '1 second') THEN
        RETURN QUERY SELECT FALSE, 'State snapshot stale - refresh required', 'BLOCKED'::TEXT;
        RETURN;
    END IF;

    -- 4. All checks passed
    RETURN QUERY SELECT TRUE, NULL::TEXT, NULL::TEXT;
END;
$$;


--
-- Name: FUNCTION vega_validate_state_request(p_agent_id text, p_state_hash text, p_intended_action text); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.vega_validate_state_request(p_agent_id text, p_state_hash text, p_intended_action text) IS 'VEGA integration point for state validation per ADR-018 7.
Validates state hash, checks DEFCON gating, and enforces freshness.
Returns rejection with enforcement action if validation fails.';


--
-- Name: vega_verify_hashes(); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.vega_verify_hashes() RETURNS TABLE(adr_id character varying, stored_hash character varying, verification_status character varying, verification_timestamp timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- SHADOW MODE: Returns hash verification status without modification
    -- Application-layer enforcement remains primary
    RETURN QUERY
    SELECT 
        r.adr_id,
        r.sha256_hash::VARCHAR(64),
        CASE 
            WHEN r.sha256_hash IS NOT NULL THEN 'HASH_PRESENT'::VARCHAR(20)
            ELSE 'HASH_MISSING'::VARCHAR(20)
        END AS verification_status,
        NOW() AS verification_timestamp
    FROM fhq_meta.adr_registry r
    WHERE r.adr_status = 'APPROVED';
END;
$$;


--
-- Name: FUNCTION vega_verify_hashes(); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.vega_verify_hashes() IS 'ADR-006 VEGA Function 1/9: Shadow-only hash verification. Returns verification status without system modification.';


--
-- Name: verify_cross_agent_sync(text[]); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.verify_cross_agent_sync(p_agent_ids text[]) RETURNS TABLE(agent_id text, state_hash text, state_age_seconds integer, is_synchronized boolean, last_attestation timestamp with time zone)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_current_hash TEXT;
    v_agent TEXT;
BEGIN
    -- Get current valid state hash
    SELECT state_vector_hash INTO v_current_hash
    FROM fhq_governance.shared_state_snapshots
    WHERE is_valid = TRUE
    ORDER BY snapshot_timestamp DESC
    LIMIT 1;

    -- Check each agent's last attestation
    FOREACH v_agent IN ARRAY p_agent_ids
    LOOP
        RETURN QUERY
        SELECT
            v_agent,
            h.state_vector_hash,
            EXTRACT(EPOCH FROM (NOW() - h.attested_at))::INTEGER,
            h.state_vector_hash = v_current_hash,
            h.attested_at
        FROM fhq_governance.agent_health_attestations h
        WHERE h.agent_id = v_agent
        ORDER BY h.attested_at DESC
        LIMIT 1;
    END LOOP;
END;
$$;


--
-- Name: FUNCTION verify_cross_agent_sync(p_agent_ids text[]); Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON FUNCTION fhq_governance.verify_cross_agent_sync(p_agent_ids text[]) IS 'Verify all agents are synchronized to the same state vector.
Per CEO Directive v2.0: Cross-agent synchronization.';


--
-- Name: verify_decision_plan_schema(uuid); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.verify_decision_plan_schema(p_decision_id uuid) RETURNS TABLE(is_valid boolean, ttl_valid boolean, has_signature boolean, has_context_hash boolean, validation_errors text[])
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_decision RECORD;
    v_errors TEXT[] := ARRAY[]::TEXT[];
    v_ttl_valid BOOLEAN;
    v_has_sig BOOLEAN;
    v_has_hash BOOLEAN;
BEGIN
    -- Get decision
    SELECT * INTO v_decision
    FROM fhq_governance.decision_log
    WHERE decision_id = p_decision_id;

    IF v_decision IS NULL THEN
        RETURN QUERY SELECT FALSE, FALSE, FALSE, FALSE, ARRAY['Decision not found'];
        RETURN;
    END IF;

    -- Check TTL
    v_ttl_valid := NOW() < v_decision.valid_until;
    IF NOT v_ttl_valid THEN
        v_errors := array_append(v_errors, 'TTL_EXPIRED');
    END IF;

    -- Check signature presence
    v_has_sig := v_decision.governance_signature IS NOT NULL;
    IF NOT v_has_sig THEN
        v_errors := array_append(v_errors, 'MISSING_SIGNATURE');
    END IF;

    -- Check context hash
    v_has_hash := v_decision.context_hash IS NOT NULL AND v_decision.context_hash != '';
    IF NOT v_has_hash THEN
        v_errors := array_append(v_errors, 'MISSING_CONTEXT_HASH');
    END IF;

    RETURN QUERY SELECT
        (v_ttl_valid AND v_has_sig AND v_has_hash),
        v_ttl_valid,
        v_has_sig,
        v_has_hash,
        v_errors;
END;
$$;


--
-- Name: verify_ed25519_signature(text, text, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.verify_ed25519_signature(p_message text, p_signature text, p_agent_id text) RETURNS fhq_governance.signature_validation_result
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_result fhq_governance.signature_validation_result;
    v_public_key TEXT;
    v_is_valid BOOLEAN := FALSE;
BEGIN
    -- Initialize result (FAIL-CLOSED default)
    v_result.is_valid := FALSE;
    v_result.agent_id := p_agent_id;
    v_result.verification_timestamp := NOW();

    -- Validate inputs exist
    IF p_message IS NULL OR p_signature IS NULL OR p_agent_id IS NULL THEN
        v_result.failure_reason := 'NULL_INPUT_PARAMETER';
        RETURN v_result;
    END IF;

    -- Get agent's public key from registry
    SELECT public_key INTO v_public_key
    FROM fhq_org.org_agents
    WHERE agent_id = p_agent_id
    AND is_active = TRUE
    AND is_suspended = FALSE;

    IF v_public_key IS NULL THEN
        v_result.failure_reason := 'AGENT_KEY_NOT_FOUND_OR_SUSPENDED';

        -- Log security alert
        INSERT INTO fhq_governance.security_alerts (
            alert_type, alert_severity, source_module, description, evidence
        ) VALUES (
            'SIGNATURE_VALIDATION_FAILURE',
            'CRITICAL',
            'IoS-012',
            'Ed25519 signature validation failed: agent key not found or suspended',
            jsonb_build_object(
                'agent_id', p_agent_id,
                'failure_reason', 'AGENT_KEY_NOT_FOUND_OR_SUSPENDED',
                'timestamp', NOW()
            )
        );

        RETURN v_result;
    END IF;

    v_result.public_key := v_public_key;

    -- Cryptographic verification via extension or external call
    -- For now, validate signature format and agent authorization
    -- Full Ed25519 verification requires nacl/cryptography library

    -- Validate signature format (hex, 128 chars for Ed25519)
    IF LENGTH(p_signature) < 64 THEN
        v_result.failure_reason := 'INVALID_SIGNATURE_FORMAT';
        RETURN v_result;
    END IF;

    -- Verify signature matches expected pattern for agent
    -- In production, this would call nacl.verify() via plpython3u
    -- For constitutional compliance, we enforce the check exists and fails-closed

    -- Check if signature was generated by authorized agent
    IF p_agent_id NOT IN ('IoS-008', 'LARS', 'VEGA') THEN
        v_result.failure_reason := 'UNAUTHORIZED_SIGNING_AGENT';
        RETURN v_result;
    END IF;

    -- Mark as valid if all checks pass
    v_result.is_valid := TRUE;
    v_result.failure_reason := NULL;

    RETURN v_result;
END;
$$;


--
-- Name: verify_phase_a(uuid, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.verify_phase_a(p_cycle_id uuid, p_verified_by text) RETURNS TABLE(success boolean, message text, can_proceed_to_phase_b boolean)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_phase_a RECORD;
    v_postmortem_exists BOOLEAN;
BEGIN
    -- Check Phase A requirements
    SELECT * INTO v_phase_a
    FROM fhq_governance.check_phase_a_requirements();

    -- Check if CEIO post-mortem exists
    SELECT EXISTS (
        SELECT 1 FROM fhq_governance.ceio_postmortem
        WHERE reactivation_cycle_id = p_cycle_id
    ) INTO v_postmortem_exists;

    IF NOT v_phase_a.all_assets_fresh THEN
        RETURN QUERY SELECT
            false,
            'Phase A FAILED: Not all primary assets have fresh data'::TEXT,
            false;
        RETURN;
    END IF;

    IF NOT v_postmortem_exists THEN
        RETURN QUERY SELECT
            false,
            'Phase A BLOCKED: CEIO Post-Mortem not yet submitted'::TEXT,
            false;
        RETURN;
    END IF;

    -- Update phase status
    UPDATE fhq_governance.aci_reactivation_phases
    SET
        phase_status = 'VERIFIED',
        completed_at = NOW(),
        verified_by = p_verified_by,
        verification_evidence = v_phase_a.details
    WHERE reactivation_cycle_id = p_cycle_id
    AND phase_name = 'PHASE_A_DATA';

    -- Update cycle status
    UPDATE fhq_governance.aci_reactivation_cycles
    SET
        cycle_status = 'PHASE_B',
        phase_a_complete = true
    WHERE cycle_id = p_cycle_id;

    -- Start Phase B
    UPDATE fhq_governance.aci_reactivation_phases
    SET
        phase_status = 'IN_PROGRESS',
        started_at = NOW()
    WHERE reactivation_cycle_id = p_cycle_id
    AND phase_name = 'PHASE_B_PERCEPTION';

    RETURN QUERY SELECT
        true,
        'Phase A VERIFIED. Proceeding to Phase B: Perception Sanity Check'::TEXT,
        true;
END;
$$;


--
-- Name: verify_phase_b(uuid, text); Type: FUNCTION; Schema: fhq_governance; Owner: -
--

CREATE FUNCTION fhq_governance.verify_phase_b(p_cycle_id uuid, p_verified_by text) RETURNS TABLE(success boolean, message text, can_proceed_to_phase_c boolean)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_phase_b RECORD;
BEGIN
    -- Run Phase B sanity check
    SELECT * INTO v_phase_b
    FROM fhq_governance.run_phase_b_sanity_check();

    IF v_phase_b.anomalies_detected THEN
        -- Rollback to blackout
        UPDATE fhq_governance.aci_reactivation_phases
        SET
            phase_status = 'ROLLED_BACK',
            completed_at = NOW(),
            verified_by = p_verified_by,
            verification_evidence = v_phase_b.details,
            blockers = ARRAY['Epistemic anomalies detected']
        WHERE reactivation_cycle_id = p_cycle_id
        AND phase_name = 'PHASE_B_PERCEPTION';

        UPDATE fhq_governance.aci_reactivation_cycles
        SET
            cycle_status = 'ROLLED_BACK',
            rollback_reason = 'Phase B anomalies: ' || v_phase_b.details::TEXT
        WHERE cycle_id = p_cycle_id;

        RETURN QUERY SELECT
            false,
            'Phase B FAILED: Epistemic anomalies detected. ROLLED BACK to DATA_BLACKOUT.'::TEXT,
            false;
        RETURN;
    END IF;

    -- Update phase status
    UPDATE fhq_governance.aci_reactivation_phases
    SET
        phase_status = 'VERIFIED',
        completed_at = NOW(),
        verified_by = p_verified_by,
        verification_evidence = v_phase_b.details
    WHERE reactivation_cycle_id = p_cycle_id
    AND phase_name = 'PHASE_B_PERCEPTION';

    -- Update cycle status
    UPDATE fhq_governance.aci_reactivation_cycles
    SET
        cycle_status = 'PHASE_C',
        phase_b_complete = true
    WHERE cycle_id = p_cycle_id;

    -- Start Phase C
    UPDATE fhq_governance.aci_reactivation_phases
    SET
        phase_status = 'IN_PROGRESS',
        started_at = NOW()
    WHERE reactivation_cycle_id = p_cycle_id
    AND phase_name = 'PHASE_C_LEARNING';

    RETURN QUERY SELECT
        true,
        format('Phase B VERIFIED. Hit rate: %s%%, Brier: %s. Proceeding to Phase C.',
               COALESCE(v_phase_b.hit_rate_paper::TEXT, 'N/A'),
               COALESCE(v_phase_b.current_brier_score::TEXT, 'N/A'))::TEXT,
        true;
END;
$$;


--
-- Name: assets_set_updated_at(); Type: FUNCTION; Schema: fhq_meta; Owner: -
--

CREATE FUNCTION fhq_meta.assets_set_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


--
-- Name: check_vendor_quota(text, integer); Type: FUNCTION; Schema: fhq_meta; Owner: -
--

CREATE FUNCTION fhq_meta.check_vendor_quota(p_vendor_name text, p_calls_needed integer DEFAULT 1) RETURNS TABLE(can_proceed boolean, current_usage integer, soft_ceiling integer, hard_limit integer, fallback_vendor text, decision text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_vendor RECORD;
    v_counter RECORD;
    v_soft_ceiling INTEGER;
    v_interval_start TIMESTAMPTZ;
BEGIN
    -- Get vendor config
    SELECT * INTO v_vendor FROM fhq_meta.vendor_limits WHERE vendor_name = p_vendor_name AND is_active = TRUE;

    IF NOT FOUND THEN
        RETURN QUERY SELECT FALSE, 0, 0, 0, NULL::TEXT, 'VENDOR_NOT_FOUND'::TEXT;
        RETURN;
    END IF;

    -- Calculate interval start
    v_interval_start := CASE v_vendor.interval_type
        WHEN 'MINUTE' THEN date_trunc('minute', NOW())
        WHEN 'HOUR' THEN date_trunc('hour', NOW())
        WHEN 'DAY' THEN date_trunc('day', NOW())
        WHEN 'MONTH' THEN date_trunc('month', NOW())
    END;

    -- Get or create counter
    SELECT * INTO v_counter FROM fhq_meta.vendor_usage_counters
    WHERE vendor_id = v_vendor.vendor_id AND interval_start = v_interval_start;

    IF NOT FOUND THEN
        INSERT INTO fhq_meta.vendor_usage_counters (vendor_id, interval_start, interval_type, current_usage)
        VALUES (v_vendor.vendor_id, v_interval_start, v_vendor.interval_type, 0)
        RETURNING * INTO v_counter;
    END IF;

    -- Calculate soft ceiling
    v_soft_ceiling := FLOOR(v_vendor.free_tier_limit * v_vendor.soft_ceiling_pct);

    -- Check if we can proceed
    IF v_counter.current_usage + p_calls_needed <= v_soft_ceiling THEN
        RETURN QUERY SELECT
            TRUE,
            v_counter.current_usage,
            v_soft_ceiling,
            v_vendor.hard_limit,
            NULL::TEXT,
            'PROCEED'::TEXT;
    ELSIF v_vendor.fallback_vendor_id IS NOT NULL THEN
        RETURN QUERY SELECT
            FALSE,
            v_counter.current_usage,
            v_soft_ceiling,
            v_vendor.hard_limit,
            (SELECT vendor_name FROM fhq_meta.vendor_limits WHERE vendor_id = v_vendor.fallback_vendor_id),
            'USE_FALLBACK'::TEXT;
    ELSE
        RETURN QUERY SELECT
            FALSE,
            v_counter.current_usage,
            v_soft_ceiling,
            v_vendor.hard_limit,
            NULL::TEXT,
            'SKIP_QUOTA_PROTECTION'::TEXT;
    END IF;
END;
$$;


--
-- Name: detect_multi_truth(text, text, timestamp with time zone); Type: FUNCTION; Schema: fhq_meta; Owner: -
--

CREATE FUNCTION fhq_meta.detect_multi_truth(p_domain_name text, p_asset_id text DEFAULT NULL::text, p_timestamp timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS TABLE(violation_detected boolean, violation_type text, conflict_description text, severity numeric)
    LANGUAGE plpgsql
    AS $$

DECLARE

    v_domain_count INTEGER;

    v_series_count INTEGER;

BEGIN

    -- Check for duplicate domains

    SELECT COUNT(*) INTO v_domain_count

    FROM fhq_meta.canonical_domain_registry

    WHERE domain_name = p_domain_name

      AND is_active = TRUE;



    IF v_domain_count > 1 THEN

        RETURN QUERY SELECT

            TRUE,

            'DUPLICATE_DOMAIN'::TEXT,

            format('Multiple active canonical domains found for: %s', p_domain_name),

            1.0::NUMERIC;

        RETURN;

    END IF;



    -- Check for duplicate series if asset specified

    IF p_asset_id IS NOT NULL THEN

        SELECT COUNT(*) INTO v_series_count

        FROM fhq_meta.canonical_series_registry

        WHERE asset_id = p_asset_id

          AND is_active = TRUE;



        IF v_series_count > 1 THEN

            RETURN QUERY SELECT

                TRUE,

                'DUPLICATE_SERIES'::TEXT,

                format('Multiple active canonical series found for asset: %s', p_asset_id),

                0.8::NUMERIC;

            RETURN;

        END IF;

    END IF;



    -- No violation detected

    RETURN QUERY SELECT FALSE, NULL::TEXT, NULL::TEXT, 0.0::NUMERIC;

END;

$$;


--
-- Name: FUNCTION detect_multi_truth(p_domain_name text, p_asset_id text, p_timestamp timestamp with time zone); Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON FUNCTION fhq_meta.detect_multi_truth(p_domain_name text, p_asset_id text, p_timestamp timestamp with time zone) IS 'ADR-013: Detects potential multi-truth violations.';


--
-- Name: get_indicator_tooltip(character varying); Type: FUNCTION; Schema: fhq_meta; Owner: -
--

CREATE FUNCTION fhq_meta.get_indicator_tooltip(p_indicator_id character varying) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_tooltip JSONB;
BEGIN
    SELECT jsonb_build_object(
        'indicator_id', indicator_id,
        'display', jsonb_build_object(
            'title', name_display,
            'subtitle', name_subtitle,
            'priority', display_priority,
            'color_scheme', tooltip_color_scheme
        ),
        'description', jsonb_build_object(
            'short', description_short,
            'finance', description_finance,
            'formula', formula_human
        ),
        'classification', jsonb_build_object(
            'category', category,
            'subcategory', subcategory,
            'source', source
        ),
        'ace_context', jsonb_build_object(
            'family', ace_family,
            'meta_relevance', meta_allocation_relevance
        ),
        'interpretation', jsonb_build_object(
            'thresholds', jsonb_build_object(
                'bullish', bullish_threshold,
                'bearish', bearish_threshold,
                'neutral_min', neutral_range_min,
                'neutral_max', neutral_range_max
            ),
            'rules', interpretation_rules
        ),
        'metadata', jsonb_build_object(
            'parameters', parameters,
            'dependencies', data_dependencies,
            'revision_hash', revision_hash,
            'last_updated', last_updated
        )
    ) INTO v_tooltip
    FROM fhq_meta.indicator_definitions
    WHERE indicator_id = p_indicator_id;

    RETURN v_tooltip;
END;
$$;


--
-- Name: FUNCTION get_indicator_tooltip(p_indicator_id character varying); Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON FUNCTION fhq_meta.get_indicator_tooltip(p_indicator_id character varying) IS 'Generate complete tooltip JSON for dashboard hover. Returns all metadata needed for human-first, FINN-integrated tooltips.';


--
-- Name: increment_vendor_usage(text, integer, text); Type: FUNCTION; Schema: fhq_meta; Owner: -
--

CREATE FUNCTION fhq_meta.increment_vendor_usage(p_vendor_name text, p_calls integer DEFAULT 1, p_task_name text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_vendor RECORD;
    v_interval_start TIMESTAMPTZ;
    v_new_usage INTEGER;
BEGIN
    SELECT * INTO v_vendor FROM fhq_meta.vendor_limits WHERE vendor_name = p_vendor_name;
    IF NOT FOUND THEN RETURN FALSE; END IF;

    v_interval_start := CASE v_vendor.interval_type
        WHEN 'MINUTE' THEN date_trunc('minute', NOW())
        WHEN 'HOUR' THEN date_trunc('hour', NOW())
        WHEN 'DAY' THEN date_trunc('day', NOW())
        WHEN 'MONTH' THEN date_trunc('month', NOW())
    END;

    INSERT INTO fhq_meta.vendor_usage_counters (vendor_id, interval_start, interval_type, current_usage)
    VALUES (v_vendor.vendor_id, v_interval_start, v_vendor.interval_type, p_calls)
    ON CONFLICT (vendor_id, interval_start, interval_type)
    DO UPDATE SET
        current_usage = fhq_meta.vendor_usage_counters.current_usage + p_calls,
        peak_usage = GREATEST(fhq_meta.vendor_usage_counters.peak_usage, fhq_meta.vendor_usage_counters.current_usage + p_calls),
        last_updated = NOW()
    RETURNING current_usage INTO v_new_usage;

    -- Log the usage
    INSERT INTO fhq_governance.vendor_quota_events (vendor_id, event_type, task_name, previous_usage, new_usage)
    VALUES (v_vendor.vendor_id, 'USAGE_INCREMENT', p_task_name, v_new_usage - p_calls, v_new_usage);

    RETURN TRUE;
END;
$$;


--
-- Name: ios_registry_set_updated_at(); Type: FUNCTION; Schema: fhq_meta; Owner: -
--

CREATE FUNCTION fhq_meta.ios_registry_set_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


--
-- Name: model_context_registry_set_updated_at(); Type: FUNCTION; Schema: fhq_meta; Owner: -
--

CREATE FUNCTION fhq_meta.model_context_registry_set_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


--
-- Name: narrative_vectors_protect_records(); Type: FUNCTION; Schema: fhq_meta; Owner: -
--

CREATE FUNCTION fhq_meta.narrative_vectors_protect_records() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Allow IoS-009 to update BPAV fields only
    IF TG_OP = 'UPDATE' THEN
        IF current_user = 'ios009_service' OR
           (NEW.bpav IS DISTINCT FROM OLD.bpav AND
            NEW.narrative = OLD.narrative AND
            NEW.probability = OLD.probability AND
            NEW.confidence = OLD.confidence) THEN
            -- IoS-009 updating BPAV or system marking as expired
            RETURN NEW;
        ELSE
            RAISE EXCEPTION 'GOVERNANCE VIOLATION: narrative_vectors is append-only. Updates prohibited except for BPAV computation by IoS-009.';
        END IF;
    END IF;

    IF TG_OP = 'DELETE' THEN
        RAISE EXCEPTION 'GOVERNANCE VIOLATION: narrative_vectors is append-only. Deletions are prohibited. Use half_life decay mechanism.';
    END IF;

    RETURN NEW;
END;
$$;


--
-- Name: register_adr_with_validation(text, text, text, text, text, text, text, text, boolean); Type: FUNCTION; Schema: fhq_meta; Owner: -
--

CREATE FUNCTION fhq_meta.register_adr_with_validation(p_adr_id text, p_adr_title text, p_adr_type text, p_file_path text DEFAULT NULL::text, p_description text DEFAULT NULL::text, p_rationale text DEFAULT NULL::text, p_alternatives_considered text DEFAULT NULL::text, p_consequences text DEFAULT NULL::text, p_force_operational boolean DEFAULT false) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_is_migration BOOLEAN;
    v_has_adr_metadata BOOLEAN;
    v_result JSONB;
BEGIN
    -- Check if this looks like a migration reference
    v_is_migration := (
        p_file_path LIKE '%MIGRATIONS%' OR 
        p_adr_id LIKE 'MIG-%' OR
        p_adr_id LIKE 'G4%' OR
        p_adr_type = 'OPERATIONAL'
    );
    
    -- Check if proper ADR metadata is provided
    v_has_adr_metadata := (
        p_description IS NOT NULL AND LENGTH(p_description) > 20 AND
        p_rationale IS NOT NULL AND LENGTH(p_rationale) > 20
    );
    
    -- CLASSIFICATION RULE ENFORCEMENT
    IF v_is_migration AND NOT v_has_adr_metadata AND NOT p_force_operational THEN
        -- Redirect to governance_documents instead of adr_registry
        INSERT INTO fhq_governance.governance_documents (
            document_id,
            document_name,
            document_type,
            tier,
            version,
            content,
            created_at,
            approved_by,
            status
        ) VALUES (
            gen_random_uuid(),
            p_adr_title,
            CASE 
                WHEN p_adr_id LIKE 'MIG-%' THEN 'MIGRATION_RECORD'
                WHEN p_adr_type = 'OPERATIONAL' THEN 'OPERATIONAL_ARTIFACT'
                ELSE 'IMPLEMENTATION_ARTIFACT'
            END,
            2,
            '1.0',
            'Auto-classified as implementation artifact per CEO Directive 2025-12-20. Original ID: ' || p_adr_id || COALESCE('. File: ' || p_file_path, ''),
            NOW(),
            'STIG',
            'ACTIVE'
        );
        
        -- Log the redirect
        INSERT INTO fhq_governance.governance_actions_log (
            action_type, action_target, decision, decision_rationale, initiated_by, initiated_at
        ) VALUES (
            'ADR_REGISTRATION_REDIRECTED',
            p_adr_id,
            'REDIRECTED_TO_GOVERNANCE_DOCS',
            'Migration/operational artifact without ADR metadata redirected per classification rule',
            'STIG',
            NOW()
        );
        
        RETURN jsonb_build_object(
            'status', 'REDIRECTED',
            'original_id', p_adr_id,
            'destination', 'governance_documents',
            'reason', 'Missing ADR metadata (description, rationale, alternatives)'
        );
    END IF;
    
    -- If proper ADR metadata exists, allow registration to adr_registry
    INSERT INTO fhq_meta.adr_registry (
        adr_id, adr_title, adr_status, adr_type, file_path,
        description, rationale, status, created_by, created_at
    ) VALUES (
        p_adr_id, p_adr_title, 'APPROVED', COALESCE(p_adr_type, 'ARCHITECTURAL'),
        p_file_path, p_description, p_rationale, 'ACTIVE', 'STIG', NOW()
    )
    ON CONFLICT (adr_id) DO NOTHING;
    
    RETURN jsonb_build_object(
        'status', 'REGISTERED',
        'adr_id', p_adr_id,
        'destination', 'adr_registry'
    );
END;
$$;


--
-- Name: FUNCTION register_adr_with_validation(p_adr_id text, p_adr_title text, p_adr_type text, p_file_path text, p_description text, p_rationale text, p_alternatives_considered text, p_consequences text, p_force_operational boolean); Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON FUNCTION fhq_meta.register_adr_with_validation(p_adr_id text, p_adr_title text, p_adr_type text, p_file_path text, p_description text, p_rationale text, p_alternatives_considered text, p_consequences text, p_force_operational boolean) IS 'CEO Directive 2025-12-20: Enforces ADR classification rule. 
Migrations and operational artifacts are redirected to governance_documents 
unless proper ADR metadata (description, rationale) is provided.';


--
-- Name: register_canonical_ingestion(text, text, text[], text, text[], text[], text, text); Type: FUNCTION; Schema: fhq_meta; Owner: -
--

CREATE FUNCTION fhq_meta.register_canonical_ingestion(p_job_name text, p_domain_name text, p_vendor_sources text[], p_primary_vendor text, p_asset_universe text[] DEFAULT ARRAY['*'::text], p_frequencies text[] DEFAULT ARRAY['1d'::text], p_job_type text DEFAULT 'SCHEDULED'::text, p_created_by text DEFAULT 'LARS'::text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$

DECLARE

    v_domain_id UUID;

    v_canonical_store TEXT;

    v_ingestion_id UUID;

BEGIN

    -- Resolve domain

    SELECT domain_id, canonical_store INTO v_domain_id, v_canonical_store

    FROM fhq_meta.canonical_domain_registry

    WHERE domain_name = p_domain_name

      AND is_active = TRUE;



    IF v_domain_id IS NULL THEN

        RAISE EXCEPTION 'ADR-013 VIOLATION: Cannot register ingestion for unknown domain: %', p_domain_name;

    END IF;



    -- Register ingestion job

    INSERT INTO fhq_meta.canonical_ingestion_registry (

        job_name, job_type, domain_id, target_canonical_store,

        asset_universe, frequencies, vendor_sources, primary_vendor,

        created_by

    ) VALUES (

        p_job_name, p_job_type, v_domain_id, v_canonical_store,

        p_asset_universe, p_frequencies, p_vendor_sources, p_primary_vendor,

        p_created_by

    )

    ON CONFLICT (job_name) DO UPDATE SET

        vendor_sources = EXCLUDED.vendor_sources,

        asset_universe = EXCLUDED.asset_universe,

        frequencies = EXCLUDED.frequencies,

        updated_at = NOW()

    RETURNING ingestion_id INTO v_ingestion_id;



    RETURN v_ingestion_id;

END;

$$;


--
-- Name: FUNCTION register_canonical_ingestion(p_job_name text, p_domain_name text, p_vendor_sources text[], p_primary_vendor text, p_asset_universe text[], p_frequencies text[], p_job_type text, p_created_by text); Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON FUNCTION fhq_meta.register_canonical_ingestion(p_job_name text, p_domain_name text, p_vendor_sources text[], p_primary_vendor text, p_asset_universe text[], p_frequencies text[], p_job_type text, p_created_by text) IS 'ADR-013: Registers an ingestion job for canonical store access.';


--
-- Name: resolve_canonical_store(text); Type: FUNCTION; Schema: fhq_meta; Owner: -
--

CREATE FUNCTION fhq_meta.resolve_canonical_store(p_domain_name text) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$

DECLARE

    v_canonical_store TEXT;

BEGIN

    SELECT canonical_store INTO v_canonical_store

    FROM fhq_meta.canonical_domain_registry

    WHERE domain_name = p_domain_name

      AND is_active = TRUE

      AND is_canonical = TRUE

    LIMIT 1;



    IF v_canonical_store IS NULL THEN

        RAISE EXCEPTION 'ADR-013 VIOLATION: No canonical store found for domain: %', p_domain_name;

    END IF;



    RETURN v_canonical_store;

END;

$$;


--
-- Name: FUNCTION resolve_canonical_store(p_domain_name text); Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON FUNCTION fhq_meta.resolve_canonical_store(p_domain_name text) IS 'ADR-013: Resolves domain name to canonical store. Raises exception if not found.';


--
-- Name: submit_narrative_vector(text, text, numeric, numeric, integer, text); Type: FUNCTION; Schema: fhq_meta; Owner: -
--

CREATE FUNCTION fhq_meta.submit_narrative_vector(p_domain text, p_narrative text, p_probability numeric, p_confidence numeric, p_half_life_hours integer DEFAULT 24, p_operator text DEFAULT 'CEO'::text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_vector_id UUID;
BEGIN
    -- Validate domain
    IF p_domain NOT IN ('Regulatory', 'Geopolitical', 'Liquidity', 'Reflexivity', 'Sentiment', 'Other') THEN
        RAISE EXCEPTION 'Invalid domain. Must be one of: Regulatory, Geopolitical, Liquidity, Reflexivity, Sentiment, Other';
    END IF;

    -- Insert the narrative vector
    INSERT INTO fhq_meta.narrative_vectors (
        domain,
        narrative,
        probability,
        confidence,
        half_life_hours,
        created_by
    ) VALUES (
        p_domain,
        p_narrative,
        p_probability,
        p_confidence,
        p_half_life_hours,
        p_operator
    ) RETURNING vector_id INTO v_vector_id;

    RETURN v_vector_id;
END;
$$;


--
-- Name: FUNCTION submit_narrative_vector(p_domain text, p_narrative text, p_probability numeric, p_confidence numeric, p_half_life_hours integer, p_operator text); Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON FUNCTION fhq_meta.submit_narrative_vector(p_domain text, p_narrative text, p_probability numeric, p_confidence numeric, p_half_life_hours integer, p_operator text) IS 'CEO/Human Oracle interface for submitting narrative vectors to IoS-009.
Returns the vector_id for tracking. BPAV will be computed by IoS-009.';


--
-- Name: update_canonical_documents_timestamp(); Type: FUNCTION; Schema: fhq_meta; Owner: -
--

CREATE FUNCTION fhq_meta.update_canonical_documents_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


--
-- Name: validate_canonical_access(text, text, text, text, text); Type: FUNCTION; Schema: fhq_meta; Owner: -
--

CREATE FUNCTION fhq_meta.validate_canonical_access(p_agent_id text, p_domain_name text, p_target_store text, p_operation_type text DEFAULT 'READ'::text, p_access_context text DEFAULT 'PRODUCTION'::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

DECLARE

    v_canonical_store TEXT;

    v_is_canonical BOOLEAN;

    v_access_authorized BOOLEAN := TRUE;

BEGIN

    -- Get canonical store for domain

    SELECT canonical_store INTO v_canonical_store

    FROM fhq_meta.canonical_domain_registry

    WHERE domain_name = p_domain_name

      AND is_active = TRUE;



    -- Check if target matches canonical

    v_is_canonical := (v_canonical_store = p_target_store);



    -- In PRODUCTION context, non-canonical access is a violation

    IF p_access_context = 'PRODUCTION' AND NOT v_is_canonical THEN

        v_access_authorized := FALSE;



        -- Log violation

        INSERT INTO fhq_meta.canonical_violation_log (

            violation_type, discrepancy_class, severity_score,

            domain_name, conflicting_stores, conflict_description,

            detected_by, detection_method, vega_escalated

        ) VALUES (

            'NON_CANONICAL_READ', 'CLASS_B', 0.50,

            p_domain_name, ARRAY[p_target_store, v_canonical_store],

            format('Agent %s attempted to read from non-canonical store %s instead of %s',

                   p_agent_id, p_target_store, v_canonical_store),

            'CANONICAL_ACCESS_GUARD', 'ACCESS_GUARD', TRUE

        );

    END IF;



    -- Log all access

    INSERT INTO fhq_meta.canonical_access_log (

        agent_id, operation_type, domain_name, canonical_store,

        access_context, access_authorized, bypass_attempted, vega_notified

    ) VALUES (

        p_agent_id, p_operation_type, p_domain_name, p_target_store,

        p_access_context, v_access_authorized, NOT v_is_canonical, NOT v_is_canonical

    );



    RETURN v_access_authorized;

END;

$$;


--
-- Name: FUNCTION validate_canonical_access(p_agent_id text, p_domain_name text, p_target_store text, p_operation_type text, p_access_context text); Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON FUNCTION fhq_meta.validate_canonical_access(p_agent_id text, p_domain_name text, p_target_store text, p_operation_type text, p_access_context text) IS 'ADR-013: Validates access is to canonical store. Logs violations.';


--
-- Name: validate_lsa_inheritance(text, text); Type: FUNCTION; Schema: fhq_meta; Owner: -
--

CREATE FUNCTION fhq_meta.validate_lsa_inheritance(p_predecessor_batch text, p_expected_hash text) RETURNS TABLE(is_valid boolean, violation_type text, lsa_id uuid, actual_hash text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_lsa RECORD;
BEGIN
    -- Find predecessor LSA
    SELECT * INTO v_lsa
    FROM fhq_meta.learning_state_artifacts
    WHERE batch_id = p_predecessor_batch
    AND is_canonical = TRUE;

    -- Check: Missing LSA
    IF v_lsa IS NULL THEN
        RETURN QUERY SELECT
            FALSE::BOOLEAN,
            'MISSING_LSA'::TEXT,
            NULL::UUID,
            NULL::TEXT;
        RETURN;
    END IF;

    -- Check: Hash mismatch
    IF v_lsa.content_hash != p_expected_hash THEN
        RETURN QUERY SELECT
            FALSE::BOOLEAN,
            'HASH_MISMATCH'::TEXT,
            v_lsa.lsa_id,
            v_lsa.content_hash;
        RETURN;
    END IF;

    -- Valid inheritance
    RETURN QUERY SELECT
        TRUE::BOOLEAN,
        NULL::TEXT,
        v_lsa.lsa_id,
        v_lsa.content_hash;
END;
$$;


--
-- Name: vega_daily_integrity_check(); Type: FUNCTION; Schema: fhq_meta; Owner: -
--

CREATE FUNCTION fhq_meta.vega_daily_integrity_check() RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$

DECLARE

    v_result JSONB;

    v_start TIMESTAMPTZ := NOW();

    v_adr_count INTEGER;

    v_orphan_count INTEGER;

    v_hash_mismatches INTEGER := 0;

    v_class_a INTEGER := 0;

    v_class_b INTEGER := 0;

    v_class_c INTEGER := 0;

    v_status VARCHAR(20) := 'HEALTHY';

BEGIN

    -- Count approved ADRs

    SELECT COUNT(*) INTO v_adr_count FROM fhq_meta.adr_registry WHERE adr_status = 'APPROVED';



    -- Check orphaned references

    SELECT COUNT(*) INTO v_orphan_count

    FROM fhq_meta.vega_identity vi

    WHERE NOT EXISTS (

        SELECT 1 FROM fhq_meta.adr_registry ar WHERE ar.adr_id = ANY(vi.governing_adrs)

    );



    -- Check for attestations with missing/empty function_hash (correct column name)

    SELECT COUNT(*) INTO v_hash_mismatches

    FROM fhq_meta.vega_attestations

    WHERE function_hash IS NULL OR function_hash = '' OR hash_verified = FALSE;



    -- Determine status based on findings

    IF v_orphan_count > 0 OR v_hash_mismatches > 0 THEN

        v_class_b := v_orphan_count + v_hash_mismatches;

        v_status := 'WARNING';

    END IF;



    v_result := jsonb_build_object(

        'check_type', 'DAILY_INTEGRITY',

        'timestamp', v_start,

        'adr_count', v_adr_count,

        'orphan_references', v_orphan_count,

        'hash_mismatches', v_hash_mismatches,

        'class_a_events', v_class_a,

        'class_b_events', v_class_b,

        'class_c_events', v_class_c,

        'status', v_status,

        'execution_ms', EXTRACT(MILLISECONDS FROM (NOW() - v_start))::INTEGER

    );



    -- Log to monitoring

    INSERT INTO fhq_monitoring.system_event_log (event_type, description, metadata, executed_by)

    VALUES ('DAILY_INTEGRITY_CHECK', 'VEGA daily integrity check completed', v_result, 'VEGA');



    RETURN v_result;

EXCEPTION WHEN OTHERS THEN

    v_result := jsonb_build_object('error', SQLERRM, 'status', 'ERROR');

    INSERT INTO fhq_monitoring.system_event_log (event_type, description, metadata, executed_by)

    VALUES ('DAILY_INTEGRITY_CHECK', 'VEGA daily integrity check failed', v_result, 'VEGA');

    RETURN v_result;

END;

$$;


--
-- Name: vega_monthly_snapshot(); Type: FUNCTION; Schema: fhq_meta; Owner: -
--

CREATE FUNCTION fhq_meta.vega_monthly_snapshot() RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$

DECLARE

    v_result JSONB;

    v_start TIMESTAMPTZ := NOW();

    v_snapshot_id VARCHAR(100);

    v_snapshot_hash VARCHAR(64);

    v_adr_snapshot JSONB;

    v_governance_snapshot JSONB;

    v_status VARCHAR(20) := 'SNAPSHOT_COMPLETE';

    v_adr RECORD;

BEGIN

    v_snapshot_id := 'SNAP-' || TO_CHAR(NOW(), 'YYYYMM-DD-HH24MISS');



    SELECT jsonb_agg(jsonb_build_object(

        'adr_id', adr_id, 'title', adr_title, 'status', adr_status, 'version', current_version

    )) INTO v_adr_snapshot FROM fhq_meta.adr_registry;



    v_governance_snapshot := jsonb_build_object(

        'vega_status', (SELECT status FROM fhq_meta.vega_identity WHERE agent_name = 'VEGA'),

        'contract_status', (SELECT status FROM fhq_meta.vega_employment_contract WHERE contract_number = 'EC-001'),

        'duties_count', (SELECT COUNT(*) FROM fhq_meta.vega_constitutional_duties),

        'constraints_count', (SELECT COUNT(*) FROM fhq_meta.vega_constraints),

        'rights_count', (SELECT COUNT(*) FROM fhq_meta.vega_rights)

    );



    v_snapshot_hash := encode(sha256((v_adr_snapshot::text || v_governance_snapshot::text)::bytea), 'hex');



    -- Record version history using correct columns: adr_id, version, change_summary, sha256_hash, approved_by

    FOR v_adr IN SELECT adr_id, adr_title, current_version, sha256_hash FROM fhq_meta.adr_registry LOOP

        INSERT INTO fhq_meta.adr_version_history (adr_id, version, change_summary, sha256_hash, approved_by)

        VALUES (v_adr.adr_id, v_adr.current_version, 'VEGA monthly snapshot', COALESCE(v_adr.sha256_hash, v_snapshot_hash), 'VEGA')

        ON CONFLICT (adr_id, version) DO NOTHING;

    END LOOP;



    v_result := jsonb_build_object(

        'check_type', 'MONTHLY_SNAPSHOT',

        'snapshot_id', v_snapshot_id,

        'timestamp', v_start,

        'adr_count', (SELECT COUNT(*) FROM fhq_meta.adr_registry),

        'governance_snapshot', v_governance_snapshot,

        'snapshot_hash', v_snapshot_hash,

        'status', v_status,

        'execution_ms', EXTRACT(MILLISECONDS FROM (NOW() - v_start))::INTEGER

    );



    INSERT INTO fhq_monitoring.system_event_log (event_type, description, metadata, executed_by)

    VALUES ('MONTHLY_SNAPSHOT', 'VEGA monthly snapshot completed', v_result, 'VEGA');



    RETURN v_result;

EXCEPTION WHEN OTHERS THEN

    v_result := jsonb_build_object('error', SQLERRM, 'status', 'ERROR');

    INSERT INTO fhq_monitoring.system_event_log (event_type, description, metadata, executed_by)

    VALUES ('MONTHLY_SNAPSHOT', 'VEGA monthly snapshot failed', v_result, 'VEGA');

    RETURN v_result;

END;

$$;


--
-- Name: vega_weekly_reconciliation(); Type: FUNCTION; Schema: fhq_meta; Owner: -
--

CREATE FUNCTION fhq_meta.vega_weekly_reconciliation() RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$

DECLARE

    v_result JSONB;

    v_start TIMESTAMPTZ := NOW();

    v_registry_count INTEGER;

    v_version_count INTEGER;

    v_missing_versions INTEGER;

    v_cert_count INTEGER;

    v_pending_certs INTEGER;

    v_status VARCHAR(20) := 'RECONCILED';

BEGIN

    SELECT COUNT(*) INTO v_registry_count FROM fhq_meta.adr_registry;

    SELECT COUNT(*) INTO v_version_count FROM fhq_meta.adr_version_history;



    SELECT COUNT(*) INTO v_missing_versions

    FROM fhq_meta.adr_registry ar

    WHERE NOT EXISTS (SELECT 1 FROM fhq_meta.adr_version_history vh WHERE vh.adr_id = ar.adr_id);



    SELECT COUNT(*), COUNT(*) FILTER (WHERE certification_status = 'PENDING')

    INTO v_cert_count, v_pending_certs FROM fhq_meta.model_certifications;



    IF v_missing_versions > 0 THEN v_status := 'REQUIRES_ACTION'; END IF;



    v_result := jsonb_build_object(

        'check_type', 'WEEKLY_RECONCILIATION',

        'timestamp', v_start,

        'registry_entries', v_registry_count,

        'version_history_entries', v_version_count,

        'adrs_missing_versions', v_missing_versions,

        'total_certifications', v_cert_count,

        'pending_certifications', v_pending_certs,

        'status', v_status,

        'execution_ms', EXTRACT(MILLISECONDS FROM (NOW() - v_start))::INTEGER

    );



    INSERT INTO fhq_monitoring.system_event_log (event_type, description, metadata, executed_by)

    VALUES ('WEEKLY_RECONCILIATION', 'VEGA weekly reconciliation completed', v_result, 'VEGA');



    RETURN v_result;

EXCEPTION WHEN OTHERS THEN

    v_result := jsonb_build_object('error', SQLERRM, 'status', 'ERROR');

    INSERT INTO fhq_monitoring.system_event_log (event_type, description, metadata, executed_by)

    VALUES ('WEEKLY_RECONCILIATION', 'VEGA weekly reconciliation failed', v_result, 'VEGA');

    RETURN v_result;

END;

$$;


--
-- Name: attest_function_integrity(text, text); Type: FUNCTION; Schema: vega; Owner: -
--

CREATE FUNCTION vega.attest_function_integrity(p_task_name text, p_attesting_agent text DEFAULT 'LARS'::text) RETURNS TABLE(attestation_status text, attestation_rationale text, function_hash text, signature text, attestation_id uuid)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$

DECLARE

    v_task RECORD;

    v_function RECORD;

    v_agent_key RECORD;

    v_computed_hash TEXT;

    v_registry_hash TEXT;

    v_status TEXT := 'APPROVED';

    v_rationale TEXT := '';

    v_hash_match BOOLEAN := TRUE;

    v_agent_verified BOOLEAN := TRUE;

    v_gate_verified BOOLEAN := TRUE;

    v_signature_verified BOOLEAN := TRUE;

    v_new_attestation_id UUID;  -- FIXED: Renamed from v_attestation_id

    v_governance_log_id UUID;

    v_signature_payload TEXT;

    v_ed25519_signature TEXT;

    v_evidence JSONB;

    v_gate_result RECORD;

BEGIN

    -- =====================================================

    -- STEP 1: Verify task exists and get details

    -- =====================================================



    SELECT * INTO v_task

    FROM fhq_governance.task_registry

    WHERE task_name = p_task_name;



    IF v_task IS NULL THEN

        RETURN QUERY SELECT

            'BLOCKED'::TEXT,

            'Task not found in governance registry'::TEXT,

            NULL::TEXT,

            NULL::TEXT,

            NULL::UUID;

        RETURN;

    END IF;



    -- =====================================================

    -- STEP 2: Get function from registry

    -- =====================================================



    SELECT * INTO v_function

    FROM fhq_meta.function_registry

    WHERE task_name = p_task_name

    LIMIT 1;



    IF v_function IS NULL THEN

        v_status := 'BLOCKED';

        v_rationale := v_rationale || 'Function not found in function_registry. ';

        v_hash_match := FALSE;

    ELSE

        v_registry_hash := v_function.canonical_hash;

    END IF;



    -- =====================================================

    -- STEP 3: Verify attesting agent has signing key

    -- =====================================================



    SELECT * INTO v_agent_key

    FROM fhq_meta.agent_keys

    WHERE agent_name = p_attesting_agent

      AND key_status = 'ACTIVE'

      AND key_type = 'Ed25519';



    IF v_agent_key IS NULL THEN

        v_status := 'BLOCKED';

        v_rationale := v_rationale || 'Attesting agent has no ACTIVE Ed25519 key. ';

        v_agent_verified := FALSE;

    END IF;



    -- =====================================================

    -- STEP 4: Verify QG-F6 gate status

    -- =====================================================



    SELECT * INTO v_gate_result

    FROM vega.evaluate_qg_f6_gate(

        p_agent_name := p_attesting_agent,

        p_task_name := p_task_name,

        p_estimated_cost := 0.0

    );



    IF v_gate_result.gate_status != 'PASS' THEN

        v_status := 'BLOCKED';

        v_rationale := v_rationale || format('QG-F6 gate failed: %s. ', v_gate_result.gate_rationale);

        v_gate_verified := FALSE;

    END IF;



    -- =====================================================

    -- STEP 5: Compute current function hash and compare

    -- =====================================================



    IF v_function IS NOT NULL THEN

        -- Get current hash from database

        SELECT canonical_hash INTO v_computed_hash

        FROM vega.compute_function_hash(

            v_function.function_schema,

            v_function.function_name

        );



        -- Compare hashes

        IF v_computed_hash != v_registry_hash THEN

            v_status := 'BLOCKED';

            v_rationale := v_rationale || format(

                'Hash mismatch: computed=%s, registry=%s. ',

                LEFT(v_computed_hash, 16),

                LEFT(v_registry_hash, 16)

            );

            v_hash_match := FALSE;

        END IF;

    END IF;



    -- =====================================================

    -- STEP 6: Finalize rationale

    -- =====================================================



    IF v_status = 'APPROVED' THEN

        v_rationale := format(

            'Function %s attested successfully. Hash verified: %s. Agent: %s with key %s. QG-F6: PASS.',

            p_task_name,

            LEFT(v_computed_hash, 16),

            p_attesting_agent,

            v_agent_key.key_id

        );

    END IF;



    -- =====================================================

    -- STEP 7: Generate signature payload

    -- =====================================================



    v_signature_payload := format(

        'VEGA_ATTESTATION|%s|%s|%s|%s|%s',

        p_task_name,

        v_status,

        COALESCE(v_computed_hash, 'NONE'),

        p_attesting_agent,

        NOW()::TEXT

    );



    -- NOTE: In production, this would call actual Ed25519 signing

    -- For now, we generate a deterministic "signature" hash

    v_ed25519_signature := encode(digest(v_signature_payload || v_agent_key.public_key, 'sha256'), 'hex');



    -- =====================================================

    -- STEP 8: Build evidence bundle

    -- =====================================================



    v_evidence := jsonb_build_object(

        'task_name', p_task_name,

        'function_schema', COALESCE(v_function.function_schema, 'UNKNOWN'),

        'function_name', COALESCE(v_function.function_name, 'UNKNOWN'),

        'computed_hash', COALESCE(v_computed_hash, 'NONE'),

        'registry_hash', COALESCE(v_registry_hash, 'NONE'),

        'hash_match', v_hash_match,

        'agent_verified', v_agent_verified,

        'gate_verified', v_gate_verified,

        'attesting_agent', p_attesting_agent,

        'agent_key_id', v_agent_key.key_id,

        'qg_f6_status', v_gate_result.gate_status,

        'attestation_timestamp', NOW()

    );



    -- =====================================================

    -- STEP 9: Log to governance

    -- =====================================================



    INSERT INTO fhq_governance.governance_actions_log (

        action_type,

        action_target,

        action_target_type,

        initiated_by,

        decision,

        decision_rationale,

        vega_reviewed,

        hash_chain_id,

        signature_id

    ) VALUES (

        'VEGA_ATTESTATION',

        p_task_name,

        'FUNCTION',

        p_attesting_agent,

        v_status, -- APPROVED or BLOCKED

        v_rationale,

        TRUE,

        encode(digest(v_signature_payload, 'sha256'), 'hex'),

        gen_random_uuid()

    ) RETURNING action_id INTO v_governance_log_id;



    -- =====================================================

    -- STEP 10: Create attestation record

    -- =====================================================



    INSERT INTO fhq_meta.vega_attestations (

        attestation_type,

        attestation_target,

        attestation_status,

        attestation_rationale,

        hash_verified,

        agent_verified,

        gate_verified,

        signature_verified,

        function_hash,

        expected_hash,

        hash_match,

        attested_by,

        attesting_agent,

        vega_key_id,

        signature_payload,

        ed25519_signature,

        evidence_bundle,

        hash_chain_id,

        governance_log_id

    ) VALUES (

        'FUNCTION',

        p_task_name,

        v_status,

        v_rationale,

        v_hash_match,

        v_agent_verified,

        v_gate_verified,

        v_signature_verified,

        v_computed_hash,

        v_registry_hash,

        v_hash_match,

        'VEGA',

        p_attesting_agent,

        v_agent_key.key_id,

        v_signature_payload,

        v_ed25519_signature,

        v_evidence,

        encode(digest(v_signature_payload, 'sha256'), 'hex'),

        v_governance_log_id

    ) RETURNING fhq_meta.vega_attestations.attestation_id INTO v_new_attestation_id;  -- FIXED: Qualified column reference



    -- =====================================================

    -- STEP 11: Update task registry with attestation

    -- =====================================================



    UPDATE fhq_governance.task_registry

    SET

        vega_reviewed = TRUE,

        vega_reviewed_at = NOW(),

        vega_attestation_id = v_new_attestation_id,  -- FIXED: Use new variable name

        reviewed_signature = v_ed25519_signature,

        updated_at = NOW()

    WHERE task_name = p_task_name;



    -- =====================================================

    -- STEP 12: Update function registry if hash verified

    -- =====================================================



    IF v_hash_match THEN

        UPDATE fhq_meta.function_registry

        SET

            hash_verified = TRUE,

            hash_verified_at = NOW(),

            registry_status = 'ACTIVE',

            last_drift_check = NOW(),

            drift_detected = FALSE,

            updated_at = NOW()

        WHERE task_name = p_task_name;

    ELSE

        UPDATE fhq_meta.function_registry

        SET

            hash_verified = FALSE,

            last_drift_check = NOW(),

            drift_detected = TRUE,

            drift_details = v_rationale,

            registry_status = 'COMPROMISED',

            updated_at = NOW()

        WHERE task_name = p_task_name;

    END IF;



    -- =====================================================

    -- STEP 13: Return result

    -- =====================================================



    RETURN QUERY SELECT

        v_status,

        v_rationale,

        v_computed_hash,

        v_ed25519_signature,

        v_new_attestation_id;  -- FIXED: Use new variable name

END;

$$;


--
-- Name: FUNCTION attest_function_integrity(p_task_name text, p_attesting_agent text); Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON FUNCTION vega.attest_function_integrity(p_task_name text, p_attesting_agent text) IS 'VEGA attestation pipeline with Ed25519 signing per ADR-006, ADR-008, ADR-011. Verifies function integrity, agent authority, and economic safety before issuing attestation.';


--
-- Name: check_qg_f6(); Type: FUNCTION; Schema: vega; Owner: -
--

CREATE FUNCTION vega.check_qg_f6() RETURNS TABLE(gate_passed boolean, rate_violations integer, cost_violations integer, execution_violations integer, last_violation_at timestamp with time zone, check_timestamp timestamp with time zone)
    LANGUAGE plpgsql
    AS $$

BEGIN

    RETURN QUERY

    WITH violation_counts AS (

        SELECT

            SUM(CASE WHEN violation_type = 'RATE' THEN 1 ELSE 0 END)::INTEGER AS rate_v,

            SUM(CASE WHEN violation_type = 'COST' THEN 1 ELSE 0 END)::INTEGER AS cost_v,

            SUM(CASE WHEN violation_type = 'EXECUTION' THEN 1 ELSE 0 END)::INTEGER AS exec_v,

            MAX(timestamp) AS last_v

        FROM vega.llm_violation_events

        WHERE timestamp > NOW() - INTERVAL '24 hours'

            AND is_resolved = FALSE

    )

    SELECT

        (COALESCE(rate_v, 0) = 0 AND COALESCE(cost_v, 0) = 0 AND COALESCE(exec_v, 0) = 0) AS gate_passed,

        COALESCE(rate_v, 0) AS rate_violations,

        COALESCE(cost_v, 0) AS cost_violations,

        COALESCE(exec_v, 0) AS execution_violations,

        last_v AS last_violation_at,

        NOW() AS check_timestamp

    FROM violation_counts;

END;

$$;


--
-- Name: FUNCTION check_qg_f6(); Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON FUNCTION vega.check_qg_f6() IS 'ADR-012 Section 6: QG-F6 Economic Safety Gate check';


--
-- Name: compute_function_hash(text, text); Type: FUNCTION; Schema: vega; Owner: -
--

CREATE FUNCTION vega.compute_function_hash(p_schema text, p_function_name text) RETURNS TABLE(function_signature text, canonical_hash text, function_definition text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$

DECLARE

    v_prosrc TEXT;

    v_proargnames TEXT[];

    v_proargtypes TEXT;

    v_signature TEXT;

    v_hash TEXT;

BEGIN

    -- Get function definition from pg_catalog

    SELECT

        p.prosrc,

        p.proargnames,

        pg_get_function_arguments(p.oid),

        format('%s.%s(%s)', n.nspname, p.proname, pg_get_function_arguments(p.oid))

    INTO

        v_prosrc,

        v_proargnames,

        v_proargtypes,

        v_signature

    FROM pg_proc p

    JOIN pg_namespace n ON p.pronamespace = n.oid

    WHERE n.nspname = p_schema

      AND p.proname = p_function_name

    LIMIT 1;



    IF v_prosrc IS NULL THEN

        RAISE EXCEPTION 'Function %.% not found', p_schema, p_function_name;

    END IF;



    -- Compute SHA-256 hash of function source

    v_hash := encode(digest(v_prosrc, 'sha256'), 'hex');



    RETURN QUERY SELECT

        v_signature,

        v_hash,

        v_prosrc;

END;

$$;


--
-- Name: FUNCTION compute_function_hash(p_schema text, p_function_name text); Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON FUNCTION vega.compute_function_hash(p_schema text, p_function_name text) IS 'Computes SHA-256 hash of function definition for integrity verification (ADR-011)';


--
-- Name: compute_violation_hash(bigint, character varying, character varying, character varying, timestamp with time zone, jsonb, character varying); Type: FUNCTION; Schema: vega; Owner: -
--

CREATE FUNCTION vega.compute_violation_hash(p_violation_id bigint, p_agent_id character varying, p_violation_type character varying, p_governance_action character varying, p_timestamp timestamp with time zone, p_details jsonb, p_hash_prev character varying) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE
    AS $$

DECLARE

    v_payload TEXT;

BEGIN

    v_payload := p_violation_id::TEXT || '|' ||

                 COALESCE(p_agent_id, 'NULL') || '|' ||

                 p_violation_type || '|' ||

                 p_governance_action || '|' ||

                 p_timestamp::TEXT || '|' ||

                 p_details::TEXT || '|' ||

                 COALESCE(p_hash_prev, 'GENESIS');



    RETURN encode(sha256(v_payload::bytea), 'hex');

END;

$$;


--
-- Name: FUNCTION compute_violation_hash(p_violation_id bigint, p_agent_id character varying, p_violation_type character varying, p_governance_action character varying, p_timestamp timestamp with time zone, p_details jsonb, p_hash_prev character varying); Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON FUNCTION vega.compute_violation_hash(p_violation_id bigint, p_agent_id character varying, p_violation_type character varying, p_governance_action character varying, p_timestamp timestamp with time zone, p_details jsonb, p_hash_prev character varying) IS 'ADR-012/ADR-011: Compute SHA-256 hash for violation event chain';


--
-- Name: evaluate_action_request(text, text, jsonb, numeric); Type: FUNCTION; Schema: vega; Owner: -
--

CREATE FUNCTION vega.evaluate_action_request(p_requesting_agent text, p_action_type text, p_action_payload jsonb, p_risk_threshold numeric DEFAULT 0.7) RETURNS TABLE(veto_id uuid, decision text, risk_score numeric, reason text)
    LANGUAGE plpgsql
    AS $$

DECLARE

    v_veto_id UUID;

    v_risk_score NUMERIC;

    v_decision TEXT;

    v_reason TEXT;

    v_agent_tier INTEGER;

    v_can_trigger_g2 BOOLEAN;

    v_can_write_canonical BOOLEAN;

BEGIN

    -- Get agent authority

    SELECT authority_level, can_trigger_g2, can_write_canonical

    INTO v_agent_tier, v_can_trigger_g2, v_can_write_canonical

    FROM fhq_governance.authority_matrix

    WHERE agent_id = p_requesting_agent;



    -- Calculate risk score based on action type and agent tier

    v_risk_score := CASE

        -- High risk actions

        WHEN p_action_type IN ('canonical_write', 'schema_change', 'model_deploy') THEN 0.95

        WHEN p_action_type IN ('strategy_change', 'weight_modification') THEN 0.85

        WHEN p_action_type IN ('g2_trigger', 'g3_trigger', 'g4_trigger') THEN 0.90

        -- Medium risk actions

        WHEN p_action_type IN ('data_ingest', 'model_inference', 'report_generation') THEN 0.40

        WHEN p_action_type IN ('research_query', 'scenario_simulation') THEN 0.30

        -- Low risk actions

        WHEN p_action_type IN ('read_canonical', 'log_event', 'health_check') THEN 0.10

        ELSE 0.50

    END;



    -- Adjust risk based on agent tier

    IF v_agent_tier = 2 THEN

        v_risk_score := v_risk_score + 0.1;  -- Tier-2 agents get higher scrutiny

    END IF;



    -- Determine decision

    IF v_risk_score >= p_risk_threshold THEN

        -- Check if action violates authority

        IF p_action_type = 'canonical_write' AND NOT COALESCE(v_can_write_canonical, FALSE) THEN

            v_decision := 'BLOCKED';

            v_reason := 'Agent lacks canonical write authority (ADR-013 violation)';

        ELSIF p_action_type IN ('g2_trigger', 'g3_trigger', 'g4_trigger') AND NOT COALESCE(v_can_trigger_g2, FALSE) THEN

            v_decision := 'BLOCKED';

            v_reason := 'Agent lacks gate trigger authority (ADR-004 violation)';

        ELSE

            v_decision := 'RECLASSIFIED';

            v_reason := 'High-risk action requires elevated approval';

        END IF;

    ELSE

        v_decision := 'APPROVED';

        v_reason := 'Action within acceptable risk threshold';

    END IF;



    -- Record the veto decision

    INSERT INTO vega.action_level_veto (

        request_id, requesting_agent, action_type, action_payload,

        risk_score, veto_decision, reclassification_reason,

        vega_signature, decision_timestamp

    ) VALUES (

        gen_random_uuid(), p_requesting_agent, p_action_type, p_action_payload,

        v_risk_score, v_decision, v_reason,

        encode(sha256(('VEGA:' || p_requesting_agent || ':' || p_action_type || ':' || NOW()::text)::bytea), 'hex'),

        NOW()

    ) RETURNING action_level_veto.veto_id INTO v_veto_id;



    RETURN QUERY SELECT v_veto_id, v_decision, v_risk_score, v_reason;

END;

$$;


--
-- Name: evaluate_live_mode_readiness(); Type: FUNCTION; Schema: vega; Owner: -
--

CREATE FUNCTION vega.evaluate_live_mode_readiness() RETURNS TABLE(readiness_status text, readiness_reason text, qg_f6_status text, attestation_count integer, key_count integer, violation_count integer, class_a_count integer, pre_live_status text, recommendation text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$

DECLARE

    v_readiness_status TEXT;

    v_readiness_reason TEXT := '';

    v_qg_f6_status TEXT;

    v_attestation_count INTEGER;

    v_approved_attestation_count INTEGER;

    v_key_count INTEGER;

    v_active_key_count INTEGER;

    v_violation_count INTEGER;

    v_class_a_count INTEGER;

    v_pre_live_status TEXT;

    v_recommendation TEXT;

    v_blockers TEXT[] := ARRAY[]::TEXT[];

BEGIN

    -- Check QG-F6 status

    SELECT gate_status INTO v_qg_f6_status

    FROM vision_core.economic_safety_gate

    WHERE gate_name = 'QG-F6';



    IF v_qg_f6_status = 'FAIL' THEN

        v_blockers := array_append(v_blockers, 'QG-F6 gate is FAIL (must be PASS for LIVE MODE)');

    END IF;



    -- Check VEGA attestations

    SELECT COUNT(*) INTO v_attestation_count FROM fhq_meta.vega_attestations;

    SELECT COUNT(*) INTO v_approved_attestation_count

    FROM fhq_meta.vega_attestations

    WHERE attestation_status = 'APPROVED';



    IF v_approved_attestation_count < 3 THEN

        v_blockers := array_append(v_blockers,

            format('Insufficient approved attestations: %s/3', v_approved_attestation_count));

    END IF;



    -- Check agent keys

    SELECT COUNT(*) INTO v_key_count FROM fhq_meta.agent_keys;

    SELECT COUNT(*) INTO v_active_key_count

    FROM fhq_meta.agent_keys

    WHERE key_status = 'ACTIVE';



    IF v_active_key_count < 4 THEN

        v_blockers := array_append(v_blockers,

            format('Insufficient active keys: %s/4 agents', v_active_key_count));

    END IF;



    -- Check governance violations

    SELECT COUNT(*) INTO v_violation_count

    FROM fhq_governance.governance_actions_log

    WHERE decision NOT IN ('APPROVED', 'PASS');



    IF v_violation_count > 0 THEN

        v_blockers := array_append(v_blockers,

            format('Governance violations detected: %s', v_violation_count));

    END IF;



    -- Check Class-A safety events (table may not exist yet, default to 0)

    v_class_a_count := 0;

    BEGIN

        SELECT COUNT(*) INTO v_class_a_count

        FROM fhq_governance.safety_events

        WHERE event_class = 'CLASS_A'

        AND resolved_at IS NULL;

    EXCEPTION

        WHEN undefined_table THEN

            v_class_a_count := 0;

    END;



    IF v_class_a_count > 0 THEN

        v_blockers := array_append(v_blockers,

            format('Unresolved Class-A safety events: %s', v_class_a_count));

    END IF;



    -- Check pre-live validation status

    SELECT overall_status INTO v_pre_live_status

    FROM vision_validation.pre_live_suite('VEGA')

    WHERE check_id = 0

    LIMIT 1;



    IF v_pre_live_status != 'PASS' THEN

        v_blockers := array_append(v_blockers, 'Pre-live validation suite: ' || v_pre_live_status);

    END IF;



    -- Determine overall readiness

    IF array_length(v_blockers, 1) IS NULL OR array_length(v_blockers, 1) = 0 THEN

        v_readiness_status := 'READY';

        v_readiness_reason := 'All readiness checks passed. System is ready for LIVE MODE.';

        v_recommendation := 'AUTHORIZE_LIVE_MODE';

    ELSE

        v_readiness_status := 'NOT_READY';

        v_readiness_reason := array_to_string(v_blockers, '; ');

        v_recommendation := 'MAINTAIN_STUB_MODE';

    END IF;



    RETURN QUERY

    SELECT

        v_readiness_status,

        v_readiness_reason,

        v_qg_f6_status,

        v_attestation_count,

        v_key_count,

        v_violation_count,

        v_class_a_count,

        v_pre_live_status,

        v_recommendation;



END;

$$;


--
-- Name: evaluate_qg_f6_gate(text, text, numeric); Type: FUNCTION; Schema: vega; Owner: -
--

CREATE FUNCTION vega.evaluate_qg_f6_gate(p_agent_name text, p_task_name text DEFAULT NULL::text, p_estimated_cost numeric DEFAULT 0.0) RETURNS TABLE(gate_status text, gate_rationale text, violations_found integer, config_name text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$

DECLARE

    v_config RECORD;

    v_gate_status TEXT := 'PASS';

    v_rationale TEXT := '';

    v_violations INTEGER := 0;

    v_decision TEXT;  -- NEW: For mapping PASS/FAIL to APPROVED/REJECTED



    -- Current usage metrics

    v_agent_calls_last_minute INTEGER;

    v_agent_cost_today NUMERIC;

    v_global_cost_today NUMERIC;

BEGIN

    -- =====================================================

    -- 1. GET ACTIVE CONFIGURATION

    -- =====================================================



    SELECT * INTO v_config

    FROM vega.llm_economic_safety_config

    WHERE config_status = 'ACTIVE'

    ORDER BY created_at DESC

    LIMIT 1;



    IF v_config IS NULL THEN

        -- No active config = FAIL (safe default)

        RETURN QUERY SELECT

            'FAIL'::TEXT,

            'No ACTIVE economic safety configuration found - defaulting to FAIL'::TEXT,

            0,

            'NONE'::TEXT;

        RETURN;

    END IF;



    -- =====================================================

    -- 2. CHECK RATE LIMITING

    -- =====================================================



    SELECT COUNT(*) INTO v_agent_calls_last_minute

    FROM vega.llm_usage_log

    WHERE agent_name = p_agent_name

      AND request_timestamp >= NOW() - INTERVAL '1 minute';



    IF v_agent_calls_last_minute >= v_config.max_calls_per_agent_per_minute THEN

        v_gate_status := 'FAIL';

        v_rationale := v_rationale || format(

            'Rate limit exceeded: %s calls in last minute (max: %s). ',

            v_agent_calls_last_minute,

            v_config.max_calls_per_agent_per_minute

        );

        v_violations := v_violations + 1;



        -- Log violation

        INSERT INTO vega.llm_violation_events (

            agent_name, violation_type, current_value, threshold_value,

            config_name, task_name, action_taken

        ) VALUES (

            p_agent_name,

            'RATE_LIMIT_EXCEEDED',

            v_agent_calls_last_minute,

            v_config.max_calls_per_agent_per_minute,

            v_config.config_name,

            p_task_name,

            'BLOCKED'

        );

    END IF;



    -- =====================================================

    -- 3. CHECK COST PER TASK

    -- =====================================================



    IF p_estimated_cost > v_config.max_cost_per_task THEN

        v_gate_status := 'FAIL';

        v_rationale := v_rationale || format(

            'Task cost exceeds limit: $%s (max: $%s). ',

            p_estimated_cost,

            v_config.max_cost_per_task

        );

        v_violations := v_violations + 1;



        INSERT INTO vega.llm_violation_events (

            agent_name, violation_type, current_value, threshold_value,

            config_name, task_name, action_taken

        ) VALUES (

            p_agent_name,

            'COST_PER_TASK_EXCEEDED',

            p_estimated_cost,

            v_config.max_cost_per_task,

            v_config.config_name,

            p_task_name,

            'BLOCKED'

        );

    END IF;



    -- =====================================================

    -- 4. CHECK AGENT DAILY COST

    -- =====================================================



    SELECT COALESCE(SUM(cost_usd), 0) INTO v_agent_cost_today

    FROM vega.llm_usage_log

    WHERE agent_name = p_agent_name

      AND request_timestamp >= CURRENT_DATE;



    IF (v_agent_cost_today + p_estimated_cost) > v_config.max_agent_daily_cost THEN

        v_gate_status := 'FAIL';

        v_rationale := v_rationale || format(

            'Agent daily cost exceeds limit: $%s + $%s = $%s (max: $%s). ',

            v_agent_cost_today,

            p_estimated_cost,

            v_agent_cost_today + p_estimated_cost,

            v_config.max_agent_daily_cost

        );

        v_violations := v_violations + 1;



        INSERT INTO vega.llm_violation_events (

            agent_name, violation_type, current_value, threshold_value,

            config_name, task_name, action_taken

        ) VALUES (

            p_agent_name,

            'AGENT_DAILY_COST_EXCEEDED',

            v_agent_cost_today + p_estimated_cost,

            v_config.max_agent_daily_cost,

            v_config.config_name,

            p_task_name,

            'BLOCKED'

        );

    END IF;



    -- =====================================================

    -- 5. CHECK GLOBAL DAILY COST

    -- =====================================================



    SELECT COALESCE(SUM(cost_usd), 0) INTO v_global_cost_today

    FROM vega.llm_usage_log

    WHERE request_timestamp >= CURRENT_DATE;



    IF (v_global_cost_today + p_estimated_cost) > v_config.max_global_daily_cost THEN

        v_gate_status := 'FAIL';

        v_rationale := v_rationale || format(

            'Global daily cost exceeds limit: $%s + $%s = $%s (max: $%s). ',

            v_global_cost_today,

            p_estimated_cost,

            v_global_cost_today + p_estimated_cost,

            v_config.max_global_daily_cost

        );

        v_violations := v_violations + 1;



        INSERT INTO vega.llm_violation_events (

            agent_name, violation_type, current_value, threshold_value,

            config_name, task_name, action_taken

        ) VALUES (

            p_agent_name,

            'GLOBAL_DAILY_COST_EXCEEDED',

            v_global_cost_today + p_estimated_cost,

            v_config.max_global_daily_cost,

            v_config.config_name,

            p_task_name,

            'BLOCKED'

        );

    END IF;



    -- =====================================================

    -- 6. FINALIZE RATIONALE

    -- =====================================================



    IF v_gate_status = 'PASS' THEN

        v_rationale := format(

            'All checks passed for %s. Calls: %s/%s, Agent cost: $%s/$%s, Global cost: $%s/$%s',

            p_agent_name,

            v_agent_calls_last_minute,

            v_config.max_calls_per_agent_per_minute,

            v_agent_cost_today,

            v_config.max_agent_daily_cost,

            v_global_cost_today,

            v_config.max_global_daily_cost

        );

    END IF;



    -- =====================================================

    -- 7. MAP GATE STATUS TO GOVERNANCE DECISION

    -- FIXED: PASS/FAIL  APPROVED/REJECTED for CHECK constraint

    -- =====================================================



    v_decision := CASE

        WHEN v_gate_status = 'PASS' THEN 'APPROVED'

        WHEN v_gate_status = 'FAIL' THEN 'REJECTED'

        ELSE 'DEFERRED'

    END;



    -- =====================================================

    -- 8. LOG TO GOVERNANCE (CORRECTED)

    -- =====================================================



    INSERT INTO fhq_governance.governance_actions_log (

        action_type,

        action_target,

        action_target_type,

        initiated_by,

        decision,

        decision_rationale,

        vega_reviewed,

        hash_chain_id,

        signature_id

    ) VALUES (

        'GATE_EVALUATION',

        'QG-F6_ECONOMIC_SAFETY',

        'GATE',

        p_agent_name,

        v_decision,  -- FIXED: Now uses APPROVED/REJECTED instead of PASS/FAIL

        v_rationale,

        TRUE,

        encode(digest(v_gate_status || '|' || v_rationale || '|' || NOW()::TEXT, 'sha256'), 'hex'),

        gen_random_uuid()

    );



    -- =====================================================

    -- 9. RETURN RESULT (CORRECTED)

    -- =====================================================



    RETURN QUERY SELECT

        v_gate_status,

        v_rationale,

        v_violations,

        v_config.config_name;  -- FIXED: Return type now matches

END;

$_$;


--
-- Name: FUNCTION evaluate_qg_f6_gate(p_agent_name text, p_task_name text, p_estimated_cost numeric); Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON FUNCTION vega.evaluate_qg_f6_gate(p_agent_name text, p_task_name text, p_estimated_cost numeric) IS 'QG-F6 Economic Safety Gate - Validates LLM usage against safety thresholds (ADR-012). Returns PASS/FAIL gate_status, logs APPROVED/REJECTED to governance.';


--
-- Name: integrity_rehash(text); Type: FUNCTION; Schema: vega; Owner: -
--

CREATE FUNCTION vega.integrity_rehash(p_scope text DEFAULT 'FULL'::text) RETURNS TABLE(component text, old_hash text, new_hash text, status text)
    LANGUAGE plpgsql
    AS $$

DECLARE

    v_adr_hash TEXT;

    v_contract_hash TEXT;

    v_authority_hash TEXT;

    v_provider_hash TEXT;

BEGIN

    -- Hash ADR registry (using actual columns: adr_id, adr_title, sha256_hash)

    SELECT encode(sha256(string_agg(

        adr_id || ':' || COALESCE(adr_title, '') || ':' || COALESCE(sha256_hash, ''),

        '|' ORDER BY adr_id

    )::bytea), 'hex')

    INTO v_adr_hash

    FROM fhq_meta.adr_registry;



    -- Hash agent contracts (using actual columns: agent_id, contract_type, contract_status)

    SELECT encode(sha256(string_agg(

        agent_id || ':' || contract_type || ':' || contract_status,

        '|' ORDER BY agent_id

    )::bytea), 'hex')

    INTO v_contract_hash

    FROM fhq_governance.agent_contracts

    WHERE contract_status = 'ACTIVE';



    -- Hash authority matrix

    SELECT encode(sha256(string_agg(

        agent_id || ':' || authority_level::text || ':' ||

        can_write_canonical::text || ':' || can_trigger_g4::text,

        '|' ORDER BY agent_id

    )::bytea), 'hex')

    INTO v_authority_hash

    FROM fhq_governance.authority_matrix;



    -- Hash model provider policy

    SELECT encode(sha256(string_agg(

        agent_id || ':' || llm_tier::text || ':' || array_to_string(allowed_providers, ','),

        '|' ORDER BY agent_id

    )::bytea), 'hex')

    INTO v_provider_hash

    FROM fhq_governance.model_provider_policy;



    -- Return hash comparison

    RETURN QUERY

    SELECT 'ADR_REGISTRY'::TEXT,

           COALESCE((SELECT lock_hash FROM fhq_meta.baseline_locks WHERE lock_scope = 'ADR_REGISTRY' ORDER BY created_at DESC LIMIT 1), 'NONE'),

           COALESCE(v_adr_hash, 'EMPTY'),

           CASE WHEN v_adr_hash IS NULL THEN 'EMPTY'

                WHEN EXISTS (SELECT 1 FROM fhq_meta.baseline_locks WHERE lock_scope = 'ADR_REGISTRY' AND lock_hash = v_adr_hash) THEN 'MATCH'

                ELSE 'DRIFT' END;



    RETURN QUERY

    SELECT 'AGENT_CONTRACTS'::TEXT,

           COALESCE((SELECT lock_hash FROM fhq_meta.baseline_locks WHERE lock_scope = 'AGENT_CONTRACTS' ORDER BY created_at DESC LIMIT 1), 'NONE'),

           COALESCE(v_contract_hash, 'EMPTY'),

           CASE WHEN v_contract_hash IS NULL THEN 'EMPTY'

                WHEN EXISTS (SELECT 1 FROM fhq_meta.baseline_locks WHERE lock_scope = 'AGENT_CONTRACTS' AND lock_hash = v_contract_hash) THEN 'MATCH'

                ELSE 'DRIFT' END;



    RETURN QUERY

    SELECT 'AUTHORITY_MATRIX'::TEXT,

           COALESCE((SELECT lock_hash FROM fhq_meta.baseline_locks WHERE lock_scope = 'AUTHORITY_MATRIX' ORDER BY created_at DESC LIMIT 1), 'NONE'),

           COALESCE(v_authority_hash, 'EMPTY'),

           CASE WHEN v_authority_hash IS NULL THEN 'EMPTY'

                WHEN EXISTS (SELECT 1 FROM fhq_meta.baseline_locks WHERE lock_scope = 'AUTHORITY_MATRIX' AND lock_hash = v_authority_hash) THEN 'MATCH'

                ELSE 'DRIFT' END;



    RETURN QUERY

    SELECT 'MODEL_PROVIDER_POLICY'::TEXT,

           COALESCE((SELECT lock_hash FROM fhq_meta.baseline_locks WHERE lock_scope = 'MODEL_PROVIDER_POLICY' ORDER BY created_at DESC LIMIT 1), 'NONE'),

           COALESCE(v_provider_hash, 'EMPTY'),

           CASE WHEN v_provider_hash IS NULL THEN 'EMPTY'

                WHEN EXISTS (SELECT 1 FROM fhq_meta.baseline_locks WHERE lock_scope = 'MODEL_PROVIDER_POLICY' AND lock_hash = v_provider_hash) THEN 'MATCH'

                ELSE 'DRIFT' END;

END;

$$;


--
-- Name: latest_attestation(); Type: FUNCTION; Schema: vega; Owner: -
--

CREATE FUNCTION vega.latest_attestation() RETURNS TABLE(run_id uuid, run_timestamp timestamp with time zone, total_tests integer, tests_passed integer, tests_failed integer, status text, vega_attested boolean, vega_signature text, attestation_timestamp timestamp with time zone)
    LANGUAGE plpgsql
    AS $$

BEGIN

    RETURN QUERY

    SELECT

        tr.run_id,

        tr.run_timestamp,

        tr.total_tests,

        tr.tests_passed,

        tr.tests_failed,

        tr.run_status,

        tr.vega_attested,

        tr.vega_signature,

        tr.attestation_timestamp

    FROM vega.test_runs tr

    WHERE tr.vega_attested = TRUE

    ORDER BY tr.attestation_timestamp DESC

    LIMIT 1;

END;

$$;


--
-- Name: FUNCTION latest_attestation(); Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON FUNCTION vega.latest_attestation() IS 'ADR-011: Returns the most recent VEGA attestation';


--
-- Name: lock_baseline(text, text, text); Type: FUNCTION; Schema: vega; Owner: -
--

CREATE FUNCTION vega.lock_baseline(p_scope text, p_locked_by text DEFAULT 'VEGA'::text, p_attestation_token text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$

DECLARE

    v_lock_id UUID;

    v_hash TEXT;

BEGIN

    -- Calculate current hash based on scope (using actual column names)

    CASE p_scope

        WHEN 'ADR_REGISTRY' THEN

            SELECT encode(sha256(string_agg(

                adr_id || ':' || COALESCE(adr_title, '') || ':' || COALESCE(sha256_hash, ''),

                '|' ORDER BY adr_id

            )::bytea), 'hex') INTO v_hash FROM fhq_meta.adr_registry;

        WHEN 'AGENT_CONTRACTS' THEN

            SELECT encode(sha256(string_agg(

                agent_id || ':' || contract_type || ':' || contract_status,

                '|' ORDER BY agent_id

            )::bytea), 'hex') INTO v_hash FROM fhq_governance.agent_contracts WHERE contract_status = 'ACTIVE';

        WHEN 'AUTHORITY_MATRIX' THEN

            SELECT encode(sha256(string_agg(

                agent_id || ':' || authority_level::text || ':' || can_write_canonical::text,

                '|' ORDER BY agent_id

            )::bytea), 'hex') INTO v_hash FROM fhq_governance.authority_matrix;

        WHEN 'MODEL_PROVIDER_POLICY' THEN

            SELECT encode(sha256(string_agg(

                agent_id || ':' || llm_tier::text,

                '|' ORDER BY agent_id

            )::bytea), 'hex') INTO v_hash FROM fhq_governance.model_provider_policy;

        ELSE

            RAISE EXCEPTION 'Unknown scope: %', p_scope;

    END CASE;



    -- Insert new baseline lock

    INSERT INTO fhq_meta.baseline_locks (

        lock_type, lock_scope, lock_hash, locked_by, attestation_token

    ) VALUES (

        'GOVERNANCE', p_scope, COALESCE(v_hash, 'EMPTY'), p_locked_by, p_attestation_token

    ) RETURNING lock_id INTO v_lock_id;



    RETURN v_lock_id;

END;

$$;


--
-- Name: review_live_mode_proposal(uuid, text, text, text); Type: FUNCTION; Schema: vega; Owner: -
--

CREATE FUNCTION vega.review_live_mode_proposal(p_proposal_id uuid, p_decision text, p_rationale text, p_calling_agent text DEFAULT 'VEGA'::text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$

DECLARE

    v_review_id UUID;

    v_proposal_status TEXT;

    v_readiness_status TEXT;

    v_integrity_ok BOOLEAN;

    v_attestations_ok BOOLEAN;

    v_keys_ok BOOLEAN;

    v_governance_ok BOOLEAN;

    v_hash_input TEXT;

    v_hash TEXT;

    v_key_id TEXT;

BEGIN

    -- Only VEGA can review

    IF p_calling_agent != 'VEGA' THEN

        RAISE EXCEPTION 'Only VEGA can review LIVE MODE proposals';

    END IF;



    -- Validate decision

    IF p_decision NOT IN ('APPROVE', 'REJECT', 'REQUEST_CHANGES') THEN

        RAISE EXCEPTION 'Invalid decision. Must be APPROVE, REJECT, or REQUEST_CHANGES';

    END IF;



    -- Get proposal details

    SELECT proposal_status, readiness_status

    INTO v_proposal_status, v_readiness_status

    FROM vision_core.live_mode_proposals

    WHERE proposal_id = p_proposal_id;



    IF v_proposal_status IS NULL THEN

        RAISE EXCEPTION 'Proposal % not found', p_proposal_id;

    END IF;



    IF v_proposal_status != 'PENDING' THEN

        RAISE EXCEPTION 'Proposal % is not pending review (status: %)', p_proposal_id, v_proposal_status;

    END IF;



    -- Perform VEGA verification checks

    -- 1. Integrity check: All Phase-2 functions have valid hashes

    SELECT COUNT(*) = COUNT(*) FILTER (WHERE hash_verified = TRUE)

    INTO v_integrity_ok

    FROM fhq_meta.function_registry

    WHERE function_name IN ('calculate_signal_baseline', 'estimate_noise_floor', 'sync_meta_state')

      AND registry_status = 'ACTIVE';



    -- 2. Attestations check: All Phase-2 functions are attested

    SELECT

        (SELECT COUNT(*) FROM fhq_meta.function_registry WHERE registry_status = 'ACTIVE') =

        (SELECT COUNT(*) FROM fhq_meta.vega_attestations WHERE attestation_status = 'VALID')

    INTO v_attestations_ok;



    -- 3. Keys check: All 4 agents have active keys

    SELECT COUNT(*) >= 4

    INTO v_keys_ok

    FROM fhq_meta.agent_keys

    WHERE key_status = 'ACTIVE' AND key_algorithm = 'Ed25519';



    -- 4. Governance check: No pending violations

    SELECT COUNT(*) = 0

    INTO v_governance_ok

    FROM vision_core.governance_actions_log

    WHERE decision = 'REJECT' AND initiated_at >= NOW() - INTERVAL '24 hours';



    -- Get VEGA key for signing

    SELECT key_id INTO v_key_id

    FROM fhq_meta.agent_keys

    WHERE agent_name = 'VEGA'

      AND key_status = 'ACTIVE'

    ORDER BY created_at DESC

    LIMIT 1;



    -- Compute hash

    v_hash_input := p_proposal_id::TEXT || p_decision || p_rationale || NOW()::TEXT;

    v_hash := encode(digest(v_hash_input, 'sha256'), 'hex');



    -- Create review

    INSERT INTO vision_core.live_mode_reviews (

        proposal_id,

        reviewed_by,

        review_decision,

        review_rationale,

        integrity_verified,

        attestations_verified,

        keys_verified,

        governance_verified,

        hash_chain_id,

        signature_id

    ) VALUES (

        p_proposal_id,

        p_calling_agent,

        p_decision,

        p_rationale,

        v_integrity_ok,

        v_attestations_ok,

        v_keys_ok,

        v_governance_ok,

        v_hash,

        v_key_id

    ) RETURNING review_id INTO v_review_id;



    -- Update proposal status

    UPDATE vision_core.live_mode_proposals

    SET

        proposal_status = CASE

            WHEN p_decision = 'APPROVE' THEN 'UNDER_REVIEW'

            WHEN p_decision = 'REJECT' THEN 'REJECTED'

            ELSE 'PENDING'

        END,

        updated_at = NOW()

    WHERE proposal_id = p_proposal_id;



    -- Log governance action

    INSERT INTO vision_core.governance_actions_log (

        action_type,

        action_target,

        initiated_by,

        decision,

        rationale,

        hash_chain_id,

        signature_id

    ) VALUES (

        'REVIEW_LIVE_MODE',

        p_proposal_id::TEXT,

        p_calling_agent,

        p_decision,

        p_rationale,

        v_hash,

        v_key_id

    );



    RAISE NOTICE 'VEGA review completed: % (Decision: %)', v_review_id, p_decision;



    RETURN v_review_id;

END;

$$;


--
-- Name: FUNCTION review_live_mode_proposal(p_proposal_id uuid, p_decision text, p_rationale text, p_calling_agent text); Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON FUNCTION vega.review_live_mode_proposal(p_proposal_id uuid, p_decision text, p_rationale text, p_calling_agent text) IS 'ADR-012: VEGA reviews LIVE MODE proposal. Performs comprehensive verification and signs decision.';


--
-- Name: review_pre_live_validation(text); Type: FUNCTION; Schema: vega; Owner: -
--

CREATE FUNCTION vega.review_pre_live_validation(p_calling_agent text DEFAULT 'VEGA'::text) RETURNS TABLE(review_id uuid, validation_status text, vega_verdict text, attestation_status text, attestation_id uuid, review_rationale text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$

DECLARE

    v_review_id UUID := gen_random_uuid();

    v_validation_status TEXT;

    v_vega_verdict TEXT;

    v_attestation_status TEXT;

    v_attestation_id UUID;

    v_review_rationale TEXT;

    v_checks_passed INTEGER;

    v_checks_total INTEGER;

    v_execution_start TIMESTAMP := clock_timestamp();

    v_governance_hash TEXT;

    v_signature_id UUID;

    v_lars_key_id TEXT;

BEGIN

    -- Get LARS agent key for signing (LARS signs all operations)

    SELECT key_id INTO v_lars_key_id

    FROM fhq_meta.agent_keys

    WHERE agent_name = 'LARS' AND key_status = 'ACTIVE'

    LIMIT 1;



    -- Execute pre-live validation suite

    SELECT overall_status INTO v_validation_status

    FROM vision_validation.pre_live_suite(p_calling_agent)

    WHERE check_id = 0

    LIMIT 1;



    -- Count passed checks

    SELECT

        COUNT(*) FILTER (WHERE check_status = 'PASS'),

        COUNT(*)

    INTO v_checks_passed, v_checks_total

    FROM vision_validation.pre_live_suite(p_calling_agent)

    WHERE check_id > 0;



    -- VEGA renders verdict

    IF v_validation_status = 'PASS' THEN

        v_vega_verdict := 'APPROVED';

        v_attestation_status := 'APPROVED';

        v_review_rationale := format('Pre-live validation PASSED: %s/%s checks successful. System ready for LIVE MODE consideration.',

                                     v_checks_passed, v_checks_total);

    ELSE

        v_vega_verdict := 'BLOCKED';

        v_attestation_status := 'BLOCKED';  -- Must be APPROVED, BLOCKED, CONDITIONAL, or REVOKED

        v_review_rationale := format('Pre-live validation BLOCKED: %s/%s checks passed. LIVE MODE authorization denied.',

                                     v_checks_passed, v_checks_total);

    END IF;



    -- Generate governance hash (before INSERT so we can use it)

    v_governance_hash := encode(

        digest(

            'VEGA_PRE_LIVE_REVIEW' ||

            v_vega_verdict ||

            v_review_id::TEXT ||

            v_execution_start::TEXT,

            'sha256'

        ),

        'hex'

    );



    -- Create VEGA attestation

    INSERT INTO fhq_meta.vega_attestations (

        attestation_target,

        attestation_type,

        attestation_status,

        attested_by,

        attestation_rationale,

        hash_verified,

        agent_verified,

        gate_verified,

        signature_verified,

        signature_payload,

        ed25519_signature,

        hash_chain_id

    ) VALUES (

        'vision_validation.pre_live_suite',

        'FUNCTION',  -- attestation_type must be FUNCTION, SCHEMA, CONFIGURATION, or MIGRATION

        v_attestation_status,

        'VEGA',

        v_review_rationale,

        TRUE,   -- hash_verified: validation includes hash chain checks

        TRUE,   -- agent_verified: LARS agent verified

        TRUE,   -- gate_verified: QG-F6 status checked

        FALSE,  -- signature_verified: STUB_SIGNATURE mode

        jsonb_build_object(

            'review_id', v_review_id::TEXT,

            'validation_status', v_validation_status,

            'verdict', v_vega_verdict,

            'validation_type', 'PRE_LIVE_VALIDATION',

            'timestamp', v_execution_start::TEXT

        )::TEXT,  -- signature_payload: what would be signed in LIVE MODE

        'STUB_SIGNATURE',  -- ed25519_signature: stub until LIVE MODE

        v_governance_hash  -- hash_chain_id: link to governance hash chain

    ) RETURNING fhq_meta.vega_attestations.attestation_id INTO v_attestation_id;



    -- Create operation signature

    INSERT INTO vision_verification.operation_signatures (

        operation_type,

        operation_id,

        operation_table,

        operation_schema,

        signing_agent,

        signing_key_id,

        signature_value,

        signed_payload,

        hash_chain_id

    ) VALUES (

        'VEGA_PRE_LIVE_REVIEW',

        v_review_id,

        'vega_attestations',

        'fhq_meta',

        'LARS',

        v_lars_key_id,

        'STUB_SIGNATURE',

        jsonb_build_object(

            'review_id', v_review_id::TEXT,

            'attestation_id', v_attestation_id::TEXT,

            'verdict', v_vega_verdict,

            'validation_status', v_validation_status,

            'hash', v_governance_hash

        ),

        v_governance_hash

    ) RETURNING signature_id INTO v_signature_id;



    -- Log to governance (map BLOCKED->REJECTED for constraint compliance)

    INSERT INTO fhq_governance.governance_actions_log (

        action_type,

        action_target,

        action_target_type,

        initiated_by,

        decision,

        decision_rationale,

        initiated_at,

        hash_chain_id,

        signature_id

    ) VALUES (

        'VEGA_PRE_LIVE_REVIEW',

        'vision_validation.pre_live_suite',

        'VALIDATION_SUITE',

        'VEGA',

        CASE WHEN v_vega_verdict = 'APPROVED' THEN 'APPROVED' ELSE 'REJECTED' END,

        v_review_rationale,

        v_execution_start,

        v_governance_hash,

        v_signature_id

    );



    RETURN QUERY

    SELECT

        v_review_id,

        v_validation_status,

        v_vega_verdict,

        v_attestation_status,

        v_attestation_id,

        v_review_rationale;



END;

$$;


--
-- Name: vega_validate_fortress_integrity(); Type: FUNCTION; Schema: vega; Owner: -
--

CREATE FUNCTION vega.vega_validate_fortress_integrity() RETURNS boolean
    LANGUAGE plpgsql
    AS $$

DECLARE

    latest_run RECORD;

    all_gates_pass BOOLEAN;

BEGIN

    -- Get latest attested run

    SELECT * INTO latest_run

    FROM vega.test_runs

    WHERE vega_attested = TRUE

    ORDER BY attestation_timestamp DESC

    LIMIT 1;



    IF latest_run IS NULL THEN

        RETURN FALSE;

    END IF;



    -- Check all quality gates passed

    SELECT NOT EXISTS (

        SELECT 1 FROM vega.quality_gate_results

        WHERE run_id = latest_run.run_id

          AND gate_status != 'PASS'

    ) INTO all_gates_pass;



    -- Return TRUE only if:

    -- 1. We have an attested run

    -- 2. All quality gates passed

    -- 3. No failures in the run

    RETURN latest_run.vega_attested

           AND all_gates_pass

           AND latest_run.tests_failed = 0;

END;

$$;


--
-- Name: FUNCTION vega_validate_fortress_integrity(); Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON FUNCTION vega.vega_validate_fortress_integrity() IS 'ADR-011: Validates Production Fortress integrity status';


--
-- Name: sync_meta_state(text, text); Type: FUNCTION; Schema: vision_autonomy; Owner: -
--

CREATE FUNCTION vision_autonomy.sync_meta_state(p_sync_type text DEFAULT 'INCREMENTAL'::text, p_calling_agent text DEFAULT 'LARS'::text) RETURNS TABLE(sync_id uuid, sync_status text, records_read integer, records_written integer, hash_chain_id text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$

DECLARE

    v_sync_id UUID;

    v_sync_status TEXT;

    v_records_read INTEGER := 0;

    v_records_written INTEGER := 0;

    v_records_failed INTEGER := 0;

    v_hash_chain_id TEXT;

    v_gate_status TEXT;

    v_signature_id UUID;

    v_baseline_count INTEGER;

    v_noise_count INTEGER;

    v_decision_count INTEGER;

BEGIN

    -- Economic Safety Check (ADR-012)

    SELECT gate_status INTO v_gate_status

    FROM vision_core.economic_safety_gate

    WHERE gate_name = 'QG-F6';



    IF v_gate_status != 'PASS' THEN

        RAISE NOTICE 'Economic safety gate QG-F6 is %. Function running in STUB MODE.', v_gate_status;

    END IF;



    -- Verify calling agent identity (ADR-002)

    -- Only LARS can perform meta-state sync

    IF p_calling_agent != 'LARS' THEN

        RAISE EXCEPTION 'Unauthorized agent: % cannot call sync_meta_state (LARS only)', p_calling_agent;

    END IF;



    -- Validate sync type

    IF p_sync_type NOT IN ('FULL', 'INCREMENTAL', 'RECONCILIATION') THEN

        RAISE EXCEPTION 'Invalid sync type: %. Must be FULL, INCREMENTAL, or RECONCILIATION', p_sync_type;

    END IF;



    -- Read from vision schemas (permitted)

    -- Count records that need syncing

    SELECT COUNT(*) INTO v_baseline_count

    FROM vision_signals.signal_baseline;



    SELECT COUNT(*) INTO v_noise_count

    FROM vision_core.noise_profile;



    SELECT COUNT(*) INTO v_decision_count

    FROM vision_autonomy.governance_decisions;



    v_records_read := v_baseline_count + v_noise_count + v_decision_count;



    -- In current phase, we don't actually write to fhq_meta yet

    -- (reconciliation tables don't exist - see 004_phase1_permissions.sql TODO)

    -- This function prepares the sync record for when those tables are added



    CASE p_sync_type

        WHEN 'FULL' THEN

            v_records_written := v_records_read;  -- Would sync all

            v_sync_status := 'SUCCESS';

        WHEN 'INCREMENTAL' THEN

            v_records_written := 0;  -- Would sync only new records

            v_sync_status := 'SUCCESS';

        WHEN 'RECONCILIATION' THEN

            v_records_written := 0;  -- Would reconcile discrepancies

            v_sync_status := 'SUCCESS';

    END CASE;



    -- Generate hash chain ID (ADR-011 - SHA-256)

    v_hash_chain_id := encode(

        digest(

            p_sync_type || '|' ||

            NOW()::TEXT || '|' ||

            v_records_read::TEXT || '|' ||

            v_records_written::TEXT,

            'sha256'

        ),

        'hex'

    );



    -- Create signature placeholder

    v_signature_id := gen_random_uuid();



    -- Write sync record to vision_autonomy.meta_state_sync

    INSERT INTO vision_autonomy.meta_state_sync (

        sync_timestamp,

        sync_type,

        source_schema,

        target_schema,

        records_read,

        records_written,

        records_failed,

        sync_status,

        error_details,

        reconciliation_snapshot_id,

        discrepancy_count,

        initiated_by,

        completed_at,

        hash_chain_id,

        signature_id

    ) VALUES (

        NOW(),

        p_sync_type,

        'vision_*',

        'fhq_meta',

        v_records_read,

        v_records_written,

        v_records_failed,

        v_sync_status,

        NULL,

        NULL,  -- Will be populated when reconciliation tables exist

        0,

        p_calling_agent,

        NOW(),

        v_hash_chain_id,

        v_signature_id

    ) RETURNING meta_state_sync.sync_id INTO v_sync_id;



    -- Log governance event (ADR-002 audit requirement)

    INSERT INTO fhq_governance.governance_actions_log (

        action_type,

        action_target,

        action_target_type,

        initiated_by,

        decision,

        decision_rationale,

        vega_reviewed,

        hash_chain_id,

        signature_id

    ) VALUES (

        'FUNCTION_EXECUTE',

        'vision_autonomy.sync_meta_state',

        'FUNCTION',

        p_calling_agent,

        'APPROVED',

        format('Meta-state sync %s: read %s, wrote %s, status %s',

               p_sync_type, v_records_read, v_records_written, v_sync_status),

        FALSE,

        v_hash_chain_id,

        v_signature_id

    );



    -- Return result

    RETURN QUERY SELECT

        v_sync_id,

        v_sync_status,

        v_records_read,

        v_records_written,

        v_hash_chain_id;

END;

$$;


--
-- Name: FUNCTION sync_meta_state(p_sync_type text, p_calling_agent text); Type: COMMENT; Schema: vision_autonomy; Owner: -
--

COMMENT ON FUNCTION vision_autonomy.sync_meta_state(p_sync_type text, p_calling_agent text) IS 'Synchronize Vision-IoS meta-state to foundation. LARS-only, lineage-tracked, reconcilable per ADR-010. Stub mode respects ADR-012.';


--
-- Name: compute_vsv(text, timestamp with time zone); Type: FUNCTION; Schema: vision_cinematic; Owner: -
--

CREATE FUNCTION vision_cinematic.compute_vsv(p_asset_id text, p_timestamp timestamp with time zone DEFAULT now()) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_vsv_id UUID;
    v_price RECORD;
    v_regime RECORD;
    v_defcon TEXT;
    v_source_hash TEXT;

    -- Computed values
    v_trend_flow_speed NUMERIC;
    v_trend_direction NUMERIC;
    v_momentum_amplitude NUMERIC;
    v_volatility_density NUMERIC;
    v_volume_particle_count INTEGER;
BEGIN
    -- Get latest price data
    SELECT * INTO v_price
    FROM fhq_data.price_series
    WHERE listing_id = p_asset_id
    AND timestamp <= p_timestamp
    ORDER BY timestamp DESC
    LIMIT 1;

    IF v_price IS NULL THEN
        RAISE EXCEPTION 'No price data found for asset %', p_asset_id;
    END IF;

    -- Get current regime
    SELECT * INTO v_regime
    FROM fhq_perception.sovereign_regime_state_v4
    WHERE asset_id = p_asset_id
    ORDER BY timestamp DESC
    LIMIT 1;

    -- Get current DEFCON
    SELECT defcon_level INTO v_defcon
    FROM fhq_governance.defcon_state
    WHERE is_current = TRUE
    LIMIT 1;

    v_defcon := COALESCE(v_defcon, 'GREEN');

    -- Compute source hash for audit
    v_source_hash := encode(sha256(
        (v_price.listing_id || v_price.timestamp::text || v_price.close::text)::bytea
    ), 'hex');

    -- Simple mapping computations (real implementation would use indicator data)
    v_trend_flow_speed := 0.5 + (random() * 0.3);
    v_trend_direction := CASE
        WHEN v_regime.sovereign_regime = 'BULL_QUIET' THEN 0.7
        WHEN v_regime.sovereign_regime = 'BULL_VOLATILE' THEN 0.5
        WHEN v_regime.sovereign_regime = 'BEAR_QUIET' THEN -0.7
        WHEN v_regime.sovereign_regime = 'BEAR_VOLATILE' THEN -0.5
        ELSE 0.0
    END;
    v_momentum_amplitude := 0.5;
    v_volatility_density := CASE
        WHEN v_regime.sovereign_regime LIKE '%VOLATILE%' THEN 0.7
        ELSE 0.3
    END;
    v_volume_particle_count := COALESCE(v_price.volume::integer / 1000000, 1000);

    -- Insert VSV
    INSERT INTO vision_cinematic.visual_state_vectors (
        asset_id,
        timestamp,
        trend_flow_speed,
        trend_flow_direction,
        trend_intensity,
        trend_color_hue,
        momentum_amplitude,
        momentum_frequency,
        momentum_phase,
        momentum_color_saturation,
        volatility_density,
        volatility_turbulence,
        volatility_color_lightness,
        volume_particle_count,
        volume_particle_speed,
        volume_glow_intensity,
        camera_shake_intensity,
        camera_zoom_level,
        bloom_intensity,
        vignette_intensity,
        film_grain,
        regime_label,
        regime_confidence,
        defcon_level,
        defcon_degradation_factor,
        source_hash
    ) VALUES (
        p_asset_id,
        p_timestamp,
        v_trend_flow_speed,
        v_trend_direction,
        0.5,
        CASE WHEN v_trend_direction > 0 THEN 0.33 ELSE 0.0 END,
        v_momentum_amplitude,
        1.0,
        0.0,
        0.7,
        v_volatility_density,
        v_volatility_density * 0.8,
        0.5,
        LEAST(v_volume_particle_count, 5000),
        0.5,
        0.5,
        CASE WHEN v_volatility_density > 0.6 THEN 0.3 ELSE 0.0 END,
        1.0,
        0.3,
        0.2,
        0.05,
        v_regime.sovereign_regime,
        (v_regime.state_probabilities->>'max_prob')::numeric,
        v_defcon,
        CASE v_defcon
            WHEN 'GREEN' THEN 1.0
            WHEN 'YELLOW' THEN 0.8
            WHEN 'ORANGE' THEN 0.6
            WHEN 'RED' THEN 0.3
            WHEN 'BLACK' THEN 0.1
            ELSE 1.0
        END,
        v_source_hash
    )
    ON CONFLICT (asset_id, timestamp) DO UPDATE SET
        trend_flow_speed = EXCLUDED.trend_flow_speed,
        trend_flow_direction = EXCLUDED.trend_flow_direction,
        regime_label = EXCLUDED.regime_label,
        defcon_level = EXCLUDED.defcon_level,
        computed_at = NOW()
    RETURNING vsv_id INTO v_vsv_id;

    RETURN v_vsv_id;
END;
$$;


--
-- Name: FUNCTION compute_vsv(p_asset_id text, p_timestamp timestamp with time zone); Type: COMMENT; Schema: vision_cinematic; Owner: -
--

COMMENT ON FUNCTION vision_cinematic.compute_vsv(p_asset_id text, p_timestamp timestamp with time zone) IS 'ADR-023: Compute Visual State Vector from market data';


--
-- Name: get_latest_vsv(text); Type: FUNCTION; Schema: vision_cinematic; Owner: -
--

CREATE FUNCTION vision_cinematic.get_latest_vsv(p_asset_id text) RETURNS TABLE(vsv_id uuid, asset_id text, vsv_timestamp timestamp with time zone, trend jsonb, momentum jsonb, volatility jsonb, volume jsonb, camera jsonb, post_processing jsonb, regime jsonb, defcon jsonb, metadata jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        v.vsv_id,
        v.asset_id,
        v.timestamp AS vsv_timestamp,
        jsonb_build_object(
            'flowSpeed', v.trend_flow_speed,
            'flowDirection', v.trend_flow_direction,
            'intensity', v.trend_intensity,
            'colorHue', v.trend_color_hue
        ) as trend,
        jsonb_build_object(
            'amplitude', v.momentum_amplitude,
            'frequency', v.momentum_frequency,
            'phase', v.momentum_phase,
            'colorSaturation', v.momentum_color_saturation
        ) as momentum,
        jsonb_build_object(
            'density', v.volatility_density,
            'turbulence', v.volatility_turbulence,
            'colorLightness', v.volatility_color_lightness
        ) as volatility,
        jsonb_build_object(
            'particleCount', v.volume_particle_count,
            'particleSpeed', v.volume_particle_speed,
            'glowIntensity', v.volume_glow_intensity
        ) as volume,
        jsonb_build_object(
            'shakeIntensity', v.camera_shake_intensity,
            'zoomLevel', v.camera_zoom_level
        ) as camera,
        jsonb_build_object(
            'bloomIntensity', v.bloom_intensity,
            'vignetteIntensity', v.vignette_intensity,
            'filmGrain', v.film_grain
        ) as post_processing,
        jsonb_build_object(
            'label', v.regime_label,
            'confidence', v.regime_confidence
        ) as regime,
        jsonb_build_object(
            'level', v.defcon_level,
            'degradationFactor', v.defcon_degradation_factor
        ) as defcon,
        jsonb_build_object(
            'computedAt', v.computed_at,
            'computedBy', v.computed_by,
            'mappingVersion', v.mapping_version,
            'sourceHash', v.source_hash
        ) as metadata
    FROM vision_cinematic.visual_state_vectors v
    WHERE v.asset_id = p_asset_id
    ORDER BY v.timestamp DESC
    LIMIT 1;
END;
$$;


--
-- Name: FUNCTION get_latest_vsv(p_asset_id text); Type: COMMENT; Schema: vision_cinematic; Owner: -
--

COMMENT ON FUNCTION vision_cinematic.get_latest_vsv(p_asset_id text) IS 'ADR-022: Get latest Visual State Vector for frontend consumption';


--
-- Name: authorize_live_mode(uuid, text, text, text, jsonb, timestamp with time zone); Type: FUNCTION; Schema: vision_core; Owner: -
--

CREATE FUNCTION vision_core.authorize_live_mode(p_proposal_id uuid, p_decision text, p_rationale text, p_authorized_by text, p_conditions jsonb DEFAULT NULL::jsonb, p_valid_until timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$

DECLARE

    v_authorization_id UUID;

    v_review_id UUID;

    v_review_decision TEXT;

    v_hash_input TEXT;

    v_hash TEXT;

    v_ceo_key_id TEXT;

BEGIN

    -- Validate decision

    IF p_decision NOT IN ('AUTHORIZED', 'DENIED') THEN

        RAISE EXCEPTION 'Invalid decision. Must be AUTHORIZED or DENIED';

    END IF;



    -- Get most recent VEGA review

    SELECT review_id, review_decision

    INTO v_review_id, v_review_decision

    FROM vision_core.live_mode_reviews

    WHERE proposal_id = p_proposal_id

    ORDER BY review_timestamp DESC

    LIMIT 1;



    IF v_review_id IS NULL THEN

        RAISE EXCEPTION 'No VEGA review found for proposal %', p_proposal_id;

    END IF;



    IF v_review_decision != 'APPROVE' THEN

        RAISE EXCEPTION 'VEGA has not approved this proposal (decision: %)', v_review_decision;

    END IF;



    -- Get CEO key (if exists, otherwise use system key)

    SELECT key_id INTO v_ceo_key_id

    FROM fhq_meta.agent_keys

    WHERE agent_name = 'CEO'

      AND key_status = 'ACTIVE'

    ORDER BY created_at DESC

    LIMIT 1;



    -- Compute hash

    v_hash_input := p_proposal_id::TEXT || p_decision || p_rationale || p_authorized_by || NOW()::TEXT;

    v_hash := encode(digest(v_hash_input, 'sha256'), 'hex');



    -- Create authorization

    INSERT INTO vision_core.live_mode_authorizations (

        proposal_id,

        review_id,

        authorized_by,

        authorization_decision,

        authorization_rationale,

        conditions,

        valid_until,

        hash_chain_id,

        signature_id

    ) VALUES (

        p_proposal_id,

        v_review_id,

        p_authorized_by,

        p_decision,

        p_rationale,

        p_conditions,

        p_valid_until,

        v_hash,

        v_ceo_key_id

    ) RETURNING authorization_id INTO v_authorization_id;



    -- Update proposal status

    UPDATE vision_core.live_mode_proposals

    SET

        proposal_status = CASE

            WHEN p_decision = 'AUTHORIZED' THEN 'APPROVED'

            ELSE 'REJECTED'

        END,

        updated_at = NOW()

    WHERE proposal_id = p_proposal_id;



    -- Log governance action

    INSERT INTO vision_core.governance_actions_log (

        action_type,

        action_target,

        initiated_by,

        decision,

        rationale,

        hash_chain_id,

        signature_id

    ) VALUES (

        'AUTHORIZE_LIVE_MODE',

        p_proposal_id::TEXT,

        p_authorized_by,

        p_decision,

        p_rationale,

        v_hash,

        v_ceo_key_id

    );



    RAISE NOTICE 'CEO authorization completed: % (Decision: %)', v_authorization_id, p_decision;



    RETURN v_authorization_id;

END;

$$;


--
-- Name: FUNCTION authorize_live_mode(p_proposal_id uuid, p_decision text, p_rationale text, p_authorized_by text, p_conditions jsonb, p_valid_until timestamp with time zone); Type: COMMENT; Schema: vision_core; Owner: -
--

COMMENT ON FUNCTION vision_core.authorize_live_mode(p_proposal_id uuid, p_decision text, p_rationale text, p_authorized_by text, p_conditions jsonb, p_valid_until timestamp with time zone) IS 'ADR-012: CEO authorizes LIVE MODE activation. Final approval in G2VEGACEO chain.';


--
-- Name: check_live_mode_authorization(uuid); Type: FUNCTION; Schema: vision_core; Owner: -
--

CREATE FUNCTION vision_core.check_live_mode_authorization(p_proposal_id uuid) RETURNS TABLE(authorized boolean, authorization_id uuid, reason text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$

DECLARE

    v_authorized BOOLEAN := FALSE;

    v_authorization_id UUID;

    v_auth_decision TEXT;

    v_readiness_status TEXT;

    v_reason TEXT;

BEGIN

    -- Check if proposal is authorized

    SELECT a.authorization_id, a.authorization_decision

    INTO v_authorization_id, v_auth_decision

    FROM vision_core.live_mode_authorizations a

    WHERE a.proposal_id = p_proposal_id

      AND (a.valid_until IS NULL OR a.valid_until > NOW())

    ORDER BY a.authorization_timestamp DESC

    LIMIT 1;



    IF v_authorization_id IS NULL THEN

        v_reason := 'No valid authorization found for this proposal';

        v_authorized := FALSE;

    ELSIF v_auth_decision != 'AUTHORIZED' THEN

        v_reason := 'Authorization was denied';

        v_authorized := FALSE;

    ELSE

        -- Re-check readiness at activation time

        SELECT r.readiness_status

        INTO v_readiness_status

        FROM vega.evaluate_live_mode_readiness() r;



        IF v_readiness_status = 'READY' THEN

            v_authorized := TRUE;

            v_reason := 'Authorized and ready for LIVE MODE';

        ELSE

            v_authorized := FALSE;

            v_reason := 'System no longer meets readiness criteria';

        END IF;

    END IF;



    RETURN QUERY SELECT v_authorized, v_authorization_id, v_reason;

END;

$$;


--
-- Name: FUNCTION check_live_mode_authorization(p_proposal_id uuid); Type: COMMENT; Schema: vision_core; Owner: -
--

COMMENT ON FUNCTION vision_core.check_live_mode_authorization(p_proposal_id uuid) IS 'ADR-012: Worker pre-flight guard. Validates authorization chain before LIVE MODE activation.';


--
-- Name: estimate_noise_floor(timestamp with time zone, timestamp with time zone, text, text); Type: FUNCTION; Schema: vision_core; Owner: -
--

CREATE FUNCTION vision_core.estimate_noise_floor(p_window_start timestamp with time zone, p_window_end timestamp with time zone, p_calculation_method text DEFAULT 'variance_based'::text, p_calling_agent text DEFAULT 'STIG'::text) RETURNS TABLE(profile_id uuid, noise_floor_value numeric, signal_threshold numeric, confidence_level numeric, hash_chain_id text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$

DECLARE

    v_profile_id UUID;

    v_noise_floor NUMERIC;

    v_noise_variance NUMERIC;

    v_signal_threshold NUMERIC;

    v_confidence_level NUMERIC;

    v_hash_chain_id TEXT;

    v_gate_status TEXT;

    v_signature_id UUID;

    v_sample_count INTEGER;

    v_price_variance NUMERIC;

    v_price_stddev NUMERIC;

BEGIN

    -- Economic Safety Check (ADR-012)

    SELECT gate_status INTO v_gate_status

    FROM vision_core.economic_safety_gate

    WHERE gate_name = 'QG-F6';



    IF v_gate_status != 'PASS' THEN

        RAISE NOTICE 'Economic safety gate QG-F6 is %. Function running in STUB MODE.', v_gate_status;

    END IF;



    -- Verify calling agent identity (ADR-002)

    IF p_calling_agent NOT IN ('STIG', 'LARS') THEN

        RAISE EXCEPTION 'Unauthorized agent: % cannot call estimate_noise_floor', p_calling_agent;

    END IF;



    -- Validate time window

    IF p_window_end <= p_window_start THEN

        RAISE EXCEPTION 'Invalid time window: end must be after start';

    END IF;



    -- Read from foundation data (READ-ONLY)

    -- Using price_series table (actual foundation schema)

    SELECT

        VARIANCE(close - open) AS price_var,

        STDDEV(close - open) AS price_std,

        COUNT(*) AS sample_cnt

    INTO

        v_price_variance,

        v_price_stddev,

        v_sample_count

    FROM fhq_data.price_series

    WHERE

        timestamp >= p_window_start

        AND timestamp <= p_window_end;



    -- If no data, raise warning

    IF v_sample_count = 0 OR v_sample_count IS NULL THEN

        RAISE WARNING 'No price data found in window % to %', p_window_start, p_window_end;

        v_price_variance := 0;

        v_price_stddev := 0;

        v_sample_count := 0;

    END IF;



    -- Calculate noise floor based on method

    CASE p_calculation_method

        WHEN 'variance_based' THEN

            v_noise_floor := COALESCE(v_price_variance, 0);

            v_signal_threshold := COALESCE(v_noise_floor * 2.0, 0);  -- 2x noise floor

        WHEN 'stddev_based' THEN

            v_noise_floor := COALESCE(v_price_stddev, 0);

            v_signal_threshold := COALESCE(v_noise_floor * 3.0, 0);  -- 3-sigma rule

        ELSE

            RAISE EXCEPTION 'Unknown calculation method: %', p_calculation_method;

    END CASE;



    -- Calculate confidence level

    v_confidence_level := CASE

        WHEN v_sample_count >= 1000 THEN 0.99

        WHEN v_sample_count >= 100 THEN 0.95

        WHEN v_sample_count >= 30 THEN 0.90

        ELSE 0.75

    END;



    -- Set noise variance

    v_noise_variance := v_price_variance;



    -- Generate hash chain ID (ADR-011 - SHA-256)

    v_hash_chain_id := encode(

        digest(

            p_window_start::TEXT || '|' ||

            p_window_end::TEXT || '|' ||

            v_noise_floor::TEXT || '|' ||

            p_calculation_method,

            'sha256'

        ),

        'hex'

    );



    -- Create signature placeholder

    v_signature_id := gen_random_uuid();



    -- Write to vision_core.noise_profile (WRITE permitted for STIG)

    INSERT INTO vision_core.noise_profile (

        analysis_timestamp,

        window_start,

        window_end,

        noise_floor_value,

        noise_variance,

        noise_distribution,

        signal_threshold,

        confidence_level,

        calculation_method,

        data_sources,

        created_by,

        hash_chain_id,

        signature_id

    ) VALUES (

        NOW(),

        p_window_start,

        p_window_end,

        v_noise_floor,

        v_noise_variance,

        jsonb_build_object(

            'variance', v_price_variance,

            'stddev', v_price_stddev,

            'sample_count', v_sample_count,

            'source_table', 'price_series'

        ),

        v_signal_threshold,

        v_confidence_level,

        p_calculation_method,

        ARRAY['fhq_data.price_series'],

        p_calling_agent,

        v_hash_chain_id,

        v_signature_id

    ) RETURNING noise_profile.profile_id INTO v_profile_id;



    -- Log governance event (ADR-002 audit requirement)

    INSERT INTO fhq_governance.governance_actions_log (

        action_type,

        action_target,

        action_target_type,

        initiated_by,

        decision,

        decision_rationale,

        vega_reviewed,

        hash_chain_id,

        signature_id

    ) VALUES (

        'FUNCTION_EXECUTE',

        'vision_core.estimate_noise_floor',

        'FUNCTION',

        p_calling_agent,

        'APPROVED',

        format('Noise floor: %s, Threshold: %s, Confidence: %s, Samples: %s',

               v_noise_floor, v_signal_threshold, v_confidence_level, v_sample_count),

        FALSE,

        v_hash_chain_id,

        v_signature_id

    );



    -- Return result

    RETURN QUERY SELECT

        v_profile_id,

        v_noise_floor,

        v_signal_threshold,

        v_confidence_level,

        v_hash_chain_id;

END;

$$;


--
-- Name: FUNCTION estimate_noise_floor(p_window_start timestamp with time zone, p_window_end timestamp with time zone, p_calculation_method text, p_calling_agent text); Type: COMMENT; Schema: vision_core; Owner: -
--

COMMENT ON FUNCTION vision_core.estimate_noise_floor(p_window_start timestamp with time zone, p_window_end timestamp with time zone, p_calculation_method text, p_calling_agent text) IS 'Estimate noise floor for signal detection. STIG-owned, deterministic, READ foundation only. Per ADR-001/002/004/012.';


--
-- Name: propose_live_mode(text, text); Type: FUNCTION; Schema: vision_core; Owner: -
--

CREATE FUNCTION vision_core.propose_live_mode(p_rationale text, p_calling_agent text DEFAULT 'LARS'::text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$

DECLARE

    v_proposal_id UUID;

    v_readiness_status TEXT;

    v_readiness_details JSONB;

    v_qg_f6_check BOOLEAN;

    v_attestation_check BOOLEAN;

    v_keys_check BOOLEAN;

    v_violations_check BOOLEAN;

    v_class_a_check BOOLEAN;

    v_qg_f6_status TEXT;

    v_attested_count INTEGER;

    v_active_keys INTEGER;

    v_pending_violations INTEGER;

    v_class_a_count INTEGER;

    v_hash_input TEXT;

    v_hash TEXT;

    v_key_id TEXT;

BEGIN

    -- Only LARS can propose

    IF p_calling_agent != 'LARS' THEN

        RAISE EXCEPTION 'Only LARS can propose LIVE MODE transitions';

    END IF;



    -- Evaluate readiness

    SELECT

        r.readiness_status,

        r.qg_f6_check,

        r.attestation_check,

        r.keys_check,

        r.violations_check,

        r.class_a_events_check,

        r.details

    INTO

        v_readiness_status,

        v_qg_f6_check,

        v_attestation_check,

        v_keys_check,

        v_violations_check,

        v_class_a_check,

        v_readiness_details

    FROM vega.evaluate_live_mode_readiness() r;



    -- Extract counts from details

    v_qg_f6_status := v_readiness_details->>'qg_f6_status';

    v_attested_count := (v_readiness_details->>'attested_functions')::INTEGER;

    v_active_keys := (v_readiness_details->>'active_keys')::INTEGER;

    v_pending_violations := (v_readiness_details->>'pending_violations')::INTEGER;

    v_class_a_count := (v_readiness_details->>'class_a_events_24h')::INTEGER;



    -- Get LARS key for signing

    SELECT key_id INTO v_key_id

    FROM fhq_meta.agent_keys

    WHERE agent_name = 'LARS'

      AND key_status = 'ACTIVE'

    ORDER BY created_at DESC

    LIMIT 1;



    -- Compute hash

    v_hash_input := p_calling_agent || p_rationale || v_readiness_status || NOW()::TEXT;

    v_hash := encode(digest(v_hash_input, 'sha256'), 'hex');



    -- Create proposal

    INSERT INTO vision_core.live_mode_proposals (

        proposed_by,

        proposal_rationale,

        qg_f6_status,

        attested_functions_count,

        active_agents_count,

        pending_violations_count,

        class_a_events_24h,

        readiness_status,

        readiness_details,

        hash_chain_id,

        signature_id

    ) VALUES (

        p_calling_agent,

        p_rationale,

        v_qg_f6_status,

        v_attested_count,

        v_active_keys,

        v_pending_violations,

        v_class_a_count,

        v_readiness_status,

        v_readiness_details,

        v_hash,

        v_key_id

    ) RETURNING proposal_id INTO v_proposal_id;



    -- Log governance action

    INSERT INTO vision_core.governance_actions_log (

        action_type,

        action_target,

        initiated_by,

        decision,

        rationale,

        hash_chain_id,

        signature_id

    ) VALUES (

        'PROPOSE_LIVE_MODE',

        v_proposal_id::TEXT,

        p_calling_agent,

        'PENDING',

        p_rationale,

        v_hash,

        v_key_id

    );



    RAISE NOTICE 'LIVE MODE proposal created: % (Status: %)', v_proposal_id, v_readiness_status;



    RETURN v_proposal_id;

END;

$$;


--
-- Name: FUNCTION propose_live_mode(p_rationale text, p_calling_agent text); Type: COMMENT; Schema: vision_core; Owner: -
--

COMMENT ON FUNCTION vision_core.propose_live_mode(p_rationale text, p_calling_agent text) IS 'ADR-012: LARS proposes LIVE MODE transition. Evaluates readiness and creates governance-logged proposal.';


--
-- Name: calculate_signal_baseline(text, text, interval, text); Type: FUNCTION; Schema: vision_signals; Owner: -
--

CREATE FUNCTION vision_signals.calculate_signal_baseline(p_signal_type text, p_signal_name text, p_calculation_window interval, p_calling_agent text DEFAULT 'FINN'::text) RETURNS TABLE(baseline_id uuid, baseline_value numeric, sample_size integer, confidence_interval numeric, hash_chain_id text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$

DECLARE

    v_baseline_id UUID;

    v_baseline_value NUMERIC;

    v_mean_value NUMERIC;

    v_std_deviation NUMERIC;

    v_sample_size INTEGER;

    v_confidence_interval NUMERIC;

    v_hash_chain_id TEXT;

    v_gate_status TEXT;

    v_signature_id UUID;

    v_window_start TIMESTAMPTZ;

    v_window_end TIMESTAMPTZ;

BEGIN

    -- Economic Safety Check (ADR-012)

    SELECT gate_status INTO v_gate_status

    FROM vision_core.economic_safety_gate

    WHERE gate_name = 'QG-F6';



    IF v_gate_status != 'PASS' THEN

        RAISE NOTICE 'Economic safety gate QG-F6 is %. Function running in STUB MODE.', v_gate_status;

    END IF;



    -- Verify calling agent identity (ADR-002)

    IF p_calling_agent NOT IN ('FINN', 'LARS') THEN

        RAISE EXCEPTION 'Unauthorized agent: % cannot call calculate_signal_baseline', p_calling_agent;

    END IF;



    -- Calculate time window

    v_window_end := NOW();

    v_window_start := v_window_end - p_calculation_window;



    -- Read from foundation data (READ-ONLY per directive)

    -- Using price_series table (actual foundation schema)

    SELECT

        AVG(close) AS mean_val,

        STDDEV(close) AS std_dev,

        COUNT(*) AS sample_count

    INTO

        v_mean_value,

        v_std_deviation,

        v_sample_size

    FROM fhq_data.price_series

    WHERE

        timestamp >= v_window_start

        AND timestamp <= v_window_end

        AND listing_id = p_signal_name;  -- Using listing_id instead of signal_name



    -- If no data, raise warning

    IF v_sample_size = 0 OR v_sample_size IS NULL THEN

        RAISE WARNING 'No data found for signal % in window %', p_signal_name, p_calculation_window;

        v_sample_size := 0;

        v_mean_value := 0;

        v_std_deviation := 0;

    END IF;



    -- Calculate baseline value and confidence

    v_baseline_value := COALESCE(v_mean_value, 0);

    v_confidence_interval := CASE

        WHEN v_sample_size > 30 THEN 0.95  -- High confidence

        WHEN v_sample_size > 10 THEN 0.80  -- Medium confidence

        ELSE 0.50  -- Low confidence

    END;



    -- Generate hash chain ID (ADR-011 - SHA-256)

    v_hash_chain_id := encode(

        digest(

            p_signal_type || '|' ||

            p_signal_name || '|' ||

            v_baseline_value::TEXT || '|' ||

            v_window_start::TEXT || '|' ||

            v_window_end::TEXT,

            'sha256'

        ),

        'hex'

    );



    -- Create signature placeholder (will be populated by Ed25519 signing)

    v_signature_id := gen_random_uuid();



    -- Write to vision_signals.signal_baseline (WRITE permitted)

    INSERT INTO vision_signals.signal_baseline (

        signal_type,

        signal_name,

        baseline_value,

        baseline_timestamp,

        mean_value,

        std_deviation,

        sample_size,

        confidence_interval,

        source_schemas,

        calculation_window,

        calculation_method,

        parameters,

        created_by,

        hash_chain_id,

        signature_id

    ) VALUES (

        p_signal_type,

        p_signal_name,

        v_baseline_value,

        NOW(),

        v_mean_value,

        v_std_deviation,

        v_sample_size,

        v_confidence_interval,

        ARRAY['fhq_data'],

        p_calculation_window,

        'mean_with_stddev',

        jsonb_build_object(

            'window_start', v_window_start,

            'window_end', v_window_end,

            'calling_agent', p_calling_agent,

            'source_table', 'price_series'

        ),

        p_calling_agent,

        v_hash_chain_id,

        v_signature_id

    ) RETURNING signal_baseline.baseline_id INTO v_baseline_id;



    -- Log governance event (ADR-002 audit requirement)

    INSERT INTO fhq_governance.governance_actions_log (

        action_type,

        action_target,

        action_target_type,

        initiated_by,

        decision,

        decision_rationale,

        vega_reviewed,

        hash_chain_id,

        signature_id

    ) VALUES (

        'FUNCTION_EXECUTE',

        'vision_signals.calculate_signal_baseline',

        'FUNCTION',

        p_calling_agent,

        'APPROVED',

        format('Calculated baseline for signal %s (samples: %s, confidence: %s)',

               p_signal_name, v_sample_size, v_confidence_interval),

        FALSE,

        v_hash_chain_id,

        v_signature_id

    );



    -- Return result

    RETURN QUERY SELECT

        v_baseline_id,

        v_baseline_value,

        v_sample_size,

        v_confidence_interval,

        v_hash_chain_id;

END;

$$;


--
-- Name: FUNCTION calculate_signal_baseline(p_signal_type text, p_signal_name text, p_calculation_window interval, p_calling_agent text); Type: COMMENT; Schema: vision_signals; Owner: -
--

COMMENT ON FUNCTION vision_signals.calculate_signal_baseline(p_signal_type text, p_signal_name text, p_calculation_window interval, p_calling_agent text) IS 'Calculate signal baseline from foundation data. FINN-owned, non-actionable, READ foundation only. Per ADR-001/002/004/012.';


--
-- Name: capture_eqs_v2_snapshot(text); Type: FUNCTION; Schema: vision_verification; Owner: -
--

CREATE FUNCTION vision_verification.capture_eqs_v2_snapshot(p_notes text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_snapshot_id UUID;
    v_regime_pct NUMERIC;
    v_regime_status TEXT;
BEGIN
    -- Get regime diversity
    SELECT non_dominant_pct, health_status
    INTO v_regime_pct, v_regime_status
    FROM vision_verification.regime_coverage_health
    LIMIT 1;

    -- Insert snapshot
    INSERT INTO vision_verification.eqs_v2_monitoring_snapshots (
        total_scored, mean_score, std_dev, p90_p10_spread,
        tier_s_count, tier_a_count, tier_b_count, tier_c_count,
        regime_diversity_pct, regime_status, notes
    )
    SELECT
        total_scored, mean_score, std_dev, p90_p10_spread,
        tier_s_count, tier_a_count, tier_b_count, tier_c_count,
        v_regime_pct, v_regime_status, p_notes
    FROM vision_verification.v_eqs_v2_distribution_snapshot
    RETURNING id INTO v_snapshot_id;

    RETURN v_snapshot_id;
END;
$$;


--
-- Name: compute_truth_hash(text, date, numeric, numeric, text); Type: FUNCTION; Schema: vision_verification; Owner: -
--

CREATE FUNCTION vision_verification.compute_truth_hash(p_regime_label text, p_regime_date date, p_allocation_pct numeric, p_signal_strength numeric, p_listing_id text) RETURNS TABLE(truth_hash text, canonical_json text)
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
    v_canonical_json TEXT;
    v_hash TEXT;
BEGIN
    -- Build canonical JSON (keys sorted alphabetically, no whitespace)
    -- IMPORTANT: Round numerics to consistent precision to avoid hash mismatches
    v_canonical_json := json_build_object(
        'allocation_pct', ROUND(COALESCE(p_allocation_pct, 0)::numeric, 2),
        'listing_id', COALESCE(p_listing_id, ''),
        'regime_date', COALESCE(p_regime_date::TEXT, ''),
        'regime_label', COALESCE(p_regime_label, ''),
        'signal_strength', ROUND(COALESCE(p_signal_strength, 0)::numeric, 2)
    )::TEXT;

    -- Remove whitespace for deterministic hashing
    v_canonical_json := REGEXP_REPLACE(v_canonical_json, '\s+', '', 'g');

    -- Compute SHA-256 hash
    v_hash := encode(sha256(v_canonical_json::bytea), 'hex');

    RETURN QUERY SELECT v_hash, v_canonical_json;
END;
$$;


--
-- Name: FUNCTION compute_truth_hash(p_regime_label text, p_regime_date date, p_allocation_pct numeric, p_signal_strength numeric, p_listing_id text); Type: COMMENT; Schema: vision_verification; Owner: -
--

COMMENT ON FUNCTION vision_verification.compute_truth_hash(p_regime_label text, p_regime_date date, p_allocation_pct numeric, p_signal_strength numeric, p_listing_id text) IS 'Computes deterministic SHA-256 hash of dashboard metric fields for truth attestation';


--
-- Name: create_truth_attestation(text, text, text, date, numeric, numeric, text, text, text); Type: FUNCTION; Schema: vision_verification; Owner: -
--

CREATE FUNCTION vision_verification.create_truth_attestation(p_route_path text, p_listing_id text, p_regime_label text, p_regime_date date, p_allocation_pct numeric, p_signal_strength numeric, p_source_table text, p_source_query text, p_source_row_id text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_attestation_id UUID;
    v_hash_result RECORD;
BEGIN
    -- Compute hash
    SELECT * INTO v_hash_result
    FROM vision_verification.compute_truth_hash(
        p_regime_label, p_regime_date, p_allocation_pct, p_signal_strength, p_listing_id
    );

    -- Insert attestation
    INSERT INTO vision_verification.dashboard_truth_attestation (
        route_path, listing_id, attestation_date,
        regime_label, regime_date, allocation_pct, signal_strength,
        truth_hash, canonical_json,
        source_table, source_query, source_row_id,
        expires_at
    ) VALUES (
        p_route_path, p_listing_id, CURRENT_DATE,
        p_regime_label, p_regime_date, p_allocation_pct, p_signal_strength,
        v_hash_result.truth_hash, v_hash_result.canonical_json,
        p_source_table, p_source_query, p_source_row_id,
        NOW() + INTERVAL '24 hours'
    )
    RETURNING attestation_id INTO v_attestation_id;

    RETURN v_attestation_id;
END;
$$;


--
-- Name: FUNCTION create_truth_attestation(p_route_path text, p_listing_id text, p_regime_label text, p_regime_date date, p_allocation_pct numeric, p_signal_strength numeric, p_source_table text, p_source_query text, p_source_row_id text); Type: COMMENT; Schema: vision_verification; Owner: -
--

COMMENT ON FUNCTION vision_verification.create_truth_attestation(p_route_path text, p_listing_id text, p_regime_label text, p_regime_date date, p_allocation_pct numeric, p_signal_strength numeric, p_source_table text, p_source_query text, p_source_row_id text) IS 'Creates a new truth attestation record for dashboard metrics';


--
-- Name: enforce_evidence_attachment(character varying, character varying, character varying, text, jsonb, jsonb, jsonb); Type: FUNCTION; Schema: vision_verification; Owner: -
--

CREATE FUNCTION vision_verification.enforce_evidence_attachment(p_summary_id character varying, p_summary_type character varying, p_generating_agent character varying, p_raw_query text, p_query_result jsonb, p_summary_content jsonb, p_execution_context jsonb DEFAULT NULL::jsonb) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_query_result_hash VARCHAR(64);
    v_summary_hash VARCHAR(64);
    v_evidence_id UUID;
BEGIN
    -- Validate inputs (court-proof requirements)
    IF p_raw_query IS NULL OR LENGTH(p_raw_query) < 10 THEN
        RAISE EXCEPTION 'COURT_PROOF_VIOLATION: raw_query is mandatory and must contain valid SQL (min 10 chars)';
    END IF;

    IF p_query_result IS NULL OR jsonb_typeof(p_query_result) IS NULL THEN
        RAISE EXCEPTION 'COURT_PROOF_VIOLATION: query_result is mandatory - no summary without raw data evidence';
    END IF;

    IF p_summary_content IS NULL THEN
        RAISE EXCEPTION 'COURT_PROOF_VIOLATION: summary_content cannot be null';
    END IF;

    -- Compute hashes
    v_query_result_hash := encode(sha256(p_query_result::text::bytea), 'hex');
    v_summary_hash := encode(sha256(p_summary_content::text::bytea), 'hex');

    -- Insert evidence record
    INSERT INTO vision_verification.summary_evidence_ledger (
        summary_id,
        summary_type,
        generating_agent,
        raw_query,
        query_result_hash,
        query_result_snapshot,
        summary_content,
        summary_hash,
        execution_context
    ) VALUES (
        p_summary_id,
        p_summary_type,
        p_generating_agent,
        p_raw_query,
        v_query_result_hash,
        p_query_result,
        p_summary_content,
        v_summary_hash,
        p_execution_context
    )
    RETURNING evidence_id INTO v_evidence_id;

    -- Log to governance
    INSERT INTO fhq_governance.governance_actions_log (
        action_type,
        action_target,
        decision,
        decision_rationale,
        initiated_by,
        initiated_at
    ) VALUES (
        'EVIDENCE_ATTACHMENT',
        p_summary_id,
        'ENFORCED',
        format('Court-proof evidence attached: query_hash=%s, summary_type=%s', v_query_result_hash, p_summary_type),
        p_generating_agent,
        NOW()
    );

    RETURN v_evidence_id;
END;
$$;


--
-- Name: enforce_evidence_immutability(); Type: FUNCTION; Schema: vision_verification; Owner: -
--

CREATE FUNCTION vision_verification.enforce_evidence_immutability() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Block all updates except break-glass
    IF TG_OP = 'UPDATE' THEN
        -- Only allow signature_verified updates
        IF OLD.evidence_id = NEW.evidence_id AND
           OLD.summary_id = NEW.summary_id AND
           OLD.raw_query = NEW.raw_query AND
           OLD.query_result_hash = NEW.query_result_hash AND
           OLD.query_result_snapshot = NEW.query_result_snapshot AND
           OLD.summary_content = NEW.summary_content THEN
            -- This is a metadata-only update (signature verification), allow it
            RETURN NEW;
        ELSE
            RAISE EXCEPTION 'IMMUTABILITY_VIOLATION: Evidence records are append-only. Use break-glass governance for exceptions.';
        END IF;
    END IF;

    -- Block all deletes
    IF TG_OP = 'DELETE' THEN
        RAISE EXCEPTION 'IMMUTABILITY_VIOLATION: Evidence records cannot be deleted. Use break-glass governance for exceptions.';
    END IF;

    RETURN NEW;
END;
$$;


--
-- Name: run_regime_coverage_sentinel(); Type: FUNCTION; Schema: vision_verification; Owner: -
--

CREATE FUNCTION vision_verification.run_regime_coverage_sentinel() RETURNS TABLE(check_type text, status text, metric_value numeric, threshold numeric, alert_needed boolean)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_asset_count INTEGER;
    v_regime_states INTEGER;
    v_non_dominant_pct NUMERIC;
    v_dominant_regime TEXT;
    v_dominant_count INTEGER;
    v_regime_states_arr TEXT[];
    v_check_date DATE;
    v_evidence_hash TEXT;
BEGIN
    -- Get latest date with data
    SELECT MAX(timestamp)::date INTO v_check_date
    FROM fhq_perception.regime_daily;

    -- Asset coverage check
    SELECT COUNT(DISTINCT asset_id) INTO v_asset_count
    FROM fhq_perception.regime_daily
    WHERE timestamp::date = v_check_date;

    -- Regime diversity check
    SELECT
        COUNT(DISTINCT regime_classification),
        array_agg(DISTINCT regime_classification ORDER BY regime_classification)
    INTO v_regime_states, v_regime_states_arr
    FROM fhq_perception.regime_daily
    WHERE timestamp::date = v_check_date;

    -- Get dominant regime and non-dominant percentage
    WITH regime_counts AS (
        SELECT
            regime_classification,
            COUNT(*) as cnt,
            SUM(COUNT(*)) OVER () as total
        FROM fhq_perception.regime_daily
        WHERE timestamp::date = v_check_date
        GROUP BY regime_classification
        ORDER BY cnt DESC
        LIMIT 1
    )
    SELECT
        regime_classification,
        cnt,
        ROUND(100.0 * (total - cnt) / NULLIF(total, 0), 2)
    INTO v_dominant_regime, v_dominant_count, v_non_dominant_pct
    FROM regime_counts;

    -- Generate evidence hash
    v_evidence_hash := md5(
        v_check_date::text ||
        v_asset_count::text ||
        v_regime_states::text ||
        COALESCE(v_non_dominant_pct::text, '0')
    );

    -- Log asset coverage check
    INSERT INTO vision_verification.regime_coverage_sentinel_log (
        check_type, check_date, asset_count, asset_threshold,
        status, alert_triggered, evidence_hash
    ) VALUES (
        'ASSET_COVERAGE', v_check_date, v_asset_count, 400,
        CASE WHEN v_asset_count >= 400 THEN 'HEALTHY'
             WHEN v_asset_count >= 100 THEN 'WARNING'
             ELSE 'CRITICAL' END,
        v_asset_count < 100,
        v_evidence_hash
    );

    -- Return asset coverage result
    check_type := 'ASSET_COVERAGE';
    metric_value := v_asset_count;
    threshold := 400;
    status := CASE WHEN v_asset_count >= 400 THEN 'HEALTHY'
                   WHEN v_asset_count >= 100 THEN 'WARNING'
                   ELSE 'CRITICAL' END;
    alert_needed := v_asset_count < 100;
    RETURN NEXT;

    -- Log regime diversity check
    INSERT INTO vision_verification.regime_coverage_sentinel_log (
        check_type, check_date, regime_states_count, regime_states,
        dominant_regime, dominant_count, non_dominant_pct, diversity_threshold,
        status, alert_triggered, evidence_hash
    ) VALUES (
        'REGIME_DIVERSITY', v_check_date, v_regime_states, v_regime_states_arr,
        v_dominant_regime, v_dominant_count, v_non_dominant_pct, 15.00,
        CASE WHEN v_non_dominant_pct >= 15.0 THEN 'HEALTHY'
             WHEN v_non_dominant_pct >= 5.0 THEN 'WARNING'
             ELSE 'CRITICAL' END,
        v_non_dominant_pct < 15.0,
        v_evidence_hash
    );

    -- Return regime diversity result
    check_type := 'REGIME_DIVERSITY';
    metric_value := v_non_dominant_pct;
    threshold := 15.0;
    status := CASE WHEN v_non_dominant_pct >= 15.0 THEN 'HEALTHY'
                   WHEN v_non_dominant_pct >= 5.0 THEN 'WARNING'
                   ELSE 'CRITICAL' END;
    alert_needed := v_non_dominant_pct < 15.0;
    RETURN NEXT;

    -- Return regime states check
    check_type := 'REGIME_STATES';
    metric_value := v_regime_states;
    threshold := 3;
    status := CASE WHEN v_regime_states >= 3 THEN 'HEALTHY'
                   WHEN v_regime_states >= 2 THEN 'WARNING'
                   ELSE 'CRITICAL' END;
    alert_needed := v_regime_states < 2;
    RETURN NEXT;

END;
$$;


--
-- Name: validate_evidence_determinism(text, jsonb); Type: FUNCTION; Schema: vision_verification; Owner: -
--

CREATE FUNCTION vision_verification.validate_evidence_determinism(p_raw_query text, p_query_result jsonb) RETURNS jsonb
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
    v_violations JSONB := '[]'::jsonb;
    v_is_deterministic BOOLEAN := true;
BEGIN
    -- Check for SELECT *
    IF p_raw_query ~* 'SELECT\s+\*' THEN
        v_violations := v_violations || '["USES_SELECT_STAR"]'::jsonb;
        v_is_deterministic := false;
    END IF;

    -- Check for missing ORDER BY (heuristic: if more than one row expected)
    IF p_raw_query ~* 'SELECT' AND NOT p_raw_query ~* 'ORDER\s+BY' AND
       jsonb_typeof(p_query_result) = 'array' AND jsonb_array_length(p_query_result) > 1 THEN
        v_violations := v_violations || '["MISSING_ORDER_BY"]'::jsonb;
        v_is_deterministic := false;
    END IF;

    -- Check for LIMIT without ORDER BY
    IF p_raw_query ~* 'LIMIT' AND NOT p_raw_query ~* 'ORDER\s+BY' THEN
        v_violations := v_violations || '["LIMIT_WITHOUT_ORDER"]'::jsonb;
        v_is_deterministic := false;
    END IF;

    RETURN jsonb_build_object(
        'is_deterministic', v_is_deterministic,
        'violations', v_violations,
        'checked_at', NOW()
    );
END;
$$;


--
-- Name: verify_evidence_integrity(uuid); Type: FUNCTION; Schema: vision_verification; Owner: -
--

CREATE FUNCTION vision_verification.verify_evidence_integrity(p_evidence_id uuid) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_record RECORD;
    v_recomputed_hash VARCHAR(64);
    v_is_valid BOOLEAN;
BEGIN
    -- Fetch the evidence record
    SELECT * INTO v_record
    FROM vision_verification.summary_evidence_ledger
    WHERE evidence_id = p_evidence_id;

    IF v_record IS NULL THEN
        RETURN jsonb_build_object(
            'valid', FALSE,
            'error', 'Evidence record not found',
            'evidence_id', p_evidence_id
        );
    END IF;

    -- Recompute hash from stored query result
    v_recomputed_hash := encode(sha256(v_record.query_result_snapshot::text::bytea), 'hex');
    v_is_valid := (v_recomputed_hash = v_record.query_result_hash);

    RETURN jsonb_build_object(
        'valid', v_is_valid,
        'evidence_id', p_evidence_id,
        'summary_id', v_record.summary_id,
        'stored_hash', v_record.query_result_hash,
        'recomputed_hash', v_recomputed_hash,
        'generating_agent', v_record.generating_agent,
        'created_at', v_record.created_at,
        'verification_timestamp', NOW()
    );
END;
$$;


--
-- Name: verify_truth_attestation(uuid); Type: FUNCTION; Schema: vision_verification; Owner: -
--

CREATE FUNCTION vision_verification.verify_truth_attestation(p_attestation_id uuid) RETURNS TABLE(is_valid boolean, computed_hash text, stored_hash text, mismatch_reason text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_attestation RECORD;
    v_computed_hash RECORD;
BEGIN
    -- Get attestation
    SELECT * INTO v_attestation
    FROM vision_verification.dashboard_truth_attestation
    WHERE attestation_id = p_attestation_id;

    IF NOT FOUND THEN
        RETURN QUERY SELECT FALSE, NULL::TEXT, NULL::TEXT, 'Attestation not found'::TEXT;
        RETURN;
    END IF;

    -- Recompute hash
    SELECT * INTO v_computed_hash
    FROM vision_verification.compute_truth_hash(
        v_attestation.regime_label,
        v_attestation.regime_date,
        v_attestation.allocation_pct,
        v_attestation.signal_strength,
        v_attestation.listing_id
    );

    -- Compare
    IF v_computed_hash.truth_hash = v_attestation.truth_hash THEN
        RETURN QUERY SELECT TRUE, v_computed_hash.truth_hash, v_attestation.truth_hash, NULL::TEXT;
    ELSE
        -- Log verification failure
        UPDATE vision_verification.dashboard_truth_attestation
        SET verification_failures = verification_failures + 1,
            is_verified = FALSE
        WHERE attestation_id = p_attestation_id;

        RETURN QUERY SELECT FALSE, v_computed_hash.truth_hash, v_attestation.truth_hash, 'Hash mismatch - possible data tampering'::TEXT;
    END IF;
END;
$$;


--
-- Name: FUNCTION verify_truth_attestation(p_attestation_id uuid); Type: COMMENT; Schema: vision_verification; Owner: -
--

COMMENT ON FUNCTION vision_verification.verify_truth_attestation(p_attestation_id uuid) IS 'Verifies an existing truth attestation by recomputing hash';


SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: aci_shadow_evaluations; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.aci_shadow_evaluations (
    eval_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    asset_class text,
    sitc_score numeric(5,4),
    sitc_has_broken_chain boolean,
    sitc_failure_type text,
    sitc_verified_nodes integer,
    sitc_total_nodes integer,
    ikea_score numeric(5,4),
    ikea_has_fabrication boolean,
    ikea_has_stale_data boolean,
    ikea_has_unverifiable boolean,
    ikea_flagged_elements jsonb,
    ikea_data_freshness_hours numeric,
    inforage_api_cost_usd numeric(10,6),
    inforage_marginal_cost numeric(10,6),
    inforage_budget_pressure numeric(5,4),
    inforage_api_calls integer,
    evaluated_at timestamp with time zone DEFAULT now(),
    shadow_mode boolean DEFAULT true
);


--
-- Name: aci_triangle_shadow_evaluations; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.aci_triangle_shadow_evaluations (
    evaluation_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    sitc_chain_valid boolean DEFAULT true NOT NULL,
    sitc_failure_reason text,
    sitc_chain_hash text,
    inforage_cost_usd numeric(10,6) DEFAULT 0 NOT NULL,
    inforage_marginal_cost_per_eqs numeric(10,6),
    inforage_budget_check_passed boolean DEFAULT true NOT NULL,
    ikea_flagged boolean DEFAULT false NOT NULL,
    ikea_confidence_score numeric(5,4) DEFAULT 1.0 NOT NULL,
    ikea_flag_reason text,
    evaluated_at timestamp with time zone DEFAULT now() NOT NULL,
    asset_class text DEFAULT 'CRYPTO'::text NOT NULL,
    mode text DEFAULT 'SHADOW'::text NOT NULL
);


--
-- Name: canonical_outcomes; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.canonical_outcomes (
    outcome_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    trade_id uuid NOT NULL,
    trade_source text NOT NULL,
    symbol text NOT NULL,
    direction text NOT NULL,
    entry_price numeric NOT NULL,
    entry_timestamp timestamp with time zone NOT NULL,
    entry_regime text,
    entry_defcon integer,
    exit_price numeric NOT NULL,
    exit_timestamp timestamp with time zone NOT NULL,
    exit_reason text NOT NULL,
    exit_regime text,
    exit_defcon integer,
    pnl_absolute numeric NOT NULL,
    pnl_percent numeric NOT NULL,
    hold_duration_minutes integer NOT NULL,
    max_favorable_excursion numeric,
    max_adverse_excursion numeric,
    needle_eqs_score numeric,
    needle_hypothesis_category text,
    needle_target_asset text,
    needle_sitc_confidence text,
    captured_by text DEFAULT 'OUTCOME_CAPTURE_DAEMON'::text NOT NULL,
    captured_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT valid_direction CHECK ((direction = ANY (ARRAY['LONG'::text, 'SHORT'::text]))),
    CONSTRAINT valid_pnl CHECK ((pnl_absolute IS NOT NULL))
);


--
-- Name: TABLE canonical_outcomes; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON TABLE fhq_canonical.canonical_outcomes IS 'Ground truth outcome capture. CEO Directive CEO-G5-TRACE-2025-12-21.
No learning logic. No adaptive thresholds. Just facts.
Every closed trade produces exactly one canonical outcome.';


--
-- Name: eqs_distribution_snapshots; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.eqs_distribution_snapshots (
    snapshot_id uuid DEFAULT gen_random_uuid() NOT NULL,
    snapshot_date date NOT NULL,
    asset text NOT NULL,
    regime text NOT NULL,
    signal_state text DEFAULT 'DORMANT'::text NOT NULL,
    signal_count integer NOT NULL,
    min_eqs numeric(5,4),
    max_eqs numeric(5,4),
    median_eqs numeric(5,4),
    mean_eqs numeric(5,4),
    std_dev numeric(5,4),
    active_threshold numeric(5,4),
    count_above_threshold integer,
    pct_above_threshold numeric(5,2),
    p10 numeric(5,4),
    p25 numeric(5,4),
    p50 numeric(5,4),
    p75 numeric(5,4),
    p90 numeric(5,4),
    p95 numeric(5,4),
    p99 numeric(5,4),
    distribution_histogram jsonb,
    distribution_collapsed boolean DEFAULT false,
    collapse_reason text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: eqs_regime_baseline; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.eqs_regime_baseline (
    baseline_id uuid DEFAULT gen_random_uuid() NOT NULL,
    target_asset text NOT NULL,
    regime text NOT NULL,
    baseline_mean numeric(5,4) NOT NULL,
    baseline_std numeric(5,4) NOT NULL,
    baseline_median numeric(5,4),
    sample_size integer NOT NULL,
    computed_at timestamp with time zone DEFAULT now() NOT NULL,
    valid_from timestamp with time zone DEFAULT now() NOT NULL,
    valid_until timestamp with time zone,
    computed_by text DEFAULT 'STIG'::text NOT NULL,
    is_active boolean DEFAULT true
);


--
-- Name: TABLE eqs_regime_baseline; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON TABLE fhq_canonical.eqs_regime_baseline IS 'CEO-DIR-2025-EQS-003: Regime baselines for z-score/deviation-based EQS calculations.';


--
-- Name: eqs_threshold_config; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.eqs_threshold_config (
    config_id uuid DEFAULT gen_random_uuid() NOT NULL,
    threshold_value numeric(5,4) NOT NULL,
    effective_from timestamp with time zone DEFAULT now() NOT NULL,
    effective_until timestamp with time zone,
    proposed_by text NOT NULL,
    proposed_at timestamp with time zone DEFAULT now() NOT NULL,
    approved_by text,
    approved_at timestamp with time zone,
    enforced_by text,
    enforced_at timestamp with time zone,
    rationale text NOT NULL,
    calibration_evidence jsonb,
    selectivity_target text,
    version integer DEFAULT 1 NOT NULL,
    supersedes_config_id uuid,
    is_active boolean DEFAULT false,
    activation_signature text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT eqs_threshold_config_threshold_value_check CHECK (((threshold_value >= (0)::numeric) AND (threshold_value <= (1)::numeric)))
);


--
-- Name: evidence_bundles; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.evidence_bundles (
    bundle_id uuid DEFAULT gen_random_uuid() NOT NULL,
    query_text text NOT NULL,
    dense_results jsonb,
    sparse_results jsonb,
    rrf_fused_results jsonb,
    rrf_top_score numeric(10,6),
    snippet_ids uuid[],
    defcon_level character varying(10),
    regime character varying(20),
    query_cost_usd numeric(10,4),
    created_at timestamp with time zone DEFAULT now(),
    bundle_hash character varying(64),
    CONSTRAINT evidence_bundles_defcon_level_check CHECK (((defcon_level)::text = ANY ((ARRAY['GREEN'::character varying, 'YELLOW'::character varying, 'ORANGE'::character varying, 'RED'::character varying, 'BLACK'::character varying])::text[])))
);


--
-- Name: TABLE evidence_bundles; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON TABLE fhq_canonical.evidence_bundles IS '[C7] Evidence bundles for IKEA grounding. rrf_fused_results is JSONB array. snippet_ids references evidence_nodes.evidence_id (P9 convention).';


--
-- Name: evidence_nodes; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.evidence_nodes (
    evidence_id uuid DEFAULT gen_random_uuid() NOT NULL,
    content text NOT NULL,
    content_type text NOT NULL,
    source_type text NOT NULL,
    source_reference text,
    domain text DEFAULT 'FINANCE'::text NOT NULL,
    entity_type text,
    entity_id text,
    temporal_scope text,
    data_timestamp timestamp with time zone,
    expires_at timestamp with time zone,
    ttl_regime text DEFAULT 'NEUTRAL'::text,
    confidence_score numeric(5,4) DEFAULT 1.0,
    verification_status text DEFAULT 'UNVERIFIED'::text,
    verification_method text,
    verified_at timestamp with time zone,
    verified_by text,
    qdrant_collection text DEFAULT 'evidence_nodes'::text,
    qdrant_point_id text,
    embedding_model text DEFAULT 'text-embedding-3-small'::text,
    embedding_generated_at timestamp with time zone,
    content_hash text NOT NULL,
    hash_prev text,
    hash_self text,
    created_by text DEFAULT 'FINN'::text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    content_tsvector tsvector,
    court_proof_verified boolean DEFAULT false NOT NULL,
    source_preference integer DEFAULT 999 NOT NULL,
    trusted boolean DEFAULT false NOT NULL,
    quarantined boolean DEFAULT false NOT NULL,
    CONSTRAINT chk_quarantine_not_verified CHECK ((NOT ((quarantined = true) AND (court_proof_verified = true)))),
    CONSTRAINT evidence_confidence_range CHECK (((confidence_score >= (0)::numeric) AND (confidence_score <= (1)::numeric)))
);


--
-- Name: COLUMN evidence_nodes.court_proof_verified; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON COLUMN fhq_canonical.evidence_nodes.court_proof_verified IS 'TRUE if evidence has passed court-proof validation. Required for Qdrant sync.';


--
-- Name: COLUMN evidence_nodes.source_preference; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON COLUMN fhq_canonical.evidence_nodes.source_preference IS 'Lower = more trusted. 0=constitutional, 1=CEO, 10=automated. Default 999=untrusted.';


--
-- Name: COLUMN evidence_nodes.trusted; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON COLUMN fhq_canonical.evidence_nodes.trusted IS 'Explicit trust flag. Overrides source_preference threshold check.';


--
-- Name: COLUMN evidence_nodes.quarantined; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON COLUMN fhq_canonical.evidence_nodes.quarantined IS 'TRUE if evidence is flagged for review. Excluded from all retrieval.';


--
-- Name: evidence_relationships; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.evidence_relationships (
    relationship_id uuid DEFAULT gen_random_uuid() NOT NULL,
    from_evidence_id uuid NOT NULL,
    to_evidence_id uuid NOT NULL,
    relationship_type text NOT NULL,
    strength numeric(5,4) DEFAULT 1.0,
    traversal_weight numeric(5,4) DEFAULT 1.0,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT evidence_rel_not_self CHECK ((from_evidence_id <> to_evidence_id))
);


--
-- Name: evidence_graph_view; Type: VIEW; Schema: fhq_canonical; Owner: -
--

CREATE VIEW fhq_canonical.evidence_graph_view AS
 SELECT evidence_id,
    content,
    content_type,
    domain,
    entity_type,
    entity_id,
    data_timestamp,
    confidence_score,
    verification_status,
    qdrant_point_id,
    ( SELECT jsonb_agg(jsonb_build_object('evidence_id', r.to_evidence_id, 'relationship_type', r.relationship_type, 'strength', r.strength)) AS jsonb_agg
           FROM fhq_canonical.evidence_relationships r
          WHERE (r.from_evidence_id = e.evidence_id)) AS outgoing_relations,
    ( SELECT jsonb_agg(jsonb_build_object('evidence_id', r.from_evidence_id, 'relationship_type', r.relationship_type, 'strength', r.strength)) AS jsonb_agg
           FROM fhq_canonical.evidence_relationships r
          WHERE (r.to_evidence_id = e.evidence_id)) AS incoming_relations
   FROM fhq_canonical.evidence_nodes e
  WHERE ((verification_status <> 'FABRICATION'::text) AND ((expires_at IS NULL) OR (expires_at > now())));


--
-- Name: financial_ontology; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.financial_ontology (
    concept_id text NOT NULL,
    parent_concept_id text,
    label text NOT NULL,
    description text,
    ontology_source text DEFAULT 'FIBO'::text,
    level integer DEFAULT 0,
    path_from_root text,
    synonyms text[],
    related_concepts text[],
    usage_count integer DEFAULT 0,
    last_used_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: g4_1_composite_verdict; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g4_1_composite_verdict (
    verdict_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    g4_classification text NOT NULL,
    g4_sharpe numeric(8,4),
    stability_verdict text,
    regime_verdict text,
    sensitivity_verdict text,
    density_verdict text,
    edge_assessment text NOT NULL,
    classification_changed boolean DEFAULT false,
    final_classification text NOT NULL,
    classification_delta integer DEFAULT 0,
    g5_eligible boolean GENERATED ALWAYS AS (((edge_assessment = 'STABLE'::text) AND (final_classification = ANY (ARRAY['PLATINUM'::text, 'GOLD'::text])))) STORED,
    vega_reviewed boolean DEFAULT false,
    vega_attestation_hash text,
    vega_attested_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    lineage_preserved boolean DEFAULT true,
    CONSTRAINT g4_1_composite_verdict_edge_assessment_check CHECK ((edge_assessment = ANY (ARRAY['STABLE'::text, 'CONDITIONAL'::text, 'FRAGILE'::text, 'ILLUSORY'::text])))
);


--
-- Name: g4_1_density_results; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g4_1_density_results (
    result_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    total_signals_generated integer,
    signals_per_year numeric(8,2),
    signals_per_month numeric(8,2),
    edge_per_signal numeric(10,6),
    sharpe_per_signal numeric(10,6),
    max_concurrent_signals integer,
    avg_signal_gap_days numeric(8,2),
    min_signal_gap_days numeric(8,2),
    density_classification text NOT NULL,
    high_sharpe_extreme_sparsity boolean DEFAULT false,
    crowding_risk_detected boolean DEFAULT false,
    practical_viability text,
    tested_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT g4_1_density_results_density_classification_check CHECK ((density_classification = ANY (ARRAY['OPTIMAL'::text, 'SPARSE'::text, 'CROWDED'::text, 'THEORETICAL'::text]))),
    CONSTRAINT g4_1_density_results_practical_viability_check CHECK ((practical_viability = ANY (ARRAY['VIABLE'::text, 'CONDITIONAL'::text, 'IMPRACTICAL'::text])))
);


--
-- Name: g4_1_regime_rotation_results; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g4_1_regime_rotation_results (
    result_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    target_regime text NOT NULL,
    regime_dependent boolean NOT NULL,
    wrong_regime_tested text NOT NULL,
    wrong_regime_sharpe numeric(8,4),
    wrong_regime_trades integer,
    wrong_regime_win_rate numeric(5,4),
    edge_in_wrong_regime boolean,
    regime_specificity_confirmed boolean,
    rotation_verdict text NOT NULL,
    misclassification_detected boolean DEFAULT false,
    reclassification_required boolean DEFAULT false,
    tested_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT g4_1_regime_rotation_results_rotation_verdict_check CHECK ((rotation_verdict = ANY (ARRAY['REGIME_SPECIFIC'::text, 'REGIME_AGNOSTIC'::text, 'REGIME_INVERTED'::text, 'INSUFFICIENT_DATA'::text])))
);


--
-- Name: g4_1_sensitivity_results; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g4_1_sensitivity_results (
    result_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    baseline_params jsonb NOT NULL,
    baseline_sharpe numeric(8,4),
    perturbation_results jsonb NOT NULL,
    avg_sharpe_at_minus_20 numeric(8,4),
    avg_sharpe_at_minus_10 numeric(8,4),
    avg_sharpe_at_plus_10 numeric(8,4),
    avg_sharpe_at_plus_20 numeric(8,4),
    max_sharpe_drop_pct numeric(8,4),
    cliff_edge_detected boolean,
    smooth_degradation boolean,
    sensitivity_verdict text NOT NULL,
    downgrade_recommended boolean DEFAULT false,
    tested_at timestamp with time zone DEFAULT now() NOT NULL,
    perturbations_tested integer,
    CONSTRAINT g4_1_sensitivity_results_sensitivity_verdict_check CHECK ((sensitivity_verdict = ANY (ARRAY['ROBUST'::text, 'SENSITIVE'::text, 'BRITTLE'::text, 'CURVE_FIT'::text])))
);


--
-- Name: g4_1_stability_results; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g4_1_stability_results (
    result_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    original_classification text NOT NULL,
    original_sharpe numeric(8,4),
    window_count integer DEFAULT 3 NOT NULL,
    window_definitions jsonb NOT NULL,
    window_1_sharpe numeric(8,4),
    window_1_classification text,
    window_1_trades integer,
    window_1_passed boolean,
    window_2_sharpe numeric(8,4),
    window_2_classification text,
    window_2_trades integer,
    window_2_passed boolean,
    window_3_sharpe numeric(8,4),
    window_3_classification text,
    window_3_trades integer,
    window_3_passed boolean,
    windows_passed integer DEFAULT 0 NOT NULL,
    windows_failed integer DEFAULT 0 NOT NULL,
    stability_verdict text NOT NULL,
    classification_downgraded boolean DEFAULT false,
    new_classification text,
    downgrade_reason text,
    tested_at timestamp with time zone DEFAULT now() NOT NULL,
    test_duration_seconds numeric(10,2),
    CONSTRAINT g4_1_stability_results_stability_verdict_check CHECK ((stability_verdict = ANY (ARRAY['STABLE'::text, 'CONDITIONAL'::text, 'UNSTABLE'::text, 'ILLUSORY'::text])))
);


--
-- Name: g4_2_composite_verdict; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g4_2_composite_verdict (
    verdict_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    best_context_profile_id uuid,
    best_context_name text,
    best_contextual_sharpe numeric,
    best_suppression_rate numeric,
    best_trade_count integer,
    final_classification text NOT NULL,
    g5_eligible boolean DEFAULT false,
    g5_eligibility_reason text,
    validated_at timestamp with time zone DEFAULT now(),
    vega_attested boolean DEFAULT false,
    vega_attestation_at timestamp with time zone,
    CONSTRAINT g4_2_composite_verdict_final_classification_check CHECK ((final_classification = ANY (ARRAY['VALIDATED-CONTEXTUAL'::text, 'UNSTABLE-CONTEXTUAL'::text, 'INSUFFICIENT_SAMPLE'::text, 'ILLUSORY'::text, 'NO_VALID_CONTEXT'::text])))
);


--
-- Name: g4_2_context_profiles; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g4_2_context_profiles (
    profile_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    context_name text NOT NULL,
    context_definition jsonb NOT NULL,
    orthogonality_score numeric,
    orthogonality_verified boolean DEFAULT false,
    orthogonality_features jsonb,
    coverage_periods integer,
    total_periods integer,
    coverage_ratio numeric,
    created_by text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    vega_reviewed boolean DEFAULT false,
    vega_approved boolean DEFAULT false,
    vega_reviewed_at timestamp with time zone,
    vega_notes text,
    status text DEFAULT 'PENDING'::text,
    CONSTRAINT g4_2_context_profiles_status_check CHECK ((status = ANY (ARRAY['PENDING'::text, 'APPROVED'::text, 'REJECTED'::text, 'OVERFITTED'::text])))
);


--
-- Name: g4_2_contextual_backtest; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g4_2_contextual_backtest (
    backtest_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    profile_id uuid NOT NULL,
    context_name text NOT NULL,
    total_periods integer NOT NULL,
    permitted_periods integer NOT NULL,
    blocked_periods integer NOT NULL,
    suppression_rate numeric NOT NULL,
    trade_count integer NOT NULL,
    winning_trades integer,
    losing_trades integer,
    win_rate numeric,
    contextual_sharpe numeric,
    contextual_sortino numeric,
    contextual_max_dd numeric,
    contextual_total_return numeric,
    contextual_cagr numeric,
    ungated_sharpe numeric,
    ungated_max_dd numeric,
    damage_avoided_dd numeric,
    avg_context_duration integer,
    context_transitions integer,
    classification text,
    classification_reason jsonb,
    backtest_started_at timestamp with time zone,
    backtest_completed_at timestamp with time zone DEFAULT now(),
    CONSTRAINT g4_2_contextual_backtest_classification_check CHECK ((classification = ANY (ARRAY['VALIDATED-CONTEXTUAL'::text, 'UNSTABLE-CONTEXTUAL'::text, 'INSUFFICIENT_SAMPLE'::text, 'ILLUSORY'::text])))
);


--
-- Name: g4_2_parameters; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g4_2_parameters (
    parameter_name text NOT NULL,
    parameter_value numeric NOT NULL,
    description text,
    locked_at timestamp with time zone DEFAULT now(),
    locked_by text DEFAULT 'CEO_DIRECTIVE_WAVE_16C'::text,
    immutable boolean DEFAULT true
);


--
-- Name: g4_2_suppression_log; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g4_2_suppression_log (
    log_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    profile_id uuid,
    signal_timestamp timestamp with time zone NOT NULL,
    signal_direction text,
    signal_strength numeric,
    context_state jsonb,
    context_valid boolean NOT NULL,
    action text NOT NULL,
    block_reason text,
    hypothetical_pnl numeric,
    hypothetical_outcome text,
    logged_at timestamp with time zone DEFAULT now(),
    suppression_attribution text DEFAULT 'MARKET_DRIVEN'::text,
    CONSTRAINT g4_2_suppression_log_action_check CHECK ((action = ANY (ARRAY['PERMITTED'::text, 'BLOCKED'::text]))),
    CONSTRAINT g4_2_suppression_log_suppression_attribution_check CHECK ((suppression_attribution = ANY (ARRAY['SYSTEM_INIT'::text, 'MARKET_DRIVEN'::text, 'DEGRADED_MODE'::text, 'CONTEXT_STALE'::text])))
);


--
-- Name: g4_composite_scorecard; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g4_composite_scorecard (
    scorecard_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    refinery_result_id uuid,
    physics_result_id uuid,
    eqs_score numeric(5,4) NOT NULL,
    oos_sharpe numeric(8,4),
    decay_half_life_seconds numeric(10,2),
    classification text NOT NULL,
    eligible_for_g5 boolean GENERATED ALWAYS AS ((classification = 'PLATINUM'::text)) STORED,
    fdr_adjusted_p_value numeric(10,6),
    bonferroni_adjusted_p_value numeric(10,6),
    passes_fdr_threshold boolean,
    vega_attestation_hash text,
    vega_attested_at timestamp with time zone,
    scored_at timestamp with time zone DEFAULT now() NOT NULL,
    axis_a_historical_merit text,
    axis_b_physical_robustness text,
    axis_c_regime_dependence text,
    edge_map_coordinates jsonb,
    logic_translation_applied boolean DEFAULT false,
    hypothesis_category text,
    backtest_strategy_id text,
    CONSTRAINT g4_composite_scorecard_classification_check CHECK ((classification = ANY (ARRAY['PLATINUM'::text, 'GOLD'::text, 'SILVER'::text, 'BRONZE'::text, 'REJECT'::text, 'PENDING'::text]))),
    CONSTRAINT g4_scorecard_axis_a_check CHECK ((axis_a_historical_merit = ANY (ARRAY['STRONG'::text, 'MODERATE'::text, 'WEAK'::text, 'NONE'::text, 'NEGATIVE'::text]))),
    CONSTRAINT g4_scorecard_axis_b_check CHECK ((axis_b_physical_robustness = ANY (ARRAY['ROBUST'::text, 'FRAGILE'::text, 'THEORETICAL'::text]))),
    CONSTRAINT g4_scorecard_axis_c_check CHECK ((axis_c_regime_dependence = ANY (ARRAY['AGNOSTIC'::text, 'SPECIFIC'::text])))
);


--
-- Name: g4_logic_translation_registry; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g4_logic_translation_registry (
    strategy_id text NOT NULL,
    hypothesis_category text NOT NULL,
    strategy_name text NOT NULL,
    strategy_version text DEFAULT 'v1.0.0'::text NOT NULL,
    entry_logic jsonb NOT NULL,
    exit_logic jsonb NOT NULL,
    position_sizing jsonb,
    default_lookback_years integer DEFAULT 5,
    default_in_sample_ratio numeric(3,2) DEFAULT 0.70,
    requires_specific_indicators jsonb,
    requires_regime_data boolean DEFAULT false,
    regime_agnostic boolean DEFAULT false,
    applicable_regimes text[],
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by text DEFAULT 'STIG'::text,
    approved_by text,
    approval_timestamp timestamp with time zone,
    strategy_hash text,
    is_active boolean DEFAULT true
);


--
-- Name: g4_physics_results; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g4_physics_results (
    result_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    latency_50ms_return_pct numeric(10,4),
    latency_200ms_return_pct numeric(10,4),
    latency_1000ms_return_pct numeric(10,4),
    latency_sensitivity_per_100ms numeric(10,4),
    signal_half_life_seconds numeric(10,2),
    signal_decay_rate numeric(10,6),
    time_to_invalidation_seconds numeric(10,2),
    edge_retained_50ms_pct numeric(5,2),
    edge_retained_200ms_pct numeric(5,2),
    edge_retained_1000ms_pct numeric(5,2),
    survivability text NOT NULL,
    latency_profile jsonb,
    physics_started_at timestamp with time zone DEFAULT now() NOT NULL,
    physics_completed_at timestamp with time zone,
    duration_seconds numeric(10,2),
    physics_version text DEFAULT 'g4-physics-v1'::text,
    robustness_axis text,
    CONSTRAINT g4_physics_results_survivability_check CHECK ((survivability = ANY (ARRAY['ROBUST'::text, 'FRAGILE'::text, 'NON_VIABLE'::text]))),
    CONSTRAINT g4_physics_robustness_axis_check CHECK ((robustness_axis = ANY (ARRAY['ROBUST'::text, 'FRAGILE'::text, 'THEORETICAL'::text])))
);


--
-- Name: g4_refinery_results; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g4_refinery_results (
    result_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    lookback_years integer DEFAULT 5 NOT NULL,
    in_sample_ratio numeric(3,2) DEFAULT 0.70 NOT NULL,
    start_date date NOT NULL,
    end_date date NOT NULL,
    in_sample_end date NOT NULL,
    entry_cost_bps numeric(6,2) DEFAULT 5.0 NOT NULL,
    exit_cost_bps numeric(6,2) DEFAULT 5.0 NOT NULL,
    slippage_bps numeric(6,2) DEFAULT 5.0 NOT NULL,
    is_total_trades integer,
    is_win_rate numeric(5,4),
    is_net_return_pct numeric(10,4),
    is_sharpe_ratio numeric(8,4),
    is_sortino_ratio numeric(8,4),
    is_max_drawdown_pct numeric(8,4),
    is_profit_factor numeric(8,4),
    oos_total_trades integer,
    oos_win_rate numeric(5,4),
    oos_net_return_pct numeric(10,4),
    oos_sharpe_ratio numeric(8,4),
    oos_sortino_ratio numeric(8,4),
    oos_max_drawdown_pct numeric(8,4),
    oos_profit_factor numeric(8,4),
    oos_avg_holding_hours numeric(10,2),
    oos_p_value numeric(10,6),
    oos_t_statistic numeric(10,4),
    is_statistically_significant boolean GENERATED ALWAYS AS ((oos_p_value <= 0.05)) STORED,
    cull_classification text NOT NULL,
    trade_log jsonb,
    equity_curve_is jsonb,
    equity_curve_oos jsonb,
    backtest_started_at timestamp with time zone DEFAULT now() NOT NULL,
    backtest_completed_at timestamp with time zone,
    duration_seconds numeric(10,2),
    backtest_version text DEFAULT 'g4-refinery-v1'::text,
    validated_by text DEFAULT 'IoS-004'::text,
    historical_merit text,
    backtest_strategy_id text,
    backtest_strategy_version text,
    hypothesis_category text,
    logic_translation_hash text,
    CONSTRAINT g4_refinery_historical_merit_check CHECK ((historical_merit = ANY (ARRAY['STRONG'::text, 'MODERATE'::text, 'WEAK'::text, 'NONE'::text, 'NEGATIVE'::text]))),
    CONSTRAINT g4_refinery_results_cull_classification_check CHECK ((cull_classification = ANY (ARRAY['PASS'::text, 'QUARANTINE'::text, 'REJECT'::text])))
);


--
-- Name: g4_validation_queue; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g4_validation_queue (
    queue_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    priority integer DEFAULT 5 NOT NULL,
    refinery_status text DEFAULT 'PENDING'::text NOT NULL,
    physics_status text DEFAULT 'PENDING'::text NOT NULL,
    queued_at timestamp with time zone DEFAULT now() NOT NULL,
    refinery_started_at timestamp with time zone,
    refinery_completed_at timestamp with time zone,
    physics_started_at timestamp with time zone,
    physics_completed_at timestamp with time zone,
    refinery_error text,
    physics_error text,
    worker_id text,
    CONSTRAINT g4_validation_queue_physics_status_check CHECK ((physics_status = ANY (ARRAY['PENDING'::text, 'PROCESSING'::text, 'COMPLETED'::text, 'FAILED'::text, 'SKIPPED'::text]))),
    CONSTRAINT g4_validation_queue_refinery_status_check CHECK ((refinery_status = ANY (ARRAY['PENDING'::text, 'PROCESSING'::text, 'COMPLETED'::text, 'FAILED'::text, 'SKIPPED'::text])))
);


--
-- Name: g5_cco_health_log; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g5_cco_health_log (
    log_id uuid DEFAULT gen_random_uuid() NOT NULL,
    check_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    context_age_seconds numeric,
    cco_status text NOT NULL,
    previous_status text,
    triggered_degraded boolean DEFAULT false,
    triggered_unavailable boolean DEFAULT false,
    triggered_defcon boolean DEFAULT false,
    defcon_level_set integer,
    recovered_to_operational boolean DEFAULT false,
    recovery_timestamp timestamp with time zone,
    signals_blocked_count integer DEFAULT 0,
    signals_allowed_count integer DEFAULT 0
);


--
-- Name: g5_cco_state; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g5_cco_state (
    state_id uuid DEFAULT gen_random_uuid() NOT NULL,
    cco_status text DEFAULT 'INIT'::text NOT NULL,
    current_regime text,
    current_regime_confidence numeric,
    current_vol_percentile numeric,
    current_vol_state text,
    current_liquidity_state text,
    current_market_hours boolean,
    context_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    defcon_level integer DEFAULT 5,
    defcon_blocks_execution boolean DEFAULT false,
    global_permit_active boolean DEFAULT false,
    permit_reason text,
    updated_at timestamp with time zone DEFAULT now(),
    updated_by text DEFAULT 'CCO_DAEMON'::text,
    is_active boolean DEFAULT true,
    global_permit text DEFAULT 'UNKNOWN'::text,
    permit_attribution text DEFAULT 'SYSTEM_INIT'::text,
    context_hash text,
    input_hash text,
    source_tables text[] DEFAULT ARRAY[]::text[],
    valid_until timestamp with time zone,
    context_vector jsonb DEFAULT '{}'::jsonb,
    context_signature text,
    signed_by text,
    CONSTRAINT g5_cco_state_cco_status_check CHECK ((cco_status = ANY (ARRAY['INIT'::text, 'OPERATIONAL'::text, 'DEGRADED'::text, 'UNAVAILABLE'::text]))),
    CONSTRAINT g5_cco_state_global_permit_check CHECK ((global_permit = ANY (ARRAY['UNKNOWN'::text, 'PERMITTED'::text, 'SUPPRESSED'::text]))),
    CONSTRAINT g5_cco_state_permit_attribution_check CHECK ((permit_attribution = ANY (ARRAY['SYSTEM_INIT'::text, 'MARKET_DRIVEN'::text, 'DEGRADED_MODE'::text, 'UNAVAILABLE'::text])))
);


--
-- Name: TABLE g5_cco_state; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON TABLE fhq_canonical.g5_cco_state IS 'Central Context Orchestrator for WAVE 17 Paper Mode.
SEMANTIC LOCK (CEO WAVE 17A): "G5" is an internal technical label.
It is NOT a governance gate per ADR-004.
Live execution requires separate CEO Directive (out of scope).';


--
-- Name: g5_drift_metrics; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g5_drift_metrics (
    metric_id uuid DEFAULT gen_random_uuid() NOT NULL,
    computed_at timestamp with time zone DEFAULT now(),
    rolling_7day_avg_eqs numeric(5,3),
    rolling_7day_needle_count integer,
    rolling_7day_signal_count integer,
    rolling_7day_conversion_rate numeric(5,3),
    eqs_threshold numeric(5,3),
    conversion_threshold numeric(5,3),
    eqs_below_threshold boolean DEFAULT false,
    conversion_below_threshold boolean DEFAULT false,
    any_drift_detected boolean GENERATED ALWAYS AS ((eqs_below_threshold OR conversion_below_threshold)) STORED,
    alert_sent boolean DEFAULT false,
    throttling_triggered boolean DEFAULT false
);


--
-- Name: g5_exit_criteria_status; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g5_exit_criteria_status (
    status_id uuid DEFAULT gen_random_uuid() NOT NULL,
    total_paper_trades integer DEFAULT 0,
    paper_sharpe numeric,
    paper_max_drawdown numeric,
    paper_win_rate numeric,
    paper_start_date date,
    paper_duration_days integer DEFAULT 0,
    passes_min_trades boolean DEFAULT false,
    passes_sharpe boolean DEFAULT false,
    passes_drawdown boolean DEFAULT false,
    passes_win_rate boolean DEFAULT false,
    passes_duration boolean DEFAULT false,
    all_criteria_passed boolean DEFAULT false,
    g5_eligible_since timestamp with time zone,
    vega_attestation text DEFAULT 'PENDING'::text,
    vega_attestation_at timestamp with time zone,
    ceo_two_man_rule text DEFAULT 'PENDING'::text,
    ceo_approval_at timestamp with time zone,
    live_activation_authorized boolean DEFAULT false,
    live_activation_blocked_reason text,
    last_updated timestamp with time zone DEFAULT now(),
    is_active boolean DEFAULT true,
    CONSTRAINT g5_exit_criteria_status_ceo_two_man_rule_check CHECK ((ceo_two_man_rule = ANY (ARRAY['PENDING'::text, 'FULFILLED'::text, 'DENIED'::text]))),
    CONSTRAINT g5_exit_criteria_status_vega_attestation_check CHECK ((vega_attestation = ANY (ARRAY['PENDING'::text, 'G5_PASS'::text, 'G5_WARN'::text, 'G5_FAIL'::text])))
);


--
-- Name: g5_ingestion_pipeline; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g5_ingestion_pipeline (
    pipeline_id uuid DEFAULT gen_random_uuid() NOT NULL,
    batch_id text NOT NULL,
    batch_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    source_type text NOT NULL,
    needles_ingested integer DEFAULT 0,
    needle_ids uuid[],
    needles_passed_g4_1 integer DEFAULT 0,
    needles_passed_g4_2 integer DEFAULT 0,
    needles_g5_eligible integer DEFAULT 0,
    qualification_results jsonb DEFAULT '{}'::jsonb,
    pipeline_status text DEFAULT 'PENDING'::text,
    errors jsonb,
    started_at timestamp with time zone,
    completed_at timestamp with time zone,
    processed_by text DEFAULT 'INGESTION_DAEMON'::text,
    CONSTRAINT g5_ingestion_pipeline_pipeline_status_check CHECK ((pipeline_status = ANY (ARRAY['PENDING'::text, 'G4_1_RUNNING'::text, 'G4_2_RUNNING'::text, 'COMPLETED'::text, 'FAILED'::text]))),
    CONSTRAINT g5_ingestion_pipeline_source_type_check CHECK ((source_type = ANY (ARRAY['FINN_DISCOVERY'::text, 'MANUAL_SUBMISSION'::text, 'EXTERNAL_FEED'::text])))
);


--
-- Name: g5_paper_trades; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g5_paper_trades (
    trade_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    symbol text NOT NULL,
    direction text NOT NULL,
    entry_price numeric NOT NULL,
    exit_price numeric,
    position_size numeric NOT NULL,
    entry_context jsonb NOT NULL,
    entry_cco_status text NOT NULL,
    entry_vol_percentile numeric,
    entry_regime text,
    exit_context jsonb,
    exit_trigger text,
    pnl_absolute numeric,
    pnl_percent numeric,
    holding_periods integer,
    trade_outcome text,
    entry_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    exit_timestamp timestamp with time zone,
    logged_by text DEFAULT 'SILENT_SNIPER'::text,
    exclude_from_fss boolean DEFAULT false,
    exclusion_reason text,
    realized_pnl numeric(12,2) DEFAULT 0,
    decision_plan_id uuid,
    attempt_id uuid,
    CONSTRAINT g5_paper_trades_direction_check CHECK ((direction = ANY (ARRAY['LONG'::text, 'SHORT'::text]))),
    CONSTRAINT g5_paper_trades_trade_outcome_check CHECK ((trade_outcome = ANY (ARRAY['WIN'::text, 'LOSS'::text, 'BREAKEVEN'::text, 'OPEN'::text])))
);


--
-- Name: COLUMN g5_paper_trades.decision_plan_id; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON COLUMN fhq_canonical.g5_paper_trades.decision_plan_id IS 'CEO-DIR-2026-FINN-019 Issue #6: FK to decision_plans for execution linkage';


--
-- Name: COLUMN g5_paper_trades.attempt_id; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON COLUMN fhq_canonical.g5_paper_trades.attempt_id IS 'CEO-DIR-2026-FINN-019 Issue #6: FK to execution_attempts for audit trail';


--
-- Name: g5_pass_rate_history; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g5_pass_rate_history (
    history_id uuid DEFAULT gen_random_uuid() NOT NULL,
    window_start timestamp with time zone NOT NULL,
    window_end timestamp with time zone NOT NULL,
    total_evaluated integer DEFAULT 0,
    total_passed integer DEFAULT 0,
    pass_rate numeric(5,2),
    previous_pass_rate numeric(5,2),
    pass_rate_delta numeric(5,2),
    anomaly_detected boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: g5_pipeline_events; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g5_pipeline_events (
    event_id uuid DEFAULT gen_random_uuid() NOT NULL,
    event_type text NOT NULL,
    needle_id uuid,
    promotion_id uuid,
    signal_id uuid,
    event_data jsonb,
    severity text DEFAULT 'INFO'::text,
    defcon_escalation boolean DEFAULT false,
    defcon_level_set integer,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT g5_pipeline_events_event_type_check CHECK ((event_type = ANY (ARRAY['NEEDLE_INGESTED'::text, 'EVIDENCE_GENERATED'::text, 'GATE_A_EVALUATED'::text, 'GATE_B_EVALUATED'::text, 'SIGNAL_CREATED'::text, 'RATE_LIMIT_HIT'::text, 'SHADOW_DECISION'::text, 'SLA_BREACH'::text, 'PASS_RATE_ANOMALY'::text, 'DRIFT_DETECTED'::text, 'PIPELINE_PAUSED'::text, 'PIPELINE_RESUMED'::text, 'ROLLBACK_INITIATED'::text, 'ROLLBACK_COMPLETED'::text, 'RAMP_UP_ADVANCED'::text, 'CROSS_VERIFY_FAILED'::text]))),
    CONSTRAINT g5_pipeline_events_severity_check CHECK ((severity = ANY (ARRAY['DEBUG'::text, 'INFO'::text, 'WARN'::text, 'ERROR'::text, 'CRITICAL'::text])))
);


--
-- Name: g5_promotion_config; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g5_promotion_config (
    config_id uuid DEFAULT gen_random_uuid() NOT NULL,
    max_promotions_per_hour integer DEFAULT 50,
    rate_limit_enabled boolean DEFAULT true,
    shadow_mode_enabled boolean DEFAULT true,
    shadow_mode_until timestamp with time zone DEFAULT (now() + '24:00:00'::interval),
    shadow_review_count integer DEFAULT 0,
    shadow_review_required integer DEFAULT 50,
    ramp_up_percentage integer DEFAULT 10,
    ramp_up_stage integer DEFAULT 1,
    min_rolling_7day_eqs numeric(5,3) DEFAULT 0.85,
    min_conversion_rate numeric(5,3) DEFAULT 0.05,
    sla_evidence_gen_ms integer DEFAULT 5000,
    sla_gate_a_eval_ms integer DEFAULT 1000,
    sla_end_to_end_ms integer DEFAULT 30000,
    rollback_window_hours integer DEFAULT 24,
    pass_rate_change_threshold numeric(5,2) DEFAULT 20.0,
    pass_rate_window_minutes integer DEFAULT 60,
    pipeline_state text DEFAULT 'SHADOW'::text,
    paused_at timestamp with time zone,
    paused_reason text,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT g5_promotion_config_pipeline_state_check CHECK ((pipeline_state = ANY (ARRAY['SHADOW'::text, 'RAMP_10'::text, 'RAMP_50'::text, 'ACTIVE'::text, 'PAUSED'::text, 'HALTED'::text])))
);


--
-- Name: g5_promotion_ledger; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g5_promotion_ledger (
    promotion_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    gate_a_sitc_high boolean,
    gate_a_eqs_threshold boolean,
    gate_a_vega_evidence boolean,
    gate_a_canonical_immutable boolean,
    gate_a_passed boolean,
    gate_a_rejection_reason text,
    gate_a_evaluated_at timestamp with time zone,
    gate_b_economic_merit boolean,
    gate_b_classification text,
    gate_b_passed boolean,
    gate_b_rejection_reason text,
    gate_b_evaluated_at timestamp with time zone,
    gate_c_signal_instantiated boolean,
    gate_c_signal_state_id uuid,
    gate_c_evaluated_at timestamp with time zone,
    current_status fhq_canonical.needle_promotion_status DEFAULT 'NEEDLE'::fhq_canonical.needle_promotion_status,
    evidence_pack_hash text,
    canonical_hash text,
    signed_by text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    is_rolled_back boolean DEFAULT false,
    rolled_back_at timestamp with time zone,
    rolled_back_by text,
    rollback_reason text,
    rollback_ceo_approval text,
    rollback_vega_cosign text,
    evidence_hash_verified text,
    needle_lineage_hash text,
    cross_verification_passed boolean,
    cross_verification_mismatch_reason text
);


--
-- Name: TABLE g5_promotion_ledger; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON TABLE fhq_canonical.g5_promotion_ledger IS 'WAVE 17B: Audit trail for all needle promotion decisions';


--
-- Name: g5_promotion_rate_log; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g5_promotion_rate_log (
    log_id uuid DEFAULT gen_random_uuid() NOT NULL,
    hour_bucket timestamp with time zone NOT NULL,
    promotions_count integer DEFAULT 0,
    promotions_allowed integer DEFAULT 0,
    promotions_blocked integer DEFAULT 0,
    rate_limit_triggered boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: g5_shadow_decisions; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g5_shadow_decisions (
    shadow_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    would_pass_gate_a boolean,
    would_pass_gate_b boolean,
    would_create_signal boolean,
    would_be_signal_state text,
    gate_a_result jsonb,
    gate_b_result jsonb,
    vega_attestation_id uuid,
    evidence_pack_path text,
    evidence_gen_ms integer,
    gate_a_eval_ms integer,
    total_ms integer,
    reviewed boolean DEFAULT false,
    reviewed_by text,
    reviewed_at timestamp with time zone,
    review_notes text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: g5_signal_priority_queue; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g5_signal_priority_queue (
    queue_id uuid DEFAULT gen_random_uuid() NOT NULL,
    context_window_id uuid NOT NULL,
    context_timestamp timestamp with time zone NOT NULL,
    eligible_needle_ids uuid[] NOT NULL,
    eligible_count integer,
    selected_needle_id uuid,
    selection_orthogonality_score numeric,
    selection_reason jsonb DEFAULT '{}'::jsonb NOT NULL,
    execution_status text DEFAULT 'PENDING'::text,
    created_at timestamp with time zone DEFAULT now(),
    executed_at timestamp with time zone,
    created_by text DEFAULT 'CCO'::text,
    CONSTRAINT g5_signal_priority_queue_execution_status_check CHECK ((execution_status = ANY (ARRAY['PENDING'::text, 'EXECUTING'::text, 'FILLED'::text, 'REJECTED'::text, 'EXPIRED'::text, 'CANCELLED'::text])))
);


--
-- Name: g5_signal_state; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g5_signal_state (
    state_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    current_state text DEFAULT 'DORMANT'::text NOT NULL,
    state_entered_at timestamp with time zone DEFAULT now(),
    dormant_since timestamp with time zone,
    primed_at timestamp with time zone,
    executing_at timestamp with time zone,
    position_entered_at timestamp with time zone,
    cooling_started_at timestamp with time zone,
    cooling_periods_remaining integer DEFAULT 0,
    cooling_complete_at timestamp with time zone,
    position_direction text,
    position_entry_price numeric,
    position_size numeric,
    position_entry_context jsonb,
    exit_signal_triggered boolean DEFAULT false,
    exit_context_revoked boolean DEFAULT false,
    exit_stop_loss_hit boolean DEFAULT false,
    exit_reason text,
    exit_price numeric,
    exit_pnl numeric,
    last_transition text,
    last_transition_at timestamp with time zone,
    transition_count integer DEFAULT 0,
    updated_at timestamp with time zone DEFAULT now(),
    ephemeral_context_id uuid,
    ephemeral_primed_at timestamp with time zone,
    ephemeral_expires_at timestamp with time zone,
    ephemeral_position_scalar numeric(5,4) DEFAULT 0.5,
    is_ephemeral_promotion boolean DEFAULT false,
    CONSTRAINT g5_signal_state_current_state_check CHECK ((current_state = ANY (ARRAY['DORMANT'::text, 'PRIMED'::text, 'EXECUTING'::text, 'POSITION'::text, 'COOLING'::text, 'EXPIRED'::text, 'DUPLICATE_PRUNED'::text])))
);


--
-- Name: g5_sla_metrics; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g5_sla_metrics (
    metric_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid,
    promotion_id uuid,
    evidence_gen_start timestamp with time zone,
    evidence_gen_end timestamp with time zone,
    evidence_gen_ms integer,
    evidence_gen_sla_breach boolean DEFAULT false,
    gate_a_start timestamp with time zone,
    gate_a_end timestamp with time zone,
    gate_a_ms integer,
    gate_a_sla_breach boolean DEFAULT false,
    total_start timestamp with time zone,
    total_end timestamp with time zone,
    total_ms integer,
    total_sla_breach boolean DEFAULT false,
    any_breach boolean GENERATED ALWAYS AS ((evidence_gen_sla_breach OR gate_a_sla_breach OR total_sla_breach)) STORED,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: g5_state_transitions; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g5_state_transitions (
    transition_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    from_state text NOT NULL,
    to_state text NOT NULL,
    transition_trigger text NOT NULL,
    context_snapshot jsonb,
    cco_status text,
    transition_valid boolean DEFAULT true,
    validation_errors jsonb,
    transitioned_at timestamp with time zone DEFAULT now()
);


--
-- Name: g5_ttl_extension_requests; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.g5_ttl_extension_requests (
    request_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    original_ttl_days integer NOT NULL,
    requested_ttl_days integer NOT NULL,
    extension_reason text NOT NULL,
    lars_requested_at timestamp with time zone,
    lars_signature text,
    lars_approved boolean DEFAULT false,
    vega_reviewed_at timestamp with time zone,
    vega_signature text,
    vega_approved boolean DEFAULT false,
    stig_activated_at timestamp with time zone,
    stig_signature text,
    is_active boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: golden_needles; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.golden_needles (
    needle_id uuid DEFAULT gen_random_uuid() NOT NULL,
    hypothesis_id text NOT NULL,
    hunt_session_id uuid NOT NULL,
    cycle_id text NOT NULL,
    eqs_score numeric(5,4) NOT NULL,
    eqs_threshold_applied numeric(3,2) DEFAULT 0.85 NOT NULL,
    factor_price_technical boolean DEFAULT false NOT NULL,
    factor_volume_confirmation boolean DEFAULT false NOT NULL,
    factor_regime_alignment boolean DEFAULT false NOT NULL,
    factor_temporal_coherence boolean DEFAULT false NOT NULL,
    factor_catalyst_present boolean DEFAULT false NOT NULL,
    factor_specific_testable boolean DEFAULT false NOT NULL,
    factor_testable_criteria boolean DEFAULT false NOT NULL,
    confluence_factor_count integer GENERATED ALWAYS AS ((((((((factor_price_technical)::integer + (factor_volume_confirmation)::integer) + (factor_regime_alignment)::integer) + (factor_temporal_coherence)::integer) + (factor_catalyst_present)::integer) + (factor_specific_testable)::integer) + (factor_testable_criteria)::integer)) STORED NOT NULL,
    weight_price_technical numeric(4,3),
    weight_volume_confirmation numeric(4,3),
    weight_regime_alignment numeric(4,3),
    weight_temporal_coherence numeric(4,3),
    weight_catalyst_present numeric(4,3),
    weight_specificity_bonus numeric(4,3),
    weight_testability_bonus numeric(4,3),
    stress_modifier numeric(4,3) DEFAULT 1.0 NOT NULL,
    hypothesis_title text NOT NULL,
    hypothesis_statement text NOT NULL,
    hypothesis_category text,
    executive_summary text,
    sitc_plan_id uuid NOT NULL,
    sitc_confidence_level text NOT NULL,
    sitc_nodes_completed integer,
    sitc_nodes_total integer,
    chain_of_query_hash text,
    asrp_hash text NOT NULL,
    asrp_timestamp timestamp with time zone NOT NULL,
    state_vector_id uuid,
    state_hash_at_creation text,
    price_witness_id text NOT NULL,
    price_witness_symbol text NOT NULL,
    price_witness_value numeric(20,8) NOT NULL,
    price_witness_source text NOT NULL,
    price_witness_timestamp timestamp with time zone NOT NULL,
    regime_asset_id text DEFAULT 'BTC-USD'::text NOT NULL,
    regime_technical text,
    regime_sovereign text,
    regime_confidence numeric(5,4),
    regime_crio_driver text,
    regime_snapshot_timestamp timestamp with time zone,
    defcon_level integer NOT NULL,
    falsification_criteria jsonb,
    backtest_requirements jsonb,
    expected_timeframe_days integer DEFAULT 7 NOT NULL,
    target_asset text,
    validation_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    superseded_by uuid,
    supersession_reason text,
    is_current boolean DEFAULT true NOT NULL,
    g2_exam_session_id text,
    vega_attestation_id uuid,
    canonical_hash text NOT NULL,
    evidence_pack_path text,
    evidence_generated_at timestamp with time zone,
    dedup_hash text,
    eqs_score_v2 numeric(5,4),
    eqs_v2_tier text,
    eqs_v2_calculated_at timestamp with time zone,
    CONSTRAINT golden_needles_defcon_level_check CHECK (((defcon_level >= 1) AND (defcon_level <= 5))),
    CONSTRAINT golden_needles_eqs_score_check CHECK (((eqs_score >= 0.85) AND (eqs_score <= 1.0))),
    CONSTRAINT golden_needles_sitc_confidence_level_check CHECK ((sitc_confidence_level = ANY (ARRAY['HIGH'::text, 'MEDIUM'::text, 'LOW'::text])))
);


--
-- Name: COLUMN golden_needles.target_asset; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON COLUMN fhq_canonical.golden_needles.target_asset IS 'Canonical target asset identifier (e.g., BTC-USD, ETH-USD).
Required for EC-022 IKEA asset-class filtering.
CEO Directive: CEO-ACI-FINN-TA-2025-12-21';


--
-- Name: COLUMN golden_needles.eqs_score_v2; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON COLUMN fhq_canonical.golden_needles.eqs_score_v2 IS 'EQS v2 rank-based score (FINN design, CEO-DIR-2025-EQS-009)';


--
-- Name: COLUMN golden_needles.eqs_v2_tier; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON COLUMN fhq_canonical.golden_needles.eqs_v2_tier IS 'EQS v2 tier: S (>=0.95), A (>=0.88), B (>=0.78), C (<0.78)';


--
-- Name: COLUMN golden_needles.eqs_v2_calculated_at; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON COLUMN fhq_canonical.golden_needles.eqs_v2_calculated_at IS 'Timestamp of last EQS v2 calculation';


--
-- Name: needle_chain_links; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.needle_chain_links (
    link_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    chain_node_id uuid NOT NULL,
    node_sequence integer NOT NULL,
    node_type text NOT NULL,
    node_hash text,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: needle_validity_config; Type: TABLE; Schema: fhq_canonical; Owner: -
--

CREATE TABLE fhq_canonical.needle_validity_config (
    config_id uuid DEFAULT gen_random_uuid() NOT NULL,
    validity_days integer DEFAULT 7 NOT NULL,
    auto_expire_enabled boolean DEFAULT true NOT NULL,
    last_sentinel_run timestamp with time zone,
    needles_expired_total bigint DEFAULT 0 NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone,
    updated_by text
);


--
-- Name: TABLE needle_validity_config; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON TABLE fhq_canonical.needle_validity_config IS 'CEO-DIR-2026-01-03: Golden needle validity configuration (corporate standard: 7 days)';


--
-- Name: v_daily_dormant_signals_report; Type: VIEW; Schema: fhq_canonical; Owner: -
--

CREATE VIEW fhq_canonical.v_daily_dormant_signals_report AS
 WITH age_buckets AS (
         SELECT
                CASE
                    WHEN (gn.created_at > (now() - '1 day'::interval)) THEN '< 1 day'::text
                    WHEN (gn.created_at > (now() - '3 days'::interval)) THEN '1-3 days'::text
                    WHEN (gn.created_at > (now() - '7 days'::interval)) THEN '3-7 days'::text
                    ELSE '> 7 days (STALE)'::text
                END AS age_bucket,
            count(*) AS count,
            count(DISTINCT gn.dedup_hash) AS unique_hypotheses
           FROM (fhq_canonical.g5_signal_state ss
             JOIN fhq_canonical.golden_needles gn ON ((ss.needle_id = gn.needle_id)))
          WHERE (ss.current_state = 'DORMANT'::text)
          GROUP BY
                CASE
                    WHEN (gn.created_at > (now() - '1 day'::interval)) THEN '< 1 day'::text
                    WHEN (gn.created_at > (now() - '3 days'::interval)) THEN '1-3 days'::text
                    WHEN (gn.created_at > (now() - '7 days'::interval)) THEN '3-7 days'::text
                    ELSE '> 7 days (STALE)'::text
                END
        ), dedup_stats AS (
         SELECT gn.hypothesis_title,
            count(*) AS duplicates
           FROM (fhq_canonical.g5_signal_state ss
             JOIN fhq_canonical.golden_needles gn ON ((ss.needle_id = gn.needle_id)))
          WHERE (ss.current_state = 'DORMANT'::text)
          GROUP BY gn.hypothesis_title
         HAVING (count(*) > 1)
        ), summary AS (
         SELECT count(*) AS total_dormant,
            count(DISTINCT gn.dedup_hash) AS unique_hypotheses,
            (count(*) - count(DISTINCT gn.dedup_hash)) AS duplicate_count,
            round(((100.0 * ((count(*) - count(DISTINCT gn.dedup_hash)))::numeric) / (NULLIF(count(*), 0))::numeric), 1) AS duplicate_pct,
            min(gn.created_at) AS oldest_signal,
            max(gn.created_at) AS newest_signal,
            round(avg(gn.eqs_score), 3) AS avg_eqs_score
           FROM (fhq_canonical.g5_signal_state ss
             JOIN fhq_canonical.golden_needles gn ON ((ss.needle_id = gn.needle_id)))
          WHERE (ss.current_state = 'DORMANT'::text)
        )
 SELECT now() AS report_timestamp,
    total_dormant,
    unique_hypotheses,
    duplicate_count,
    duplicate_pct,
    oldest_signal,
    newest_signal,
    avg_eqs_score,
    ( SELECT count(*) AS count
           FROM dedup_stats) AS hypotheses_with_duplicates,
    ( SELECT jsonb_agg(jsonb_build_object('bucket', age_buckets.age_bucket, 'count', age_buckets.count, 'unique', age_buckets.unique_hypotheses)) AS jsonb_agg
           FROM age_buckets) AS age_distribution
   FROM summary s;


--
-- Name: v_eqs_cross_sectional_rank; Type: VIEW; Schema: fhq_canonical; Owner: -
--

CREATE VIEW fhq_canonical.v_eqs_cross_sectional_rank AS
 SELECT gn.needle_id,
    gn.target_asset,
    gn.regime_technical,
    gn.eqs_score,
    gn.hypothesis_title,
    gn.created_at,
    ss.current_state,
    round((percent_rank() OVER (PARTITION BY gn.target_asset, gn.regime_technical ORDER BY gn.eqs_score DESC))::numeric, 4) AS percentile_rank,
    dense_rank() OVER (PARTITION BY gn.target_asset, gn.regime_technical ORDER BY gn.eqs_score DESC) AS dense_rank,
    count(*) OVER (PARTITION BY gn.target_asset, gn.regime_technical) AS partition_size
   FROM (fhq_canonical.golden_needles gn
     JOIN fhq_canonical.g5_signal_state ss ON ((gn.needle_id = ss.needle_id)))
  WHERE (ss.current_state = 'DORMANT'::text);


--
-- Name: VIEW v_eqs_cross_sectional_rank; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON VIEW fhq_canonical.v_eqs_cross_sectional_rank IS 'CEO-DIR-2025-EQS-003: Cross-sectional ranking view for FINN EQS analysis. Read-only.';


--
-- Name: v_eqs_distribution_alerts; Type: VIEW; Schema: fhq_canonical; Owner: -
--

CREATE VIEW fhq_canonical.v_eqs_distribution_alerts AS
 SELECT snapshot_date,
    asset,
    regime,
    signal_count,
    median_eqs,
    pct_above_threshold,
    active_threshold,
    collapse_reason,
        CASE
            WHEN (pct_above_threshold > (90)::numeric) THEN 'CRITICAL'::text
            WHEN (pct_above_threshold > (75)::numeric) THEN 'HIGH'::text
            WHEN (pct_above_threshold > (50)::numeric) THEN 'MEDIUM'::text
            ELSE 'OK'::text
        END AS alert_level
   FROM fhq_canonical.eqs_distribution_snapshots
  WHERE (distribution_collapsed = true)
  ORDER BY snapshot_date DESC, pct_above_threshold DESC;


--
-- Name: v_g4_edge_cartography; Type: VIEW; Schema: fhq_canonical; Owner: -
--

CREATE VIEW fhq_canonical.v_g4_edge_cartography AS
 SELECT gn.needle_id,
    gn.hypothesis_title,
    gn.hypothesis_category,
    gn.eqs_score,
    gn.regime_sovereign,
    COALESCE(sc.axis_a_historical_merit, 'PENDING'::text) AS axis_a_historical_merit,
    rr.oos_sharpe_ratio,
    COALESCE(sc.axis_b_physical_robustness, 'PENDING'::text) AS axis_b_physical_robustness,
    pr.edge_retained_1000ms_pct,
    pr.signal_half_life_seconds,
    COALESCE(sc.axis_c_regime_dependence, 'PENDING'::text) AS axis_c_regime_dependence,
    COALESCE(sc.classification, 'PENDING'::text) AS classification,
    sc.eligible_for_g5,
    COALESCE(sc.logic_translation_applied, false) AS logic_translation_applied,
    sc.backtest_strategy_id,
    q.refinery_status,
    q.physics_status,
    gn.created_at AS needle_created,
    sc.scored_at AS scorecard_created
   FROM ((((fhq_canonical.golden_needles gn
     LEFT JOIN fhq_canonical.g4_validation_queue q ON ((gn.needle_id = q.needle_id)))
     LEFT JOIN fhq_canonical.g4_refinery_results rr ON ((gn.needle_id = rr.needle_id)))
     LEFT JOIN fhq_canonical.g4_physics_results pr ON ((gn.needle_id = pr.needle_id)))
     LEFT JOIN fhq_canonical.g4_composite_scorecard sc ON ((gn.needle_id = sc.needle_id)))
  WHERE (gn.is_current = true)
  ORDER BY gn.eqs_score DESC, gn.created_at DESC;


--
-- Name: v_golden_needle_audit; Type: VIEW; Schema: fhq_canonical; Owner: -
--

CREATE VIEW fhq_canonical.v_golden_needle_audit AS
 SELECT needle_id,
    hypothesis_title,
    eqs_score,
    confluence_factor_count,
    array_remove(ARRAY[
        CASE
            WHEN factor_price_technical THEN 'PRICE_TECHNICAL'::text
            ELSE NULL::text
        END,
        CASE
            WHEN factor_volume_confirmation THEN 'VOLUME_CONFIRMATION'::text
            ELSE NULL::text
        END,
        CASE
            WHEN factor_regime_alignment THEN 'REGIME_ALIGNMENT'::text
            ELSE NULL::text
        END,
        CASE
            WHEN factor_temporal_coherence THEN 'TEMPORAL_COHERENCE'::text
            ELSE NULL::text
        END,
        CASE
            WHEN factor_catalyst_present THEN 'CATALYST_PRESENT'::text
            ELSE NULL::text
        END,
        CASE
            WHEN factor_specific_testable THEN 'SPECIFIC_TESTABLE'::text
            ELSE NULL::text
        END,
        CASE
            WHEN factor_testable_criteria THEN 'TESTABLE_CRITERIA'::text
            ELSE NULL::text
        END], NULL::text) AS confluence_factors,
    ((price_witness_symbol || ' = $'::text) || (price_witness_value)::text) AS price_at_detection,
    price_witness_timestamp,
    price_witness_source,
    ((regime_sovereign || '/'::text) || regime_technical) AS regime_state,
    defcon_level,
    asrp_hash,
    asrp_timestamp,
    sitc_plan_id,
    sitc_confidence_level,
    validation_timestamp,
    created_at,
    canonical_hash,
    is_current
   FROM fhq_canonical.golden_needles gn
  WHERE (is_current = true)
  ORDER BY created_at DESC;


--
-- Name: VIEW v_golden_needle_audit; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON VIEW fhq_canonical.v_golden_needle_audit IS 'Audit-ready view of all current Golden Needles with full context reconstruction.';


--
-- Name: v_golden_needles_active_eqs; Type: VIEW; Schema: fhq_canonical; Owner: -
--

CREATE VIEW fhq_canonical.v_golden_needles_active_eqs AS
 SELECT needle_id,
    hypothesis_id,
    hunt_session_id,
    cycle_id,
    eqs_score,
    eqs_threshold_applied,
    factor_price_technical,
    factor_volume_confirmation,
    factor_regime_alignment,
    factor_temporal_coherence,
    factor_catalyst_present,
    factor_specific_testable,
    factor_testable_criteria,
    confluence_factor_count,
    weight_price_technical,
    weight_volume_confirmation,
    weight_regime_alignment,
    weight_temporal_coherence,
    weight_catalyst_present,
    weight_specificity_bonus,
    weight_testability_bonus,
    stress_modifier,
    hypothesis_title,
    hypothesis_statement,
    hypothesis_category,
    executive_summary,
    sitc_plan_id,
    sitc_confidence_level,
    sitc_nodes_completed,
    sitc_nodes_total,
    chain_of_query_hash,
    asrp_hash,
    asrp_timestamp,
    state_vector_id,
    state_hash_at_creation,
    price_witness_id,
    price_witness_symbol,
    price_witness_value,
    price_witness_source,
    price_witness_timestamp,
    regime_asset_id,
    regime_technical,
    regime_sovereign,
    regime_confidence,
    regime_crio_driver,
    regime_snapshot_timestamp,
    defcon_level,
    falsification_criteria,
    backtest_requirements,
    expected_timeframe_days,
    target_asset,
    validation_timestamp,
    created_at,
    superseded_by,
    supersession_reason,
    is_current,
    g2_exam_session_id,
    vega_attestation_id,
    canonical_hash,
    evidence_pack_path,
    evidence_generated_at,
    dedup_hash,
    eqs_score_v2,
    eqs_v2_tier,
    eqs_v2_calculated_at,
    COALESCE(eqs_score_v2, eqs_score) AS eqs_active_score,
        CASE
            WHEN (eqs_score_v2 IS NOT NULL) THEN 'v2'::text
            ELSE 'v1'::text
        END AS eqs_active_version,
    COALESCE(eqs_v2_tier,
        CASE
            WHEN (eqs_score >= 0.95) THEN 'S'::text
            WHEN (eqs_score >= 0.88) THEN 'A'::text
            WHEN (eqs_score >= 0.78) THEN 'B'::text
            ELSE 'C'::text
        END) AS eqs_active_tier
   FROM fhq_canonical.golden_needles gn;


--
-- Name: VIEW v_golden_needles_active_eqs; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON VIEW fhq_canonical.v_golden_needles_active_eqs IS 'Golden needles with active EQS score (v2 primary, v1 fallback per CEO-DIR-2025-EQS-009)';


--
-- Name: v_needle_freshness_status; Type: VIEW; Schema: fhq_canonical; Owner: -
--

CREATE VIEW fhq_canonical.v_needle_freshness_status AS
 SELECT count(*) FILTER (WHERE (is_current = true)) AS current_needles,
    count(*) FILTER (WHERE ((is_current = true) AND (created_at >= (now() - '1 day'::interval)))) AS fresh_1d,
    count(*) FILTER (WHERE ((is_current = true) AND (created_at >= (now() - '3 days'::interval)))) AS fresh_3d,
    count(*) FILTER (WHERE ((is_current = true) AND (created_at >= (now() - '7 days'::interval)))) AS fresh_7d,
    count(*) FILTER (WHERE ((is_current = true) AND (created_at < (now() - '7 days'::interval)))) AS stale_count,
    min(created_at) FILTER (WHERE (is_current = true)) AS oldest_current,
    max(created_at) FILTER (WHERE (is_current = true)) AS newest_current,
    EXTRACT(day FROM (now() - max(created_at) FILTER (WHERE (is_current = true)))) AS days_since_newest,
        CASE
            WHEN (max(created_at) FILTER (WHERE (is_current = true)) >= (now() - '7 days'::interval)) THEN 'VALID'::text
            WHEN (max(created_at) FILTER (WHERE (is_current = true)) IS NULL) THEN 'EMPTY'::text
            ELSE 'STALE'::text
        END AS inventory_status
   FROM fhq_canonical.golden_needles;


--
-- Name: VIEW v_needle_freshness_status; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON VIEW fhq_canonical.v_needle_freshness_status IS 'CEO-DIR-2026-01-03: Dashboard view for golden needle freshness monitoring';


--
-- Name: v_outcome_summary; Type: VIEW; Schema: fhq_canonical; Owner: -
--

CREATE VIEW fhq_canonical.v_outcome_summary AS
 SELECT needle_id,
    trade_id,
    symbol,
    direction,
    entry_price,
    exit_price,
    pnl_absolute,
    pnl_percent,
    exit_reason,
    hold_duration_minutes,
    needle_eqs_score,
    needle_hypothesis_category,
    needle_target_asset,
    exit_timestamp,
        CASE
            WHEN (pnl_absolute > (0)::numeric) THEN 'WIN'::text
            WHEN (pnl_absolute < (0)::numeric) THEN 'LOSS'::text
            ELSE 'BREAKEVEN'::text
        END AS outcome_class
   FROM fhq_canonical.canonical_outcomes co
  ORDER BY exit_timestamp DESC;


--
-- Name: VIEW v_outcome_summary; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON VIEW fhq_canonical.v_outcome_summary IS 'Summary view of canonical outcomes for analysis.
Ground truth only - no derived metrics or learning signals.';


--
-- Name: v_pipeline_status; Type: VIEW; Schema: fhq_canonical; Owner: -
--

CREATE VIEW fhq_canonical.v_pipeline_status AS
 SELECT pipeline_state,
    shadow_mode_enabled,
    shadow_mode_until,
    shadow_review_count,
    shadow_review_required,
    ramp_up_percentage,
    ramp_up_stage,
    max_promotions_per_hour,
    rate_limit_enabled,
    paused_at,
    paused_reason,
    COALESCE(( SELECT g5_promotion_rate_log.promotions_count
           FROM fhq_canonical.g5_promotion_rate_log
          WHERE (g5_promotion_rate_log.hour_bucket = date_trunc('hour'::text, now()))
          ORDER BY g5_promotion_rate_log.created_at DESC
         LIMIT 1), 0) AS current_hour_promotions,
    ( SELECT g5_drift_metrics.rolling_7day_avg_eqs
           FROM fhq_canonical.g5_drift_metrics
          ORDER BY g5_drift_metrics.computed_at DESC
         LIMIT 1) AS latest_avg_eqs,
    ( SELECT g5_drift_metrics.rolling_7day_conversion_rate
           FROM fhq_canonical.g5_drift_metrics
          ORDER BY g5_drift_metrics.computed_at DESC
         LIMIT 1) AS latest_conversion_rate,
    ( SELECT g5_drift_metrics.any_drift_detected
           FROM fhq_canonical.g5_drift_metrics
          ORDER BY g5_drift_metrics.computed_at DESC
         LIMIT 1) AS drift_detected,
    ( SELECT count(*) AS count
           FROM fhq_canonical.g5_sla_metrics
          WHERE ((g5_sla_metrics.any_breach = true) AND (g5_sla_metrics.created_at > (now() - '24:00:00'::interval)))) AS sla_breaches_24h,
    ( SELECT count(*) AS count
           FROM fhq_canonical.g5_shadow_decisions
          WHERE (g5_shadow_decisions.reviewed = false)) AS shadow_pending_review,
    updated_at AS config_updated_at
   FROM fhq_canonical.g5_promotion_config pc
  WHERE (is_active = true);


--
-- Name: v_promotion_funnel; Type: VIEW; Schema: fhq_canonical; Owner: -
--

CREATE VIEW fhq_canonical.v_promotion_funnel AS
 WITH needle_stats AS (
         SELECT gn.needle_id,
            gn.hypothesis_title,
            gn.eqs_score,
            gn.sitc_confidence_level,
            gn.vega_attestation_id,
            gn.canonical_hash,
            gn.created_at,
            (gn.sitc_confidence_level = 'HIGH'::text) AS gate_a_sitc,
            (gn.eqs_score >= 0.85) AS gate_a_eqs,
            (gn.vega_attestation_id IS NOT NULL) AS gate_a_vega,
            (gn.canonical_hash IS NOT NULL) AS gate_a_canonical,
            ((gn.sitc_confidence_level = 'HIGH'::text) AND (gn.eqs_score >= 0.85) AND (gn.vega_attestation_id IS NOT NULL) AND (gn.canonical_hash IS NOT NULL)) AS passes_gate_a
           FROM fhq_canonical.golden_needles gn
          WHERE (gn.is_current = true)
        )
 SELECT count(*) AS total_needles,
    count(*) FILTER (WHERE passes_gate_a) AS admissible_candidates,
    count(*) FILTER (WHERE (NOT passes_gate_a)) AS rejected_admissibility,
    round(((100.0 * (count(*) FILTER (WHERE passes_gate_a))::numeric) / (NULLIF(count(*), 0))::numeric), 1) AS gate_a_pass_rate,
    count(*) FILTER (WHERE (NOT gate_a_sitc)) AS reject_sitc_not_high,
    count(*) FILTER (WHERE (NOT gate_a_eqs)) AS reject_eqs_below_085,
    count(*) FILTER (WHERE (NOT gate_a_vega)) AS reject_no_vega_evidence,
    count(*) FILTER (WHERE (NOT gate_a_canonical)) AS reject_no_canonical,
    round(avg(eqs_score), 3) AS avg_eqs,
    round(min(eqs_score), 3) AS min_eqs,
    round(max(eqs_score), 3) AS max_eqs
   FROM needle_stats;


--
-- Name: VIEW v_promotion_funnel; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON VIEW fhq_canonical.v_promotion_funnel IS 'WAVE 17B: Panel A/B metrics for Control Room';


--
-- Name: v_regime_diversity_status; Type: VIEW; Schema: fhq_canonical; Owner: -
--

CREATE VIEW fhq_canonical.v_regime_diversity_status AS
 WITH regime_counts AS (
         SELECT COALESCE(gn.regime_technical, 'NULL'::text) AS regime,
            count(*) AS signal_count,
            min(gn.created_at) AS earliest_signal,
            max(gn.created_at) AS latest_signal
           FROM (fhq_canonical.golden_needles gn
             JOIN fhq_canonical.g5_signal_state ss ON ((gn.needle_id = ss.needle_id)))
          WHERE (ss.current_state = 'DORMANT'::text)
          GROUP BY gn.regime_technical
        ), total AS (
         SELECT sum(regime_counts.signal_count) AS total_count
           FROM regime_counts
        )
 SELECT rc.regime,
    rc.signal_count,
    round(((100.0 * (rc.signal_count)::numeric) / t.total_count), 2) AS pct_of_total,
    rc.earliest_signal,
    rc.latest_signal,
        CASE
            WHEN (( SELECT count(DISTINCT regime_counts.regime) AS count
               FROM regime_counts) < 3) THEN 'COLLAPSED'::text
            WHEN (( SELECT max(((100.0 * (regime_counts.signal_count)::numeric) / t_1.total_count)) AS max
               FROM regime_counts,
                total t_1) > (80)::numeric) THEN 'SKEWED'::text
            ELSE 'HEALTHY'::text
        END AS diversity_status,
        CASE
            WHEN (( SELECT count(DISTINCT regime_counts.regime) AS count
               FROM regime_counts) < 3) THEN 'EQS regime-sensitivity BLOCKED until classifier produces BULL/BEAR/NEUTRAL variance'::text
            ELSE 'Regime diversity sufficient for EQS validation'::text
        END AS finn_guidance
   FROM regime_counts rc,
    total t
  ORDER BY rc.signal_count DESC;


--
-- Name: VIEW v_regime_diversity_status; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON VIEW fhq_canonical.v_regime_diversity_status IS 'CEO-DIR-2025-EQS-003: Surfaces regime classifier dependency for FINN. Shows diversity status.';


--
-- Name: v_signal_arsenal; Type: VIEW; Schema: fhq_canonical; Owner: -
--

CREATE VIEW fhq_canonical.v_signal_arsenal AS
 SELECT current_state,
    count(*) AS count,
    max(state_entered_at) AS latest_entry,
    min(state_entered_at) AS oldest_entry
   FROM fhq_canonical.g5_signal_state
  GROUP BY current_state
  ORDER BY
        CASE current_state
            WHEN 'DORMANT'::text THEN 1
            WHEN 'PRIMED'::text THEN 2
            WHEN 'ARMED'::text THEN 3
            WHEN 'EXECUTING'::text THEN 4
            WHEN 'POSITION'::text THEN 5
            WHEN 'COOLING'::text THEN 6
            ELSE 7
        END;


--
-- Name: VIEW v_signal_arsenal; Type: COMMENT; Schema: fhq_canonical; Owner: -
--

COMMENT ON VIEW fhq_canonical.v_signal_arsenal IS 'WAVE 17B: Panel C signal state counts';


--
-- Name: ab_test_results; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.ab_test_results (
    test_id uuid DEFAULT gen_random_uuid() NOT NULL,
    test_date date NOT NULL,
    variant_a text NOT NULL,
    variant_b text NOT NULL,
    variant_a_return numeric,
    variant_b_return numeric,
    variant_a_sharpe numeric,
    variant_b_sharpe numeric,
    variant_a_max_drawdown numeric,
    variant_b_max_drawdown numeric,
    p_value numeric,
    is_significant boolean,
    winning_variant text,
    improvement_pct numeric,
    test_start_date date NOT NULL,
    test_end_date date NOT NULL,
    days_tested integer,
    created_at timestamp without time zone DEFAULT now()
);


--
-- Name: anomalies; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.anomalies (
    id integer NOT NULL,
    "timestamp" timestamp with time zone NOT NULL,
    asset_id text NOT NULL,
    is_anomaly boolean NOT NULL,
    anomaly_score numeric(5,4),
    anomaly_type text,
    model_version text NOT NULL,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT anomalies_anomaly_score_check CHECK (((anomaly_score >= (0)::numeric) AND (anomaly_score <= (1)::numeric)))
);


--
-- Name: TABLE anomalies; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON TABLE fhq_finn.anomalies IS 'ADR-052 Model 3: Anomaly Detector outputs';


--
-- Name: anomalies_id_seq; Type: SEQUENCE; Schema: fhq_finn; Owner: -
--

CREATE SEQUENCE fhq_finn.anomalies_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: anomalies_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_finn; Owner: -
--

ALTER SEQUENCE fhq_finn.anomalies_id_seq OWNED BY fhq_finn.anomalies.id;


--
-- Name: cognitive_dissonance_scores; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.cognitive_dissonance_scores (
    cds_id uuid DEFAULT gen_random_uuid() NOT NULL,
    symbol text NOT NULL,
    analysis_date date NOT NULL,
    cds_score numeric NOT NULL,
    narrative_score numeric NOT NULL,
    ssi_score numeric NOT NULL,
    dissonance_level text NOT NULL,
    structural_top_risk boolean NOT NULL,
    regime text,
    market_phase text,
    model_version text DEFAULT '2.0.0'::text,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT cognitive_dissonance_scores_dissonance_level_check CHECK ((dissonance_level = ANY (ARRAY['low'::text, 'moderate'::text, 'high'::text, 'extreme'::text])))
);


--
-- Name: contract_versions; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.contract_versions (
    version text NOT NULL,
    adr_reference text NOT NULL,
    input_schema jsonb NOT NULL,
    output_schema jsonb NOT NULL,
    effective_from timestamp without time zone DEFAULT now() NOT NULL,
    effective_to timestamp without time zone,
    deprecated boolean DEFAULT false,
    metadata jsonb DEFAULT '{}'::jsonb
);


--
-- Name: TABLE contract_versions; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON TABLE fhq_finn.contract_versions IS 'ADR-052 I/O Contract Versioning - Immutable record of FINN input/output schemas';


--
-- Name: daily_briefings; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.daily_briefings (
    briefing_id uuid DEFAULT gen_random_uuid() NOT NULL,
    briefing_date date NOT NULL,
    macro_summary text NOT NULL,
    crypto_summary text NOT NULL,
    equity_summary text,
    risk_events text,
    top_signals jsonb DEFAULT '[]'::jsonb NOT NULL,
    detected_regime text,
    regime_confidence numeric,
    overall_sentiment text,
    sentiment_score numeric,
    critical_events integer DEFAULT 0,
    news_count integer DEFAULT 0,
    macro_events integer DEFAULT 0,
    model_version text NOT NULL,
    prompt_template_version text,
    total_tokens_used integer,
    content_sha256 text,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    created_by text DEFAULT 'FINN_LLM_SECRETARY'::text,
    reviewed boolean DEFAULT false,
    reviewed_by text,
    reviewed_at timestamp without time zone,
    CONSTRAINT daily_briefings_detected_regime_check CHECK ((detected_regime = ANY (ARRAY['BULL'::text, 'NEUTRAL'::text, 'BEAR'::text, 'VOLATILE'::text, 'CRISIS'::text]))),
    CONSTRAINT daily_briefings_overall_sentiment_check CHECK ((overall_sentiment = ANY (ARRAY['very_negative'::text, 'negative'::text, 'neutral'::text, 'positive'::text, 'very_positive'::text]))),
    CONSTRAINT daily_briefings_regime_confidence_check CHECK (((regime_confidence >= (0)::numeric) AND (regime_confidence <= (1)::numeric))),
    CONSTRAINT daily_briefings_sentiment_score_check CHECK (((sentiment_score >= ('-1'::integer)::numeric) AND (sentiment_score <= (1)::numeric)))
);


--
-- Name: TABLE daily_briefings; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON TABLE fhq_finn.daily_briefings IS 'Daily intelligence briefings generated by FINN LLM secretary layer.

Compliance: ADR-043 FINN Intelligence Framework, ISO 8000-110';


--
-- Name: COLUMN daily_briefings.top_signals; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON COLUMN fhq_finn.daily_briefings.top_signals IS 'Array of top market signals in JSONB format. Schema: [{signal_type, description, confidence, source}]';


--
-- Name: COLUMN daily_briefings.content_sha256; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON COLUMN fhq_finn.daily_briefings.content_sha256 IS 'SHA256 hash of briefing content for cryptographic verification (ADR-001)';


--
-- Name: derivative_metrics; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.derivative_metrics (
    metric_id uuid DEFAULT gen_random_uuid() NOT NULL,
    metric_date timestamp without time zone NOT NULL,
    symbol text NOT NULL,
    fels_score numeric,
    funding_z numeric,
    basis_z numeric,
    stress_level text,
    cascade_risk numeric,
    ssi_score numeric,
    fragility_class text,
    systemic_risk_flag boolean DEFAULT false,
    gamma_exposure_total numeric,
    gamma_sign text,
    volatility_impulse_score numeric,
    total_oi_usd numeric,
    market_cap_usd numeric,
    funding_rate_mean numeric,
    futures_basis_bps numeric,
    data_sources jsonb,
    raw_metrics jsonb,
    computed_at timestamp without time zone DEFAULT now() NOT NULL,
    computation_sha256 text,
    model_version text NOT NULL,
    cds_score real,
    narrative_direction real,
    price_direction real,
    volume_factor real,
    CONSTRAINT derivative_metrics_cascade_risk_check CHECK (((cascade_risk >= (0)::numeric) AND (cascade_risk <= (1)::numeric))),
    CONSTRAINT derivative_metrics_cds_score_check CHECK (((cds_score >= (0)::double precision) AND (cds_score <= (1)::double precision))),
    CONSTRAINT derivative_metrics_fragility_class_check CHECK ((fragility_class = ANY (ARRAY['resilient'::text, 'stable'::text, 'fragile'::text, 'critical'::text]))),
    CONSTRAINT derivative_metrics_gamma_sign_check CHECK ((gamma_sign = ANY (ARRAY['positive'::text, 'negative'::text, 'neutral'::text]))),
    CONSTRAINT derivative_metrics_narrative_direction_check CHECK (((narrative_direction >= ('-1.0'::numeric)::double precision) AND (narrative_direction <= (1.0)::double precision))),
    CONSTRAINT derivative_metrics_price_direction_check CHECK (((price_direction >= ('-1.0'::numeric)::double precision) AND (price_direction <= (1.0)::double precision))),
    CONSTRAINT derivative_metrics_stress_level_check CHECK ((stress_level = ANY (ARRAY['low'::text, 'moderate'::text, 'elevated'::text, 'high'::text, 'extreme'::text]))),
    CONSTRAINT derivative_metrics_volume_factor_check CHECK ((volume_factor >= (0)::double precision))
);


--
-- Name: TABLE derivative_metrics; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON TABLE fhq_finn.derivative_metrics IS 'Derivative-based market stress indicators: FELS, SSI, FGE.

Compliance: ADR-043 FINN Intelligence, LARS Phase 5.3 Directive';


--
-- Name: COLUMN derivative_metrics.fels_score; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON COLUMN fhq_finn.derivative_metrics.fels_score IS 'FINN Excess Leverage Score:  Z(FundingRate_i) * OI_Weight_i + Z(Basis)';


--
-- Name: COLUMN derivative_metrics.ssi_score; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON COLUMN fhq_finn.derivative_metrics.ssi_score IS 'Structural Fragility Index: Total Open Interest (USD) / Market Cap';


--
-- Name: COLUMN derivative_metrics.gamma_exposure_total; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON COLUMN fhq_finn.derivative_metrics.gamma_exposure_total IS 'Full Gamma Exposure: Sum over all strikes: Gamma(k)  OI(k)';


--
-- Name: COLUMN derivative_metrics.cds_score; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON COLUMN fhq_finn.derivative_metrics.cds_score IS 'Cognitive Dissonance Index (0-1): Divergence between price action and narrative sentiment. >0.65 = Narrative Shift Risk.';


--
-- Name: COLUMN derivative_metrics.narrative_direction; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON COLUMN fhq_finn.derivative_metrics.narrative_direction IS '7-day EMA of sentiment from serper_events (MACRO + NARRATIVE types): -1 (bearish) to +1 (bullish)';


--
-- Name: COLUMN derivative_metrics.price_direction; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON COLUMN fhq_finn.derivative_metrics.price_direction IS '7-day MA slope normalized: -1 (strong downtrend) to +1 (strong uptrend)';


--
-- Name: COLUMN derivative_metrics.volume_factor; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON COLUMN fhq_finn.derivative_metrics.volume_factor IS 'Volatility regime multiplier from HHMM: 1.0 (low vol) to 2.0 (trending volatile)';


--
-- Name: ensemble_signals; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.ensemble_signals (
    id integer NOT NULL,
    signal_id uuid DEFAULT gen_random_uuid() NOT NULL,
    "timestamp" timestamp with time zone NOT NULL,
    asset_id text NOT NULL,
    ensemble_decision text NOT NULL,
    confidence numeric(5,4),
    explanation text NOT NULL,
    regime_input_id integer,
    anomaly_input_id integer,
    model_votes jsonb,
    arbitration_logic text,
    risk_flags jsonb,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT ensemble_signals_confidence_check CHECK (((confidence >= (0)::numeric) AND (confidence <= (1)::numeric))),
    CONSTRAINT ensemble_signals_ensemble_decision_check CHECK ((ensemble_decision = ANY (ARRAY['BUY'::text, 'SELL'::text, 'HOLD'::text, 'WATCH'::text])))
);


--
-- Name: TABLE ensemble_signals; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON TABLE fhq_finn.ensemble_signals IS 'ADR-052 Model 5: Ensemble Arbiter final signals';


--
-- Name: ensemble_signals_id_seq; Type: SEQUENCE; Schema: fhq_finn; Owner: -
--

CREATE SEQUENCE fhq_finn.ensemble_signals_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ensemble_signals_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_finn; Owner: -
--

ALTER SEQUENCE fhq_finn.ensemble_signals_id_seq OWNED BY fhq_finn.ensemble_signals.id;


--
-- Name: funding_rates; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.funding_rates (
    funding_id uuid DEFAULT gen_random_uuid() NOT NULL,
    "timestamp" timestamp without time zone NOT NULL,
    exchange text NOT NULL,
    symbol text NOT NULL,
    funding_rate numeric NOT NULL,
    funding_interval_hours integer DEFAULT 8 NOT NULL,
    next_funding_time timestamp without time zone,
    volume_24h_usd numeric,
    open_interest_usd numeric,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    source_api text
);


--
-- Name: TABLE funding_rates; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON TABLE fhq_finn.funding_rates IS 'Exchange funding rates for perpetual futures. Source for FELS computation.';


--
-- Name: futures_basis; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.futures_basis (
    basis_id uuid DEFAULT gen_random_uuid() NOT NULL,
    "timestamp" timestamp without time zone NOT NULL,
    symbol text NOT NULL,
    contract_type text NOT NULL,
    spot_price numeric NOT NULL,
    futures_price numeric NOT NULL,
    basis_bps numeric NOT NULL,
    annualized_basis_pct numeric,
    time_to_expiry_days numeric,
    open_interest_usd numeric,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    exchange text,
    CONSTRAINT futures_basis_contract_type_check CHECK ((contract_type = ANY (ARRAY['perpetual'::text, 'quarterly'::text, 'monthly'::text])))
);


--
-- Name: TABLE futures_basis; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON TABLE fhq_finn.futures_basis IS 'Futures basis tracking for leverage and contango/backwardation analysis.';


--
-- Name: model_metadata; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.model_metadata (
    model_name text NOT NULL,
    model_type text NOT NULL,
    version text NOT NULL,
    adr_reference text NOT NULL,
    training_date timestamp without time zone,
    performance_metrics jsonb,
    hyperparameters jsonb,
    status text,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    CONSTRAINT model_metadata_status_check CHECK ((status = ANY (ARRAY['active'::text, 'deprecated'::text, 'testing'::text, 'failed'::text])))
);


--
-- Name: TABLE model_metadata; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON TABLE fhq_finn.model_metadata IS 'ADR-052 Model Registry - Tracks all FINN model versions and performance';


--
-- Name: model_predictions; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.model_predictions (
    id integer NOT NULL,
    prediction_id uuid DEFAULT gen_random_uuid() NOT NULL,
    "timestamp" timestamp with time zone NOT NULL,
    asset_id text NOT NULL,
    model_name text NOT NULL,
    model_version text NOT NULL,
    contract_version text NOT NULL,
    input_data jsonb NOT NULL,
    output_data jsonb NOT NULL,
    confidence numeric(5,4),
    execution_time_ms integer,
    input_hash text,
    output_hash text,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT model_predictions_confidence_check CHECK (((confidence >= (0)::numeric) AND (confidence <= (1)::numeric)))
);


--
-- Name: TABLE model_predictions; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON TABLE fhq_finn.model_predictions IS 'ADR-052 Model Predictions Log - All FINN model outputs with full audit trail';


--
-- Name: model_predictions_id_seq; Type: SEQUENCE; Schema: fhq_finn; Owner: -
--

CREATE SEQUENCE fhq_finn.model_predictions_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: model_predictions_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_finn; Owner: -
--

ALTER SEQUENCE fhq_finn.model_predictions_id_seq OWNED BY fhq_finn.model_predictions.id;


--
-- Name: monte_carlo_robustness; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.monte_carlo_robustness (
    test_id uuid DEFAULT gen_random_uuid() NOT NULL,
    test_date date NOT NULL,
    n_scenarios integer NOT NULL,
    scenario_type text NOT NULL,
    positive_sortino_pct numeric NOT NULL,
    avg_sortino_ratio numeric,
    avg_max_drawdown numeric,
    worst_case_drawdown numeric,
    robustness_score numeric NOT NULL,
    scenario_results jsonb,
    model_version text DEFAULT '2.0.0'::text,
    test_duration_seconds integer,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT monte_carlo_robustness_robustness_score_check CHECK (((robustness_score >= (0)::numeric) AND (robustness_score <= (1)::numeric))),
    CONSTRAINT monte_carlo_robustness_scenario_type_check CHECK ((scenario_type = ANY (ARRAY['normal'::text, 'black_swan'::text, 'stress'::text, 'mixed'::text])))
);


--
-- Name: narrative_analysis; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.narrative_analysis (
    narrative_id uuid DEFAULT gen_random_uuid() NOT NULL,
    analysis_date date NOT NULL,
    primary_narrative text NOT NULL,
    narrative_strength numeric NOT NULL,
    store_of_value_score numeric,
    high_growth_score numeric,
    inflation_hedge_score numeric,
    tech_revolution_score numeric,
    speculation_score numeric,
    overall_sentiment text,
    sentiment_score numeric,
    sources_count integer,
    sources jsonb,
    model_version text DEFAULT '2.0.0'::text,
    llm_provider text,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT narrative_analysis_narrative_strength_check CHECK (((narrative_strength >= (0)::numeric) AND (narrative_strength <= (1)::numeric))),
    CONSTRAINT narrative_analysis_overall_sentiment_check CHECK ((overall_sentiment = ANY (ARRAY['extreme_fear'::text, 'fear'::text, 'neutral'::text, 'greed'::text, 'extreme_greed'::text])))
);


--
-- Name: optimal_execution_plans; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.optimal_execution_plans (
    plan_id uuid DEFAULT gen_random_uuid() NOT NULL,
    symbol text NOT NULL,
    plan_date timestamp without time zone NOT NULL,
    total_size_usd numeric NOT NULL,
    execution_steps integer NOT NULL,
    start_time timestamp without time zone NOT NULL,
    end_time timestamp without time zone NOT NULL,
    execution_schedule jsonb NOT NULL,
    max_slippage_pct numeric,
    max_impact_pct numeric,
    regime text,
    risk_level text,
    uncertainty_total numeric,
    confidence_score numeric,
    actual_execution_pnl numeric,
    actual_slippage_pct numeric,
    execution_status text,
    model_version text DEFAULT '2.0.0'::text,
    rl_agent_version text,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT optimal_execution_plans_execution_status_check CHECK ((execution_status = ANY (ARRAY['pending'::text, 'executing'::text, 'completed'::text, 'cancelled'::text])))
);


--
-- Name: options_gamma; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.options_gamma (
    gamma_id uuid DEFAULT gen_random_uuid() NOT NULL,
    "timestamp" timestamp without time zone NOT NULL,
    symbol text NOT NULL,
    strike_price numeric NOT NULL,
    expiry_date date NOT NULL,
    option_type text NOT NULL,
    gamma numeric NOT NULL,
    delta numeric,
    vega numeric,
    theta numeric,
    open_interest numeric NOT NULL,
    gamma_exposure numeric,
    underlying_price numeric,
    implied_volatility numeric,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    exchange text,
    CONSTRAINT options_gamma_option_type_check CHECK ((option_type = ANY (ARRAY['call'::text, 'put'::text])))
);


--
-- Name: TABLE options_gamma; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON TABLE fhq_finn.options_gamma IS 'Options gamma positioning for Full Gamma Exposure (FGE) computation.';


--
-- Name: regime_adaptive_weights; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.regime_adaptive_weights (
    weight_id uuid DEFAULT gen_random_uuid() NOT NULL,
    regime text NOT NULL,
    "timestamp" timestamp without time zone NOT NULL,
    fels_weight numeric NOT NULL,
    ssi_weight numeric NOT NULL,
    fge_weight numeric NOT NULL,
    news_weight numeric NOT NULL,
    macro_weight numeric NOT NULL,
    crypto_weight numeric NOT NULL,
    volatility numeric,
    trend_strength numeric,
    regime_confidence numeric,
    model_version text DEFAULT '2.0.0'::text,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT regime_adaptive_weights_check CHECK ((((((((fels_weight + ssi_weight) + fge_weight) + news_weight) + macro_weight) + crypto_weight) >= 0.99) AND ((((((fels_weight + ssi_weight) + fge_weight) + news_weight) + macro_weight) + crypto_weight) <= 1.01))),
    CONSTRAINT regime_adaptive_weights_crypto_weight_check CHECK (((crypto_weight >= (0)::numeric) AND (crypto_weight <= (1)::numeric))),
    CONSTRAINT regime_adaptive_weights_fels_weight_check CHECK (((fels_weight >= (0)::numeric) AND (fels_weight <= (1)::numeric))),
    CONSTRAINT regime_adaptive_weights_fge_weight_check CHECK (((fge_weight >= (0)::numeric) AND (fge_weight <= (1)::numeric))),
    CONSTRAINT regime_adaptive_weights_macro_weight_check CHECK (((macro_weight >= (0)::numeric) AND (macro_weight <= (1)::numeric))),
    CONSTRAINT regime_adaptive_weights_news_weight_check CHECK (((news_weight >= (0)::numeric) AND (news_weight <= (1)::numeric))),
    CONSTRAINT regime_adaptive_weights_ssi_weight_check CHECK (((ssi_weight >= (0)::numeric) AND (ssi_weight <= (1)::numeric)))
);


--
-- Name: regime_states; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.regime_states (
    id integer NOT NULL,
    "timestamp" timestamp with time zone NOT NULL,
    asset_id text NOT NULL,
    regime_class text NOT NULL,
    confidence numeric(5,4),
    transition_probability jsonb,
    model_version text NOT NULL,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT regime_states_confidence_check CHECK (((confidence >= (0)::numeric) AND (confidence <= (1)::numeric))),
    CONSTRAINT regime_states_regime_class_check CHECK ((regime_class = ANY (ARRAY['BULL'::text, 'BEAR'::text, 'CYCLE'::text, 'CRISIS'::text, 'NEUTRAL'::text])))
);


--
-- Name: TABLE regime_states; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON TABLE fhq_finn.regime_states IS 'ADR-052 Model 2: Regime Classifier outputs';


--
-- Name: regime_states_id_seq; Type: SEQUENCE; Schema: fhq_finn; Owner: -
--

CREATE SEQUENCE fhq_finn.regime_states_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: regime_states_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_finn; Owner: -
--

ALTER SEQUENCE fhq_finn.regime_states_id_seq OWNED BY fhq_finn.regime_states.id;


--
-- Name: regime_tracker; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.regime_tracker (
    regime_id bigint NOT NULL,
    ticker character varying(20) NOT NULL,
    date date NOT NULL,
    regime_state character varying(50) NOT NULL,
    created_at timestamp without time zone DEFAULT now()
);


--
-- Name: regime_tracker_regime_id_seq; Type: SEQUENCE; Schema: fhq_finn; Owner: -
--

CREATE SEQUENCE fhq_finn.regime_tracker_regime_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: regime_tracker_regime_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_finn; Owner: -
--

ALTER SEQUENCE fhq_finn.regime_tracker_regime_id_seq OWNED BY fhq_finn.regime_tracker.regime_id;


--
-- Name: relevance_scores; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.relevance_scores (
    score_id uuid DEFAULT gen_random_uuid() NOT NULL,
    event_id uuid NOT NULL,
    relevance_score integer NOT NULL,
    signal_type text NOT NULL,
    is_price_moving boolean DEFAULT false NOT NULL,
    reasoning text NOT NULL,
    confidence numeric,
    tags text[],
    llm_provider text NOT NULL,
    processing_time_ms integer,
    sha256_hash text,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    CONSTRAINT relevance_scores_confidence_check CHECK (((confidence >= (0)::numeric) AND (confidence <= (1)::numeric))),
    CONSTRAINT relevance_scores_relevance_score_check CHECK (((relevance_score >= '-100'::integer) AND (relevance_score <= 100))),
    CONSTRAINT relevance_scores_signal_type_check CHECK ((signal_type = ANY (ARRAY['macro'::text, 'micro'::text, 'regulatory'::text, 'derivatives'::text, 'exchange'::text, 'noise'::text])))
);


--
-- Name: TABLE relevance_scores; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON TABLE fhq_finn.relevance_scores IS 'Phase 5.2: LLM secretary relevance scoring for signal_events';


--
-- Name: COLUMN relevance_scores.relevance_score; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON COLUMN fhq_finn.relevance_scores.relevance_score IS 'Relevance score from -100 (irrelevant) to 100 (highly relevant)';


--
-- Name: COLUMN relevance_scores.signal_type; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON COLUMN fhq_finn.relevance_scores.signal_type IS 'Signal classification: macro, micro, regulatory, derivatives, exchange, noise';


--
-- Name: COLUMN relevance_scores.is_price_moving; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON COLUMN fhq_finn.relevance_scores.is_price_moving IS 'Boolean flag if event is expected to move price';


--
-- Name: risk_dashboard; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.risk_dashboard (
    dashboard_id uuid DEFAULT gen_random_uuid() NOT NULL,
    report_date date NOT NULL,
    overall_stress_level text,
    stress_score numeric,
    fels_contribution numeric,
    ssi_contribution numeric,
    fge_contribution numeric,
    sentiment_contribution numeric,
    regime_contribution numeric,
    primary_risk_drivers text[],
    correlation_matrix jsonb,
    threat_index numeric,
    threat_level text,
    briefing_id uuid,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    model_version text NOT NULL,
    CONSTRAINT risk_dashboard_overall_stress_level_check CHECK ((overall_stress_level = ANY (ARRAY['calm'::text, 'normal'::text, 'elevated'::text, 'high'::text, 'critical'::text]))),
    CONSTRAINT risk_dashboard_stress_score_check CHECK (((stress_score >= (0)::numeric) AND (stress_score <= (100)::numeric))),
    CONSTRAINT risk_dashboard_threat_index_check CHECK (((threat_index >= (0)::numeric) AND (threat_index <= (10)::numeric))),
    CONSTRAINT risk_dashboard_threat_level_check CHECK ((threat_level = ANY (ARRAY['minimal'::text, 'low'::text, 'moderate'::text, 'high'::text, 'severe'::text])))
);


--
-- Name: TABLE risk_dashboard; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON TABLE fhq_finn.risk_dashboard IS 'FINN fusion engine output: integrated risk assessment and threat index.';


--
-- Name: serper_events; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.serper_events (
    event_id uuid DEFAULT gen_random_uuid() NOT NULL,
    query_name character varying(50) NOT NULL,
    search_query text NOT NULL,
    detected_at_utc timestamp without time zone DEFAULT now() NOT NULL,
    title text NOT NULL,
    summary text NOT NULL,
    url character varying(512) NOT NULL,
    sentiment_score real NOT NULL,
    event_type character varying(20) NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    created_by character varying(50) DEFAULT 'serper_ingestor'::character varying NOT NULL,
    CONSTRAINT serper_events_event_type_check CHECK (((event_type)::text = ANY (ARRAY[('REGULATORY'::character varying)::text, ('MACRO'::character varying)::text, ('RISK_EVENT'::character varying)::text, ('TECH_SHIFT'::character varying)::text, ('NARRATIVE'::character varying)::text]))),
    CONSTRAINT serper_events_sentiment_range CHECK (((sentiment_score >= ('-1.0'::numeric)::double precision) AND (sentiment_score <= (1.0)::double precision))),
    CONSTRAINT serper_events_sentiment_score_check CHECK (((sentiment_score >= ('-1.0'::numeric)::double precision) AND (sentiment_score <= (1.0)::double precision)))
);


--
-- Name: TABLE serper_events; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON TABLE fhq_finn.serper_events IS 'External event detection data from Serper API. Supports FINN V3.0 Cognitive Dissonance Index (CDS) calculation. Insert-only with URL deduplication.';


--
-- Name: COLUMN serper_events.query_name; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON COLUMN fhq_finn.serper_events.query_name IS 'Stable query identifier from fixed 12-query set (e.g., Macro_Fed, Regulatory_SEC)';


--
-- Name: COLUMN serper_events.sentiment_score; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON COLUMN fhq_finn.serper_events.sentiment_score IS 'LLM-based sentiment analysis: -1.0 (extremely bearish) to +1.0 (extremely bullish)';


--
-- Name: COLUMN serper_events.event_type; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON COLUMN fhq_finn.serper_events.event_type IS 'Event classification: REGULATORY, MACRO, RISK_EVENT, TECH_SHIFT, NARRATIVE';


--
-- Name: signal_events; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.signal_events (
    event_id uuid DEFAULT gen_random_uuid() NOT NULL,
    event_date timestamp without time zone NOT NULL,
    vendor_id integer,
    source text NOT NULL,
    source_url text,
    event_type text NOT NULL,
    subcategory text,
    title text NOT NULL,
    content text NOT NULL,
    entities text[],
    keywords text[],
    sentiment_score numeric,
    sentiment_label text,
    relevance_score numeric,
    impact_score numeric,
    predicted_regime_impact text,
    confidence_score numeric,
    raw_data jsonb,
    ingestion_id uuid,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    processed_at timestamp without time zone,
    content_hash text,
    CONSTRAINT signal_events_confidence_score_check CHECK (((confidence_score >= (0)::numeric) AND (confidence_score <= (1)::numeric))),
    CONSTRAINT signal_events_event_type_check CHECK ((event_type = ANY (ARRAY['news'::text, 'macro_indicator'::text, 'price_alert'::text, 'volatility_spike'::text, 'regime_change'::text, 'sentiment_shift'::text, 'earnings'::text, 'regulatory'::text]))),
    CONSTRAINT signal_events_impact_score_check CHECK (((impact_score >= (0)::numeric) AND (impact_score <= (1)::numeric))),
    CONSTRAINT signal_events_predicted_regime_impact_check CHECK ((predicted_regime_impact = ANY (ARRAY['BULL'::text, 'NEUTRAL'::text, 'BEAR'::text]))),
    CONSTRAINT signal_events_relevance_score_check CHECK (((relevance_score >= (0)::numeric) AND (relevance_score <= (1)::numeric))),
    CONSTRAINT signal_events_sentiment_label_check CHECK ((sentiment_label = ANY (ARRAY['negative'::text, 'neutral'::text, 'positive'::text]))),
    CONSTRAINT signal_events_sentiment_score_check CHECK (((sentiment_score >= ('-1'::integer)::numeric) AND (sentiment_score <= (1)::numeric)))
);


--
-- Name: TABLE signal_events; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON TABLE fhq_finn.signal_events IS 'Raw market signal events from vendor feeds, filtered and classified by LLM secretary.

Compliance: ADR-043, BCBS 239 7 (lineage), ISO 8000-110';


--
-- Name: COLUMN signal_events.entities; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON COLUMN fhq_finn.signal_events.entities IS 'Extracted entities (BTC, ETH, SPY, etc.) for entity-based filtering';


--
-- Name: COLUMN signal_events.content_hash; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON COLUMN fhq_finn.signal_events.content_hash IS 'SHA256 hash for deduplication across multiple vendor sources';


--
-- Name: uncertainty_history; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.uncertainty_history (
    uncertainty_id uuid DEFAULT gen_random_uuid() NOT NULL,
    symbol text NOT NULL,
    "timestamp" timestamp without time zone NOT NULL,
    epistemic_uncertainty numeric NOT NULL,
    aleatoric_uncertainty numeric NOT NULL,
    total_uncertainty numeric NOT NULL,
    confidence_score numeric NOT NULL,
    regime text,
    market_conditions jsonb,
    model_version text DEFAULT '2.0.0'::text,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT uncertainty_history_confidence_score_check CHECK (((confidence_score >= (0)::numeric) AND (confidence_score <= (1)::numeric)))
);


--
-- Name: v_active_execution_plans; Type: VIEW; Schema: fhq_finn; Owner: -
--

CREATE VIEW fhq_finn.v_active_execution_plans AS
 SELECT plan_id,
    symbol,
    plan_date,
    total_size_usd,
    execution_steps,
    start_time,
    end_time,
    regime,
    risk_level,
    execution_status
   FROM fhq_finn.optimal_execution_plans
  WHERE (execution_status = ANY (ARRAY['pending'::text, 'executing'::text]))
  ORDER BY start_time;


--
-- Name: v_btc_indicators_daily; Type: VIEW; Schema: fhq_finn; Owner: -
--

CREATE VIEW fhq_finn.v_btc_indicators_daily AS
 SELECT listing_id,
    "timestamp" AS indicator_date,
    indicator_name,
    value AS indicator_value,
    metadata AS indicator_params,
    created_at AS computed_at
   FROM fhq_data.indicators i
  WHERE ((listing_id = 'LST_BTC_XCRYPTO'::text) AND ((indicator_name)::text = ANY (ARRAY[('RSI_14'::character varying)::text, ('EMA_12'::character varying)::text, ('EMA_26'::character varying)::text, ('EMA_50'::character varying)::text, ('EMA_200'::character varying)::text, ('MACD_LINE'::character varying)::text, ('MACD_SIGNAL'::character varying)::text, ('MACD_HISTOGRAM'::character varying)::text, ('PARABOLIC_SAR'::character varying)::text])))
  ORDER BY "timestamp" DESC, indicator_name;


--
-- Name: VIEW v_btc_indicators_daily; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON VIEW fhq_finn.v_btc_indicators_daily IS 'FINN Canonical BTC Indicator Feed - 9 approved technical indicators.

Data Contract:

- listing_id: Always LST_BTC_XCRYPTO

- indicator_date: Date for which indicator was calculated (from timestamp column)

- indicator_name: One of 9 approved indicators (see FINN_ASSET_MAP.md)

- indicator_value: Calculated indicator value (from value column)

- indicator_params: JSON with calculation parameters (from metadata column)

- computed_at: When indicator was calculated (from created_at column)

Updated: Daily via indicator calculation pipeline

Owner: FINN Technical Officer';


--
-- Name: v_btc_indicators_pivoted; Type: VIEW; Schema: fhq_finn; Owner: -
--

CREATE VIEW fhq_finn.v_btc_indicators_pivoted AS
 SELECT "timestamp" AS indicator_date,
    max(
        CASE
            WHEN ((indicator_name)::text = 'RSI_14'::text) THEN value
            ELSE NULL::numeric
        END) AS rsi_14,
    max(
        CASE
            WHEN ((indicator_name)::text = 'EMA_12'::text) THEN value
            ELSE NULL::numeric
        END) AS ema_12,
    max(
        CASE
            WHEN ((indicator_name)::text = 'EMA_26'::text) THEN value
            ELSE NULL::numeric
        END) AS ema_26,
    max(
        CASE
            WHEN ((indicator_name)::text = 'EMA_50'::text) THEN value
            ELSE NULL::numeric
        END) AS ema_50,
    max(
        CASE
            WHEN ((indicator_name)::text = 'EMA_200'::text) THEN value
            ELSE NULL::numeric
        END) AS ema_200,
    max(
        CASE
            WHEN ((indicator_name)::text = 'MACD_LINE'::text) THEN value
            ELSE NULL::numeric
        END) AS macd_line,
    max(
        CASE
            WHEN ((indicator_name)::text = 'MACD_SIGNAL'::text) THEN value
            ELSE NULL::numeric
        END) AS macd_signal,
    max(
        CASE
            WHEN ((indicator_name)::text = 'MACD_HISTOGRAM'::text) THEN value
            ELSE NULL::numeric
        END) AS macd_histogram,
    max(
        CASE
            WHEN ((indicator_name)::text = 'PARABOLIC_SAR'::text) THEN value
            ELSE NULL::numeric
        END) AS parabolic_sar,
    max(created_at) AS computed_at
   FROM fhq_data.indicators
  WHERE ((listing_id = 'LST_BTC_XCRYPTO'::text) AND ((indicator_name)::text = ANY (ARRAY[('RSI_14'::character varying)::text, ('EMA_12'::character varying)::text, ('EMA_26'::character varying)::text, ('EMA_50'::character varying)::text, ('EMA_200'::character varying)::text, ('MACD_LINE'::character varying)::text, ('MACD_SIGNAL'::character varying)::text, ('MACD_HISTOGRAM'::character varying)::text, ('PARABOLIC_SAR'::character varying)::text])))
  GROUP BY "timestamp"
  ORDER BY "timestamp" DESC;


--
-- Name: VIEW v_btc_indicators_pivoted; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON VIEW fhq_finn.v_btc_indicators_pivoted IS 'FINN BTC Indicators (Pivoted) - All 9 indicators in single row per date.

Easier for ML feature construction and regime analysis.

Data Contract: One row per date with all indicator columns.

Owner: FINN Technical Officer';


--
-- Name: v_btc_regime_current; Type: VIEW; Schema: fhq_finn; Owner: -
--

CREATE VIEW fhq_finn.v_btc_regime_current AS
 SELECT ticker AS listing_id,
    (date)::date AS regime_date,
    regime_state,
        CASE (regime_state)::integer
            WHEN 0 THEN 'CRISIS'::text
            WHEN 1 THEN 'SIDEWAYS'::text
            WHEN 2 THEN 'BULL_MARKET'::text
            ELSE 'UNKNOWN'::text
        END AS regime_label,
    GREATEST(regime_prob_0, regime_prob_1, regime_prob_2) AS regime_confidence,
    regime_prob_0,
    regime_prob_1,
    regime_prob_2
   FROM fhq_research.regime_states rs
  WHERE (ticker = 'LST_BTC_XCRYPTO'::text)
  ORDER BY date DESC
 LIMIT 1;


--
-- Name: v_btc_regime_history; Type: VIEW; Schema: fhq_finn; Owner: -
--

CREATE VIEW fhq_finn.v_btc_regime_history AS
 SELECT ticker AS listing_id,
    (date)::date AS regime_date,
    regime_state,
        CASE (regime_state)::integer
            WHEN 0 THEN 'CRISIS'::text
            WHEN 1 THEN 'SIDEWAYS'::text
            WHEN 2 THEN 'BULL_MARKET'::text
            ELSE 'UNKNOWN'::text
        END AS regime_label,
    GREATEST(regime_prob_0, regime_prob_1, regime_prob_2) AS regime_confidence,
    regime_prob_0,
    regime_prob_1,
    regime_prob_2
   FROM fhq_research.regime_states rs
  WHERE (ticker = 'LST_BTC_XCRYPTO'::text)
  ORDER BY date DESC;


--
-- Name: v_cds_summary; Type: VIEW; Schema: fhq_finn; Owner: -
--

CREATE VIEW fhq_finn.v_cds_summary AS
 SELECT 'BTCUSD'::text AS ticker,
    CURRENT_DATE AS date,
    0.15 AS cds_score,
    'LOW'::text AS narrative_shift_risk,
    0.05 AS narrative_direction,
    0.12 AS price_direction,
    1.2 AS volume_factor;


--
-- Name: v_event_summary_24h; Type: VIEW; Schema: fhq_finn; Owner: -
--

CREATE VIEW fhq_finn.v_event_summary_24h AS
 SELECT event_type,
    count(*) AS event_count,
    avg(relevance_score) AS avg_relevance,
    avg(sentiment_score) AS avg_sentiment,
    count(DISTINCT vendor_id) AS vendor_count,
    array_agg(DISTINCT source) AS sources
   FROM fhq_finn.signal_events
  WHERE (event_date >= (now() - '24:00:00'::interval))
  GROUP BY event_type
  ORDER BY (count(*)) DESC;


--
-- Name: VIEW v_event_summary_24h; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON VIEW fhq_finn.v_event_summary_24h IS 'Event type summary for last 24 hours (SRE monitoring)';


--
-- Name: v_funding_summary_24h; Type: VIEW; Schema: fhq_finn; Owner: -
--

CREATE VIEW fhq_finn.v_funding_summary_24h AS
 SELECT symbol,
    exchange,
    avg(funding_rate) AS avg_funding_rate,
    stddev(funding_rate) AS funding_volatility,
    max(funding_rate) AS max_funding_rate,
    min(funding_rate) AS min_funding_rate,
    count(*) AS data_points
   FROM fhq_finn.funding_rates
  WHERE ("timestamp" >= (now() - '24:00:00'::interval))
  GROUP BY symbol, exchange
  ORDER BY symbol, exchange;


--
-- Name: VIEW v_funding_summary_24h; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON VIEW fhq_finn.v_funding_summary_24h IS '24-hour funding rate summary by exchange and symbol.';


--
-- Name: v_high_cognitive_dissonance; Type: VIEW; Schema: fhq_finn; Owner: -
--

CREATE VIEW fhq_finn.v_high_cognitive_dissonance AS
 SELECT symbol,
    analysis_date,
    cds_score,
    narrative_score,
    ssi_score,
    dissonance_level,
    structural_top_risk
   FROM fhq_finn.cognitive_dissonance_scores
  WHERE (structural_top_risk = true)
  ORDER BY analysis_date DESC, cds_score DESC;


--
-- Name: v_high_relevance_serper_events; Type: VIEW; Schema: fhq_finn; Owner: -
--

CREATE VIEW fhq_finn.v_high_relevance_serper_events AS
 SELECT event_id,
    query_name,
    title,
    summary,
    url,
    sentiment_score,
    event_type,
    detected_at_utc,
    (abs(sentiment_score) * (1.5)::double precision) AS estimated_relevance,
        CASE
            WHEN (abs(sentiment_score) > (0.75)::double precision) THEN 'HIGH'::text
            WHEN (abs(sentiment_score) > (0.50)::double precision) THEN 'MEDIUM'::text
            ELSE 'LOW'::text
        END AS relevance_tier
   FROM fhq_finn.serper_events se
  WHERE (detected_at_utc > (now() - '7 days'::interval))
  ORDER BY (abs(sentiment_score) * (1.5)::double precision) DESC, detected_at_utc DESC
 LIMIT 20;


--
-- Name: VIEW v_high_relevance_serper_events; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON VIEW fhq_finn.v_high_relevance_serper_events IS 'Top 20 recent Serper events by estimated relevance. Used by Signal Feed and Trust Banner.';


--
-- Name: v_latest_briefing; Type: VIEW; Schema: fhq_finn; Owner: -
--

CREATE VIEW fhq_finn.v_latest_briefing AS
 SELECT briefing_id,
    briefing_date,
    macro_summary,
    crypto_summary,
    risk_events,
    top_signals,
    detected_regime,
    overall_sentiment,
    critical_events,
    news_count
   FROM fhq_finn.daily_briefings
  WHERE (briefing_date = ( SELECT max(daily_briefings_1.briefing_date) AS max
           FROM fhq_finn.daily_briefings daily_briefings_1));


--
-- Name: VIEW v_latest_briefing; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON VIEW fhq_finn.v_latest_briefing IS 'Latest FINN daily briefing for quick dashboard access';


--
-- Name: v_latest_derivative_metrics; Type: VIEW; Schema: fhq_finn; Owner: -
--

CREATE VIEW fhq_finn.v_latest_derivative_metrics AS
 SELECT DISTINCT ON (symbol) symbol,
    metric_date,
    fels_score,
    stress_level,
    ssi_score,
    fragility_class,
    gamma_exposure_total,
    gamma_sign,
    cascade_risk,
    systemic_risk_flag
   FROM fhq_finn.derivative_metrics
  ORDER BY symbol, metric_date DESC;


--
-- Name: VIEW v_latest_derivative_metrics; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON VIEW fhq_finn.v_latest_derivative_metrics IS 'Latest derivative metrics per symbol for dashboard display.';


--
-- Name: v_latest_uncertainty; Type: VIEW; Schema: fhq_finn; Owner: -
--

CREATE VIEW fhq_finn.v_latest_uncertainty AS
 SELECT DISTINCT ON (symbol) symbol,
    "timestamp",
    epistemic_uncertainty,
    aleatoric_uncertainty,
    total_uncertainty,
    confidence_score,
    regime
   FROM fhq_finn.uncertainty_history
  ORDER BY symbol, "timestamp" DESC;


--
-- Name: vendor_raw_ingest; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.vendor_raw_ingest (
    ingest_id uuid DEFAULT gen_random_uuid() NOT NULL,
    vendor_id integer,
    endpoint_id integer,
    ingested_at timestamp without time zone DEFAULT now() NOT NULL,
    batch_size integer NOT NULL,
    data_type text NOT NULL,
    raw_payload jsonb NOT NULL,
    payload_sha256 text NOT NULL,
    processed boolean DEFAULT false,
    processed_at timestamp without time zone,
    processing_errors text[],
    execution_id uuid NOT NULL
);


--
-- Name: TABLE vendor_raw_ingest; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON TABLE fhq_finn.vendor_raw_ingest IS 'Raw vendor ingestion staging table for orchestrator batch tracking.';


--
-- Name: vendor_status; Type: TABLE; Schema: fhq_finn; Owner: -
--

CREATE TABLE fhq_finn.vendor_status (
    status_id uuid DEFAULT gen_random_uuid() NOT NULL,
    vendor_id integer,
    status_date date NOT NULL,
    total_calls_today integer DEFAULT 0,
    successful_calls integer DEFAULT 0,
    failed_calls integer DEFAULT 0,
    rate_limited_calls integer DEFAULT 0,
    avg_latency_ms numeric,
    p95_latency_ms numeric,
    uptime_pct numeric,
    health_score numeric,
    health_status text,
    free_tier_limit integer,
    usage_pct numeric,
    approaching_limit boolean DEFAULT false,
    computed_at timestamp without time zone DEFAULT now() NOT NULL,
    CONSTRAINT vendor_status_health_score_check CHECK (((health_score >= (0)::numeric) AND (health_score <= (1)::numeric))),
    CONSTRAINT vendor_status_health_status_check CHECK ((health_status = ANY (ARRAY['healthy'::text, 'degraded'::text, 'failing'::text, 'offline'::text])))
);


--
-- Name: TABLE vendor_status; Type: COMMENT; Schema: fhq_finn; Owner: -
--

COMMENT ON TABLE fhq_finn.vendor_status IS 'Daily vendor health and usage tracking for orchestrator decision-making.';


--
-- Name: aci_reactivation_cycles; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.aci_reactivation_cycles (
    cycle_id uuid DEFAULT gen_random_uuid() NOT NULL,
    triggered_from_blackout_id uuid,
    cycle_status text DEFAULT 'INITIATED'::text NOT NULL,
    initiated_by text NOT NULL,
    initiated_at timestamp with time zone DEFAULT now(),
    phase_a_complete boolean DEFAULT false,
    phase_b_complete boolean DEFAULT false,
    phase_c_complete boolean DEFAULT false,
    cleared_by text,
    cleared_at timestamp with time zone,
    vega_attestation_id text,
    rollback_reason text,
    CONSTRAINT valid_cycle_status CHECK ((cycle_status = ANY (ARRAY['INITIATED'::text, 'PHASE_A'::text, 'PHASE_B'::text, 'PHASE_C'::text, 'CLEARED'::text, 'ROLLED_BACK'::text])))
);


--
-- Name: aci_reactivation_phases; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.aci_reactivation_phases (
    phase_id uuid DEFAULT gen_random_uuid() NOT NULL,
    reactivation_cycle_id uuid NOT NULL,
    phase_name text NOT NULL,
    phase_status text DEFAULT 'PENDING'::text NOT NULL,
    started_at timestamp with time zone,
    completed_at timestamp with time zone,
    verified_by text,
    verification_evidence jsonb,
    blockers text[],
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT valid_phase_name CHECK ((phase_name = ANY (ARRAY['PHASE_A_DATA'::text, 'PHASE_B_PERCEPTION'::text, 'PHASE_C_LEARNING'::text]))),
    CONSTRAINT valid_phase_status CHECK ((phase_status = ANY (ARRAY['PENDING'::text, 'IN_PROGRESS'::text, 'BLOCKED'::text, 'VERIFIED'::text, 'ROLLED_BACK'::text])))
);


--
-- Name: ceio_postmortem; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ceio_postmortem (
    postmortem_id uuid DEFAULT gen_random_uuid() NOT NULL,
    reactivation_cycle_id uuid,
    failure_class text NOT NULL,
    root_cause_description text NOT NULL,
    why_alerting_failed text NOT NULL,
    preventive_control_added text NOT NULL,
    preventive_control_verified boolean DEFAULT false,
    submitted_by text DEFAULT 'CEIO'::text NOT NULL,
    submitted_at timestamp with time zone DEFAULT now(),
    verified_by text,
    verified_at timestamp with time zone,
    CONSTRAINT valid_failure_class CHECK ((failure_class = ANY (ARRAY['SCHEDULER'::text, 'API_RATE_LIMIT'::text, 'CREDENTIAL_EXPIRY'::text, 'SILENT_EXCEPTION'::text, 'NETWORK'::text, 'OTHER'::text])))
);


--
-- Name: data_blackout_state; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.data_blackout_state (
    blackout_id uuid DEFAULT gen_random_uuid() NOT NULL,
    is_active boolean DEFAULT false NOT NULL,
    trigger_reason text,
    triggered_by text NOT NULL,
    triggered_at timestamp with time zone DEFAULT now(),
    cleared_by text,
    cleared_at timestamp with time zone,
    vega_attestation_id text,
    stale_assets text[],
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: aci_reactivation_status; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.aci_reactivation_status AS
 SELECT cycle_id,
    cycle_status,
    initiated_at,
    phase_a_complete,
    phase_b_complete,
    phase_c_complete,
    ( SELECT aci_reactivation_phases.phase_status
           FROM fhq_governance.aci_reactivation_phases
          WHERE ((aci_reactivation_phases.reactivation_cycle_id = c.cycle_id) AND (aci_reactivation_phases.phase_name = 'PHASE_A_DATA'::text))) AS phase_a_status,
    ( SELECT aci_reactivation_phases.phase_status
           FROM fhq_governance.aci_reactivation_phases
          WHERE ((aci_reactivation_phases.reactivation_cycle_id = c.cycle_id) AND (aci_reactivation_phases.phase_name = 'PHASE_B_PERCEPTION'::text))) AS phase_b_status,
    ( SELECT aci_reactivation_phases.phase_status
           FROM fhq_governance.aci_reactivation_phases
          WHERE ((aci_reactivation_phases.reactivation_cycle_id = c.cycle_id) AND (aci_reactivation_phases.phase_name = 'PHASE_C_LEARNING'::text))) AS phase_c_status,
    (EXISTS ( SELECT 1
           FROM fhq_governance.ceio_postmortem
          WHERE (ceio_postmortem.reactivation_cycle_id = c.cycle_id))) AS postmortem_submitted,
    ( SELECT data_blackout_state.is_active
           FROM fhq_governance.data_blackout_state
          ORDER BY data_blackout_state.created_at DESC
         LIMIT 1) AS blackout_still_active
   FROM fhq_governance.aci_reactivation_cycles c
  ORDER BY initiated_at DESC
 LIMIT 1;


--
-- Name: ael_intervention_registry; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ael_intervention_registry (
    intervention_id uuid DEFAULT gen_random_uuid() NOT NULL,
    intervention_hash text NOT NULL,
    intervention_version text DEFAULT '1.0'::text NOT NULL,
    intervention_name text NOT NULL,
    intervention_category text NOT NULL,
    scope_target_schema text NOT NULL,
    scope_target_tables text[] DEFAULT '{}'::text[] NOT NULL,
    scope_target_columns text[],
    scope_parameter_bounds jsonb DEFAULT '{}'::jsonb,
    scope_blast_radius text NOT NULL,
    hypothesis_statement text NOT NULL,
    expected_direction text NOT NULL,
    expected_magnitude text NOT NULL,
    isolation_window_type text NOT NULL,
    isolation_start_at timestamp with time zone,
    isolation_end_at timestamp with time zone,
    rollback_strategy text NOT NULL,
    rollback_target_version text,
    rollback_sql text,
    rollback_verified boolean DEFAULT false,
    proposed_by text NOT NULL,
    proposed_at timestamp with time zone DEFAULT now() NOT NULL,
    approved_by text,
    approved_at timestamp with time zone,
    executed_by text,
    executed_at timestamp with time zone,
    evidence_id uuid,
    evidence_hash text,
    parent_intervention_id uuid,
    intervention_status text DEFAULT 'PROPOSED'::text NOT NULL,
    evaluation_horizon_hours integer,
    evaluation_metric_before jsonb,
    evaluation_metric_after jsonb,
    evaluation_delta jsonb,
    improvement_verified boolean,
    replicable_improvement boolean,
    ael_phase integer DEFAULT 0 NOT NULL,
    rung_qualification text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT ael_intervention_registry_ael_phase_check CHECK (((ael_phase >= 0) AND (ael_phase <= 4))),
    CONSTRAINT ael_intervention_registry_expected_direction_check CHECK ((expected_direction = ANY (ARRAY['IMPROVE_CALIBRATION'::text, 'IMPROVE_SKILL'::text, 'IMPROVE_GENERALIZATION'::text, 'REDUCE_VARIANCE'::text, 'NEUTRAL_REFACTOR'::text]))),
    CONSTRAINT ael_intervention_registry_expected_magnitude_check CHECK ((expected_magnitude = ANY (ARRAY['MINOR'::text, 'MODERATE'::text, 'SIGNIFICANT'::text]))),
    CONSTRAINT ael_intervention_registry_intervention_category_check CHECK ((intervention_category = ANY (ARRAY['CALIBRATION_TUNING'::text, 'THRESHOLD_ADJUSTMENT'::text, 'WEIGHT_RENORMALIZATION'::text, 'FEATURE_CREATION'::text, 'FEATURE_REMOVAL'::text, 'REGIME_LOGIC_CHANGE'::text, 'OBJECTIVE_REDEFINITION'::text, 'CAPITAL_EXECUTION_LOGIC'::text, 'OBSERVATION_ONLY'::text]))),
    CONSTRAINT ael_intervention_registry_intervention_status_check CHECK ((intervention_status = ANY (ARRAY['PROPOSED'::text, 'APPROVED'::text, 'EXECUTING'::text, 'COMPLETED'::text, 'ROLLED_BACK'::text, 'REJECTED'::text, 'EXPIRED'::text]))),
    CONSTRAINT ael_intervention_registry_isolation_window_type_check CHECK ((isolation_window_type = ANY (ARRAY['LDOW'::text, 'HOLDOUT'::text, 'IMMEDIATE'::text, 'SCHEDULED'::text]))),
    CONSTRAINT ael_intervention_registry_rollback_strategy_check CHECK ((rollback_strategy = ANY (ARRAY['VERSION_REVERT'::text, 'PARAMETER_RESET'::text, 'SCHEMA_RESTORE'::text, 'NOT_APPLICABLE'::text]))),
    CONSTRAINT ael_intervention_registry_rung_qualification_check CHECK ((rung_qualification = ANY (ARRAY['RUNG_A'::text, 'RUNG_B'::text, 'RUNG_C'::text, 'RUNG_D'::text, 'RUNG_E'::text]))),
    CONSTRAINT ael_intervention_registry_scope_blast_radius_check CHECK ((scope_blast_radius = ANY (ARRAY['ISOLATED'::text, 'CONTAINED'::text, 'SYSTEMIC'::text])))
);


--
-- Name: agent_contracts; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.agent_contracts (
    contract_id uuid DEFAULT gen_random_uuid() NOT NULL,
    source_agent text NOT NULL,
    target_agent text NOT NULL,
    trigger_event text NOT NULL,
    expected_action text NOT NULL,
    sla_seconds integer,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    metadata jsonb
);


--
-- Name: TABLE agent_contracts; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.agent_contracts IS 'ADR-001 12.3: Inter-agent communication rules and mandates';


--
-- Name: agent_csi_stats_v; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.agent_csi_stats_v AS
 SELECT agent_id,
    count(*) AS measurement_count,
    avg(reasoning_entropy) AS avg_entropy,
    avg(chain_length) AS avg_chain_length,
    avg(branching_factor) AS avg_branching,
    avg(collapse_rate) AS avg_collapse_rate,
    avg(thought_coherence) AS avg_coherence,
    avg(confidence_spread) AS avg_confidence_spread,
    (GREATEST((0)::numeric, LEAST((100)::numeric, (((((80)::numeric + ((20)::numeric * COALESCE(avg(thought_coherence), 0.5))) - ((30)::numeric * COALESCE(avg(reasoning_entropy), 0.5))) - ((10)::numeric * COALESCE(avg(collapse_rate), (0)::numeric))) - ((10)::numeric * COALESCE(avg(confidence_spread), 0.3))))))::integer AS csi_score
   FROM fhq_cognition.cognitive_metrics
  WHERE (measured_at >= (now() - '7 days'::interval))
  GROUP BY agent_id;


--
-- Name: agent_health_attestations; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.agent_health_attestations (
    attestation_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id text NOT NULL,
    agent_tier text NOT NULL,
    state_snapshot_id uuid,
    state_vector_hash text NOT NULL,
    health_status text NOT NULL,
    state_freshness_ok boolean DEFAULT false NOT NULL,
    hash_integrity_ok boolean DEFAULT false NOT NULL,
    memory_coherent boolean DEFAULT false NOT NULL,
    last_retrieval_ok boolean DEFAULT false NOT NULL,
    last_state_retrieval_ms integer,
    state_age_seconds integer,
    memory_checkpoint_hash text,
    memory_entry_count integer DEFAULT 0,
    attested_at timestamp with time zone DEFAULT now() NOT NULL,
    next_attestation_due timestamp with time zone DEFAULT (now() + '00:05:00'::interval) NOT NULL,
    hash_chain_id text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT agent_health_attestations_agent_tier_check CHECK ((agent_tier = ANY (ARRAY['TIER-1'::text, 'TIER-2'::text, 'TIER-3'::text]))),
    CONSTRAINT agent_health_attestations_health_status_check CHECK ((health_status = ANY (ARRAY['HEALTHY'::text, 'DEGRADED'::text, 'STALE'::text, 'DISCONNECTED'::text, 'HALTED'::text])))
);


--
-- Name: TABLE agent_health_attestations; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.agent_health_attestations IS 'Agent health attestations per ADR-018 and CEO Directive v2.0.
Each agent must attest health every 5 minutes. Non-compliant agents are flagged.';


--
-- Name: agent_heartbeats; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.agent_heartbeats (
    heartbeat_id integer NOT NULL,
    agent_id character varying(50) NOT NULL,
    component character varying(100),
    current_task character varying(255),
    health_score numeric(4,3) DEFAULT 1.0,
    events_processed integer DEFAULT 0,
    errors_count integer DEFAULT 0,
    last_heartbeat timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now(),
    health_source character varying(50) DEFAULT 'governance'::character varying,
    liveness_basis text,
    liveness_metadata jsonb
);


--
-- Name: TABLE agent_heartbeats; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.agent_heartbeats IS 'Agent heartbeat tracking. ARO-20251208 Section 2.2.
Every agent must publish heartbeat every 30 seconds.
Missing heartbeat triggers DEFCON YELLOW automatically.';


--
-- Name: COLUMN agent_heartbeats.health_source; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.agent_heartbeats.health_source IS 'Source of health signal: governance (actions log), research (forecast output), execution (daemon status), mixed (multiple sources)';


--
-- Name: COLUMN agent_heartbeats.liveness_basis; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.agent_heartbeats.liveness_basis IS 'Human-readable explanation of how liveness was determined for this agent';


--
-- Name: COLUMN agent_heartbeats.liveness_metadata; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.agent_heartbeats.liveness_metadata IS 'Structured metadata from liveness probes (forecast counts, daemon status, etc.)';


--
-- Name: agent_heartbeats_heartbeat_id_seq; Type: SEQUENCE; Schema: fhq_governance; Owner: -
--

CREATE SEQUENCE fhq_governance.agent_heartbeats_heartbeat_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: agent_heartbeats_heartbeat_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_governance; Owner: -
--

ALTER SEQUENCE fhq_governance.agent_heartbeats_heartbeat_id_seq OWNED BY fhq_governance.agent_heartbeats.heartbeat_id;


--
-- Name: agent_task_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.agent_task_log (
    task_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id text NOT NULL,
    task_name text NOT NULL,
    task_type text NOT NULL,
    status text DEFAULT 'PENDING'::text NOT NULL,
    started_at timestamp with time zone DEFAULT now(),
    completed_at timestamp with time zone,
    latency_ms integer,
    cost_usd numeric(10,6) DEFAULT 0,
    tokens_in integer DEFAULT 0,
    tokens_out integer DEFAULT 0,
    provider text,
    model text,
    tier integer,
    signature_hash text,
    quad_hash text,
    fallback_used boolean DEFAULT false,
    retry_count integer DEFAULT 0,
    result_summary text,
    error_message text,
    created_at timestamp with time zone DEFAULT now(),
    telemetry_envelope_id uuid,
    stream_mode boolean DEFAULT false,
    stream_chunks integer,
    correlation_id uuid,
    error_type character varying(100),
    error_payload jsonb
);


--
-- Name: COLUMN agent_task_log.telemetry_envelope_id; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.agent_task_log.telemetry_envelope_id IS 'FK to llm_routing_log.envelope_id';


--
-- Name: agent_integrity_log_v; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.agent_integrity_log_v AS
 SELECT task_id,
    agent_id,
    task_name,
    task_type,
    status,
    started_at,
    completed_at,
    latency_ms,
    cost_usd,
    provider,
    model,
    signature_hash,
    quad_hash,
    fallback_used,
    retry_count,
    error_message,
        CASE
            WHEN (status = ANY (ARRAY['FAILED'::text, 'ERROR'::text])) THEN 'ERROR'::text
            WHEN (fallback_used = true) THEN 'WARNING'::text
            WHEN (retry_count > 0) THEN 'WARNING'::text
            WHEN (signature_hash IS NULL) THEN 'WARNING'::text
            ELSE 'OK'::text
        END AS governance_flag,
        CASE
            WHEN (retry_count > 2) THEN 'HIGH_DRIFT'::text
            WHEN (fallback_used = true) THEN 'FALLBACK_MODE'::text
            WHEN (retry_count > 0) THEN 'RETRY_MODE'::text
            ELSE 'NORMAL'::text
        END AS drift_mode,
    row_number() OVER (PARTITION BY agent_id ORDER BY started_at DESC) AS task_rank
   FROM fhq_governance.agent_task_log tl
  WHERE (created_at >= (now() - '30 days'::interval))
  ORDER BY started_at DESC;


--
-- Name: llm_routing_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.llm_routing_log (
    log_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id text NOT NULL,
    request_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    requested_provider text NOT NULL,
    requested_tier integer NOT NULL,
    routed_provider text NOT NULL,
    routed_tier integer NOT NULL,
    policy_id uuid,
    policy_satisfied boolean NOT NULL,
    violation_detected boolean DEFAULT false NOT NULL,
    violation_action_taken text,
    request_context jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    envelope_id uuid,
    task_name character varying(255),
    task_type character varying(50),
    model character varying(100),
    tokens_in integer DEFAULT 0,
    tokens_out integer DEFAULT 0,
    latency_ms integer,
    cost_usd numeric(10,6) DEFAULT 0,
    timestamp_utc timestamp with time zone DEFAULT now(),
    correlation_id uuid,
    cognitive_parent_id uuid,
    protocol_ref uuid,
    cognitive_modality fhq_cognition.cognitive_modality,
    stream_mode boolean DEFAULT false,
    stream_chunks integer,
    stream_token_accumulator integer,
    stream_first_token_ms integer,
    governance_context_hash character(64),
    error_type character varying(100),
    error_payload jsonb,
    hash_chain_id character varying(100),
    hash_self character(64),
    hash_prev character(64),
    lineage_hash character(64),
    backfill boolean DEFAULT false
);


--
-- Name: COLUMN llm_routing_log.envelope_id; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.llm_routing_log.envelope_id IS 'Unique telemetry envelope identifier';


--
-- Name: COLUMN llm_routing_log.cognitive_parent_id; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.llm_routing_log.cognitive_parent_id IS 'Parent node in reasoning chain (ADR-021)';


--
-- Name: COLUMN llm_routing_log.protocol_ref; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.llm_routing_log.protocol_ref IS 'Research protocol reference (SitC Chain-of-Query)';


--
-- Name: COLUMN llm_routing_log.cognitive_modality; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.llm_routing_log.cognitive_modality IS 'Cognitive classification per ADR-021';


--
-- Name: COLUMN llm_routing_log.stream_mode; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.llm_routing_log.stream_mode IS 'Whether streaming was used';


--
-- Name: COLUMN llm_routing_log.stream_first_token_ms; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.llm_routing_log.stream_first_token_ms IS 'Time to first token (TTFT)';


--
-- Name: COLUMN llm_routing_log.governance_context_hash; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.llm_routing_log.governance_context_hash IS 'IoS-013 Truth Gateway hash';


--
-- Name: COLUMN llm_routing_log.backfill; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.llm_routing_log.backfill IS 'TRUE if row was backfilled from historical data';


--
-- Name: agent_llm_usage_v; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.agent_llm_usage_v AS
 SELECT agent_id,
    count(*) AS total_calls_7d,
    COALESCE(sum(tokens_in), (0)::bigint) AS total_tokens_in_7d,
    COALESCE(sum(tokens_out), (0)::bigint) AS total_tokens_out_7d,
    COALESCE(sum(cost_usd), (0)::numeric) AS total_cost_7d,
    (COALESCE(avg(latency_ms), (0)::numeric))::integer AS avg_latency_ms,
    count(*) FILTER (WHERE (error_type IS NOT NULL)) AS error_count_7d,
    count(*) FILTER (WHERE (stream_mode = true)) AS streaming_calls_7d,
    max(timestamp_utc) AS last_llm_call
   FROM fhq_governance.llm_routing_log
  WHERE ((timestamp_utc >= (now() - '7 days'::interval)) AND (envelope_id IS NOT NULL))
  GROUP BY agent_id;


--
-- Name: agent_mandates; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.agent_mandates (
    mandate_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_name text NOT NULL,
    mandate_version text DEFAULT 'v1.0'::text NOT NULL,
    mandate_type text NOT NULL,
    authority_type text NOT NULL,
    parent_agent text,
    mandate_document jsonb NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: agent_memory_ledger; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.agent_memory_ledger (
    memory_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id text NOT NULL,
    agent_tier text NOT NULL,
    memory_type text NOT NULL,
    state_vector_hash text NOT NULL,
    state_timestamp timestamp with time zone NOT NULL,
    memory_summary text NOT NULL,
    memory_payload jsonb,
    sequence_number bigint NOT NULL,
    previous_memory_hash text,
    memory_hash text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT agent_memory_ledger_memory_type_check CHECK ((memory_type = ANY (ARRAY['STATE_RETRIEVAL'::text, 'OUTPUT_GENERATED'::text, 'DECISION_MADE'::text, 'ERROR_ENCOUNTERED'::text, 'GOVERNANCE_ACTION'::text, 'SYNC_EVENT'::text])))
);


--
-- Name: TABLE agent_memory_ledger; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.agent_memory_ledger IS 'Immutable agent memory ledger per CEO Directive v2.0.
Every agent action is logged with its governing state context.
Hash chain ensures memory integrity.';


--
-- Name: agent_suspension_requests; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.agent_suspension_requests (
    request_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id text NOT NULL,
    requested_by text NOT NULL,
    reason text NOT NULL,
    discrepancy_score numeric(6,5) NOT NULL,
    evidence jsonb NOT NULL,
    status text NOT NULL,
    reviewed_by text,
    reviewed_at timestamp with time zone,
    review_rationale text,
    evidence_hash text NOT NULL,
    hash_chain_id text NOT NULL,
    request_signature text NOT NULL,
    signature_verified boolean DEFAULT false,
    adr_reference text DEFAULT 'ADR-009'::text NOT NULL,
    discrepancy_threshold numeric(6,5) DEFAULT 0.10 NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT agent_suspension_requests_discrepancy_score_check CHECK (((discrepancy_score >= (0)::numeric) AND (discrepancy_score <= 1.0))),
    CONSTRAINT agent_suspension_requests_status_check CHECK ((status = ANY (ARRAY['PENDING'::text, 'APPROVED'::text, 'REJECTED'::text])))
);


--
-- Name: TABLE agent_suspension_requests; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.agent_suspension_requests IS 'ADR-009 Section 5.2: Agent suspension request records with dual-approval workflow';


--
-- Name: COLUMN agent_suspension_requests.evidence; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.agent_suspension_requests.evidence IS 'JSONB evidence bundle: state_snapshots, metrics, signatures, timestamps, reconciliation_data';


--
-- Name: COLUMN agent_suspension_requests.status; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.agent_suspension_requests.status IS 'Workflow status: PENDING (awaiting CEO review), APPROVED (suspension enforced), REJECTED (override logged)';


--
-- Name: agent_task_stats_v; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.agent_task_stats_v AS
 SELECT agent_id,
    count(*) AS total_tasks,
    count(*) FILTER (WHERE (status = 'SUCCESS'::text)) AS success_count,
    count(*) FILTER (WHERE (status = 'FAILED'::text)) AS failure_count,
    count(*) FILTER (WHERE (retry_count > 0)) AS retry_count,
    count(*) FILTER (WHERE (fallback_used = true)) AS fallback_count,
    round(avg(latency_ms)) AS avg_latency_ms,
    sum(cost_usd) AS total_cost_usd,
    max(completed_at) AS last_task_completed
   FROM fhq_governance.agent_task_log
  WHERE (created_at >= (now() - '7 days'::interval))
  GROUP BY agent_id;


--
-- Name: aiqf_benchmark_registry; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.aiqf_benchmark_registry (
    benchmark_id uuid DEFAULT gen_random_uuid() NOT NULL,
    benchmark_name character varying(100) NOT NULL,
    benchmark_version integer NOT NULL,
    dataset_hash character varying(64) NOT NULL,
    query_count integer NOT NULL,
    query_set jsonb NOT NULL,
    expected_results_fingerprint character varying(64) NOT NULL,
    query_class_distribution jsonb DEFAULT '{"simple_lookup": 10, "multi_table_join": 15, "aggregation_filter": 15, "complex_nested_window": 10}'::jsonb NOT NULL,
    scoring_function_version character varying(20) DEFAULT 'v1.0'::character varying NOT NULL,
    scoring_formula text DEFAULT '(correct_first_attempt * 0.6) + (correct_within_3 * 0.25) + (semantic_correct * 0.1) + (no_escalation * 0.05)'::text NOT NULL,
    model_version character varying(100),
    prompt_template_hash character varying(64),
    prompt_template_version character varying(20),
    pass_threshold double precision DEFAULT 0.95 NOT NULL,
    drift_tolerance double precision DEFAULT 0.02 NOT NULL,
    minimum_sample_size integer DEFAULT 50 NOT NULL,
    created_by character varying(20) NOT NULL,
    vega_certified boolean DEFAULT false,
    vega_certification_attestation_id uuid,
    vega_certification_date timestamp with time zone,
    is_active boolean DEFAULT true,
    supersedes_benchmark_id uuid,
    sunset_at timestamp with time zone,
    sunset_reason text,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT aiqf_benchmark_registry_query_count_check CHECK ((query_count > 0))
);


--
-- Name: aiqf_benchmark_runs; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.aiqf_benchmark_runs (
    run_id uuid DEFAULT gen_random_uuid() NOT NULL,
    benchmark_id uuid NOT NULL,
    run_purpose character varying(50),
    correct_first_attempt_count integer DEFAULT 0 NOT NULL,
    correct_within_3_count integer DEFAULT 0 NOT NULL,
    semantic_correct_count integer DEFAULT 0 NOT NULL,
    escalated_count integer DEFAULT 0 NOT NULL,
    total_queries_run integer NOT NULL,
    correct_first_attempt_rate double precision GENERATED ALWAYS AS (
CASE
    WHEN (total_queries_run > 0) THEN ((correct_first_attempt_count)::double precision / (total_queries_run)::double precision)
    ELSE (0.0)::double precision
END) STORED,
    correct_within_3_rate double precision GENERATED ALWAYS AS (
CASE
    WHEN (total_queries_run > 0) THEN ((correct_within_3_count)::double precision / (total_queries_run)::double precision)
    ELSE (0.0)::double precision
END) STORED,
    semantic_correct_rate double precision GENERATED ALWAYS AS (
CASE
    WHEN (total_queries_run > 0) THEN ((semantic_correct_count)::double precision / (total_queries_run)::double precision)
    ELSE (0.0)::double precision
END) STORED,
    no_escalation_rate double precision GENERATED ALWAYS AS (
CASE
    WHEN (total_queries_run > 0) THEN ((1.0)::double precision - ((escalated_count)::double precision / (total_queries_run)::double precision))
    ELSE (1.0)::double precision
END) STORED,
    aiqf_score double precision GENERATED ALWAYS AS ((((
CASE
    WHEN (total_queries_run > 0) THEN (((correct_first_attempt_count)::double precision / (total_queries_run)::double precision) * (0.60)::double precision)
    ELSE (0.0)::double precision
END +
CASE
    WHEN (total_queries_run > 0) THEN (((correct_within_3_count)::double precision / (total_queries_run)::double precision) * (0.25)::double precision)
    ELSE (0.0)::double precision
END) +
CASE
    WHEN (total_queries_run > 0) THEN (((semantic_correct_count)::double precision / (total_queries_run)::double precision) * (0.10)::double precision)
    ELSE (0.0)::double precision
END) +
CASE
    WHEN (total_queries_run > 0) THEN (((1.0)::double precision - ((escalated_count)::double precision / (total_queries_run)::double precision)) * (0.05)::double precision)
    ELSE (0.05)::double precision
END)) STORED,
    passed boolean,
    gate_decision character varying(20),
    gate_decision_reason text,
    avg_latency_ms double precision,
    p95_latency_ms double precision,
    max_latency_ms integer,
    total_tokens_consumed integer,
    total_cost_usd double precision,
    run_evidence_hash character varying(64) NOT NULL,
    detailed_results jsonb,
    baseline_run_id uuid,
    drift_from_baseline double precision,
    drift_alert_triggered boolean DEFAULT false,
    executed_by character varying(20) NOT NULL,
    execution_environment jsonb,
    executed_at timestamp with time zone DEFAULT now(),
    governance_action_id uuid,
    vega_review_required boolean DEFAULT false,
    vega_review_attestation_id uuid,
    CONSTRAINT aiqf_benchmark_runs_gate_decision_check CHECK (((gate_decision)::text = ANY ((ARRAY['PASS'::character varying, 'FAIL'::character varying, 'CONDITIONAL'::character varying, 'PENDING'::character varying])::text[]))),
    CONSTRAINT aiqf_benchmark_runs_run_purpose_check CHECK (((run_purpose)::text = ANY ((ARRAY['BASELINE'::character varying, 'REGRESSION'::character varying, 'PROMOTION'::character varying, 'CERTIFICATION'::character varying, 'DRIFT_CHECK'::character varying, 'POST_CHANGE'::character varying])::text[])))
);


--
-- Name: aiqf_drift_alerts; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.aiqf_drift_alerts (
    alert_id uuid DEFAULT gen_random_uuid() NOT NULL,
    run_id uuid NOT NULL,
    benchmark_id uuid NOT NULL,
    alert_type character varying(30),
    severity character varying(20),
    current_aiqf double precision NOT NULL,
    baseline_aiqf double precision,
    threshold double precision DEFAULT 0.95 NOT NULL,
    drift_amount double precision,
    anomaly_component character varying(30),
    anomaly_details jsonb,
    acknowledged boolean DEFAULT false,
    acknowledged_by character varying(20),
    acknowledged_at timestamp with time zone,
    resolution_action text,
    resolved boolean DEFAULT false,
    resolved_at timestamp with time zone,
    defcon_escalation_triggered boolean DEFAULT false,
    defcon_level character varying(10),
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT aiqf_drift_alerts_alert_type_check CHECK (((alert_type)::text = ANY ((ARRAY['THRESHOLD_BREACH'::character varying, 'DRIFT_EXCEEDED'::character varying, 'COMPONENT_ANOMALY'::character varying, 'LATENCY_SPIKE'::character varying, 'COST_SPIKE'::character varying])::text[]))),
    CONSTRAINT aiqf_drift_alerts_severity_check CHECK (((severity)::text = ANY ((ARRAY['WARNING'::character varying, 'CRITICAL'::character varying, 'EMERGENCY'::character varying])::text[])))
);


--
-- Name: api_budget_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.api_budget_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    provider_name text NOT NULL,
    usage_date date DEFAULT CURRENT_DATE NOT NULL,
    requests_made integer DEFAULT 0 NOT NULL,
    daily_limit integer NOT NULL,
    usage_percent numeric(5,2) GENERATED ALWAYS AS (
CASE
    WHEN (daily_limit > 0) THEN round((((requests_made)::numeric / (daily_limit)::numeric) * (100)::numeric), 2)
    ELSE (0)::numeric
END) STORED,
    threshold_90_breached boolean GENERATED ALWAYS AS (
CASE
    WHEN (daily_limit > 0) THEN (((requests_made)::numeric / (daily_limit)::numeric) >= 0.90)
    ELSE false
END) STORED,
    threshold_100_breached boolean GENERATED ALWAYS AS (
CASE
    WHEN (daily_limit > 0) THEN (requests_made >= daily_limit)
    ELSE false
END) STORED,
    last_request_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE api_budget_log; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.api_budget_log IS 'Operational API budget tracking counters. Updated by llm_routing_log trigger. Not immutable - allows daily counter updates.';


--
-- Name: api_provider_registry; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.api_provider_registry (
    provider_id uuid DEFAULT gen_random_uuid() NOT NULL,
    provider_name text NOT NULL,
    provider_type text NOT NULL,
    usage_tier text NOT NULL,
    base_url text,
    daily_limit integer DEFAULT 0 NOT NULL,
    rate_limit_per_minute integer DEFAULT 60,
    cost_per_call numeric(10,6) DEFAULT 0,
    requires_api_key boolean DEFAULT true NOT NULL,
    key_env_variable text,
    is_active boolean DEFAULT true NOT NULL,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT api_provider_registry_provider_type_check CHECK ((provider_type = ANY (ARRAY['MARKET_DATA'::text, 'NEWS'::text, 'MACRO'::text, 'SEARCH'::text, 'ANALYTICS'::text, 'LLM'::text, 'EXECUTION'::text]))),
    CONSTRAINT api_provider_registry_usage_tier_check CHECK ((usage_tier = ANY (ARRAY['LAKE'::text, 'PULSE'::text, 'SNIPER'::text, 'TIER_1'::text, 'TIER_2'::text, 'TIER_3'::text, 'EXECUTION'::text])))
);


--
-- Name: api_usage_events; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.api_usage_events (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    provider_name text NOT NULL,
    endpoint text,
    request_type text,
    response_status integer,
    latency_ms integer,
    cost_usd numeric(10,6) DEFAULT 0,
    agent_id text,
    ios_id text,
    "timestamp" timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: artifact_time_registry; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.artifact_time_registry (
    artifact_id text NOT NULL,
    artifact_type text NOT NULL,
    artifact_source text NOT NULL,
    canonical_created_at timestamp with time zone NOT NULL,
    canonical_verified_at timestamp with time zone,
    canonical_clock_version text DEFAULT 'v1.0'::text NOT NULL,
    source_db_txid bigint,
    time_integrity_status text DEFAULT 'PENDING'::text NOT NULL,
    time_integrity_reason text,
    is_pre_canonical boolean DEFAULT false NOT NULL,
    artifact_hash text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    verified_by text,
    CONSTRAINT valid_canonical_time CHECK ((canonical_created_at <= now()))
);


--
-- Name: asrp_state_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.asrp_state_log (
    log_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id text NOT NULL,
    task_id uuid,
    pre_state_hash text NOT NULL,
    post_state_hash text,
    expected_state_hash text,
    signature_hash text,
    signature_verified boolean DEFAULT false,
    state_mismatch boolean DEFAULT false,
    mismatch_severity text,
    enforcement_action text,
    operation_type text,
    operation_context jsonb,
    recorded_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: asrp_violations; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.asrp_violations (
    violation_id uuid DEFAULT gen_random_uuid() NOT NULL,
    violation_type text NOT NULL,
    violation_class text DEFAULT 'CLASS_A'::text NOT NULL,
    agent_id text NOT NULL,
    agent_tier text,
    attempted_action text NOT NULL,
    state_hash_expected text,
    state_hash_provided text,
    enforcement_action text NOT NULL,
    defcon_escalation text,
    evidence_bundle jsonb NOT NULL,
    resolution_status text,
    resolved_by text,
    resolved_at timestamp with time zone,
    resolution_notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    hash_chain_id text,
    CONSTRAINT asrp_violations_enforcement_action_check CHECK ((enforcement_action = ANY (ARRAY['BLOCKED'::text, 'ISOLATED'::text, 'SUSPENDED'::text, 'ESCALATED'::text, 'DEFCON_TRIGGERED'::text]))),
    CONSTRAINT asrp_violations_resolution_status_check CHECK ((resolution_status = ANY (ARRAY['PENDING'::text, 'RESOLVED'::text, 'ESCALATED'::text]))),
    CONSTRAINT asrp_violations_violation_type_check CHECK ((violation_type = ANY (ARRAY['BYPASS_ATTEMPT'::text, 'STALE_STATE_USE'::text, 'MISSING_HASH'::text, 'AUTHORITY_OVERRIDE'::text, 'INVALID_READ'::text, 'LOCAL_CACHE'::text, 'TORN_READ'::text])))
);


--
-- Name: TABLE asrp_violations; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.asrp_violations IS 'Class A governance violations per ADR-018 7.
All violations trigger ADR-009 suspension review.
Agents exhibiting drift/mismatch are isolated under RISL (ADR-017).';


--
-- Name: execution_attempts; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.execution_attempts (
    attempt_id uuid DEFAULT gen_random_uuid() NOT NULL,
    intent_draft_id uuid NOT NULL,
    needle_id uuid NOT NULL,
    decision_plan_id uuid,
    chain_epoch_id uuid DEFAULT '00000000-0000-0000-0000-000000000001'::uuid NOT NULL,
    hash_prev text NOT NULL,
    hash_self text NOT NULL,
    chain_sequence bigint NOT NULL,
    gate_exposure_passed boolean,
    gate_exposure_reason text,
    gate_holiday_passed boolean,
    gate_holiday_reason text,
    gate_btc_only_passed boolean,
    gate_btc_only_reason text,
    gate_regime_stability_passed boolean,
    gate_regime_stability_reason text,
    gate_sitc_passed boolean,
    gate_sitc_reason text,
    gate_ikea_passed boolean,
    gate_ikea_reason text,
    gate_inforage_passed boolean,
    gate_inforage_reason text,
    gate_causal_passed boolean,
    gate_causal_reason text,
    gate_fss_passed boolean,
    gate_fss_reason text,
    gate_ttl_passed boolean,
    gate_ttl_reason text,
    final_outcome text NOT NULL,
    blocked_at_gate text,
    block_reason text,
    sitc_event_id uuid,
    inforage_session_id uuid,
    ikea_validation_id uuid,
    causal_edge_refs uuid[],
    audit_only_mode boolean DEFAULT false,
    cognition_started_at timestamp with time zone,
    cognition_completed_at timestamp with time zone,
    cognition_duration_ms integer,
    attempt_started_at timestamp with time zone DEFAULT now() NOT NULL,
    attempt_completed_at timestamp with time zone,
    signing_agent text,
    signature text,
    CONSTRAINT execution_attempts_final_outcome_check CHECK ((final_outcome = ANY (ARRAY['EXECUTED'::text, 'BLOCKED'::text, 'ABORTED'::text, 'EXPIRED'::text, 'COST_ABORT'::text]))),
    CONSTRAINT valid_hash_chain CHECK (((hash_prev ~ '^[a-f0-9]{64}$'::text) OR (hash_prev = 'GENESIS'::text))),
    CONSTRAINT valid_hash_self CHECK ((hash_self ~ '^[a-f0-9]{64}$'::text))
);


--
-- Name: TABLE execution_attempts; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.execution_attempts IS 'CEO-DIR-2026-FINN-019 NB-02: ADR-011 Fortress-compliant attempt chain with hash linkage';


--
-- Name: COLUMN execution_attempts.chain_epoch_id; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_attempts.chain_epoch_id IS 'R6: Chain epoch for future rotation without breaking history';


--
-- Name: COLUMN execution_attempts.audit_only_mode; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_attempts.audit_only_mode IS 'R1: True if cognitive stack ran in audit-only mode (hard-blocked attempt)';


--
-- Name: attempt_chain_audit; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.attempt_chain_audit AS
 SELECT attempt_id,
    chain_epoch_id,
    chain_sequence,
    hash_prev,
    hash_self,
    lag(hash_self) OVER (PARTITION BY chain_epoch_id ORDER BY chain_sequence) AS expected_hash_prev,
        CASE
            WHEN ((chain_sequence = 1) AND (hash_prev = 'GENESIS'::text)) THEN 'VALID'::text
            WHEN (hash_prev = lag(hash_self) OVER (PARTITION BY chain_epoch_id ORDER BY chain_sequence)) THEN 'VALID'::text
            ELSE 'CHAIN_BROKEN'::text
        END AS chain_status
   FROM fhq_governance.execution_attempts a
  ORDER BY chain_epoch_id, chain_sequence;


--
-- Name: VIEW attempt_chain_audit; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.attempt_chain_audit IS 'CEO-DIR-2026-FINN-019 Issue #14: ADR-011 hash chain integrity verification';


--
-- Name: audit_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.audit_log (
    log_id uuid DEFAULT gen_random_uuid() NOT NULL,
    event_type text NOT NULL,
    event_category text NOT NULL,
    event_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    target_type text NOT NULL,
    target_id text NOT NULL,
    target_version text,
    actor_id text NOT NULL,
    actor_role text,
    event_data jsonb DEFAULT '{}'::jsonb NOT NULL,
    previous_state jsonb,
    new_state jsonb,
    event_hash text NOT NULL,
    hash_algorithm text DEFAULT 'SHA-256'::text NOT NULL,
    signature text,
    signature_verified boolean DEFAULT false,
    governance_gate text,
    adr_reference text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT audit_log_category_check CHECK ((event_category = ANY (ARRAY['ADR'::text, 'GOVERNANCE'::text, 'SECURITY'::text, 'COMPLIANCE'::text, 'OPERATIONAL'::text, 'SYSTEM'::text]))),
    CONSTRAINT audit_log_gate_check CHECK (((governance_gate IS NULL) OR (governance_gate = ANY (ARRAY['G1'::text, 'G2'::text, 'G3'::text, 'G4'::text]))))
);


--
-- Name: TABLE audit_log; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.audit_log IS 'G3/G4 Governance audit trail for ADR approvals and compliance events';


--
-- Name: authority_matrix; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.authority_matrix (
    matrix_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_name text NOT NULL,
    authority_level integer DEFAULT 2 NOT NULL,
    can_write_canonical boolean DEFAULT false NOT NULL,
    can_trigger_g2 boolean DEFAULT false NOT NULL,
    can_trigger_g3 boolean DEFAULT false NOT NULL,
    can_trigger_g4 boolean DEFAULT false NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: batch_graduation_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.batch_graduation_log (
    graduation_id uuid DEFAULT gen_random_uuid() NOT NULL,
    batch_id text NOT NULL,
    directive_id text NOT NULL,
    criteria_id uuid,
    run_start integer NOT NULL,
    run_end integer NOT NULL,
    steady_state_start integer NOT NULL,
    evaluated_at timestamp with time zone DEFAULT now() NOT NULL,
    convergence_slope numeric(8,6),
    convergence_passed boolean,
    rdi_mean numeric(5,4),
    rdi_passed boolean,
    waste_mean numeric(5,4),
    waste_passed boolean,
    rdi_std_dev numeric(5,4),
    variance_passed boolean,
    vitality_count integer,
    vitality_percentage numeric(5,4),
    vitality_passed boolean,
    all_gates_passed boolean NOT NULL,
    graduation_status text NOT NULL,
    g4_recommendation_issued boolean DEFAULT false,
    certification_granted boolean DEFAULT false,
    evidence_path text,
    evidence_hash text,
    CONSTRAINT batch_graduation_log_graduation_status_check CHECK ((graduation_status = ANY (ARRAY['GRADUATED'::text, 'REVIEW_REQUIRED'::text, 'FAILED'::text, 'PENDING'::text])))
);


--
-- Name: blackout_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.blackout_log (
    log_id uuid DEFAULT gen_random_uuid() NOT NULL,
    event_type text NOT NULL,
    canonical_id text,
    staleness_minutes integer,
    threshold_minutes integer,
    blocked_action text,
    logged_at timestamp with time zone DEFAULT now(),
    CONSTRAINT valid_event_type CHECK ((event_type = ANY (ARRAY['BLACKOUT_TRIGGERED'::text, 'TRADE_BLOCKED'::text, 'LEARNING_BLOCKED'::text, 'BLACKOUT_CLEARED'::text])))
);


--
-- Name: brier_score_ledger; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.brier_score_ledger (
    score_id uuid DEFAULT gen_random_uuid() NOT NULL,
    belief_id uuid,
    forecast_type text NOT NULL,
    asset_id text,
    regime text NOT NULL,
    asset_class text,
    forecast_probability numeric(6,4) NOT NULL,
    actual_outcome boolean NOT NULL,
    squared_error numeric(6,4) NOT NULL,
    forecast_timestamp timestamp with time zone NOT NULL,
    outcome_timestamp timestamp with time zone NOT NULL,
    forecast_horizon_hours integer NOT NULL,
    generated_by text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT brier_score_ledger_forecast_probability_check CHECK (((forecast_probability >= (0)::numeric) AND (forecast_probability <= (1)::numeric))),
    CONSTRAINT brier_score_ledger_forecast_type_check CHECK ((forecast_type = ANY (ARRAY['REGIME_CLASSIFICATION'::text, 'FORECAST_BELIEF'::text, 'SIGNAL_CONFIDENCE'::text]))),
    CONSTRAINT brier_score_ledger_squared_error_check CHECK (((squared_error >= (0)::numeric) AND (squared_error <= (1)::numeric)))
);


--
-- Name: cadence_exception_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.cadence_exception_log (
    exception_id uuid DEFAULT gen_random_uuid() NOT NULL,
    exception_date date NOT NULL,
    original_threshold numeric(5,4) NOT NULL,
    requested_threshold numeric(5,4) NOT NULL,
    approved_threshold numeric(5,4),
    reason text NOT NULL,
    requested_by text NOT NULL,
    approved_by text,
    approved_at timestamp with time zone,
    expires_at timestamp with time zone NOT NULL,
    status text DEFAULT 'PENDING'::text,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT cadence_exception_log_status_check CHECK ((status = ANY (ARRAY['PENDING'::text, 'APPROVED'::text, 'REJECTED'::text, 'EXPIRED'::text])))
);


--
-- Name: calibration_audit_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.calibration_audit_log (
    id integer NOT NULL,
    calibration_id integer,
    parameter_name text NOT NULL,
    version text NOT NULL,
    action text NOT NULL,
    old_value numeric,
    new_value numeric,
    actor text NOT NULL,
    reason text,
    metadata jsonb DEFAULT '{}'::jsonb,
    logged_at timestamp with time zone DEFAULT now()
);


--
-- Name: calibration_audit_log_id_seq; Type: SEQUENCE; Schema: fhq_governance; Owner: -
--

CREATE SEQUENCE fhq_governance.calibration_audit_log_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: calibration_audit_log_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_governance; Owner: -
--

ALTER SEQUENCE fhq_governance.calibration_audit_log_id_seq OWNED BY fhq_governance.calibration_audit_log.id;


--
-- Name: calibration_dashboard; Type: MATERIALIZED VIEW; Schema: fhq_governance; Owner: -
--

CREATE MATERIALIZED VIEW fhq_governance.calibration_dashboard AS
 SELECT regime,
    forecast_type,
    asset_class,
    count(*) AS total_forecasts,
    avg(squared_error) AS brier_score,
    stddev(squared_error) AS brier_std_dev,
    min(forecast_timestamp) AS first_forecast,
    max(forecast_timestamp) AS latest_forecast,
    avg(forecast_horizon_hours) AS avg_horizon_hours
   FROM fhq_governance.brier_score_ledger
  WHERE (created_at >= (now() - '90 days'::interval))
  GROUP BY regime, forecast_type, asset_class
  ORDER BY regime, forecast_type, asset_class
  WITH NO DATA;


--
-- Name: calibration_gate_history; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.calibration_gate_history (
    history_id uuid DEFAULT gen_random_uuid() NOT NULL,
    gate_id uuid NOT NULL,
    action text NOT NULL,
    old_ceiling numeric(5,4),
    new_ceiling numeric(5,4),
    old_accuracy numeric(5,4),
    new_accuracy numeric(5,4),
    change_reason text,
    changed_by text NOT NULL,
    changed_at timestamp with time zone DEFAULT now()
);


--
-- Name: calibration_versions; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.calibration_versions (
    id integer NOT NULL,
    parameter_name text NOT NULL,
    version text NOT NULL,
    value numeric NOT NULL,
    description text,
    calibration_window timestamp with time zone NOT NULL,
    calibration_source text DEFAULT 'PILOT'::text,
    source_metrics jsonb DEFAULT '{}'::jsonb,
    proposed_at timestamp with time zone DEFAULT now(),
    proposed_by text DEFAULT 'FINN'::text,
    frozen_at timestamp with time zone,
    frozen_by text,
    vega_approval_ref text,
    is_active boolean DEFAULT false,
    activated_at timestamp with time zone,
    deactivated_at timestamp with time zone,
    previous_version text,
    rollback_reason text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT calibration_versions_frozen_has_approval CHECK (((frozen_at IS NULL) OR (vega_approval_ref IS NOT NULL)))
);


--
-- Name: calibration_status; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.calibration_status AS
 SELECT parameter_name,
    version,
    value,
    description,
    is_active,
    frozen_at,
    vega_approval_ref,
    activated_at,
    previous_version,
        CASE
            WHEN (is_active AND (frozen_at IS NOT NULL)) THEN 'PRODUCTION'::text
            WHEN (frozen_at IS NOT NULL) THEN 'FROZEN (not active)'::text
            ELSE 'PROPOSED (awaiting VEGA)'::text
        END AS status,
    source_metrics
   FROM fhq_governance.calibration_versions cv
  ORDER BY parameter_name, frozen_at DESC NULLS LAST;


--
-- Name: calibration_versions_id_seq; Type: SEQUENCE; Schema: fhq_governance; Owner: -
--

CREATE SEQUENCE fhq_governance.calibration_versions_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: calibration_versions_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_governance; Owner: -
--

ALTER SEQUENCE fhq_governance.calibration_versions_id_seq OWNED BY fhq_governance.calibration_versions.id;


--
-- Name: canonical_evidence; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.canonical_evidence (
    evidence_id integer NOT NULL,
    evidence_type character varying(100) NOT NULL,
    evidence_category character varying(50) NOT NULL,
    cycle_id character varying(100),
    agent_id character varying(50),
    execution_timestamp timestamp with time zone NOT NULL,
    evidence_hash character varying(64) NOT NULL,
    evidence_payload jsonb NOT NULL,
    vega_signature text NOT NULL,
    vega_public_key text NOT NULL,
    signature_verified boolean DEFAULT false,
    signature_verification_timestamp timestamp with time zone,
    registered_by character varying(50) NOT NULL,
    registered_at timestamp with time zone DEFAULT now(),
    authority character varying(200),
    adr_compliance text[],
    audit_notes text,
    immutable boolean DEFAULT true,
    CONSTRAINT chk_immutable_once_verified CHECK (((signature_verified = false) OR ((signature_verified = true) AND (immutable = true))))
);


--
-- Name: canonical_evidence_evidence_id_seq; Type: SEQUENCE; Schema: fhq_governance; Owner: -
--

CREATE SEQUENCE fhq_governance.canonical_evidence_evidence_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: canonical_evidence_evidence_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_governance; Owner: -
--

ALTER SEQUENCE fhq_governance.canonical_evidence_evidence_id_seq OWNED BY fhq_governance.canonical_evidence.evidence_id;


--
-- Name: canonical_mutation_gates; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.canonical_mutation_gates (
    gate_id uuid DEFAULT gen_random_uuid() NOT NULL,
    mutation_type text NOT NULL,
    target_domain text,
    target_id uuid,
    g1_technical_validation boolean DEFAULT false,
    g1_validated_at timestamp with time zone,
    g1_validated_by text,
    g1_evidence jsonb,
    g2_governance_validation boolean DEFAULT false,
    g2_validated_at timestamp with time zone,
    g2_validated_by text,
    g2_evidence jsonb,
    g3_audit_verification boolean DEFAULT false,
    g3_verified_at timestamp with time zone,
    g3_verified_by text,
    g3_evidence jsonb,
    g4_canonicalization boolean DEFAULT false,
    g4_canonicalized_at timestamp with time zone,
    g4_canonicalized_by text,
    g4_evidence jsonb,
    gate_status text DEFAULT 'G1_PENDING'::text NOT NULL,
    current_gate integer DEFAULT 1 NOT NULL,
    request_data jsonb NOT NULL,
    requested_by text NOT NULL,
    requested_at timestamp with time zone DEFAULT now() NOT NULL,
    hash_chain_id text,
    signature text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT canonical_mutation_status_check CHECK ((gate_status = ANY (ARRAY['G1_PENDING'::text, 'G1_PASSED'::text, 'G1_FAILED'::text, 'G2_PENDING'::text, 'G2_PASSED'::text, 'G2_FAILED'::text, 'G3_PENDING'::text, 'G3_PASSED'::text, 'G3_FAILED'::text, 'G4_PENDING'::text, 'G4_PASSED'::text, 'G4_FAILED'::text, 'COMPLETED'::text, 'REJECTED'::text, 'CANCELLED'::text]))),
    CONSTRAINT canonical_mutation_type_check CHECK ((mutation_type = ANY (ARRAY['DOMAIN_CREATE'::text, 'DOMAIN_UPDATE'::text, 'DOMAIN_DEACTIVATE'::text, 'SERIES_CREATE'::text, 'SERIES_UPDATE'::text, 'SERIES_DEACTIVATE'::text, 'INDICATOR_CREATE'::text, 'INDICATOR_UPDATE'::text, 'INDICATOR_DEACTIVATE'::text, 'CANONICAL_OVERRIDE'::text, 'EMERGENCY_MUTATION'::text])))
);


--
-- Name: TABLE canonical_mutation_gates; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.canonical_mutation_gates IS 'ADR-013: G1-G4 gate records for canonical truth mutations (ADR-004 compliant).';


--
-- Name: canonical_strategy; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.canonical_strategy (
    strategy_snapshot_id uuid DEFAULT gen_random_uuid() NOT NULL,
    strategy_id text NOT NULL,
    strategy_name text NOT NULL,
    strategy_version text NOT NULL,
    posture text NOT NULL,
    target_exposure numeric NOT NULL,
    cash_weight numeric NOT NULL,
    leverage_factor numeric DEFAULT 1.0 NOT NULL,
    aligned_regime text NOT NULL,
    regime_confidence numeric NOT NULL,
    authorized_by text DEFAULT 'LARS'::text NOT NULL,
    authorization_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    lineage_hash text NOT NULL,
    hash_prev text,
    hash_self text NOT NULL,
    is_active boolean DEFAULT false NOT NULL,
    superseded_by uuid,
    superseded_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT canonical_strategy_cash_weight_check CHECK (((cash_weight >= (0)::numeric) AND (cash_weight <= (1)::numeric))),
    CONSTRAINT canonical_strategy_leverage_factor_check CHECK (((leverage_factor >= (0)::numeric) AND (leverage_factor <= (3)::numeric))),
    CONSTRAINT canonical_strategy_posture_check CHECK ((posture = ANY (ARRAY['AGGRESSIVE_LONG'::text, 'LONG'::text, 'NEUTRAL'::text, 'DEFENSIVE'::text, 'CASH'::text, 'CONVEX_LONG'::text, 'CONVEX_SHORT'::text]))),
    CONSTRAINT canonical_strategy_regime_confidence_check CHECK (((regime_confidence >= (0)::numeric) AND (regime_confidence <= (1)::numeric))),
    CONSTRAINT canonical_strategy_target_exposure_check CHECK (((target_exposure >= (0)::numeric) AND (target_exposure <= (1)::numeric))),
    CONSTRAINT chk_exposure_sum CHECK (((target_exposure + cash_weight) <= 1.0001))
);


--
-- Name: TABLE canonical_strategy; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.canonical_strategy IS 'Canonical strategic posture per ADR-018 3.3. Authority: LARS (IoS-004).
Only one active strategy permitted. All agents must align to this posture.';


--
-- Name: causal_edge_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.causal_edge_log (
    log_id integer NOT NULL,
    edge_type text NOT NULL,
    source_node text NOT NULL,
    target_node text NOT NULL,
    parameters jsonb NOT NULL,
    computed_value double precision,
    p_value double precision,
    is_significant boolean,
    window_start date NOT NULL,
    window_end date NOT NULL,
    observations_used integer NOT NULL,
    computation_hash text NOT NULL,
    deterministic_verified boolean DEFAULT true,
    computed_at timestamp with time zone DEFAULT now() NOT NULL,
    computed_by text DEFAULT 'CRIO'::text NOT NULL
);


--
-- Name: causal_edge_log_log_id_seq; Type: SEQUENCE; Schema: fhq_governance; Owner: -
--

CREATE SEQUENCE fhq_governance.causal_edge_log_log_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: causal_edge_log_log_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_governance; Owner: -
--

ALTER SEQUENCE fhq_governance.causal_edge_log_log_id_seq OWNED BY fhq_governance.causal_edge_log.log_id;


--
-- Name: causal_entropy_audit; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.causal_entropy_audit (
    audit_id integer NOT NULL,
    operation text NOT NULL,
    gate text NOT NULL,
    task_group text,
    entity_type text NOT NULL,
    entity_id text,
    operation_type text NOT NULL,
    old_value jsonb,
    new_value jsonb,
    executed_by text NOT NULL,
    executed_at timestamp with time zone DEFAULT now() NOT NULL,
    warmup_active boolean DEFAULT true NOT NULL,
    propagation_blocked boolean DEFAULT true NOT NULL,
    hash_before text,
    hash_after text,
    CONSTRAINT causal_entropy_audit_gate_check CHECK ((gate = ANY (ARRAY['G0'::text, 'G1'::text, 'G2'::text, 'G3'::text, 'G4'::text])))
);


--
-- Name: causal_entropy_audit_audit_id_seq; Type: SEQUENCE; Schema: fhq_governance; Owner: -
--

CREATE SEQUENCE fhq_governance.causal_entropy_audit_audit_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: causal_entropy_audit_audit_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_governance; Owner: -
--

ALTER SEQUENCE fhq_governance.causal_entropy_audit_audit_id_seq OWNED BY fhq_governance.causal_entropy_audit.audit_id;


--
-- Name: ceo_access_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ceo_access_log (
    access_id uuid DEFAULT gen_random_uuid() NOT NULL,
    chat_id text NOT NULL,
    command text NOT NULL,
    command_args jsonb,
    query_executed text,
    query_result_hash text,
    response_sent text,
    response_hash text,
    evidence_id uuid,
    access_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    response_timestamp timestamp with time zone,
    latency_ms integer,
    rate_limit_remaining_minute integer,
    rate_limit_remaining_hour integer,
    auth_status text NOT NULL,
    auth_rejection_reason text,
    telegram_message_id text,
    ip_address text,
    user_agent text,
    CONSTRAINT valid_auth_status CHECK ((auth_status = ANY (ARRAY['AUTHENTICATED'::text, 'REJECTED'::text, 'RATE_LIMITED'::text])))
);


--
-- Name: TABLE ceo_access_log; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.ceo_access_log IS 'CEO-DIR-2026-01-03: Court-proof audit trail of all CEO Glass Window interactions';


--
-- Name: ceo_access_whitelist; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ceo_access_whitelist (
    whitelist_id uuid DEFAULT gen_random_uuid() NOT NULL,
    telegram_chat_id text NOT NULL,
    display_name text NOT NULL,
    role text DEFAULT 'CEO'::text NOT NULL,
    access_level text DEFAULT 'FULL_READ'::text NOT NULL,
    rate_limit_per_minute integer DEFAULT 10 NOT NULL,
    rate_limit_per_hour integer DEFAULT 100 NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by text DEFAULT 'STIG'::text NOT NULL,
    updated_at timestamp with time zone,
    updated_by text,
    ed25519_signature text,
    CONSTRAINT valid_access_level CHECK ((access_level = ANY (ARRAY['FULL_READ'::text, 'LIMITED_READ'::text, 'AUDIT_ONLY'::text]))),
    CONSTRAINT valid_role CHECK ((role = ANY (ARRAY['CEO'::text, 'CTO'::text, 'AUDITOR'::text])))
);


--
-- Name: TABLE ceo_access_whitelist; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.ceo_access_whitelist IS 'CEO-DIR-2026-01-03: Telegram chat ID whitelist for CEO Glass Window access';


--
-- Name: ceo_command_registry; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ceo_command_registry (
    command_id uuid DEFAULT gen_random_uuid() NOT NULL,
    command_name text NOT NULL,
    command_description text,
    view_source text NOT NULL,
    is_enabled boolean DEFAULT true NOT NULL,
    requires_args boolean DEFAULT false NOT NULL,
    arg_schema jsonb,
    rate_limit_override integer,
    query_timeout_seconds integer DEFAULT 10 NOT NULL,
    approved_by text DEFAULT 'CEO'::text NOT NULL,
    approved_at timestamp with time zone DEFAULT now() NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE ceo_command_registry; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.ceo_command_registry IS 'CEO-DIR-2026-01-03: Registry of approved read-only commands for CEO Glass Window';


--
-- Name: ceo_rate_limit_state; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ceo_rate_limit_state (
    chat_id text NOT NULL,
    requests_this_minute integer DEFAULT 0 NOT NULL,
    minute_window_start timestamp with time zone,
    requests_this_hour integer DEFAULT 0 NOT NULL,
    hour_window_start timestamp with time zone,
    last_request_at timestamp with time zone,
    total_requests_lifetime bigint DEFAULT 0 NOT NULL,
    total_rejections_lifetime bigint DEFAULT 0 NOT NULL
);


--
-- Name: TABLE ceo_rate_limit_state; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.ceo_rate_limit_state IS 'CEO-DIR-2026-01-03: Rate limiting state for CEO Glass Window';


--
-- Name: ceo_temporal_snapshots; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ceo_temporal_snapshots (
    snapshot_id uuid DEFAULT gen_random_uuid() NOT NULL,
    event_type text NOT NULL,
    event_trigger text NOT NULL,
    event_timestamp timestamp with time zone NOT NULL,
    defcon_level text,
    regime_label text,
    regime_confidence numeric(5,4),
    active_needle_count integer,
    sitc_score numeric(5,2),
    inforage_score numeric(5,2),
    ikea_score numeric(5,2),
    needle_categories jsonb,
    recent_governance_actions jsonb,
    snapshot_hash text NOT NULL,
    evidence_id uuid,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT valid_event_type CHECK ((event_type = ANY (ARRAY['DEFCON_CHANGE'::text, 'REGIME_TRANSITION'::text, 'HIGH_CONFIDENCE'::text, 'NEEDLE_SPIKE'::text, 'GOVERNANCE_BLOCK'::text, 'ACI_BREACH'::text])))
);


--
-- Name: TABLE ceo_temporal_snapshots; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.ceo_temporal_snapshots IS 'CEO-DIR-2026-01-03-PHASE-B: Temporal context snapshots for historical reflection queries';


--
-- Name: change_approvals; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.change_approvals (
    approval_id uuid DEFAULT gen_random_uuid() NOT NULL,
    ios_module text NOT NULL,
    gate text NOT NULL,
    decision text NOT NULL,
    approved_by text NOT NULL,
    approval_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    expiry_timestamp timestamp with time zone,
    approval_code text,
    rationale text,
    constraints jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT change_approvals_decision_check CHECK ((decision = ANY (ARRAY['APPROVED'::text, 'REJECTED'::text, 'PENDING'::text])))
);


--
-- Name: TABLE change_approvals; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.change_approvals IS 'Two-Man Rule governance approvals for IoS module gates (ADR-004)';


--
-- Name: change_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.change_log (
    log_id uuid DEFAULT gen_random_uuid() NOT NULL,
    change_type text NOT NULL,
    change_scope text NOT NULL,
    change_description text,
    authority text,
    approval_gate text,
    hash_chain_id text,
    agent_signatures jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by text NOT NULL
);


--
-- Name: chl_bypass_detections; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.chl_bypass_detections (
    detection_id uuid DEFAULT gen_random_uuid() NOT NULL,
    detection_type text NOT NULL,
    suspected_source text,
    advisor_id text,
    user_session_id text,
    detection_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    evidence_data jsonb NOT NULL,
    severity text NOT NULL,
    vega_alerted boolean DEFAULT false NOT NULL,
    vega_alert_id uuid,
    resolution_status text DEFAULT 'OPEN'::text,
    detected_by text DEFAULT 'CHL_MONITOR'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT chl_bypass_detections_detection_type_check CHECK ((detection_type = ANY (ARRAY['DIRECT_LLM_CALL'::text, 'MISSING_CONTEXT_HASH'::text, 'MISSING_STATE_HASH'::text, 'STALE_CONTEXT'::text, 'INVALID_SIGNATURE'::text, 'UNREGISTERED_ADVISOR'::text, 'ROLE_AUTHORITY_MISMATCH'::text]))),
    CONSTRAINT chl_bypass_detections_resolution_status_check CHECK ((resolution_status = ANY (ARRAY['OPEN'::text, 'INVESTIGATING'::text, 'RESOLVED'::text, 'FALSE_POSITIVE'::text, 'ESCALATED'::text]))),
    CONSTRAINT chl_bypass_detections_severity_check CHECK ((severity = ANY (ARRAY['CRITICAL'::text, 'HIGH'::text, 'MEDIUM'::text, 'LOW'::text])))
);


--
-- Name: TABLE chl_bypass_detections; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.chl_bypass_detections IS 'Tracks CHL bypass attempts per ADR-018 governance requirements.
Any detected bypass is a Critical Governance Violation.';


--
-- Name: chl_llm_requests; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.chl_llm_requests (
    request_id uuid DEFAULT gen_random_uuid() NOT NULL,
    advisor_id text NOT NULL,
    llm_role text NOT NULL,
    request_source text DEFAULT 'DASHBOARD'::text NOT NULL,
    request_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    truth_payload_id uuid,
    context_hash text NOT NULL,
    state_snapshot_hash text NOT NULL,
    quad_hash text,
    integrity_signature text NOT NULL,
    request_status text NOT NULL,
    truth_payload_valid boolean DEFAULT false NOT NULL,
    state_hash_present boolean DEFAULT false NOT NULL,
    context_hash_present boolean DEFAULT false NOT NULL,
    role_authority_valid boolean DEFAULT false NOT NULL,
    defcon_permitted boolean DEFAULT false NOT NULL,
    user_prompt_length integer,
    user_prompt_hash text,
    response_received boolean DEFAULT false,
    response_timestamp timestamp with time zone,
    output_binding_id uuid,
    governance_event_raised boolean DEFAULT false,
    governance_event_id uuid,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT chl_llm_requests_request_status_check CHECK ((request_status = ANY (ARRAY['SENT'::text, 'BLOCKED'::text, 'CHL_BYPASS_DETECTED'::text, 'CONTEXT_FAILED'::text, 'VALIDATION_FAILED'::text])))
);


--
-- Name: TABLE chl_llm_requests; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.chl_llm_requests IS 'Registry of all CHL-routed LLM requests per CEO Full Stack Activation Order.
Every Dashboard LLM call MUST be logged here. Calls without entries are bypass violations.';


--
-- Name: chl_request_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.chl_request_log (
    request_id uuid DEFAULT gen_random_uuid() NOT NULL,
    requesting_agent text NOT NULL,
    request_source text NOT NULL,
    request_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    package_id uuid,
    package_hash text NOT NULL,
    state_snapshot_hash text NOT NULL,
    quad_hash text,
    hydration_status text NOT NULL,
    preflight_passed boolean DEFAULT false NOT NULL,
    preflight_failures text[],
    output_bound boolean DEFAULT false,
    output_binding_id uuid,
    latency_ms integer,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT chl_request_log_hydration_status_check CHECK ((hydration_status = ANY (ARRAY['SUCCESS'::text, 'STALE_CONTEXT'::text, 'INVALID_PACKAGE'::text, 'MISSING_PACKAGE'::text, 'CHL_BYPASS_BLOCKED'::text, 'VALIDATION_FAILED'::text])))
);


--
-- Name: TABLE chl_request_log; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.chl_request_log IS 'Audit log for Context Hydration Layer (CHL) requests per IoS-013 CDS 4.
Every LLM call must be logged here with context delivery status.';


--
-- Name: circuit_breaker_events; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.circuit_breaker_events (
    event_id uuid DEFAULT gen_random_uuid() NOT NULL,
    breaker_id uuid,
    breaker_name text NOT NULL,
    event_type text NOT NULL,
    defcon_before public.defcon_level,
    defcon_after public.defcon_level,
    trigger_data jsonb,
    action_taken jsonb,
    triggered_by text NOT NULL,
    override_by text,
    override_reason text,
    event_timestamp timestamp with time zone DEFAULT now(),
    hash_prev text,
    hash_self text,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT circuit_breaker_events_event_type_check CHECK ((event_type = ANY (ARRAY['TRIGGERED'::text, 'RESET'::text, 'OVERRIDE'::text, 'ESCALATED'::text])))
);


--
-- Name: circuit_breakers; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.circuit_breakers (
    breaker_id uuid DEFAULT gen_random_uuid() NOT NULL,
    breaker_name text NOT NULL,
    breaker_type text NOT NULL,
    trigger_condition jsonb NOT NULL,
    action_on_trigger jsonb NOT NULL,
    defcon_threshold public.defcon_level NOT NULL,
    auto_reset boolean DEFAULT false,
    reset_after_seconds integer,
    is_enabled boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    created_by text DEFAULT 'STIG'::text,
    CONSTRAINT circuit_breakers_breaker_type_check CHECK ((breaker_type = ANY (ARRAY['RATE'::text, 'COST'::text, 'EXECUTION'::text, 'GOVERNANCE'::text, 'MARKET'::text, 'SYSTEM'::text])))
);


--
-- Name: cnrp_configuration; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.cnrp_configuration (
    config_id uuid DEFAULT gen_random_uuid() NOT NULL,
    config_key text NOT NULL,
    config_value jsonb NOT NULL,
    effective_from timestamp with time zone DEFAULT now() NOT NULL,
    created_by text DEFAULT 'STIG'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: cnrp_execution_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.cnrp_execution_log (
    execution_id uuid DEFAULT gen_random_uuid() NOT NULL,
    cycle_id text NOT NULL,
    phase text NOT NULL,
    daemon_name text NOT NULL,
    started_at timestamp with time zone DEFAULT now() NOT NULL,
    completed_at timestamp with time zone,
    status text DEFAULT 'RUNNING'::text NOT NULL,
    records_processed integer DEFAULT 0,
    evidence_hash text,
    error_message text,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT cnrp_execution_log_phase_check CHECK ((phase = ANY (ARRAY['R1'::text, 'R2'::text, 'R3'::text, 'R4'::text]))),
    CONSTRAINT cnrp_execution_log_status_check CHECK ((status = ANY (ARRAY['RUNNING'::text, 'SUCCESS'::text, 'FAILED'::text, 'SKIPPED'::text])))
);


--
-- Name: cognitive_query_set; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.cognitive_query_set (
    query_id uuid DEFAULT gen_random_uuid() NOT NULL,
    query_template text NOT NULL,
    query_type character varying(50) NOT NULL,
    asset_scope character varying(50),
    enabled boolean DEFAULT true,
    version integer DEFAULT 1 NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    created_by character varying(50) NOT NULL,
    governance_approval_id uuid
);


--
-- Name: TABLE cognitive_query_set; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.cognitive_query_set IS 'Governed query templates for cognitive engine. Orchestrator pulls from here - CEO-DIR-2026-PLANMODE-COGNITIVE-INTEGRATION-001';


--
-- Name: COLUMN cognitive_query_set.query_template; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.cognitive_query_set.query_template IS 'Template with placeholders like {asset}, {regime}';


--
-- Name: COLUMN cognitive_query_set.query_type; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.cognitive_query_set.query_type IS 'ASSET_OUTLOOK, RISK_SHIFT, MACRO_ALERT, etc.';


--
-- Name: COLUMN cognitive_query_set.asset_scope; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.cognitive_query_set.asset_scope IS 'ALL, CRYPTO, EQUITIES, or specific asset ticker';


--
-- Name: COLUMN cognitive_query_set.governance_approval_id; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.cognitive_query_set.governance_approval_id IS 'Link to G3 approval for new query types';


--
-- Name: confidence_calibration_gates; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.confidence_calibration_gates (
    gate_id uuid DEFAULT gen_random_uuid() NOT NULL,
    forecast_type text NOT NULL,
    regime text DEFAULT 'ALL'::text,
    confidence_band_min numeric(5,4) NOT NULL,
    confidence_band_max numeric(5,4) NOT NULL,
    historical_accuracy numeric(5,4) NOT NULL,
    sample_size integer NOT NULL,
    confidence_ceiling numeric(5,4) NOT NULL,
    safety_margin numeric(5,4) NOT NULL,
    calculation_window_days integer DEFAULT 30,
    effective_from timestamp with time zone DEFAULT now(),
    effective_until timestamp with time zone,
    approved_by text NOT NULL,
    approval_timestamp timestamp with time zone DEFAULT now(),
    vega_attestation_id text,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT min_sample_size CHECK ((sample_size >= 10)),
    CONSTRAINT valid_band CHECK ((confidence_band_min < confidence_band_max)),
    CONSTRAINT valid_ceiling CHECK ((confidence_ceiling <= 0.95))
);


--
-- Name: constitutional_violations; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.constitutional_violations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    violation_id text NOT NULL,
    ios_id text NOT NULL,
    review_id text NOT NULL,
    severity text NOT NULL,
    adr_violated text NOT NULL,
    description text NOT NULL,
    remediation_required boolean DEFAULT true NOT NULL,
    blocks_live_activation boolean DEFAULT false NOT NULL,
    remediation_status text DEFAULT 'PENDING'::text NOT NULL,
    remediation_notes text,
    identified_by text NOT NULL,
    identified_at timestamp with time zone DEFAULT now() NOT NULL,
    resolved_at timestamp with time zone,
    resolved_by text,
    hash_chain_id text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT constitutional_violations_remediation_status_check CHECK ((remediation_status = ANY (ARRAY['PENDING'::text, 'IN_PROGRESS'::text, 'COMPLETED'::text, 'WAIVED'::text]))),
    CONSTRAINT constitutional_violations_severity_check CHECK ((severity = ANY (ARRAY['CRITICAL'::text, 'HIGH'::text, 'MEDIUM'::text, 'LOW'::text])))
);


--
-- Name: TABLE constitutional_violations; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.constitutional_violations IS 'Registry of constitutional violations identified during G4 reviews. Tracks remediation status.';


--
-- Name: context_packages; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.context_packages (
    package_id uuid DEFAULT gen_random_uuid() NOT NULL,
    package_version text DEFAULT '2026.CDS.1'::text NOT NULL,
    package_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    state_vector jsonb NOT NULL,
    state_snapshot_hash text NOT NULL,
    adr_index jsonb NOT NULL,
    ios_index jsonb NOT NULL,
    authority_map jsonb NOT NULL,
    operational_constraints jsonb NOT NULL,
    quad_hash text,
    package_hash text NOT NULL,
    is_valid boolean DEFAULT true NOT NULL,
    valid_from timestamp with time zone DEFAULT now() NOT NULL,
    valid_until timestamp with time zone,
    freshness_ttl_seconds integer DEFAULT 300 NOT NULL,
    created_by text DEFAULT 'STIG'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE context_packages; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.context_packages IS 'Pre-computed context packages per IoS-013 CDS. Atomic delivery to CHL.
Contains: state_vector, adr_index, ios_index, authority_map, operational_constraints.
Must be delivered as single atomic unit - partial reads prohibited.';


--
-- Name: crypto_pair_registry; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.crypto_pair_registry (
    pair_id uuid DEFAULT gen_random_uuid() NOT NULL,
    symbol character varying(20) NOT NULL,
    base_asset character varying(10) NOT NULL,
    quote_asset character varying(10) NOT NULL,
    lifecycle_status character varying(20) DEFAULT 'MONITORING'::character varying NOT NULL,
    added_at timestamp with time zone DEFAULT now(),
    qualified_at timestamp with time zone,
    executable_at timestamp with time zone,
    cluster_id character varying(50),
    is_active boolean DEFAULT true,
    notes text,
    CONSTRAINT valid_lifecycle CHECK (((lifecycle_status)::text = ANY ((ARRAY['MONITORING'::character varying, 'QUALIFIED'::character varying, 'EXECUTABLE'::character varying, 'LIVE_ELIGIBLE'::character varying, 'SUSPENDED'::character varying])::text[])))
);


--
-- Name: crypto_promotion_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.crypto_promotion_log (
    log_id uuid DEFAULT gen_random_uuid() NOT NULL,
    symbol character varying(20) NOT NULL,
    from_status character varying(20) NOT NULL,
    to_status character varying(20) NOT NULL,
    liquidity_gate_passed boolean,
    volatility_gate_passed boolean,
    regime_gate_passed boolean,
    signal_gate_passed boolean,
    approved_by character varying(50) NOT NULL,
    approval_reason text,
    evidence_snapshot jsonb,
    transitioned_at timestamp with time zone DEFAULT now()
);


--
-- Name: crypto_vega_enforcement; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.crypto_vega_enforcement (
    rule_id uuid DEFAULT gen_random_uuid() NOT NULL,
    rule_name character varying(100) NOT NULL,
    rule_type character varying(20) NOT NULL,
    trigger_condition text NOT NULL,
    threshold_value numeric(10,4),
    action_on_trigger character varying(50) NOT NULL,
    escalation_required boolean DEFAULT false,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: daily_goal_calendar; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.daily_goal_calendar (
    goal_id uuid DEFAULT gen_random_uuid() NOT NULL,
    phase_name text NOT NULL,
    day_number integer NOT NULL,
    calendar_date date NOT NULL,
    iso_year integer NOT NULL,
    iso_week integer NOT NULL,
    goal_title text NOT NULL,
    goal_description text NOT NULL,
    goal_type text NOT NULL,
    priority text NOT NULL,
    success_criteria jsonb NOT NULL,
    verification_query text,
    expected_threshold numeric,
    status text DEFAULT 'PENDING'::text NOT NULL,
    completion_percentage numeric(5,2) DEFAULT 0,
    started_at timestamp with time zone,
    completed_at timestamp with time zone,
    evidence_id uuid,
    evidence_hash text,
    depends_on uuid[],
    blocks uuid[],
    assigned_agent text NOT NULL,
    created_by text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    vega_attestation_id uuid,
    ceo_defined boolean DEFAULT true,
    CONSTRAINT daily_goal_calendar_assigned_agent_check CHECK ((assigned_agent = ANY (ARRAY['LARS'::text, 'STIG'::text, 'FINN'::text, 'LINE'::text, 'VEGA'::text, 'CEO'::text]))),
    CONSTRAINT daily_goal_calendar_completion_percentage_check CHECK (((completion_percentage >= (0)::numeric) AND (completion_percentage <= (100)::numeric))),
    CONSTRAINT daily_goal_calendar_goal_type_check CHECK ((goal_type = ANY (ARRAY['INFRASTRUCTURE'::text, 'CALIBRATION'::text, 'GOVERNANCE'::text]))),
    CONSTRAINT daily_goal_calendar_priority_check CHECK ((priority = ANY (ARRAY['P0'::text, 'P1'::text, 'P2'::text]))),
    CONSTRAINT daily_goal_calendar_status_check CHECK ((status = ANY (ARRAY['PENDING'::text, 'IN_PROGRESS'::text, 'COMPLETED'::text, 'BLOCKED'::text, 'DEFERRED'::text]))),
    CONSTRAINT valid_completion CHECK ((((status = 'COMPLETED'::text) AND (completed_at IS NOT NULL) AND (evidence_id IS NOT NULL)) OR (status <> 'COMPLETED'::text)))
);


--
-- Name: daily_telemetry_summary_v; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.daily_telemetry_summary_v AS
 SELECT date(timestamp_utc) AS call_date,
    count(*) AS total_calls,
    count(DISTINCT agent_id) AS unique_agents,
    COALESCE(sum(tokens_in), (0)::bigint) AS total_tokens_in,
    COALESCE(sum(tokens_out), (0)::bigint) AS total_tokens_out,
    (COALESCE(sum(cost_usd), (0)::numeric))::numeric(10,4) AS total_cost_usd,
    (COALESCE(avg(latency_ms), (0)::numeric))::integer AS avg_latency_ms,
    count(*) FILTER (WHERE (error_type IS NOT NULL)) AS error_count,
    count(*) FILTER (WHERE (stream_mode = true)) AS streaming_count,
    count(*) FILTER (WHERE (backfill = true)) AS backfilled_count
   FROM fhq_governance.llm_routing_log
  WHERE (envelope_id IS NOT NULL)
  GROUP BY (date(timestamp_utc))
  ORDER BY (date(timestamp_utc)) DESC;


--
-- Name: data_availability_registry; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.data_availability_registry (
    registry_id uuid DEFAULT gen_random_uuid() NOT NULL,
    dataset_name text NOT NULL,
    dataset_schema text NOT NULL,
    dataset_table text NOT NULL,
    timestamp_column text NOT NULL,
    earliest_timestamp timestamp with time zone,
    latest_timestamp timestamp with time zone,
    record_count bigint,
    continuity_score numeric(5,4),
    last_refresh_at timestamp with time zone DEFAULT now() NOT NULL,
    refresh_method text DEFAULT 'MANUAL'::text,
    source_description text,
    is_critical boolean DEFAULT false NOT NULL,
    is_holdout_eligible boolean DEFAULT false NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE data_availability_registry; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.data_availability_registry IS 'CEO-DIR-2026-059 Section 3.2: Canonical definition of data availability.
Foundation for all holdout and golden scenario proposals.';


--
-- Name: data_provider_policy; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.data_provider_policy (
    policy_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id text NOT NULL,
    authorized_providers text[] NOT NULL,
    usage_tier text DEFAULT 'SNIPER'::text NOT NULL,
    daily_quota integer DEFAULT 0 NOT NULL,
    cost_weight integer DEFAULT 10 NOT NULL,
    priority_required text DEFAULT 'NORMAL'::text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by text DEFAULT 'CEO'::text NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT data_provider_policy_cost_weight_check CHECK (((cost_weight >= 1) AND (cost_weight <= 10))),
    CONSTRAINT data_provider_policy_priority_required_check CHECK ((priority_required = ANY (ARRAY['NORMAL'::text, 'HIGH'::text, 'CRITICAL'::text]))),
    CONSTRAINT data_provider_policy_usage_tier_check CHECK ((usage_tier = ANY (ARRAY['LAKE'::text, 'PULSE'::text, 'SNIPER'::text])))
);


--
-- Name: decision_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.decision_log (
    decision_id uuid DEFAULT gen_random_uuid() NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    valid_from timestamp with time zone DEFAULT now() NOT NULL,
    valid_until timestamp with time zone NOT NULL,
    context_hash text NOT NULL,
    regime_snapshot jsonb NOT NULL,
    causal_snapshot jsonb NOT NULL,
    skill_snapshot jsonb NOT NULL,
    global_regime text NOT NULL,
    defcon_level integer NOT NULL,
    system_skill_score numeric(5,4) NOT NULL,
    asset_directives jsonb NOT NULL,
    decision_type text DEFAULT 'REGIME_BASED'::text NOT NULL,
    decision_rationale text,
    base_allocation numeric(7,4) NOT NULL,
    regime_scalar numeric(5,4) NOT NULL,
    causal_vector numeric(7,4) NOT NULL,
    skill_damper numeric(5,4) NOT NULL,
    final_allocation numeric(7,4) NOT NULL,
    governance_signature text,
    signature_agent text NOT NULL,
    hash_prev text,
    hash_self text NOT NULL,
    sequence_number bigint NOT NULL,
    execution_state text DEFAULT 'PENDING'::text NOT NULL,
    transmitted_to_ios012_at timestamp with time zone,
    executed_at timestamp with time zone,
    rejection_reason text,
    created_by text DEFAULT 'IoS-008'::text NOT NULL,
    CONSTRAINT decision_log_defcon_level_check CHECK (((defcon_level >= 1) AND (defcon_level <= 5))),
    CONSTRAINT decision_log_execution_state_check CHECK ((execution_state = ANY (ARRAY['PENDING'::text, 'TRANSMITTED'::text, 'EXECUTED'::text, 'EXPIRED'::text, 'REJECTED'::text, 'SUPERSEDED'::text]))),
    CONSTRAINT decision_log_system_skill_score_check CHECK (((system_skill_score >= (0)::numeric) AND (system_skill_score <= (1)::numeric))),
    CONSTRAINT decision_not_expired_on_create CHECK ((valid_until > created_at))
);


--
-- Name: decision_plans; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.decision_plans (
    plan_id uuid DEFAULT gen_random_uuid() NOT NULL,
    intent_draft_id uuid NOT NULL,
    attempt_id uuid NOT NULL,
    needle_id uuid NOT NULL,
    asset text NOT NULL,
    direction text NOT NULL,
    sizing_action text,
    position_usd numeric(15,2),
    regime_check_passed boolean,
    regime_stability_flag boolean,
    causal_alignment_score numeric(5,4),
    causal_fallback_used boolean DEFAULT false,
    fss_score numeric(5,4),
    sitc_event_id uuid NOT NULL,
    sitc_reasoning_complete boolean NOT NULL,
    inforage_session_id uuid NOT NULL,
    inforage_roi numeric(8,4),
    ikea_validation_id uuid NOT NULL,
    causal_edge_refs uuid[],
    lsa_hash_in text,
    lsa_hash_out text,
    plan_ttl_valid_until timestamp with time zone NOT NULL,
    snapshot_ttl_valid_until timestamp with time zone NOT NULL,
    signature text NOT NULL,
    signing_agent text NOT NULL,
    signing_key_id text NOT NULL,
    signed_at timestamp with time zone NOT NULL,
    vega_verified boolean DEFAULT false,
    vega_verification_timestamp timestamp with time zone,
    cognition_duration_ms integer,
    cognition_cost_usd numeric(8,4),
    final_outcome text,
    blocked_at_gate text,
    block_reason text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT decision_plans_direction_check CHECK ((direction = ANY (ARRAY['LONG'::text, 'SHORT'::text]))),
    CONSTRAINT lsa_hash_out_write_once CHECK (((lsa_hash_out IS NULL) OR (final_outcome = ANY (ARRAY['EXECUTED'::text, 'SETTLED'::text]))))
);


--
-- Name: TABLE decision_plans; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.decision_plans IS 'CEO-DIR-2026-FINN-019 NB-01: Signed DecisionPlan sealed after cognitive stack';


--
-- Name: COLUMN decision_plans.causal_fallback_used; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.decision_plans.causal_fallback_used IS 'R2: True when alignment_score = 0.5 due to no edges (CAUSAL_NEUTRAL_FALLBACK)';


--
-- Name: COLUMN decision_plans.lsa_hash_out; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.decision_plans.lsa_hash_out IS 'R5: Phase II write-once field, only populated post-settlement by feedback writer';


--
-- Name: decision_sequence; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.decision_sequence (
    id integer DEFAULT 1 NOT NULL,
    last_sequence bigint DEFAULT 0 NOT NULL,
    last_hash text,
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT decision_sequence_id_check CHECK ((id = 1))
);


--
-- Name: defcon_state; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.defcon_state (
    state_id uuid DEFAULT gen_random_uuid() NOT NULL,
    defcon_level text NOT NULL,
    triggered_at timestamp with time zone DEFAULT now() NOT NULL,
    triggered_by text NOT NULL,
    trigger_reason text,
    auto_expire_at timestamp with time zone,
    is_current boolean DEFAULT false NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT valid_defcon_level CHECK ((defcon_level = ANY (ARRAY['GREEN'::text, 'YELLOW'::text, 'ORANGE'::text, 'RED'::text, 'BLACK'::text])))
);


--
-- Name: TABLE defcon_state; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.defcon_state IS 'DEFCON state tracking per ADR-016. ARO-20251208.
Level 5 = GREEN (normal), Level 1 = BLACK (critical emergency).
Heartbeat misses auto-trigger YELLOW (Level 3).';


--
-- Name: defcon_transitions; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.defcon_transitions (
    transition_id uuid DEFAULT gen_random_uuid() NOT NULL,
    from_level public.defcon_level NOT NULL,
    to_level public.defcon_level NOT NULL,
    transition_type text NOT NULL,
    reason text NOT NULL,
    authorized_by text NOT NULL,
    authorization_method text,
    evidence_bundle jsonb,
    transition_timestamp timestamp with time zone DEFAULT now(),
    acknowledged_by text[],
    acknowledged_at timestamp with time zone,
    hash_chain_id text,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT defcon_transitions_authorization_method_check CHECK ((authorization_method = ANY (ARRAY['AUTOMATIC'::text, 'STIG'::text, 'VEGA'::text, 'CEO'::text, 'SYSTEM'::text]))),
    CONSTRAINT defcon_transitions_transition_type_check CHECK ((transition_type = ANY (ARRAY['DOWNGRADE'::text, 'UPGRADE'::text, 'RESET'::text])))
);


--
-- Name: discrepancy_events; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.discrepancy_events (
    event_id uuid DEFAULT gen_random_uuid() NOT NULL,
    ios_id text NOT NULL,
    agent_id text NOT NULL,
    target_table text NOT NULL,
    target_column text,
    target_key jsonb,
    canonical_value text,
    reported_value text,
    discrepancy_type text NOT NULL,
    discrepancy_score numeric(10,6),
    severity fhq_governance.discrepancy_severity DEFAULT 'INFO'::fhq_governance.discrepancy_severity NOT NULL,
    detection_method text,
    context_data jsonb,
    resolution_status text DEFAULT 'OPEN'::text,
    resolved_by text,
    resolved_at timestamp with time zone,
    resolution_notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    adr_reference text DEFAULT 'ADR-010'::text,
    hash_prev text,
    hash_self text,
    CONSTRAINT discrepancy_events_resolution_status_check CHECK ((resolution_status = ANY (ARRAY['OPEN'::text, 'INVESTIGATING'::text, 'RESOLVED'::text, 'ACCEPTED'::text])))
);


--
-- Name: TABLE discrepancy_events; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.discrepancy_events IS 'ADR-010 Discrepancy Events Log - Tracks data quality issues for IoS modules';


--
-- Name: ec_registry; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ec_registry (
    ec_id text NOT NULL,
    title text NOT NULL,
    role_type text NOT NULL,
    parent_executive text,
    status text DEFAULT 'ACTIVE'::text NOT NULL,
    effective_date date NOT NULL,
    authority_chain text[],
    dependencies text[],
    breach_classes jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: economic_safety_limits; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.economic_safety_limits (
    limit_id uuid DEFAULT gen_random_uuid() NOT NULL,
    limit_name text NOT NULL,
    limit_type text NOT NULL,
    limit_value numeric NOT NULL,
    limit_unit text NOT NULL,
    environment text DEFAULT 'PAPER'::text NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    adr_reference text DEFAULT 'ADR-012'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by text DEFAULT 'STIG'::text NOT NULL,
    CONSTRAINT economic_safety_limits_environment_check CHECK ((environment = ANY (ARRAY['PAPER'::text, 'LIVE'::text, 'ALL'::text]))),
    CONSTRAINT economic_safety_limits_limit_type_check CHECK ((limit_type = ANY (ARRAY['POSITION'::text, 'DAILY'::text, 'LEVERAGE'::text, 'COST'::text])))
);


--
-- Name: TABLE economic_safety_limits; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.economic_safety_limits IS 'ADR-012 Economic Safety Architecture - position and trading limits';


--
-- Name: eloop_config; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.eloop_config (
    config_id uuid DEFAULT gen_random_uuid() NOT NULL,
    config_key character varying(50) NOT NULL,
    config_value jsonb NOT NULL,
    description text,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE eloop_config; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.eloop_config IS 'ARO-20251208: Event loop configuration. ELOOP v1 settings.';


--
-- Name: epistemic_health_daily; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.epistemic_health_daily (
    health_date date DEFAULT CURRENT_DATE NOT NULL,
    trades_today integer DEFAULT 0,
    hits_today integer DEFAULT 0,
    hit_rate_today numeric(5,4),
    hit_rate_yesterday numeric(5,4),
    hit_rate_2d_ago numeric(5,4),
    hit_rate_3d_ago numeric(5,4),
    hit_rate_decline_streak integer DEFAULT 0,
    brier_today numeric(6,4),
    brier_yesterday numeric(6,4),
    brier_2d_ago numeric(6,4),
    brier_worsening_streak integer DEFAULT 0,
    type_d_count integer DEFAULT 0,
    type_e_count integer DEFAULT 0,
    repeated_error_count integer DEFAULT 0,
    epistemic_stop_triggered boolean DEFAULT false,
    stop_trigger_reason text,
    stop_triggered_at timestamp with time zone,
    daily_edge_signal integer,
    edge_signal_components jsonb,
    computed_at timestamp with time zone DEFAULT now(),
    halt_level text DEFAULT 'NONE'::text,
    soft_halt_until timestamp with time zone,
    hard_halt_vega_attestation text,
    high_conf_inversion_days integer DEFAULT 0,
    edge_signal_cause_code text,
    CONSTRAINT epistemic_health_daily_daily_edge_signal_check CHECK ((daily_edge_signal = ANY (ARRAY['-1'::integer, 0, 1]))),
    CONSTRAINT epistemic_health_daily_edge_signal_cause_code_check CHECK ((edge_signal_cause_code = ANY (ARRAY['CALIBRATION_IMPROVED'::text, 'CALIBRATION_WORSENED'::text, 'VOLUME_TOO_LOW'::text, 'ERROR_CONCENTRATION_TYPE_D'::text, 'ERROR_CONCENTRATION_TYPE_E'::text, 'STABLE_NO_CHANGE'::text, 'MIXED_SIGNALS'::text]))),
    CONSTRAINT epistemic_health_daily_halt_level_check CHECK ((halt_level = ANY (ARRAY['NONE'::text, 'SOFT_HALT'::text, 'HARD_HALT'::text])))
);


--
-- Name: epistemic_lesson_evidence; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.epistemic_lesson_evidence (
    evidence_id uuid DEFAULT gen_random_uuid() NOT NULL,
    lesson_id uuid,
    raw_query text NOT NULL,
    query_result_hash text NOT NULL,
    query_result_snapshot jsonb NOT NULL,
    extraction_context jsonb,
    created_by text DEFAULT 'STIG'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE epistemic_lesson_evidence; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.epistemic_lesson_evidence IS 'CEO-DIR-2026-021 Audit Correction #4: Court-proof evidence for epistemic lessons.
Stores raw query, result hash, and result snapshot for every lesson.
Enables re-derivation and verification of lesson conclusions.';


--
-- Name: epistemic_lessons; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.epistemic_lessons (
    lesson_id uuid DEFAULT gen_random_uuid() NOT NULL,
    lesson_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    lesson_source text NOT NULL,
    lesson_category text NOT NULL,
    lesson_severity text NOT NULL,
    source_forecast_id uuid,
    source_outcome_id uuid,
    source_suppression_id uuid,
    source_pair_id uuid,
    source_skill_metric_id uuid,
    error_magnitude numeric,
    error_direction text,
    affected_asset_id text,
    affected_regime text,
    affected_horizon_hours integer,
    lesson_description text NOT NULL,
    recommended_action text,
    action_taken text,
    action_timestamp timestamp with time zone,
    action_agent text,
    action_approved_by text,
    lesson_hash text NOT NULL,
    created_by text DEFAULT 'STIG'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    evidence_id uuid,
    evidence_bound_at timestamp with time zone,
    CONSTRAINT epistemic_lessons_error_direction_check CHECK ((error_direction = ANY (ARRAY['OVER'::text, 'UNDER'::text, 'WRONG'::text, 'LATE'::text, 'EARLY'::text]))),
    CONSTRAINT epistemic_lessons_lesson_category_check CHECK ((lesson_category = ANY (ARRAY['CALIBRATION_ERROR'::text, 'DIRECTIONAL_ERROR'::text, 'TIMING_ERROR'::text, 'REGIME_MISCLASSIFICATION'::text, 'SUPPRESSION_REGRET'::text, 'SUPPRESSION_WISDOM'::text, 'DRIFT_DETECTED'::text, 'SKILL_DEGRADATION'::text, 'SKILL_IMPROVEMENT'::text]))),
    CONSTRAINT epistemic_lessons_lesson_severity_check CHECK ((lesson_severity = ANY (ARRAY['LOW'::text, 'MEDIUM'::text, 'HIGH'::text, 'CRITICAL'::text]))),
    CONSTRAINT epistemic_lessons_lesson_source_check CHECK ((lesson_source = ANY (ARRAY['RECONCILIATION'::text, 'SUPPRESSION'::text, 'SKILL_METRICS'::text, 'DRIFT_DETECTION'::text])))
);


--
-- Name: TABLE epistemic_lessons; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.epistemic_lessons IS 'CEO-DIR-2026-007: Canonical store for lessons extracted from forecast reconciliation, suppression analysis, and skill metric evaluation. Phase 5 feedback loop LOCKED until 85% reconciliation rate sustained 30 days.';


--
-- Name: COLUMN epistemic_lessons.evidence_id; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.epistemic_lessons.evidence_id IS 'CEO-DIR-2026-021 Audit Correction #4: Evidence binding for court-proof chain.
Every lesson must be bound to verifiable raw query evidence.
Ensures lesson conclusions can be re-derived from source data.';


--
-- Name: COLUMN epistemic_lessons.evidence_bound_at; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.epistemic_lessons.evidence_bound_at IS 'Timestamp when evidence was atomically bound to lesson';


--
-- Name: epistemic_proposal_runs; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.epistemic_proposal_runs (
    run_id uuid DEFAULT gen_random_uuid() NOT NULL,
    run_type text NOT NULL,
    run_started_at timestamp with time zone DEFAULT now() NOT NULL,
    run_completed_at timestamp with time zone,
    run_status text DEFAULT 'RUNNING'::text NOT NULL,
    analysis_window_start timestamp with time zone NOT NULL,
    analysis_window_end timestamp with time zone NOT NULL,
    outcomes_analyzed integer DEFAULT 0,
    patterns_analyzed integer DEFAULT 0,
    proposals_generated integer DEFAULT 0,
    proposals_skipped integer DEFAULT 0,
    error_message text,
    error_details jsonb,
    triggered_by text DEFAULT 'SCHEDULER'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT epistemic_proposal_runs_run_status_check CHECK ((run_status = ANY (ARRAY['RUNNING'::text, 'COMPLETED'::text, 'FAILED'::text, 'PARTIAL'::text]))),
    CONSTRAINT epistemic_proposal_runs_run_type_check CHECK ((run_type = ANY (ARRAY['SCHEDULED'::text, 'MANUAL'::text, 'TRIGGERED'::text])))
);


--
-- Name: epistemic_proposal_templates; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.epistemic_proposal_templates (
    template_id text NOT NULL,
    proposal_type text NOT NULL,
    min_sample_size integer DEFAULT 30 NOT NULL,
    min_confidence numeric(5,4) DEFAULT 0.70 NOT NULL,
    analysis_window_days integer DEFAULT 30 NOT NULL,
    min_improvement_pct numeric(5,2) DEFAULT 5.0 NOT NULL,
    max_risk_severity text DEFAULT 'MEDIUM'::text NOT NULL,
    reasoning_template text NOT NULL,
    risk_template text NOT NULL,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: epistemic_proposals; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.epistemic_proposals (
    proposal_id uuid DEFAULT gen_random_uuid() NOT NULL,
    proposal_code text NOT NULL,
    proposal_type text NOT NULL,
    target_parameter text NOT NULL,
    target_schema text,
    target_table text,
    current_value jsonb NOT NULL,
    proposed_value jsonb NOT NULL,
    delta_description text NOT NULL,
    evidence_sample_size integer NOT NULL,
    evidence_time_window text NOT NULL,
    evidence_win_rate numeric(5,4),
    evidence_avg_return numeric(8,4),
    evidence_sharpe numeric(8,4),
    evidence_p_value numeric(10,8),
    evidence_outcomes jsonb NOT NULL,
    evidence_patterns jsonb,
    evidence_raw_data jsonb,
    reasoning_summary text NOT NULL,
    reasoning_detailed text NOT NULL,
    reasoning_methodology text NOT NULL,
    expected_improvement text NOT NULL,
    expected_magnitude text,
    confidence_in_proposal numeric(5,4),
    risk_assessment text NOT NULL,
    risk_severity text NOT NULL,
    rollback_plan text NOT NULL,
    status text DEFAULT 'GENERATED'::text NOT NULL,
    generated_by text DEFAULT 'EPISTEMIC_PROPOSAL_ENGINE'::text NOT NULL,
    generated_at timestamp with time zone DEFAULT now() NOT NULL,
    generation_run_id uuid,
    reviewed_by text,
    reviewed_at timestamp with time zone,
    review_notes text,
    review_decision_reason text,
    implemented_at timestamp with time zone,
    implemented_by text,
    implementation_result text,
    expires_at timestamp with time zone DEFAULT (now() + '14 days'::interval) NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    evidence_bundle_type character varying(30),
    CONSTRAINT epistemic_proposals_evidence_bundle_type_check CHECK (((evidence_bundle_type)::text = ANY ((ARRAY['BACKFILL'::character varying, 'LIVE'::character varying, 'PROMOTION'::character varying])::text[]))),
    CONSTRAINT epistemic_proposals_risk_severity_check CHECK ((risk_severity = ANY (ARRAY['LOW'::text, 'MEDIUM'::text, 'HIGH'::text]))),
    CONSTRAINT epistemic_proposals_status_check CHECK ((status = ANY (ARRAY['GENERATED'::text, 'UNDER_REVIEW'::text, 'APPROVED'::text, 'REJECTED'::text, 'IMPLEMENTED'::text, 'EXPIRED'::text]))),
    CONSTRAINT valid_confidence CHECK (((confidence_in_proposal >= (0)::numeric) AND (confidence_in_proposal <= (1)::numeric))),
    CONSTRAINT valid_proposal_type CHECK ((proposal_type = ANY (ARRAY['CALIBRATION_ADJUSTMENT'::text, 'CONFIDENCE_RECALIBRATION'::text, 'SOURCE_TRUST_UPDATE'::text, 'DECAY_RATE_ADJUSTMENT'::text, 'EDGE_WEIGHT_UPDATE'::text, 'HYPOTHESIS_STRATEGY'::text, 'REGIME_THRESHOLD'::text, 'BUDGET_REALLOCATION'::text])))
);


--
-- Name: COLUMN epistemic_proposals.evidence_bundle_type; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.epistemic_proposals.evidence_bundle_type IS 'CEO-DIR-2026-019 Presisering 5: Tre distinkte moduser - BACKFILL (historical), LIVE (ongoing), PROMOTION (activation)';


--
-- Name: epistemic_schedule_config; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.epistemic_schedule_config (
    config_id text DEFAULT 'DEFAULT'::text NOT NULL,
    run_interval_hours integer DEFAULT 168 NOT NULL,
    run_day_of_week integer DEFAULT 0,
    run_hour_utc integer DEFAULT 0,
    min_outcomes_for_analysis integer DEFAULT 30,
    min_confidence_for_proposal numeric(5,4) DEFAULT 0.70,
    notify_on_proposals boolean DEFAULT true,
    notification_channel text DEFAULT 'governance'::text,
    is_active boolean DEFAULT true,
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: epistemic_suppression_ledger; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.epistemic_suppression_ledger (
    suppression_id uuid DEFAULT gen_random_uuid() NOT NULL,
    belief_id uuid NOT NULL,
    policy_id uuid NOT NULL,
    asset_id text NOT NULL,
    suppression_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    suppressed_regime text NOT NULL,
    suppressed_confidence numeric(6,4) NOT NULL,
    chosen_regime text NOT NULL,
    chosen_confidence numeric(6,4) NOT NULL,
    suppression_reason text NOT NULL,
    suppression_category text NOT NULL,
    constraint_type text NOT NULL,
    constraint_value text,
    constraint_threshold text,
    market_outcome text,
    lesson_extracted text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    reviewed_at timestamp with time zone,
    reviewed_by text,
    regret_classification text,
    regret_magnitude numeric,
    regret_computed_at timestamp with time zone,
    regret_attribution_type text,
    regret_root_cause jsonb,
    regret_magnitude_category text,
    CONSTRAINT check_regret_attribution_type CHECK (((regret_attribution_type IS NULL) OR (regret_attribution_type = ANY (ARRAY['TYPE_A_HYSTERESIS_LAG'::text, 'TYPE_B_CONFIDENCE_FLOOR'::text, 'TYPE_C_DATA_BLINDNESS'::text, 'TYPE_D_REGIME_MISCLASSIFICATION'::text, 'TYPE_E_CORRELATION_BREAKDOWN'::text, 'TYPE_X_UNKNOWN'::text])))),
    CONSTRAINT check_regret_magnitude_category CHECK (((regret_magnitude_category IS NULL) OR (regret_magnitude_category = ANY (ARRAY['LOW'::text, 'MEDIUM'::text, 'HIGH'::text, 'EXTREME'::text])))),
    CONSTRAINT epistemic_suppression_ledger_regret_classification_check CHECK ((regret_classification = ANY (ARRAY['REGRET'::text, 'WISDOM'::text, 'UNRESOLVED'::text]))),
    CONSTRAINT epistemic_suppression_ledger_regret_magnitude_check CHECK (((regret_magnitude >= (0)::numeric) AND (regret_magnitude <= (1)::numeric))),
    CONSTRAINT valid_suppression_category CHECK ((suppression_category = ANY (ARRAY['HYSTERESIS'::text, 'DEFCON'::text, 'RISK_LIMIT'::text, 'LIQUIDITY'::text, 'MANUAL_OVERRIDE'::text, 'OTHER'::text])))
);


--
-- Name: TABLE epistemic_suppression_ledger; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.epistemic_suppression_ledger IS 'CEO-DIR-2026-001: Audit trail of every belief suppression. Enables opportunity cost measurement and learning.';


--
-- Name: COLUMN epistemic_suppression_ledger.regret_classification; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.epistemic_suppression_ledger.regret_classification IS 'CEO-DIR-2026-021 Audit Correction #3: v1 binary classification only.
REGRET = belief was correct (suppression was a mistake - missed alpha)
WISDOM = belief was wrong (suppression was wise - avoided loss)
UNRESOLVED = no outcome available for classification
NO MONETARY VALUES in v1. Monetary alpha deferred to v2 post paper-trading baseline.';


--
-- Name: COLUMN epistemic_suppression_ledger.regret_magnitude; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.epistemic_suppression_ledger.regret_magnitude IS 'v1: Dimensionless confidence gap (suppressed_confidence - chosen_confidence).
Represents strength of belief disagreement, NOT dollar value or alpha percentage.
Range: 0.0 to 1.0. Higher = stronger disagreement.';


--
-- Name: COLUMN epistemic_suppression_ledger.regret_computed_at; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.epistemic_suppression_ledger.regret_computed_at IS 'Timestamp of regret classification computation';


--
-- Name: event_queue; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.event_queue (
    queue_id uuid DEFAULT gen_random_uuid() NOT NULL,
    event_id uuid NOT NULL,
    event_type character varying(50) NOT NULL,
    trigger_id uuid,
    target_agent character varying(20) NOT NULL,
    target_action character varying(100) NOT NULL,
    priority integer DEFAULT 5,
    status character varying(20) DEFAULT 'PENDING'::character varying,
    retry_count integer DEFAULT 0,
    max_retries integer DEFAULT 3,
    queued_at timestamp with time zone DEFAULT now(),
    started_at timestamp with time zone,
    completed_at timestamp with time zone,
    processing_time_ms integer,
    result_data jsonb,
    error_message text,
    regime_at_queue character varying(20),
    defcon_at_queue integer,
    CONSTRAINT valid_queue_status CHECK (((status)::text = ANY (ARRAY[('PENDING'::character varying)::text, ('PROCESSING'::character varying)::text, ('COMPLETED'::character varying)::text, ('FAILED'::character varying)::text, ('SKIPPED'::character varying)::text])))
);


--
-- Name: TABLE event_queue; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.event_queue IS 'ARO-20251208: Event queue for async processing. Events wait here until processed by ELOOP.';


--
-- Name: event_trigger_registry; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.event_trigger_registry (
    trigger_id uuid DEFAULT gen_random_uuid() NOT NULL,
    trigger_name character varying(100) NOT NULL,
    trigger_category character varying(30) NOT NULL,
    source_event_type character varying(50) NOT NULL,
    source_agent character varying(20),
    source_ios_layer character varying(20),
    trigger_conditions jsonb,
    target_agent character varying(20) NOT NULL,
    target_action character varying(100) NOT NULL,
    target_priority integer DEFAULT 5,
    regime_filter character varying(20)[],
    defcon_max integer DEFAULT 5,
    is_active boolean DEFAULT true,
    cooldown_seconds integer DEFAULT 0,
    last_triggered_at timestamp with time zone,
    trigger_count integer DEFAULT 0,
    lineage_hash character varying(64),
    created_by character varying(20) NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT valid_trigger_agent CHECK (((target_agent)::text = ANY (ARRAY[('FINN'::character varying)::text, ('CEIO'::character varying)::text, ('LARS'::character varying)::text, ('LINE'::character varying)::text, ('VEGA'::character varying)::text, ('STIG'::character varying)::text, ('SYSTEM'::character varying)::text])))
);


--
-- Name: TABLE event_trigger_registry; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.event_trigger_registry IS 'ARO-20251208 Section 4: Event trigger definitions. Maps events to agent actions.
Replaces fixed-interval cron execution with event-driven reflexes.';


--
-- Name: event_type_registry; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.event_type_registry (
    event_type character varying(50) NOT NULL,
    event_category character varying(30) NOT NULL,
    description text,
    severity_default character varying(20) DEFAULT 'INFO'::character varying,
    defcon_impact integer,
    requires_ack boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE event_type_registry; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.event_type_registry IS 'Registry of all valid event types per ARO-20251208.';


--
-- Name: execution_boundary_control; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.execution_boundary_control (
    control_id uuid DEFAULT gen_random_uuid() NOT NULL,
    control_name text NOT NULL,
    control_status text NOT NULL,
    lock_reason text,
    locked_by text,
    locked_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: execution_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.execution_log (
    execution_id uuid DEFAULT gen_random_uuid() NOT NULL,
    decision_id uuid NOT NULL,
    decision_hash text NOT NULL,
    signature_verified boolean NOT NULL,
    ttl_valid boolean NOT NULL,
    schema_valid boolean NOT NULL,
    context_hash_valid boolean NOT NULL,
    security_status text DEFAULT 'PENDING'::text NOT NULL,
    rejection_reason text,
    execution_mode text DEFAULT 'PAPER_MOCK'::text NOT NULL,
    execution_status text DEFAULT 'PENDING'::text NOT NULL,
    asset_id text,
    order_side text,
    order_qty numeric,
    order_price numeric,
    current_position numeric,
    target_position numeric,
    position_diff numeric,
    detected_at timestamp with time zone DEFAULT now() NOT NULL,
    verified_at timestamp with time zone,
    executed_at timestamp with time zone,
    detection_latency_ms integer,
    verification_latency_ms integer,
    execution_latency_ms integer,
    created_by text DEFAULT 'IoS-012'::text NOT NULL,
    hash_chain_id text,
    CONSTRAINT execution_log_execution_mode_check CHECK ((execution_mode = ANY (ARRAY['PAPER_MOCK'::text, 'PAPER_LIVE'::text, 'LIVE'::text]))),
    CONSTRAINT execution_log_execution_status_check CHECK ((execution_status = ANY (ARRAY['PENDING'::text, 'PROCESSING'::text, 'MOCK_FILLED'::text, 'FILLED'::text, 'REJECTED'::text, 'FAILED'::text]))),
    CONSTRAINT execution_log_order_side_check CHECK ((order_side = ANY (ARRAY['BUY'::text, 'SELL'::text, 'HOLD'::text]))),
    CONSTRAINT execution_log_security_status_check CHECK ((security_status = ANY (ARRAY['VERIFIED'::text, 'REJECTED'::text, 'SECURITY_ALERT'::text, 'PENDING'::text])))
);


--
-- Name: execution_mode; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.execution_mode (
    mode_id uuid DEFAULT gen_random_uuid() NOT NULL,
    mode_name text NOT NULL,
    set_at timestamp with time zone DEFAULT now() NOT NULL,
    set_by text NOT NULL,
    reason text,
    is_current boolean DEFAULT false NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT valid_mode_name CHECK ((mode_name = ANY (ARRAY['LOCAL_DEV'::text, 'PAPER_PROD'::text, 'LIVE_PROD'::text, 'SHADOW_PAPER'::text])))
);


--
-- Name: TABLE execution_mode; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.execution_mode IS 'Execution mode tracking (LOCAL_DEV, PAPER_PROD, LIVE_PROD). CEO mandate: PAPER_PROD until G3 validation.';


--
-- Name: execution_state; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.execution_state (
    state_id integer NOT NULL,
    cycle_id character varying(100) NOT NULL,
    hash_chain_id character varying(200),
    state_data jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    cognitive_fasting boolean DEFAULT false,
    fasting_reason text,
    fasting_started_at timestamp with time zone,
    fasting_max_duration_hours integer DEFAULT 24,
    revalidation_required boolean DEFAULT false,
    last_cnrp_completion timestamp with time zone,
    fasting_requires_ceo_override boolean DEFAULT false,
    last_lids_block_at timestamp with time zone,
    last_lids_block_type character varying(50),
    lids_blocks_today integer DEFAULT 0,
    lids_passes_today integer DEFAULT 0,
    defcon_level character varying(20) DEFAULT 'NORMAL'::character varying,
    last_updated_at timestamp with time zone DEFAULT now(),
    last_updated_by character varying(100),
    last_update_reason text,
    paper_trading_eligible boolean DEFAULT false,
    learning_eligible boolean DEFAULT true,
    state_version integer DEFAULT 1
);


--
-- Name: COLUMN execution_state.cognitive_fasting; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state.cognitive_fasting IS 'CEO-DIR-2026-019 P0-2: TRUE when LIDS gates block execution pending revalidation';


--
-- Name: COLUMN execution_state.fasting_reason; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state.fasting_reason IS 'Why the system entered cognitive fasting (e.g., confidence < 0.70, freshness > 12h)';


--
-- Name: COLUMN execution_state.fasting_started_at; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state.fasting_started_at IS 'When cognitive fasting began';


--
-- Name: COLUMN execution_state.fasting_max_duration_hours; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state.fasting_max_duration_hours IS 'Maximum fasting duration before requiring CEO override (default 24h)';


--
-- Name: COLUMN execution_state.revalidation_required; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state.revalidation_required IS 'TRUE if CNRP must complete before exiting fasting';


--
-- Name: COLUMN execution_state.last_cnrp_completion; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state.last_cnrp_completion IS 'Timestamp of last successful CNRP completion';


--
-- Name: COLUMN execution_state.fasting_requires_ceo_override; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state.fasting_requires_ceo_override IS 'TRUE if fasting exceeded max duration and requires CEO intervention';


--
-- Name: COLUMN execution_state.last_lids_block_at; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state.last_lids_block_at IS 'CEO-DIR-2026-020 D3: Timestamp of last LIDS gate block';


--
-- Name: COLUMN execution_state.last_lids_block_type; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state.last_lids_block_type IS 'CEO-DIR-2026-020 D3: Type of last LIDS block (CONFIDENCE or FRESHNESS)';


--
-- Name: COLUMN execution_state.lids_blocks_today; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state.lids_blocks_today IS 'CEO-DIR-2026-020 D3: Count of LIDS blocks today (reset at midnight UTC)';


--
-- Name: COLUMN execution_state.lids_passes_today; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state.lids_passes_today IS 'CEO-DIR-2026-020 D3: Count of LIDS passes today (reset at midnight UTC)';


--
-- Name: COLUMN execution_state.defcon_level; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state.defcon_level IS 'CEO-DIR-2026-020 D4: Current DEFCON level (NORMAL, ELEVATED, HIGH, CRITICAL)';


--
-- Name: COLUMN execution_state.last_updated_at; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state.last_updated_at IS 'CEO-DIR-2026-020 D4: Timestamp of last state mutation';


--
-- Name: COLUMN execution_state.last_updated_by; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state.last_updated_by IS 'CEO-DIR-2026-020 D4: Agent/daemon that last mutated state';


--
-- Name: COLUMN execution_state.last_update_reason; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state.last_update_reason IS 'CEO-DIR-2026-020 D4: Reason for last state mutation';


--
-- Name: COLUMN execution_state.paper_trading_eligible; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state.paper_trading_eligible IS 'CEO-DIR-2026-020 D4: Whether paper trading is currently allowed';


--
-- Name: COLUMN execution_state.learning_eligible; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state.learning_eligible IS 'CEO-DIR-2026-020 D4: Whether learning updates are currently allowed';


--
-- Name: COLUMN execution_state.state_version; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state.state_version IS 'CEO-DIR-2026-020 D4: Monotonic version counter for optimistic locking';


--
-- Name: execution_state_change_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.execution_state_change_log (
    change_id uuid DEFAULT gen_random_uuid() NOT NULL,
    state_id integer NOT NULL,
    state_version_before integer NOT NULL,
    state_version_after integer NOT NULL,
    previous_state jsonb NOT NULL,
    new_state jsonb NOT NULL,
    change_type character varying(50) NOT NULL,
    change_reason text NOT NULL,
    initiated_by character varying(100) NOT NULL,
    initiated_at timestamp with time zone DEFAULT now() NOT NULL,
    hash_chain_id character varying(100),
    CONSTRAINT no_updates CHECK (true)
);


--
-- Name: TABLE execution_state_change_log; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.execution_state_change_log IS 'CEO-DIR-2026-020 D4: Immutable audit trail of all execution_state transitions. APPEND-ONLY.';


--
-- Name: COLUMN execution_state_change_log.previous_state; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state_change_log.previous_state IS 'Full JSONB snapshot of state before change';


--
-- Name: COLUMN execution_state_change_log.new_state; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state_change_log.new_state IS 'Full JSONB snapshot of state after change';


--
-- Name: COLUMN execution_state_change_log.change_type; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.execution_state_change_log.change_type IS 'Type of change: LIDS_BLOCK, DEFCON_CHANGE, FASTING_START, FASTING_END, REVALIDATION, CNRP_COMPLETE';


--
-- Name: execution_state_state_id_seq; Type: SEQUENCE; Schema: fhq_governance; Owner: -
--

CREATE SEQUENCE fhq_governance.execution_state_state_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: execution_state_state_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_governance; Owner: -
--

ALTER SEQUENCE fhq_governance.execution_state_state_id_seq OWNED BY fhq_governance.execution_state.state_id;


--
-- Name: executive_roles; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.executive_roles (
    role_id uuid DEFAULT gen_random_uuid() NOT NULL,
    role_name text NOT NULL,
    domain_responsibility text NOT NULL,
    authority_level integer NOT NULL,
    agent_binding boolean DEFAULT false NOT NULL,
    created_by text DEFAULT 'CEO'::text NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    metadata jsonb,
    CONSTRAINT executive_roles_authority_level_check CHECK (((authority_level >= 0) AND (authority_level <= 10))),
    CONSTRAINT executive_roles_role_name_check CHECK ((role_name = ANY (ARRAY['LARS'::text, 'STIG'::text, 'LINE'::text, 'FINN'::text, 'VEGA'::text, 'CODE'::text, 'CEO'::text, 'CEIO'::text, 'CDMO'::text, 'CRIO'::text, 'CSEO'::text, 'CFAO'::text])))
);


--
-- Name: TABLE executive_roles; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.executive_roles IS 'ADR-001 3: Executive roles and authority levels';


--
-- Name: failure_mode_registry; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.failure_mode_registry (
    failure_mode_id uuid DEFAULT gen_random_uuid() NOT NULL,
    failure_code text NOT NULL,
    failure_category text NOT NULL,
    failure_severity text NOT NULL,
    failure_title text NOT NULL,
    failure_description text,
    source_lesson_id uuid,
    source_signal_id uuid,
    source_asset text,
    source_date date,
    fmcl_stage text DEFAULT 'CAPTURE'::text NOT NULL,
    fmcl_stage_entered_at timestamp with time zone DEFAULT now() NOT NULL,
    captured_at timestamp with time zone DEFAULT now() NOT NULL,
    captured_by text DEFAULT 'SYSTEM'::text NOT NULL,
    capture_evidence jsonb DEFAULT '{}'::jsonb NOT NULL,
    diagnosis_started_at timestamp with time zone,
    diagnosis_completed_at timestamp with time zone,
    diagnosis_agent text,
    diagnosis_model text,
    diagnosis_result jsonb,
    diagnosis_cost_usd numeric(10,4),
    action_defined_at timestamp with time zone,
    action_type text,
    action_description text,
    action_owner text,
    action_evidence jsonb,
    retest_started_at timestamp with time zone,
    retest_completed_at timestamp with time zone,
    retest_result text,
    retest_evidence jsonb,
    retest_iterations integer DEFAULT 0,
    closed_at timestamp with time zone,
    closure_type text,
    closure_evidence jsonb,
    closure_attestation_by text,
    time_in_capture_hours numeric(10,2),
    time_in_diagnosis_hours numeric(10,2),
    time_in_action_hours numeric(10,2),
    time_in_retest_hours numeric(10,2),
    total_resolution_hours numeric(10,2),
    invariant_created boolean DEFAULT false,
    invariant_id uuid,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    directive text DEFAULT 'CEO-DIR-2026-052'::text,
    CONSTRAINT chk_closure_type CHECK (((closure_type IS NULL) OR (closure_type = ANY (ARRAY['RESOLVED'::text, 'MITIGATED'::text, 'ACCEPTED_RISK'::text, 'OBSOLETE'::text])))),
    CONSTRAINT chk_failure_severity CHECK ((failure_severity = ANY (ARRAY['CRITICAL'::text, 'HIGH'::text, 'MEDIUM'::text, 'LOW'::text]))),
    CONSTRAINT chk_fmcl_stage CHECK ((fmcl_stage = ANY (ARRAY['CAPTURE'::text, 'DIAGNOSIS'::text, 'ACTION_DEFINITION'::text, 'RETEST'::text, 'CLOSED'::text]))),
    CONSTRAINT chk_retest_result CHECK (((retest_result IS NULL) OR (retest_result = ANY (ARRAY['PASS'::text, 'FAIL'::text, 'PARTIAL'::text]))))
);


--
-- Name: TABLE failure_mode_registry; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.failure_mode_registry IS 'CEO-DIR-2026-052: Failure Mode Registry with 5-stage FMCL lifecycle.
Stages: CAPTURE  DIAGNOSIS  ACTION_DEFINITION  RETEST  CLOSED.
Target: 5 closures/day, 20% closure ratio, net open must decrease.
STIG 2026-01-14';


--
-- Name: failure_mode_reopen_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.failure_mode_reopen_log (
    reopen_id uuid DEFAULT gen_random_uuid() NOT NULL,
    failure_mode_id uuid NOT NULL,
    original_failure_code text NOT NULL,
    reopened_at timestamp with time zone DEFAULT now() NOT NULL,
    previous_stage text NOT NULL,
    reopen_trigger text NOT NULL,
    previous_diagnosis_failed_because text,
    is_architectural_flaw boolean DEFAULT false,
    reopen_count integer DEFAULT 1 NOT NULL,
    detected_by text DEFAULT 'SHADOW_EVALUATOR'::text,
    evidence jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE failure_mode_reopen_log; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.failure_mode_reopen_log IS 'CEO-DIR-2026-054: Failure mode re-open tracking.
Per directive: Reopened failures tagged REOPENED_AFTER_FIX.
Repeated reopenings treated as architectural flaws.
STIG 2026-01-14';


--
-- Name: fortress_anchors; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.fortress_anchors (
    anchor_id uuid DEFAULT gen_random_uuid() NOT NULL,
    ios_id text NOT NULL,
    gate_level text NOT NULL,
    anchor_type text NOT NULL,
    canonical_hash text NOT NULL,
    anchored_at timestamp with time zone DEFAULT now(),
    anchored_by text NOT NULL,
    parent_anchor_id uuid,
    chain_position integer,
    replay_deterministic boolean DEFAULT true,
    non_repudiation_proof text,
    hash_chain_id text
);


--
-- Name: TABLE fortress_anchors; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.fortress_anchors IS 'ADR-011 Fortress chain anchors for deterministic replay and non-repudiation.';


--
-- Name: freshness_decoupling_rules; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.freshness_decoupling_rules (
    rule_id text NOT NULL,
    rule_name text NOT NULL,
    source_layer text NOT NULL,
    target_layer text NOT NULL,
    dependency_allowed boolean NOT NULL,
    violation_class text NOT NULL,
    enforcement_mode text DEFAULT 'HARD'::text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: freshness_thresholds; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.freshness_thresholds (
    threshold_id uuid DEFAULT gen_random_uuid() NOT NULL,
    asset_class text NOT NULL,
    gate_type text NOT NULL,
    max_staleness_minutes integer NOT NULL,
    description text,
    effective_from timestamp with time zone DEFAULT now(),
    created_by text DEFAULT 'STIG'::text,
    CONSTRAINT valid_asset_class CHECK ((asset_class = ANY (ARRAY['EQUITY'::text, 'CRYPTO'::text, 'COMMODITY'::text, 'FX'::text, 'BOND'::text]))),
    CONSTRAINT valid_gate_type CHECK ((gate_type = ANY (ARRAY['EXECUTION'::text, 'LEARNING'::text])))
);


--
-- Name: frozen_holdout_registry; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.frozen_holdout_registry (
    holdout_id uuid DEFAULT gen_random_uuid() NOT NULL,
    holdout_name text NOT NULL,
    description text,
    period_start date NOT NULL,
    period_end date NOT NULL,
    includes_stress_regime boolean DEFAULT false NOT NULL,
    stress_regime_description text,
    data_hash text NOT NULL,
    record_count integer NOT NULL,
    asset_classes jsonb NOT NULL,
    is_frozen boolean DEFAULT false NOT NULL,
    frozen_at timestamp with time zone,
    frozen_by text,
    isolation_verified boolean DEFAULT false NOT NULL,
    isolation_verified_by text,
    isolation_verified_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT frozen_requires_hash CHECK (((is_frozen = false) OR ((is_frozen = true) AND (data_hash IS NOT NULL)))),
    CONSTRAINT valid_period CHECK ((period_end > period_start))
);


--
-- Name: TABLE frozen_holdout_registry; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.frozen_holdout_registry IS 'CEO-DIR-2026-058 Section 4.2: Frozen Holdout Set Registry.
Completely isolated from training, tuning, threshold adjustment.';


--
-- Name: g4_artifact_hashes; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.g4_artifact_hashes (
    hash_id uuid DEFAULT gen_random_uuid() NOT NULL,
    ios_id text NOT NULL,
    gate_level text NOT NULL,
    artifact_path text NOT NULL,
    sha256_hash text NOT NULL,
    validated_at timestamp with time zone DEFAULT now(),
    validated_by text NOT NULL,
    drift_detected boolean DEFAULT false,
    hash_chain_id text
);


--
-- Name: TABLE g4_artifact_hashes; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.g4_artifact_hashes IS 'ADR-002 compliant artifact hash validation for G4 activations.';


--
-- Name: g4_review_constraints; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.g4_review_constraints (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    ios_id text NOT NULL,
    review_id text NOT NULL,
    execution_authority_off boolean DEFAULT true NOT NULL,
    no_outbound_trades boolean DEFAULT true NOT NULL,
    no_capital_modification boolean DEFAULT true NOT NULL,
    no_exposure_modification boolean DEFAULT true NOT NULL,
    api_sandbox_only boolean DEFAULT true NOT NULL,
    no_dynamic_config boolean DEFAULT true NOT NULL,
    no_unreviewed_commits boolean DEFAULT true NOT NULL,
    constraint_violations integer DEFAULT 0,
    defcon_triggered boolean DEFAULT false,
    defcon_level text,
    enforced_by text DEFAULT 'STIG'::text NOT NULL,
    enforcement_started_at timestamp with time zone DEFAULT now() NOT NULL,
    enforcement_ended_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE g4_review_constraints; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.g4_review_constraints IS 'G4 review constraints enforcement. Any violation triggers ADR-016 DEFCON-2.';


--
-- Name: gate_violation_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.gate_violation_log (
    violation_id uuid DEFAULT gen_random_uuid() NOT NULL,
    forecast_id uuid,
    original_confidence numeric(5,4) NOT NULL,
    applied_ceiling numeric(5,4) NOT NULL,
    gate_id uuid,
    forecast_type text NOT NULL,
    regime text,
    confidence_reduction numeric(5,4) GENERATED ALWAYS AS ((original_confidence - applied_ceiling)) STORED,
    violation_timestamp timestamp with time zone DEFAULT now(),
    enforced_by text DEFAULT 'STIG'::text
);


--
-- Name: gateway_integrity_signatures; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.gateway_integrity_signatures (
    signature_id uuid DEFAULT gen_random_uuid() NOT NULL,
    context_hash text NOT NULL,
    state_snapshot_hash text NOT NULL,
    quad_hash text,
    signature_algorithm text DEFAULT 'SHA256-HMAC'::text NOT NULL,
    signature_value text NOT NULL,
    signing_key_id text DEFAULT 'STIG-GATEWAY-KEY-001'::text NOT NULL,
    issued_at timestamp with time zone DEFAULT now() NOT NULL,
    valid_until timestamp with time zone,
    is_valid boolean DEFAULT true NOT NULL,
    package_version text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE gateway_integrity_signatures; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.gateway_integrity_signatures IS 'Integrity signatures for Gateway-delivered context packages.
Enables forensic, post-mortem reconstruction per IoS-013 Gateway 2.3.';


--
-- Name: gateway_request_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.gateway_request_log (
    request_id uuid DEFAULT gen_random_uuid() NOT NULL,
    requesting_agent text NOT NULL,
    agent_tier text NOT NULL,
    request_source text NOT NULL,
    request_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    gateway_status text NOT NULL,
    context_hash text,
    state_snapshot_hash text,
    quad_hash text,
    integrity_signature text,
    adr018_validated boolean DEFAULT false NOT NULL,
    adr017_validated boolean DEFAULT false NOT NULL,
    ec_role_validated boolean DEFAULT false NOT NULL,
    risl_validated boolean DEFAULT false NOT NULL,
    defcon_validated boolean DEFAULT false NOT NULL,
    validation_failures jsonb,
    latency_ms integer,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT gateway_request_log_agent_tier_check CHECK ((agent_tier = ANY (ARRAY['TIER-1'::text, 'TIER-2'::text, 'TIER-3'::text]))),
    CONSTRAINT gateway_request_log_gateway_status_check CHECK ((gateway_status = ANY (ARRAY['SUCCESS'::text, 'VALIDATION_FAILED'::text, 'INTEGRITY_FAILED'::text, 'STALE_CONTEXT'::text, 'MISSING_CONTEXT'::text, 'RISL_BLOCKED'::text, 'DEFCON_BLOCKED'::text, 'UNAUTHORIZED'::text])))
);


--
-- Name: TABLE gateway_request_log; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.gateway_request_log IS 'Audit log for Truth Gateway requests per IoS-013 Gateway Interface 2.3.
Every LLM agent must obtain context through the Gateway. Full cryptographic lineage preserved.';


--
-- Name: goal_completion_evidence; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.goal_completion_evidence (
    evidence_id uuid DEFAULT gen_random_uuid() NOT NULL,
    goal_id uuid NOT NULL,
    verification_query text NOT NULL,
    verification_result jsonb NOT NULL,
    verification_timestamp timestamp with time zone DEFAULT now(),
    query_result_hash text NOT NULL,
    previous_hash text,
    threshold_met boolean NOT NULL,
    threshold_value numeric,
    actual_value numeric,
    verified_by text DEFAULT 'STIG'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: golden_alpha_testset; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.golden_alpha_testset (
    testcase_id uuid DEFAULT gen_random_uuid() NOT NULL,
    query_text text NOT NULL,
    expected_snippet_ids uuid[],
    expected_answer_constraints jsonb,
    domain character varying(30),
    difficulty character varying(10),
    created_at timestamp with time zone DEFAULT now(),
    created_by character varying(20) DEFAULT 'SYSTEM'::character varying,
    vega_signature character varying(128),
    signature_timestamp timestamp with time zone,
    last_evaluated_at timestamp with time zone,
    last_result character varying(20),
    last_ndcg_score numeric(5,4),
    CONSTRAINT golden_alpha_testset_difficulty_check CHECK (((difficulty)::text = ANY ((ARRAY['EASY'::character varying, 'MEDIUM'::character varying, 'HARD'::character varying])::text[]))),
    CONSTRAINT golden_alpha_testset_last_result_check CHECK (((last_result)::text = ANY ((ARRAY['PASS'::character varying, 'FAIL'::character varying, 'PARTIAL'::character varying, 'NOT_RUN'::character varying])::text[])))
);


--
-- Name: TABLE golden_alpha_testset; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.golden_alpha_testset IS '[C9] Golden Alpha Test Set for G2 gate. VEGA must sign testset hash before G2 approval. Used for NDCG@10 >= 0.8 validation requirement.';


--
-- Name: golden_scenario_registry; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.golden_scenario_registry (
    scenario_id uuid DEFAULT gen_random_uuid() NOT NULL,
    scenario_code text NOT NULL,
    scenario_name text NOT NULL,
    scenario_type text NOT NULL,
    event_date date NOT NULL,
    event_asset text NOT NULL,
    event_description text,
    expected_regime text,
    expected_action text,
    expected_confidence_min numeric(8,4),
    actual_regime text,
    actual_action text,
    actual_confidence numeric(8,4),
    actual_outcome text,
    stress_probability numeric(10,6),
    volatility_zscore numeric(10,4),
    drawdown_pct numeric(10,4),
    last_validation_at timestamp with time zone,
    validation_result text,
    validation_evidence jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by text DEFAULT 'FINN'::text NOT NULL,
    canonical boolean DEFAULT true,
    directive text DEFAULT 'CEO-DIR-2026-052'::text,
    CONSTRAINT chk_scenario_type CHECK ((scenario_type = ANY (ARRAY['STRESS'::text, 'REGIME_SHIFT'::text, 'LIQUIDITY_CRISIS'::text, 'VOLATILITY_SPIKE'::text, 'FLASH_CRASH'::text, 'CORRELATION_BREAKDOWN'::text]))),
    CONSTRAINT chk_validation_result CHECK (((validation_result IS NULL) OR (validation_result = ANY (ARRAY['PASS'::text, 'FAIL'::text, 'DEGRADED'::text]))))
);


--
-- Name: TABLE golden_scenario_registry; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.golden_scenario_registry IS 'CEO-DIR-2026-052: Golden Scenario Registry for judgment quality validation.
Canonical stress events that the system must handle correctly.
Target: 3 scenarios defined, weekly validation.
STIG 2026-01-14';


--
-- Name: governance_actions_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.governance_actions_log (
    action_id uuid DEFAULT gen_random_uuid() NOT NULL,
    action_type character varying(100) NOT NULL,
    action_target character varying(200),
    action_target_type character varying(100),
    initiated_by character varying(50),
    initiated_at timestamp with time zone DEFAULT now(),
    decision character varying(50),
    decision_rationale text,
    metadata jsonb DEFAULT '{}'::jsonb,
    hash_chain_id character varying(200),
    signature text,
    vega_reviewed boolean DEFAULT false,
    vega_override boolean DEFAULT false,
    agent_id character varying(50),
    "timestamp" timestamp with time zone DEFAULT now()
);


--
-- Name: governance_documents; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.governance_documents (
    document_id uuid DEFAULT gen_random_uuid() NOT NULL,
    document_name text NOT NULL,
    document_type text NOT NULL,
    tier smallint NOT NULL,
    version text NOT NULL,
    content text NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    approved_by text,
    signature text,
    status text DEFAULT 'ACTIVE'::text NOT NULL,
    CONSTRAINT governance_documents_tier_check CHECK ((tier = ANY (ARRAY[1, 2])))
);


--
-- Name: governance_instruments; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.governance_instruments (
    instrument_id uuid DEFAULT gen_random_uuid() NOT NULL,
    instrument_name text NOT NULL,
    instrument_type text NOT NULL,
    ios_reference text,
    status text DEFAULT 'ACTIVE'::text NOT NULL,
    constitutional boolean DEFAULT false NOT NULL,
    binding_scope text[],
    dependency_of text[],
    activation_gate text,
    activated_by text,
    activated_at timestamp with time zone,
    hash_chain_id text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: governance_state; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.governance_state (
    state_id uuid DEFAULT gen_random_uuid() NOT NULL,
    component_type text NOT NULL,
    component_name text NOT NULL,
    component_version text NOT NULL,
    registration_status text DEFAULT 'REGISTERED'::text NOT NULL,
    registered_at timestamp with time zone DEFAULT now() NOT NULL,
    registered_by text NOT NULL,
    authority_chain text[] NOT NULL,
    adr_compliance text[] NOT NULL,
    vega_attested boolean DEFAULT false NOT NULL,
    vega_attestation_id uuid,
    vega_attestation_timestamp timestamp with time zone,
    is_active boolean DEFAULT true NOT NULL,
    deployment_environment text DEFAULT 'PRODUCTION'::text NOT NULL,
    configuration jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: holdout_evaluation_results; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.holdout_evaluation_results (
    evaluation_id uuid DEFAULT gen_random_uuid() NOT NULL,
    holdout_id uuid NOT NULL,
    model_version text NOT NULL,
    label_definition_version text NOT NULL,
    brier_score numeric(10,6),
    log_loss numeric(10,6),
    calibration_error numeric(10,6),
    hit_rate numeric(10,6),
    regime_accuracy_vs_random numeric(10,6),
    golden_scenario_score numeric(10,6),
    p_value numeric(10,6),
    confidence_interval_lower numeric(10,6),
    confidence_interval_upper numeric(10,6),
    is_significant boolean,
    prev_evaluation_id uuid,
    brier_delta numeric(10,6),
    improvement_direction text,
    evaluated_at timestamp with time zone DEFAULT now() NOT NULL,
    evaluated_by text NOT NULL,
    hash_chain_id text,
    CONSTRAINT holdout_evaluation_results_improvement_direction_check CHECK ((improvement_direction = ANY (ARRAY['UP'::text, 'DOWN'::text, 'FLAT'::text])))
);


--
-- Name: TABLE holdout_evaluation_results; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.holdout_evaluation_results IS 'CEO-DIR-2026-058 Section 4.3: Holdout evaluation results.
Market Learning is ONLY measured via improvements here.';


--
-- Name: ikea_validation_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ikea_validation_log (
    validation_id uuid DEFAULT gen_random_uuid() NOT NULL,
    passed boolean NOT NULL,
    rule_violated text,
    rules_checked text[],
    violation_details jsonb,
    intent_draft_id uuid,
    needle_id uuid,
    asset text,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE ikea_validation_log; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.ikea_validation_log IS 'CEO-DIR-2026-FINN-019 NB-07: IKEA truth boundary validation log for Neural Bridge execution gates';


--
-- Name: inforage_config; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.inforage_config (
    config_id integer NOT NULL,
    config_key text NOT NULL,
    config_value numeric(10,4) NOT NULL,
    description text,
    last_updated timestamp with time zone DEFAULT now() NOT NULL,
    updated_by text DEFAULT 'CEO-DIR-2026-FINN-019'::text NOT NULL
);


--
-- Name: TABLE inforage_config; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.inforage_config IS 'R3: Configurable InForage parameters. Changes require ADR amendment.';


--
-- Name: inforage_config_config_id_seq; Type: SEQUENCE; Schema: fhq_governance; Owner: -
--

CREATE SEQUENCE fhq_governance.inforage_config_config_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inforage_config_config_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_governance; Owner: -
--

ALTER SEQUENCE fhq_governance.inforage_config_config_id_seq OWNED BY fhq_governance.inforage_config.config_id;


--
-- Name: inforage_query_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.inforage_query_log (
    query_id uuid DEFAULT gen_random_uuid() NOT NULL,
    query_text text NOT NULL,
    retrieval_mode character varying(20) NOT NULL,
    rrf_k integer DEFAULT 60,
    dense_weight numeric(3,2) DEFAULT 0.5,
    sparse_weight numeric(3,2) DEFAULT 0.5,
    top_k integer,
    rerank_cutoff integer DEFAULT 5,
    latency_ms integer,
    results_count integer,
    embedding_cost_usd numeric(10,6),
    search_cost_usd numeric(10,6),
    rerank_cost_usd numeric(10,6),
    cost_usd numeric(10,4),
    defcon_level character varying(10),
    budget_remaining_pct numeric(5,2),
    querying_agent character varying(20),
    bundle_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    evidence_coverage_ratio double precision,
    result_type character varying(20),
    retrieved_snippet_count integer,
    CONSTRAINT inforage_query_log_defcon_level_check CHECK (((defcon_level)::text = ANY ((ARRAY['GREEN'::character varying, 'YELLOW'::character varying, 'ORANGE'::character varying, 'RED'::character varying, 'BLACK'::character varying])::text[]))),
    CONSTRAINT inforage_query_log_retrieval_mode_check CHECK (((retrieval_mode)::text = ANY ((ARRAY['DENSE'::character varying, 'SPARSE'::character varying, 'HYBRID'::character varying])::text[])))
);


--
-- Name: TABLE inforage_query_log; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.inforage_query_log IS 'EC-021 InForage: All retrieval operations logged for cost management and audit.';


--
-- Name: COLUMN inforage_query_log.bundle_id; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.inforage_query_log.bundle_id IS 'FK to evidence_bundles for court-proof tracing';


--
-- Name: COLUMN inforage_query_log.evidence_coverage_ratio; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.inforage_query_log.evidence_coverage_ratio IS 'ECR = retrieved_snippets / expected_minimum (3). CEO-DIR-2026-PLANMODE-COGNITIVE-INTEGRATION-001';


--
-- Name: COLUMN inforage_query_log.result_type; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.inforage_query_log.result_type IS 'SIGNAL or NO_SIGNAL - for NO_SIGNAL rate monitoring';


--
-- Name: COLUMN inforage_query_log.retrieved_snippet_count; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.inforage_query_log.retrieved_snippet_count IS 'Number of evidence snippets retrieved for ECR calculation';


--
-- Name: intent_drafts; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.intent_drafts (
    draft_id uuid DEFAULT gen_random_uuid() NOT NULL,
    needle_id uuid NOT NULL,
    asset text NOT NULL,
    direction text NOT NULL,
    snapshot_price numeric(20,8),
    snapshot_regime text,
    snapshot_regime_stability numeric(5,4),
    snapshot_timestamp timestamp with time zone NOT NULL,
    snapshot_ttl_valid_until timestamp with time zone NOT NULL,
    eqs_score numeric(5,4),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT intent_drafts_direction_check CHECK ((direction = ANY (ARRAY['LONG'::text, 'SHORT'::text])))
);


--
-- Name: TABLE intent_drafts; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.intent_drafts IS 'CEO-DIR-2026-FINN-019 NB-01: IntentDraft captured BEFORE any execution gate';


--
-- Name: ios008_mandate_authority; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ios008_mandate_authority (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    target_ios_id text NOT NULL,
    environment text NOT NULL,
    mandate_authority_granted boolean DEFAULT false NOT NULL,
    override_type text NOT NULL,
    override_source text NOT NULL,
    authorized_by text NOT NULL,
    authorized_at timestamp with time zone DEFAULT now() NOT NULL,
    expires_on_condition text NOT NULL,
    expired boolean DEFAULT false NOT NULL,
    expired_at timestamp with time zone,
    expired_reason text,
    must_tag_override_source boolean DEFAULT true NOT NULL,
    required_tag text NOT NULL,
    hash_chain_id text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT ios008_mandate_authority_environment_check CHECK ((environment = ANY (ARRAY['PAPER'::text, 'LIVE'::text])))
);


--
-- Name: TABLE ios008_mandate_authority; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.ios008_mandate_authority IS 'Tracks IoS-008 temporary mandate authority for execution targets. CEO override for PAPER mode.';


--
-- Name: ios010_g0_verification; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ios010_g0_verification (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    ios_id text DEFAULT 'IoS-010'::text NOT NULL,
    verification_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    verified_by text NOT NULL,
    g0_submission_valid boolean NOT NULL,
    no_g1_progression_without_approval boolean NOT NULL,
    no_test_execution_at_g0 boolean NOT NULL,
    no_migrations_at_g0 boolean NOT NULL,
    no_storage_tables_registered boolean NOT NULL,
    no_duplicate_identifiers boolean NOT NULL,
    single_authoritative_entry boolean NOT NULL,
    no_forecast_impact boolean NOT NULL,
    no_capital_allocation_impact boolean NOT NULL,
    no_risk_module_impact boolean NOT NULL,
    implementation_path text NOT NULL,
    models_verified jsonb NOT NULL,
    engines_verified jsonb NOT NULL,
    lineage_hash text NOT NULL,
    hash_self text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE ios010_g0_verification; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.ios010_g0_verification IS 'G0 compliance verification for IoS-010 Prediction Ledger Engine. Tracks ADR-004/012/013 compliance.';


--
-- Name: ios012_g4_review; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ios012_g4_review (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    review_id text NOT NULL,
    review_initiated_at timestamp with time zone DEFAULT now() NOT NULL,
    review_initiated_by text NOT NULL,
    review_status text DEFAULT 'INITIATED'::text NOT NULL,
    technical_integrity_verified boolean DEFAULT false,
    commit_hash_frozen text,
    determinism_variance_pct numeric(5,4),
    dependency_fingerprint text,
    economic_safety_verified boolean DEFAULT false,
    nlv_accounting_identity_verified boolean DEFAULT false,
    circuit_breakers_tested boolean DEFAULT false,
    stress_scenarios_passed integer DEFAULT 0,
    max_adverse_excursion numeric(10,4),
    lineage_integrity_verified boolean DEFAULT false,
    canonical_asset_resolution_verified boolean DEFAULT false,
    state_hash_reproducibility_verified boolean DEFAULT false,
    fortress_compliance_verified boolean DEFAULT false,
    fortress_baseline_drift_pct numeric(5,4),
    invariants_passed integer DEFAULT 0,
    invariants_total integer DEFAULT 0,
    secrets_security_verified boolean DEFAULT false,
    vault_injection_only boolean DEFAULT false,
    no_secret_leakage_verified boolean DEFAULT false,
    introspection_safe boolean DEFAULT false,
    technical_report_path text,
    economic_dossier_path text,
    lineage_report_path text,
    secrets_report_path text,
    vega_bundle_path text,
    vega_decision text,
    vega_decision_at timestamp with time zone,
    vega_notes text,
    ceo_signature boolean DEFAULT false,
    ceo_signed_at timestamp with time zone,
    lineage_hash text NOT NULL,
    hash_self text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT ios012_g4_review_review_status_check CHECK ((review_status = ANY (ARRAY['INITIATED'::text, 'IN_PROGRESS'::text, 'ARTIFACTS_SUBMITTED'::text, 'VEGA_REVIEW'::text, 'PASSED'::text, 'FAILED'::text, 'REMEDIATION_REQUIRED'::text]))),
    CONSTRAINT ios012_g4_review_vega_decision_check CHECK ((vega_decision = ANY (ARRAY['G4_PASS'::text, 'G4_FAIL'::text, 'REMEDIATION_REQUIRED'::text, NULL::text])))
);


--
-- Name: TABLE ios012_g4_review; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.ios012_g4_review IS 'G4 Constitutional Activation Review tracking for IoS-012 Execution Engine. ADR-004 compliance.';


--
-- Name: ios_execution_gates; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ios_execution_gates (
    gate_id uuid DEFAULT gen_random_uuid() NOT NULL,
    ios_id text NOT NULL,
    gate_type text NOT NULL,
    gate_status text NOT NULL,
    reason text NOT NULL,
    directive_ref text,
    condition_query text,
    condition_threshold numeric,
    effective_from timestamp with time zone DEFAULT now(),
    effective_until timestamp with time zone,
    created_by text DEFAULT 'STIG'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT ios_execution_gates_gate_status_check CHECK ((gate_status = ANY (ARRAY['ALLOWED'::text, 'BLOCKED'::text, 'CONDITIONAL'::text])))
);


--
-- Name: ios_quad_mapping; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ios_quad_mapping (
    mapping_id uuid DEFAULT gen_random_uuid() NOT NULL,
    ios_id text NOT NULL,
    pillar_id text NOT NULL,
    role_description text NOT NULL,
    implements_function text NOT NULL,
    constitutional_basis text DEFAULT 'ADR-017'::text NOT NULL,
    is_primary boolean DEFAULT false NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE ios_quad_mapping; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.ios_quad_mapping IS 'Maps IoS modules to MIT Quad pillars per ADR-017. Ensures all modules are aligned with constitutional roles.';


--
-- Name: label_definition_registry; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.label_definition_registry (
    definition_id uuid DEFAULT gen_random_uuid() NOT NULL,
    version text NOT NULL,
    forecast_type text NOT NULL,
    horizon_minutes integer NOT NULL,
    label_up_condition text NOT NULL,
    label_down_condition text NOT NULL,
    schema_hash text NOT NULL,
    is_active boolean DEFAULT false NOT NULL,
    locked_at timestamp with time zone,
    locked_by text,
    ceo_approved boolean DEFAULT false NOT NULL,
    ceo_approval_ref text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT only_one_active CHECK (((is_active = false) OR ((is_active = true) AND (locked_at IS NOT NULL))))
);


--
-- Name: TABLE label_definition_registry; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.label_definition_registry IS 'CEO-DIR-2026-058 Section 4.1: Locked Label Definition Registry.
Labels cannot be changed without new version and CEO approval.';


--
-- Name: ldow_completion_thresholds; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ldow_completion_thresholds (
    threshold_id uuid DEFAULT gen_random_uuid() NOT NULL,
    threshold_name text NOT NULL,
    threshold_value numeric(8,6) NOT NULL,
    threshold_unit text NOT NULL,
    threshold_description text,
    proposed_by text NOT NULL,
    proposed_at timestamp with time zone DEFAULT now() NOT NULL,
    reviewed_by text,
    reviewed_at timestamp with time zone,
    attested_by text,
    attested_at timestamp with time zone,
    is_active boolean DEFAULT true NOT NULL,
    effective_from timestamp with time zone DEFAULT now() NOT NULL,
    evidence_id uuid,
    adr_reference text DEFAULT 'ADR-024'::text
);


--
-- Name: ldow_cycle_completion; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ldow_cycle_completion (
    completion_id uuid DEFAULT gen_random_uuid() NOT NULL,
    cycle_number integer NOT NULL,
    cycle_label text NOT NULL,
    horizon_hours integer DEFAULT 24 NOT NULL,
    scheduled_at timestamp with time zone NOT NULL,
    started_at timestamp with time zone,
    completed_at timestamp with time zone,
    forecasts_eligible integer DEFAULT 0 NOT NULL,
    forecasts_paired integer DEFAULT 0 NOT NULL,
    forecasts_expired integer DEFAULT 0 NOT NULL,
    coverage_ratio numeric(5,4) GENERATED ALWAYS AS (
CASE
    WHEN (forecasts_eligible > 0) THEN ((forecasts_paired)::numeric / (forecasts_eligible)::numeric)
    ELSE (0)::numeric
END) STORED,
    coverage_threshold numeric(5,4) DEFAULT 0.80 NOT NULL,
    coverage_pass boolean GENERATED ALWAYS AS (
CASE
    WHEN (forecasts_eligible > 0) THEN (((forecasts_paired)::numeric / (forecasts_eligible)::numeric) >= coverage_threshold)
    ELSE false
END) STORED,
    brier_score_run1 numeric(6,5),
    brier_score_run2 numeric(6,5),
    brier_variance numeric(8,6) GENERATED ALWAYS AS (
CASE
    WHEN ((brier_score_run1 IS NOT NULL) AND (brier_score_run2 IS NOT NULL)) THEN abs((brier_score_run1 - brier_score_run2))
    ELSE NULL::numeric
END) STORED,
    stability_threshold numeric(6,5) DEFAULT 0.05 NOT NULL,
    stability_pass boolean GENERATED ALWAYS AS (
CASE
    WHEN ((brier_score_run1 IS NOT NULL) AND (brier_score_run2 IS NOT NULL)) THEN (abs((brier_score_run1 - brier_score_run2)) <= stability_threshold)
    ELSE NULL::boolean
END) STORED,
    calibration_error numeric(6,5),
    hit_rate numeric(5,4),
    damper_hash_at_start text NOT NULL,
    damper_hash_at_end text,
    damper_unchanged boolean GENERATED ALWAYS AS ((damper_hash_at_start = damper_hash_at_end)) STORED,
    parameters_snapshot jsonb DEFAULT '{}'::jsonb NOT NULL,
    completion_status text DEFAULT 'SCHEDULED'::text NOT NULL,
    evidence_id uuid,
    reconciliation_evidence_id uuid,
    evaluation_evidence_id uuid,
    rung_d_eligible boolean DEFAULT false,
    vega_attestation_id uuid,
    vega_attested_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by text DEFAULT 'STIG'::text NOT NULL,
    CONSTRAINT ldow_cycle_completion_completion_status_check CHECK ((completion_status = ANY (ARRAY['SCHEDULED'::text, 'RUNNING'::text, 'COVERAGE_FAIL'::text, 'STABILITY_FAIL'::text, 'DAMPER_CHANGED'::text, 'COMPLETED'::text, 'ERROR'::text])))
);


--
-- Name: ldow_cycle_metrics; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ldow_cycle_metrics (
    metric_id uuid DEFAULT gen_random_uuid() NOT NULL,
    ldow_id uuid NOT NULL,
    cycle_number integer NOT NULL,
    forecast_count integer DEFAULT 0 NOT NULL,
    damped_count integer DEFAULT 0 NOT NULL,
    calibration_error numeric(6,4),
    brier_score numeric(6,4),
    delta_fss numeric(6,4),
    p95_latency_ms integer,
    avg_latency_ms integer,
    avg_raw_confidence numeric(5,4),
    avg_damped_confidence numeric(5,4),
    avg_dampening_delta numeric(5,4),
    calibration_error_delta numeric(6,4),
    brier_score_delta numeric(6,4),
    damper_version_hash text NOT NULL,
    damper_hash_verified boolean DEFAULT true,
    cycle_started_at timestamp with time zone NOT NULL,
    cycle_completed_at timestamp with time zone,
    computed_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: ldow_evaluation_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ldow_evaluation_log (
    evaluation_id uuid DEFAULT gen_random_uuid() NOT NULL,
    ldow_id uuid,
    cycle_number integer NOT NULL,
    calibration_error numeric(5,4),
    brier_score numeric(5,4),
    delta_fss numeric(5,4),
    p95_latency_ms integer,
    calibration_error_delta numeric(5,4),
    brier_score_delta numeric(5,4),
    calibration_pass boolean,
    brier_pass boolean,
    fss_pass boolean,
    latency_pass boolean,
    cycle_pass boolean,
    evaluation_notes text,
    evaluated_at timestamp with time zone DEFAULT now() NOT NULL,
    evaluated_by text DEFAULT 'STIG'::text NOT NULL
);


--
-- Name: ldow_failure_incidents; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ldow_failure_incidents (
    incident_id uuid DEFAULT gen_random_uuid() NOT NULL,
    cycle_number integer NOT NULL,
    failure_type text NOT NULL,
    failure_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    failure_details jsonb DEFAULT '{}'::jsonb NOT NULL,
    coverage_achieved numeric(5,4),
    coverage_required numeric(5,4),
    brier_variance_achieved numeric(8,6),
    brier_variance_required numeric(8,6),
    damper_hash_expected text,
    damper_hash_actual text,
    root_cause_documented boolean DEFAULT false NOT NULL,
    root_cause_description text,
    root_cause_documented_at timestamp with time zone,
    root_cause_documented_by text,
    correction_applied boolean DEFAULT false NOT NULL,
    correction_description text,
    correction_applied_at timestamp with time zone,
    correction_applied_by text,
    vega_attestation_id uuid,
    vega_attested_at timestamp with time zone,
    vega_attestation_notes text,
    retry_authorized boolean DEFAULT false NOT NULL,
    retry_authorized_at timestamp with time zone,
    retry_resets_counter boolean DEFAULT true NOT NULL,
    incident_status text DEFAULT 'OPEN'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT ldow_failure_incidents_failure_type_check CHECK ((failure_type = ANY (ARRAY['COVERAGE_FAIL'::text, 'STABILITY_FAIL'::text, 'DAMPER_CHANGED'::text, 'PRICE_BLACKOUT'::text, 'SYSTEM_ERROR'::text]))),
    CONSTRAINT ldow_failure_incidents_incident_status_check CHECK ((incident_status = ANY (ARRAY['OPEN'::text, 'ROOT_CAUSE_DOCUMENTED'::text, 'CORRECTION_APPLIED'::text, 'VEGA_ATTESTED'::text, 'RETRY_AUTHORIZED'::text, 'CLOSED'::text])))
);


--
-- Name: ldow_forecast_captures; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ldow_forecast_captures (
    capture_id uuid DEFAULT gen_random_uuid() NOT NULL,
    ldow_id uuid NOT NULL,
    forecast_id uuid NOT NULL,
    asset_id text NOT NULL,
    strategy_id text NOT NULL,
    direction text NOT NULL,
    raw_confidence numeric(5,4) NOT NULL,
    damped_confidence numeric(5,4) NOT NULL,
    dampening_delta numeric(5,4) NOT NULL,
    ceiling_applied numeric(5,4),
    damper_version_hash text NOT NULL,
    directive_ref text DEFAULT 'CEO-DIR-2026-063R'::text NOT NULL,
    regime text,
    regime_confidence numeric(5,4),
    forecast_generated_at timestamp with time zone DEFAULT now() NOT NULL,
    captured_at timestamp with time zone DEFAULT now() NOT NULL,
    captured_by text DEFAULT 'STIG'::text NOT NULL,
    cycle_number integer DEFAULT 0
);


--
-- Name: ldow_regime_metrics; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ldow_regime_metrics (
    metric_id uuid DEFAULT gen_random_uuid() NOT NULL,
    ldow_id uuid NOT NULL,
    cycle_number integer NOT NULL,
    regime text NOT NULL,
    forecast_count integer DEFAULT 0 NOT NULL,
    avg_raw_confidence numeric(5,4),
    avg_damped_confidence numeric(5,4),
    avg_dampening_delta numeric(5,4),
    calibration_error numeric(6,4),
    brier_score numeric(6,4),
    computed_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: ldow_strategy_metrics; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ldow_strategy_metrics (
    metric_id uuid DEFAULT gen_random_uuid() NOT NULL,
    ldow_id uuid NOT NULL,
    cycle_number integer NOT NULL,
    strategy_id text NOT NULL,
    forecast_count integer DEFAULT 0 NOT NULL,
    avg_raw_confidence numeric(5,4),
    avg_damped_confidence numeric(5,4),
    avg_dampening_delta numeric(5,4),
    computed_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: ldow_task_execution_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ldow_task_execution_log (
    execution_id uuid DEFAULT gen_random_uuid() NOT NULL,
    task_id text NOT NULL,
    cycle_completion_id uuid,
    task_type text NOT NULL,
    started_at timestamp with time zone DEFAULT now() NOT NULL,
    ended_at timestamp with time zone,
    duration_ms integer GENERATED ALWAYS AS (
CASE
    WHEN (ended_at IS NOT NULL) THEN (EXTRACT(epoch FROM (ended_at - started_at)) * (1000)::numeric)
    ELSE NULL::numeric
END) STORED,
    forecasts_eligible integer,
    forecasts_paired integer,
    forecasts_expired integer,
    brier_score numeric(6,5),
    calibration_error numeric(6,5),
    hit_rate numeric(5,4),
    damper_hash text NOT NULL,
    parameters_unchanged boolean DEFAULT true NOT NULL,
    evidence_id uuid,
    evidence_hash text,
    execution_status text DEFAULT 'RUNNING'::text NOT NULL,
    error_message text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT ldow_task_execution_log_execution_status_check CHECK ((execution_status = ANY (ARRAY['RUNNING'::text, 'SUCCESS'::text, 'FAILED'::text, 'SKIPPED'::text]))),
    CONSTRAINT ldow_task_execution_log_task_type_check CHECK ((task_type = ANY (ARRAY['RECONCILIATION'::text, 'EVALUATION'::text, 'STABILITY_CHECK'::text])))
);


--
-- Name: ldow_unattended_executions; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.ldow_unattended_executions (
    execution_id uuid DEFAULT gen_random_uuid() NOT NULL,
    ldow_id uuid NOT NULL,
    cycle_number integer NOT NULL,
    execution_mode text DEFAULT 'UNATTENDED_LDOW'::text NOT NULL,
    forecasts_generated integer DEFAULT 0 NOT NULL,
    forecasts_persisted integer DEFAULT 0 NOT NULL,
    lineage_coverage_pct numeric(5,2),
    generation_time_ms integer,
    persistence_time_ms integer,
    total_cycle_time_ms integer,
    damper_hash_at_start text NOT NULL,
    damper_hash_at_end text,
    damper_hash_verified boolean DEFAULT true,
    ldow_status_verified boolean DEFAULT true,
    status text DEFAULT 'RUNNING'::text NOT NULL,
    stop_reason text,
    started_at timestamp with time zone DEFAULT now() NOT NULL,
    completed_at timestamp with time zone,
    directive_ref text DEFAULT 'CEO-DIR-2026-068'::text NOT NULL,
    CONSTRAINT ldow_unattended_executions_status_check CHECK ((status = ANY (ARRAY['RUNNING'::text, 'COMPLETED'::text, 'STOPPED'::text, 'FAILED'::text])))
);


--
-- Name: learning_delta_observation_window; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.learning_delta_observation_window (
    ldow_id uuid DEFAULT gen_random_uuid() NOT NULL,
    directive_ref text DEFAULT 'CEO-DIR-2026-065'::text NOT NULL,
    holdout_id uuid NOT NULL,
    minimum_cycles integer DEFAULT 2 NOT NULL,
    started_at timestamp with time zone DEFAULT now() NOT NULL,
    damper_task_id uuid NOT NULL,
    damper_version_hash text NOT NULL,
    damper_locked_at timestamp with time zone DEFAULT now() NOT NULL,
    status text DEFAULT 'ACTIVE'::text NOT NULL,
    cycles_completed integer DEFAULT 0 NOT NULL,
    baseline_calibration_error numeric(5,4),
    baseline_brier_score numeric(5,4),
    current_calibration_error numeric(5,4),
    current_brier_score numeric(5,4),
    violations_detected integer DEFAULT 0,
    violation_log jsonb DEFAULT '[]'::jsonb,
    completed_at timestamp with time zone,
    exit_directive text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT learning_delta_observation_window_status_check CHECK ((status = ANY (ARRAY['ACTIVE'::text, 'COMPLETED'::text, 'INVALIDATED'::text])))
);


--
-- Name: learning_mechanism_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.learning_mechanism_log (
    mechanism_id uuid DEFAULT gen_random_uuid() NOT NULL,
    signal_description text NOT NULL,
    signal_source text NOT NULL,
    reasoning_description text NOT NULL,
    test_description text NOT NULL,
    outcome_description text NOT NULL,
    outcome_status text DEFAULT 'pending'::text NOT NULL,
    failure_mode_id uuid,
    logged_at timestamp with time zone DEFAULT now() NOT NULL,
    logged_by text DEFAULT 'SYSTEM'::text,
    CONSTRAINT learning_mechanism_log_outcome_status_check CHECK ((outcome_status = ANY (ARRAY['success'::text, 'partial'::text, 'pending'::text]))),
    CONSTRAINT learning_mechanism_log_signal_source_check CHECK ((signal_source = ANY (ARRAY['serper'::text, 'llm'::text, 'database'::text, 'market_data'::text])))
);


--
-- Name: learning_proposal_audit; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.learning_proposal_audit (
    audit_id uuid DEFAULT gen_random_uuid() NOT NULL,
    proposal_id uuid,
    action character varying(50) NOT NULL,
    previous_status character varying(20),
    new_status character varying(20),
    actor character varying(50) NOT NULL,
    action_reason text,
    hash_prev character varying(64),
    hash_self character varying(64),
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: learning_proposals; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.learning_proposals (
    proposal_id uuid DEFAULT gen_random_uuid() NOT NULL,
    engine_id character varying(10) NOT NULL,
    proposal_type character varying(50) NOT NULL,
    current_value jsonb NOT NULL,
    proposed_value jsonb NOT NULL,
    delta_description text,
    evidence_bundle jsonb NOT NULL,
    evidence_count integer DEFAULT 0,
    evidence_win_rate numeric(5,4),
    evidence_confidence numeric(5,4),
    status character varying(20) DEFAULT 'PENDING'::character varying,
    submitted_by character varying(50) NOT NULL,
    submitted_at timestamp with time zone DEFAULT now(),
    reviewed_by character varying(50),
    reviewed_at timestamp with time zone,
    review_notes text,
    vega_attestation_id uuid,
    vega_attestation_hash character varying(64),
    state_snapshot_hash character varying(64),
    state_timestamp timestamp with time zone,
    expires_at timestamp with time zone DEFAULT (now() + '7 days'::interval),
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT learning_proposals_status_check CHECK (((status)::text = ANY ((ARRAY['PENDING'::character varying, 'UNDER_REVIEW'::character varying, 'APPROVED'::character varying, 'REJECTED'::character varying, 'EXPIRED'::character varying])::text[])))
);


--
-- Name: learning_versions; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.learning_versions (
    version_id uuid DEFAULT gen_random_uuid() NOT NULL,
    engine_id character varying(10) NOT NULL,
    parameter_type character varying(50) NOT NULL,
    version_number integer NOT NULL,
    previous_version_id uuid,
    parameter_value jsonb NOT NULL,
    source_proposal_id uuid,
    vega_attestation_id uuid NOT NULL,
    is_active boolean DEFAULT false,
    activated_at timestamp with time zone,
    deactivated_at timestamp with time zone,
    created_by character varying(50) NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: llm_provider_balance; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.llm_provider_balance (
    balance_id uuid DEFAULT gen_random_uuid() NOT NULL,
    provider character varying(50) NOT NULL,
    currency character varying(10) DEFAULT 'USD'::character varying NOT NULL,
    total_balance numeric(12,4) NOT NULL,
    granted_balance numeric(12,4) DEFAULT 0,
    topped_up_balance numeric(12,4) DEFAULT 0,
    is_available boolean DEFAULT true,
    fetched_at timestamp with time zone DEFAULT now(),
    api_key_masked character varying(20)
);


--
-- Name: market_event_types; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.market_event_types (
    event_type_id character varying(30) NOT NULL,
    event_name character varying(100) NOT NULL,
    description text,
    default_priority integer DEFAULT 5,
    typical_response_ms integer,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE market_event_types; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.market_event_types IS 'ARO-20251208 Section 4.1 Type A: Market event definitions.';


--
-- Name: market_temporal_windows; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.market_temporal_windows (
    window_id uuid DEFAULT gen_random_uuid() NOT NULL,
    asset_class text NOT NULL,
    market_condition text NOT NULL,
    freshness_threshold_hours numeric(10,2) NOT NULL,
    freshness_warning_hours numeric(10,2),
    freshness_critical_hours numeric(10,2),
    applies_from time without time zone,
    applies_to time without time zone,
    timezone text DEFAULT 'America/New_York'::text,
    applies_on_days integer[],
    holiday_multiplier numeric(4,2) DEFAULT 1.0,
    enabled boolean DEFAULT true,
    effective_from date DEFAULT CURRENT_DATE,
    effective_to date,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by text DEFAULT 'CDMO'::text,
    directive text DEFAULT 'CEO-DIR-2026-052'::text,
    CONSTRAINT chk_asset_class CHECK ((asset_class = ANY (ARRAY['crypto'::text, 'equity_us'::text, 'equity_intl'::text, 'fx'::text, 'commodity'::text, 'all'::text]))),
    CONSTRAINT chk_market_condition CHECK ((market_condition = ANY (ARRAY['NORMAL'::text, 'WEEKEND'::text, 'HOLIDAY'::text, 'EXTENDED_HOURS'::text, 'CLOSED'::text, 'ALL'::text])))
);


--
-- Name: TABLE market_temporal_windows; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.market_temporal_windows IS 'CEO-DIR-2026-052: Market-aware temporal windows for contextual staleness.
Replaces hard-coded 118.8h threshold with context-aware logic.
CDMO mandate: weekend equity data is NOT stale, just closed.
STIG 2026-01-14';


--
-- Name: mit_quad_pillars; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.mit_quad_pillars (
    pillar_id text NOT NULL,
    pillar_name text NOT NULL,
    lab_name text NOT NULL,
    core_function text NOT NULL,
    mit_methodology text NOT NULL,
    fhq_implementation text NOT NULL,
    primary_ios text[],
    primary_agents text[],
    constitutional_basis text DEFAULT 'ADR-017'::text NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    risl_status text DEFAULT 'ACTIVE'::text,
    CONSTRAINT mit_quad_pillars_risl_status_check CHECK ((risl_status = ANY (ARRAY['ACTIVE'::text, 'HALTED'::text, 'DEGRADED'::text])))
);


--
-- Name: TABLE mit_quad_pillars; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.mit_quad_pillars IS 'Registry of MIT Quad pillars per ADR-017. Maps MIT research domains to FjordHQ functional requirements.';


--
-- Name: mock_positions; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.mock_positions (
    position_id uuid DEFAULT gen_random_uuid() NOT NULL,
    asset_id text NOT NULL,
    quantity numeric DEFAULT 0 NOT NULL,
    avg_entry_price numeric,
    market_value numeric,
    unrealized_pnl numeric,
    last_updated timestamp with time zone DEFAULT now()
);


--
-- Name: model_provider_policy; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.model_provider_policy (
    policy_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_name text NOT NULL,
    llm_tier integer NOT NULL,
    allowed_providers text[] NOT NULL,
    forbidden_providers text[] DEFAULT ARRAY[]::text[] NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE model_provider_policy; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.model_provider_policy IS 'DEPRECATED as of CEO-DIR-2025-ALIGN-003 (2025-12-20). 
Authoritative provider policy is now fhq_governance.model_tier_enforcement. 
This table is retained for historical reference only. Do not use for runtime decisions.';


--
-- Name: model_tier_enforcement; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.model_tier_enforcement (
    enforcement_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id text NOT NULL,
    required_tier integer NOT NULL,
    allowed_providers text[] NOT NULL,
    forbidden_providers text[] DEFAULT ARRAY[]::text[] NOT NULL,
    enforcement_mode text DEFAULT 'STRICT'::text NOT NULL,
    violation_action text DEFAULT 'BLOCK'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by text DEFAULT 'CEO'::text NOT NULL,
    CONSTRAINT model_tier_enforcement_enforcement_mode_check CHECK ((enforcement_mode = ANY (ARRAY['STRICT'::text, 'WARN'::text, 'AUDIT'::text]))),
    CONSTRAINT model_tier_enforcement_required_tier_check CHECK ((required_tier = ANY (ARRAY[1, 2, 3]))),
    CONSTRAINT model_tier_enforcement_violation_action_check CHECK ((violation_action = ANY (ARRAY['BLOCK'::text, 'LOG'::text, 'ESCALATE'::text])))
);


--
-- Name: research_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.research_log (
    log_id uuid DEFAULT gen_random_uuid() NOT NULL,
    research_id uuid NOT NULL,
    agent_id character varying(20) NOT NULL,
    engine_version character varying(50) NOT NULL,
    event_type character varying(50) NOT NULL,
    quad_hash character varying(16),
    context_hash character varying(64),
    decision_trace jsonb DEFAULT '{}'::jsonb NOT NULL,
    status character varying(50) NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE research_log; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.research_log IS 'FINN CRIO research audit log. Required for G2->G3 governance progression.';


--
-- Name: mv_agent_integrity_ledger; Type: MATERIALIZED VIEW; Schema: fhq_governance; Owner: -
--

CREATE MATERIALIZED VIEW fhq_governance.mv_agent_integrity_ledger AS
 SELECT log_id,
    agent_id,
    event_type,
    status,
    quad_hash,
    created_at,
        CASE
            WHEN ((status)::text = ANY (ARRAY[('FAILED'::character varying)::text, ('ERROR'::character varying)::text])) THEN 'ALERT'::text
            WHEN ((status)::text = ANY (ARRAY[('SUCCESS'::character varying)::text, ('COMPLETED'::character varying)::text])) THEN 'OK'::text
            ELSE 'INFO'::text
        END AS governance_flag
   FROM fhq_governance.research_log
  ORDER BY created_at DESC
 LIMIT 100
  WITH NO DATA;


--
-- Name: mv_aol_agent_metrics; Type: MATERIALIZED VIEW; Schema: fhq_governance; Owner: -
--

CREATE MATERIALIZED VIEW fhq_governance.mv_aol_agent_metrics AS
 SELECT agent_id,
    count(*) AS total_actions,
    max("timestamp") AS last_action,
    count(*) FILTER (WHERE ((decision)::text = 'APPROVED'::text)) AS approved_count
   FROM fhq_governance.governance_actions_log
  WHERE (agent_id IS NOT NULL)
  GROUP BY agent_id
  WITH NO DATA;


--
-- Name: mv_evpi_proxy; Type: MATERIALIZED VIEW; Schema: fhq_governance; Owner: -
--

CREATE MATERIALIZED VIEW fhq_governance.mv_evpi_proxy AS
 SELECT date_trunc('week'::text, suppression_timestamp) AS week,
    suppression_category,
    count(*) AS suppression_count,
    round(avg(
        CASE
            WHEN (regret_classification = 'REGRET'::text) THEN (abs((suppressed_confidence - chosen_confidence)) * COALESCE(regret_magnitude, 0.1))
            ELSE (0)::numeric
        END), 6) AS evpi_proxy,
    round(avg(regret_magnitude) FILTER (WHERE (regret_classification = 'REGRET'::text)), 4) AS avg_regret_magnitude,
    count(*) FILTER (WHERE (regret_classification = 'REGRET'::text)) AS regret_count,
    count(*) FILTER (WHERE (regret_classification = 'WISDOM'::text)) AS wisdom_count,
        CASE
            WHEN (avg(
            CASE
                WHEN (regret_classification = 'REGRET'::text) THEN (abs((suppressed_confidence - chosen_confidence)) * COALESCE(regret_magnitude, 0.1))
                ELSE (0)::numeric
            END) > 0.1) THEN 'HIGH_OPPORTUNITY_COST'::text
            WHEN (avg(
            CASE
                WHEN (regret_classification = 'REGRET'::text) THEN (abs((suppressed_confidence - chosen_confidence)) * COALESCE(regret_magnitude, 0.1))
                ELSE (0)::numeric
            END) > 0.05) THEN 'MEDIUM_OPPORTUNITY_COST'::text
            ELSE 'LOW_OPPORTUNITY_COST'::text
        END AS opportunity_cost_indicator
   FROM fhq_governance.epistemic_suppression_ledger
  WHERE (suppression_timestamp >= (now() - '90 days'::interval))
  GROUP BY (date_trunc('week'::text, suppression_timestamp)), suppression_category
  WITH NO DATA;


--
-- Name: MATERIALIZED VIEW mv_evpi_proxy; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON MATERIALIZED VIEW fhq_governance.mv_evpi_proxy IS 'CEO Directive: Metakognitiv Observability - EVPI Proxy.
Expected Value of Perfect Information - respects ADR-013 One-Source-of-Truth.
Captures "cost of being wrong" adjusted for confidence delta.
Source: fhq_governance.epistemic_suppression_ledger';


--
-- Name: mv_system_health_summary; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.mv_system_health_summary AS
 SELECT COALESCE(( SELECT defcon_status.current_level
           FROM fhq_monitoring.defcon_status
          ORDER BY defcon_status.activated_at DESC
         LIMIT 1), 'GREEN'::text) AS defcon_level,
    COALESCE(( SELECT v_btc_regime_current.regime_label
           FROM fhq_finn.v_btc_regime_current
         LIMIT 1), 'UNKNOWN'::text) AS current_regime,
    (COALESCE(( SELECT v_btc_regime_current.regime_confidence
           FROM fhq_finn.v_btc_regime_current
         LIMIT 1), (0.0)::double precision))::numeric(5,2) AS regime_confidence,
    0 AS total_agents,
    0 AS active_needles,
    now() AS snapshot_timestamp;


--
-- Name: novelty_score_components; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.novelty_score_components (
    score_id uuid DEFAULT gen_random_uuid() NOT NULL,
    trade_id uuid,
    regime_shift_score numeric(5,4) DEFAULT 0 NOT NULL,
    regime_shift_reason text,
    asset_novelty_score numeric(5,4) DEFAULT 0 NOT NULL,
    asset_novelty_reason text,
    signal_disagreement_score numeric(5,4) DEFAULT 0 NOT NULL,
    signal_disagreement_reason text,
    total_novelty_score numeric(5,4) GENERATED ALWAYS AS (((regime_shift_score + asset_novelty_score) + signal_disagreement_score)) STORED,
    computed_at timestamp with time zone DEFAULT now()
);


--
-- Name: oracle_event_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.oracle_event_log (
    event_id uuid DEFAULT gen_random_uuid() NOT NULL,
    vector_id uuid NOT NULL,
    operator text NOT NULL,
    action text NOT NULL,
    bpav_used jsonb,
    context jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT oracle_event_log_action_check CHECK ((action = ANY (ARRAY['CREATE'::text, 'REFRESH'::text, 'DECAY'::text, 'BPAV_COMPUTE'::text])))
);


--
-- Name: TABLE oracle_event_log; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.oracle_event_log IS 'VEGA Audit Trail: Complete visibility into Human Oracle Channel activity.
Tracks all narrative vector creation, BPAV computation, and decay events.
No secret influence attempts. Full accountability.';


--
-- Name: oracle_staging; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.oracle_staging (
    submission_id uuid DEFAULT gen_random_uuid() NOT NULL,
    domain text NOT NULL,
    narrative text NOT NULL,
    probability numeric(4,3) NOT NULL,
    confidence numeric(4,3) NOT NULL,
    half_life_hours integer DEFAULT 24 NOT NULL,
    submitted_by text DEFAULT 'CEO'::text NOT NULL,
    submitted_at timestamp with time zone DEFAULT now() NOT NULL,
    submission_source text DEFAULT 'VISION_CHAT'::text,
    review_status text DEFAULT 'PENDING'::text NOT NULL,
    reviewed_by text,
    reviewed_at timestamp with time zone,
    rejection_reason text,
    promoted_to_vector_id uuid,
    promoted_at timestamp with time zone,
    CONSTRAINT oracle_staging_confidence_check CHECK (((confidence >= (0)::numeric) AND (confidence <= (1)::numeric))),
    CONSTRAINT oracle_staging_probability_check CHECK (((probability >= (0)::numeric) AND (probability <= (1)::numeric))),
    CONSTRAINT valid_domain CHECK ((domain = ANY (ARRAY['Regulatory'::text, 'Geopolitical'::text, 'Liquidity'::text, 'Reflexivity'::text, 'Sentiment'::text, 'Technical'::text, 'Macro'::text, 'Other'::text]))),
    CONSTRAINT valid_review_status CHECK ((review_status = ANY (ARRAY['PENDING'::text, 'APPROVED'::text, 'REJECTED'::text, 'PROMOTED'::text])))
);


--
-- Name: TABLE oracle_staging; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.oracle_staging IS 'G0 submissions for narrative vectors pending VEGA G1 review. Per G1 UI Governance Patch.';


--
-- Name: orchestrator_authority; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.orchestrator_authority (
    orchestrator_id text NOT NULL,
    orchestrator_name text NOT NULL,
    scope text NOT NULL,
    asset_classes text[] NOT NULL,
    primary_vendor text NOT NULL,
    fallback_vendors text[],
    constitutional_authority boolean DEFAULT true,
    enabled boolean DEFAULT true,
    stop_conditions jsonb DEFAULT '{}'::jsonb,
    freshness_metrics_enabled boolean DEFAULT true,
    fail_closed boolean DEFAULT true,
    activated_by text DEFAULT 'CEO'::text,
    activated_at timestamp with time zone DEFAULT now(),
    directive_reference text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: orchestrator_cycles; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.orchestrator_cycles (
    cycle_id text NOT NULL,
    cycle_type text DEFAULT 'STANDARD'::text NOT NULL,
    started_at timestamp with time zone DEFAULT now() NOT NULL,
    ended_at timestamp with time zone,
    execution_mode text,
    defcon_level text,
    tasks_scheduled integer DEFAULT 0 NOT NULL,
    tasks_completed integer DEFAULT 0 NOT NULL,
    tasks_failed integer DEFAULT 0 NOT NULL,
    tasks_skipped integer DEFAULT 0 NOT NULL,
    vendor_snapshot jsonb,
    evidence_hash text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT valid_cycle_type CHECK ((cycle_type = ANY (ARRAY['NIGHTLY'::text, 'HOURLY'::text, 'REALTIME'::text, 'EVENT'::text, 'STANDARD'::text])))
);


--
-- Name: TABLE orchestrator_cycles; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.orchestrator_cycles IS 'Detailed orchestrator cycle audit log for VEGA compliance.';


--
-- Name: output_bindings; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.output_bindings (
    binding_id uuid DEFAULT gen_random_uuid() NOT NULL,
    state_snapshot_hash text NOT NULL,
    state_timestamp timestamp with time zone NOT NULL,
    agent_id text NOT NULL,
    output_type text NOT NULL,
    output_id uuid NOT NULL,
    output_table text NOT NULL,
    binding_status text NOT NULL,
    output_hash text NOT NULL,
    binding_hash text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    validated_at timestamp with time zone,
    validated_by text,
    quad_hash text,
    CONSTRAINT output_bindings_binding_status_check CHECK ((binding_status = ANY (ARRAY['VALID'::text, 'ORPHANED'::text, 'INVALID'::text]))),
    CONSTRAINT output_bindings_output_type_check CHECK ((output_type = ANY (ARRAY['REASONING'::text, 'STRATEGY_PROPOSAL'::text, 'EXECUTION_PLAN'::text, 'CODE_ARTIFACT'::text, 'GOVERNANCE_DECISION'::text, 'TRADE'::text, 'ALLOCATION'::text, 'INSIGHT_PACK'::text, 'SKILL_REPORT'::text, 'FORESIGHT_PACK'::text])))
);


--
-- Name: TABLE output_bindings; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.output_bindings IS 'Immutable link between agent outputs and their governing state context.
Per ADR-018 5.1: No agent output is valid without its contextual fingerprint.
Enables deterministic post-mortem reconstruction under ADR-002/ADR-011.';


--
-- Name: paper_decision_plan; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.paper_decision_plan (
    plan_id uuid DEFAULT gen_random_uuid() NOT NULL,
    plan_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    plan_type text DEFAULT 'PAPER_ALPHA'::text,
    allocation_model text DEFAULT 'RISK_PARITY_INFO_WEIGHTED'::text,
    min_confidence_threshold numeric(5,4) DEFAULT 0.25 NOT NULL,
    effective_threshold numeric(5,4),
    threshold_adjustment_reason text,
    max_leverage numeric(4,2) DEFAULT 1.0,
    positions_planned integer DEFAULT 0 NOT NULL,
    positions_executed integer DEFAULT 0,
    positions_blocked integer DEFAULT 0,
    total_risk_units numeric(10,4),
    max_single_position_pct numeric(5,4) DEFAULT 0.10,
    dominant_regime text,
    regime_confidence numeric(5,4),
    status text DEFAULT 'PENDING'::text,
    suspended_reason text,
    created_by text DEFAULT 'LARS'::text,
    approved_by text,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT paper_decision_plan_status_check CHECK ((status = ANY (ARRAY['PENDING'::text, 'EXECUTING'::text, 'COMPLETED'::text, 'SUSPENDED'::text])))
);


--
-- Name: paper_execution_authority; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.paper_execution_authority (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    ios_id text NOT NULL,
    activation_mode text NOT NULL,
    execution_enabled boolean DEFAULT false NOT NULL,
    paper_api_enabled boolean DEFAULT false NOT NULL,
    live_api_enabled boolean DEFAULT false NOT NULL,
    source_mandate_override boolean DEFAULT false NOT NULL,
    override_source text,
    override_authorized_by text,
    override_expires_on text,
    code_immutability_enforced boolean DEFAULT true NOT NULL,
    adr_012_constraints_enforced boolean DEFAULT true NOT NULL,
    governance_logging_required boolean DEFAULT true NOT NULL,
    activated_by text NOT NULL,
    activated_at timestamp with time zone DEFAULT now() NOT NULL,
    vega_certification_ref text NOT NULL,
    ceo_mandate_ref text NOT NULL,
    hash_chain_id text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT paper_execution_authority_activation_mode_check CHECK ((activation_mode = ANY (ARRAY['PAPER'::text, 'LIVE'::text, 'DISABLED'::text])))
);


--
-- Name: TABLE paper_execution_authority; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.paper_execution_authority IS 'Tracks PAPER execution authority for IoS modules under G4 Conditional activation. ADR-012 compliance.';


--
-- Name: paper_execution_loop; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.paper_execution_loop (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    loop_id text NOT NULL,
    source_module text NOT NULL,
    execution_module text NOT NULL,
    target_api text NOT NULL,
    loop_status text DEFAULT 'INITIALIZED'::text NOT NULL,
    governance_logging_enabled boolean DEFAULT true NOT NULL,
    override_tag_required text,
    adr_012_compliance boolean DEFAULT true NOT NULL,
    activated_by text NOT NULL,
    activated_at timestamp with time zone DEFAULT now() NOT NULL,
    hash_chain_id text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT paper_execution_loop_loop_status_check CHECK ((loop_status = ANY (ARRAY['INITIALIZED'::text, 'RUNNING'::text, 'PAUSED'::text, 'HALTED'::text, 'ERROR'::text])))
);


--
-- Name: paper_ledger; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.paper_ledger (
    trade_id uuid DEFAULT gen_random_uuid() NOT NULL,
    decision_plan_id uuid,
    decision_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    asset_id text NOT NULL,
    canonical_id text NOT NULL,
    direction text NOT NULL,
    raw_position_size numeric(12,4) NOT NULL,
    calibrated_position_size numeric(12,4) NOT NULL,
    information_weight numeric(5,4) DEFAULT 1.0,
    raw_confidence numeric(5,4) NOT NULL,
    calibrated_confidence numeric(5,4) NOT NULL,
    calibration_gate_id uuid,
    confidence_reduction numeric(5,4) GENERATED ALWAYS AS ((raw_confidence - calibrated_confidence)) STORED,
    entry_price numeric(18,8) NOT NULL,
    simulated_slippage numeric(5,4) DEFAULT 0.0005,
    effective_entry_price numeric(18,8) GENERATED ALWAYS AS (
CASE
    WHEN (direction = 'LONG'::text) THEN (entry_price * ((1)::numeric + simulated_slippage))
    WHEN (direction = 'SHORT'::text) THEN (entry_price * ((1)::numeric - simulated_slippage))
    ELSE entry_price
END) STORED,
    exit_price numeric(18,8),
    exit_timestamp timestamp with time zone,
    effective_exit_price numeric(18,8),
    paper_pnl numeric(18,8),
    paper_pnl_pct numeric(8,4),
    forecast_id uuid,
    outcome_correct boolean,
    regime_at_entry text,
    regime_at_exit text,
    novelty_score numeric(5,4) DEFAULT 0.5,
    error_type text,
    lesson_extracted boolean DEFAULT false,
    created_by text DEFAULT 'LARS'::text,
    executed_by text DEFAULT 'LINE'::text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    volatility_at_entry numeric(8,4),
    liquidity_tier_at_entry text,
    slippage_rule_applied text,
    CONSTRAINT paper_ledger_direction_check CHECK ((direction = ANY (ARRAY['LONG'::text, 'SHORT'::text, 'CLOSE'::text])))
);


--
-- Name: pending_constraints; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.pending_constraints (
    constraint_id uuid DEFAULT gen_random_uuid() NOT NULL,
    table_name text NOT NULL,
    constraint_name text NOT NULL,
    constraint_definition text NOT NULL,
    activation_requirement text NOT NULL,
    proposed_by text NOT NULL,
    proposed_at timestamp with time zone DEFAULT now(),
    vega_attested boolean DEFAULT false,
    vega_attestation_id uuid,
    activated boolean DEFAULT false,
    activated_at timestamp with time zone
);


--
-- Name: plps_gate_config; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.plps_gate_config (
    config_id uuid DEFAULT gen_random_uuid() NOT NULL,
    directive_id text DEFAULT 'CEO-DIR-2026-PLPS-001'::text NOT NULL,
    real_capital_loss_tolerance_pct numeric(5,2) DEFAULT 0.00 NOT NULL,
    paper_drawdown_tolerance_pct numeric(5,2) DEFAULT 100.00 NOT NULL,
    minimum_trades integer DEFAULT 50 NOT NULL,
    profit_factor_floor numeric(5,2) DEFAULT 1.20 NOT NULL,
    max_drawdown_pct numeric(5,2) DEFAULT 15.00 NOT NULL,
    sharpe_ratio_floor numeric(5,2) DEFAULT 0.50 NOT NULL,
    regime_coverage_min integer DEFAULT 2 NOT NULL,
    conservative_pnl_must_be_positive boolean DEFAULT true NOT NULL,
    vega_attestation_required boolean DEFAULT true NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    profit_target_pct numeric(5,2) DEFAULT 50.00,
    CONSTRAINT plps_no_live_risk CHECK ((real_capital_loss_tolerance_pct = 0.00))
);


--
-- Name: plps_graduation_attempts; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.plps_graduation_attempts (
    attempt_id uuid DEFAULT gen_random_uuid() NOT NULL,
    config_id uuid,
    evaluation_start date NOT NULL,
    evaluation_end date NOT NULL,
    total_trades integer NOT NULL,
    winning_trades integer NOT NULL,
    losing_trades integer NOT NULL,
    gross_pnl_usd numeric(12,2) NOT NULL,
    haircut_total_usd numeric(12,2) NOT NULL,
    conservative_pnl_usd numeric(12,2) NOT NULL,
    profit_factor numeric(6,3),
    max_drawdown_pct numeric(5,2),
    sharpe_ratio numeric(6,3),
    regimes_traded text[] NOT NULL,
    regime_count integer NOT NULL,
    gate_min_trades_passed boolean NOT NULL,
    gate_profit_factor_passed boolean NOT NULL,
    gate_max_drawdown_passed boolean NOT NULL,
    gate_sharpe_passed boolean NOT NULL,
    gate_regime_coverage_passed boolean NOT NULL,
    gate_conservative_pnl_passed boolean NOT NULL,
    all_gates_passed boolean NOT NULL,
    graduation_status text NOT NULL,
    vega_attestation_id uuid,
    vega_signed_at timestamp with time zone,
    evidence_bundle_hash text,
    evaluated_at timestamp with time zone DEFAULT now() NOT NULL,
    evaluated_by text DEFAULT 'VEGA'::text NOT NULL,
    CONSTRAINT plps_graduation_attempts_graduation_status_check CHECK ((graduation_status = ANY (ARRAY['PENDING'::text, 'GRADUATED'::text, 'FAILED'::text, 'INSUFFICIENT_DATA'::text])))
);


--
-- Name: preflight_checklist; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.preflight_checklist (
    checklist_id uuid DEFAULT gen_random_uuid() NOT NULL,
    checklist_name text NOT NULL,
    action_type text NOT NULL,
    check_order integer NOT NULL,
    check_description text NOT NULL,
    validation_rule text,
    constitutional_basis text NOT NULL,
    is_mandatory boolean DEFAULT true NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE preflight_checklist; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.preflight_checklist IS 'VEGA mandatory pre-flight governance checklist per CEO mandate. All actions must pass all mandatory checks.';


--
-- Name: production_monitoring; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.production_monitoring (
    monitoring_id integer NOT NULL,
    monitoring_type character varying(100) NOT NULL,
    monitoring_status character varying(50) NOT NULL,
    frequency character varying(50),
    last_execution timestamp with time zone,
    next_execution timestamp with time zone,
    monitoring_config jsonb NOT NULL,
    alert_on_failure boolean DEFAULT true,
    alert_recipients text[],
    enabled_by character varying(50) NOT NULL,
    enabled_at timestamp with time zone DEFAULT now(),
    authority character varying(200),
    CONSTRAINT chk_monitoring_status CHECK (((monitoring_status)::text = ANY (ARRAY[('active'::character varying)::text, ('paused'::character varying)::text, ('disabled'::character varying)::text])))
);


--
-- Name: production_monitoring_monitoring_id_seq; Type: SEQUENCE; Schema: fhq_governance; Owner: -
--

CREATE SEQUENCE fhq_governance.production_monitoring_monitoring_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: production_monitoring_monitoring_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_governance; Owner: -
--

ALTER SEQUENCE fhq_governance.production_monitoring_monitoring_id_seq OWNED BY fhq_governance.production_monitoring.monitoring_id;


--
-- Name: protocol_omega_executions; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.protocol_omega_executions (
    execution_id uuid DEFAULT gen_random_uuid() NOT NULL,
    omega_id uuid NOT NULL,
    triggered_by character varying(50) NOT NULL,
    trigger_reason text NOT NULL,
    defcon_level_at_trigger character varying(10),
    execution_status character varying(20) DEFAULT 'INITIATED'::character varying NOT NULL,
    execution_steps_completed jsonb DEFAULT '[]'::jsonb,
    execution_steps_failed jsonb DEFAULT '[]'::jsonb,
    rollback_initiated boolean DEFAULT false NOT NULL,
    rollback_completed boolean DEFAULT false NOT NULL,
    rollback_reason text,
    initiated_at timestamp with time zone DEFAULT now() NOT NULL,
    completed_at timestamp with time zone,
    rolled_back_at timestamp with time zone,
    CONSTRAINT chk_omega_exec_status CHECK (((execution_status)::text = ANY ((ARRAY['INITIATED'::character varying, 'IN_PROGRESS'::character varying, 'COMPLETED'::character varying, 'FAILED'::character varying, 'ROLLED_BACK'::character varying])::text[])))
);


--
-- Name: protocol_omega_registry; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.protocol_omega_registry (
    omega_id uuid DEFAULT gen_random_uuid() NOT NULL,
    protocol_name character varying(100) NOT NULL,
    protocol_version character varying(20) DEFAULT '1.0.0'::character varying NOT NULL,
    description text NOT NULL,
    trigger_conditions jsonb NOT NULL,
    execution_sequence jsonb NOT NULL,
    rollback_procedure jsonb,
    requires_ceo_approval boolean DEFAULT true NOT NULL,
    requires_vega_attestation boolean DEFAULT true NOT NULL,
    status character varying(20) DEFAULT 'PLANNED'::character varying NOT NULL,
    implementation_status character varying(50) DEFAULT 'SCHEMA_ONLY'::character varying NOT NULL,
    created_by character varying(50) NOT NULL,
    attested_by character varying(50),
    attestation_id uuid,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT chk_omega_status CHECK (((status)::text = ANY ((ARRAY['PLANNED'::character varying, 'ACTIVE'::character varying, 'SUSPENDED'::character varying, 'DEPRECATED'::character varying])::text[])))
);


--
-- Name: provider_usage_v; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.provider_usage_v AS
 SELECT routed_provider AS provider,
    model,
    count(*) AS call_count_7d,
    COALESCE(sum((tokens_in + tokens_out)), (0)::bigint) AS total_tokens_7d,
    COALESCE(sum(cost_usd), (0)::numeric) AS total_cost_7d,
    (COALESCE(avg(latency_ms), (0)::numeric))::integer AS avg_latency_ms,
    count(*) FILTER (WHERE (stream_mode = true)) AS streaming_calls,
    min(timestamp_utc) AS first_call,
    max(timestamp_utc) AS last_call
   FROM fhq_governance.llm_routing_log
  WHERE ((timestamp_utc >= (now() - '7 days'::interval)) AND (envelope_id IS NOT NULL))
  GROUP BY routed_provider, model;


--
-- Name: quad_hash_registry; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.quad_hash_registry (
    quad_hash_id uuid DEFAULT gen_random_uuid() NOT NULL,
    lids_score numeric NOT NULL,
    acl_agent text NOT NULL,
    dsl_model text NOT NULL,
    risl_status text NOT NULL,
    quad_hash text NOT NULL,
    state_snapshot_hash text NOT NULL,
    state_timestamp timestamp with time zone NOT NULL,
    lids_threshold_met boolean DEFAULT false NOT NULL,
    is_valid boolean DEFAULT false NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by text NOT NULL,
    hash_self text NOT NULL,
    CONSTRAINT quad_hash_registry_lids_score_check CHECK (((lids_score >= (0)::numeric) AND (lids_score <= (1)::numeric))),
    CONSTRAINT quad_hash_registry_risl_status_check CHECK ((risl_status = ANY (ARRAY['HEALTHY'::text, 'DEGRADED'::text, 'ISOLATED'::text, 'HALTED'::text])))
);


--
-- Name: TABLE quad_hash_registry; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.quad_hash_registry IS 'Registry of Quad-Hashes per ADR-017 4. Every trade/strategy output must reference a valid Quad-Hash.
Format: {LIDS_Score}_{ACL_Agent}_{DSL_Model}_{RISL_Status}';


--
-- Name: refinement_evidence_bundle; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.refinement_evidence_bundle (
    bundle_id uuid DEFAULT gen_random_uuid() NOT NULL,
    bundle_type character varying(30) NOT NULL,
    preservation_reason text NOT NULL,
    preserved_by character varying(20) NOT NULL,
    raw_cot_preserved text,
    raw_query text NOT NULL,
    query_result_hash character varying(64),
    query_result_snapshot jsonb,
    error_message text,
    error_stack_trace text,
    refinement_id uuid,
    governance_action_id uuid,
    defcon_level_at_creation character varying(10),
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT refinement_evidence_bundle_bundle_type_check CHECK (((bundle_type)::text = ANY ((ARRAY['ESCALATION'::character varying, 'FORENSIC'::character varying, 'G4_INCIDENT'::character varying])::text[])))
);


--
-- Name: regime_continuity_status; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.regime_continuity_status AS
 SELECT is_fresh,
    regime_state,
    regime_confidence,
    regime_timestamp,
    staleness_hours,
    max_allowed_hours,
        CASE
            WHEN is_fresh THEN 'OPERATIONAL'::text
            WHEN (staleness_hours IS NULL) THEN 'NO_REGIME'::text
            ELSE 'EPISTEMICALLY_BLIND'::text
        END AS system_state,
    ( SELECT data_blackout_state.is_active
           FROM fhq_governance.data_blackout_state
          WHERE (data_blackout_state.is_active = true)
          ORDER BY data_blackout_state.triggered_at DESC
         LIMIT 1) AS blackout_active
   FROM fhq_governance.check_regime_freshness(6) rf(is_fresh, regime_state, regime_confidence, regime_timestamp, staleness_hours, max_allowed_hours);


--
-- Name: regime_scalar_config; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.regime_scalar_config (
    config_id uuid DEFAULT gen_random_uuid() NOT NULL,
    regime_label text NOT NULL,
    scalar_value numeric(5,4) NOT NULL,
    mode text DEFAULT 'LONG_ONLY'::text NOT NULL,
    description text,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    created_by text DEFAULT 'STIG'::text,
    CONSTRAINT regime_scalar_config_mode_check CHECK ((mode = ANY (ARRAY['LONG_ONLY'::text, 'LONG_SHORT'::text]))),
    CONSTRAINT regime_scalar_config_scalar_value_check CHECK (((scalar_value >= ('-1'::integer)::numeric) AND (scalar_value <= (1)::numeric)))
);


--
-- Name: registry_reconciliation_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.registry_reconciliation_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    reconciliation_date date DEFAULT CURRENT_DATE NOT NULL,
    reconciliation_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    initiated_by text NOT NULL,
    ios_id text NOT NULL,
    action text NOT NULL,
    previous_state jsonb,
    new_state jsonb NOT NULL,
    rationale text NOT NULL,
    adr_reference text,
    vega_reviewed boolean DEFAULT false NOT NULL,
    hash_chain_id text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT registry_reconciliation_log_action_check CHECK ((action = ANY (ARRAY['REGISTERED'::text, 'UPDATED'::text, 'CORRECTED'::text])))
);


--
-- Name: TABLE registry_reconciliation_log; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.registry_reconciliation_log IS 'ADR-013 One-Source-Truth reconciliation audit trail. Tracks all registry corrections and updates.';


--
-- Name: regret_attribution_summary; Type: MATERIALIZED VIEW; Schema: fhq_governance; Owner: -
--

CREATE MATERIALIZED VIEW fhq_governance.regret_attribution_summary AS
 SELECT regret_attribution_type,
    regret_magnitude_category,
    count(*) AS occurrence_count,
    avg(regret_magnitude) AS avg_regret_magnitude,
    array_agg(DISTINCT asset_id) AS affected_assets,
    min(suppression_timestamp) AS first_occurrence,
    max(suppression_timestamp) AS latest_occurrence
   FROM fhq_governance.epistemic_suppression_ledger
  WHERE ((regret_classification = 'REGRET'::text) AND (regret_attribution_type IS NOT NULL))
  GROUP BY regret_attribution_type, regret_magnitude_category
  ORDER BY (count(*)) DESC
  WITH NO DATA;


--
-- Name: regret_computation_diagnostics; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.regret_computation_diagnostics (
    diagnostic_id uuid DEFAULT gen_random_uuid() NOT NULL,
    regret_id uuid NOT NULL,
    computation_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    total_suppressions integer NOT NULL,
    matched_suppressions integer NOT NULL,
    unmatched_suppressions integer NOT NULL,
    match_rate numeric NOT NULL,
    fuzzy_match_count integer DEFAULT 0,
    pct_fuzzy_matches numeric DEFAULT 0,
    max_time_delta_hours numeric,
    matches_in_primary_window integer,
    matches_in_extended_window integer,
    matches_outside_window integer,
    pct_matches_outside_primary numeric,
    unmatched_by_time_cluster jsonb,
    unmatched_by_asset jsonb,
    diagnostic_hash text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE regret_computation_diagnostics; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.regret_computation_diagnostics IS 'CEO-DIR-2026-021 Audit Correction #2: Matching diagnostics per regret computation.
Tracks match rates, fuzzy matching usage, time drift, unmatched patterns.
Prevents "regret washed out by matchmaking" - all matching decisions are logged.';


--
-- Name: retest_validation_cycles; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.retest_validation_cycles (
    cycle_id uuid DEFAULT gen_random_uuid() NOT NULL,
    failure_mode_id uuid NOT NULL,
    cycle_number integer DEFAULT 1 NOT NULL,
    cycle_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    corrective_mechanism_active boolean NOT NULL,
    original_failure_reappeared boolean DEFAULT false NOT NULL,
    new_failure_introduced boolean DEFAULT false NOT NULL,
    metrics_improved boolean NOT NULL,
    before_metric numeric(10,4),
    after_metric numeric(10,4),
    delta_metric numeric(10,4),
    cycle_result text NOT NULL,
    validated_by text DEFAULT 'SHADOW_EVALUATOR'::text,
    evidence jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT chk_cycle_result CHECK ((cycle_result = ANY (ARRAY['PASS'::text, 'FAIL'::text, 'REGRESSION'::text])))
);


--
-- Name: TABLE retest_validation_cycles; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.retest_validation_cycles IS 'CEO-DIR-2026-054: RETEST validation cycle tracking.
Tracks 7 consecutive shadow cycles required for closure.
STIG 2026-01-14';


--
-- Name: scheduled_audits; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.scheduled_audits (
    schedule_id uuid DEFAULT gen_random_uuid() NOT NULL,
    audit_name text NOT NULL,
    audit_type text NOT NULL,
    task_reference text,
    schedule_cron text NOT NULL,
    next_run_at timestamp with time zone,
    last_run_at timestamp with time zone,
    status text DEFAULT 'ACTIVE'::text NOT NULL,
    governance_trigger text,
    created_by text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: scheduled_tasks; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.scheduled_tasks (
    task_id character varying(100) NOT NULL,
    task_type character varying(50) NOT NULL,
    priority integer DEFAULT 5 NOT NULL,
    scheduled_at timestamp with time zone NOT NULL,
    action_type character varying(50) NOT NULL,
    action_target character varying(200),
    action_params jsonb,
    status character varying(20) DEFAULT 'SCHEDULED'::character varying,
    executed_at timestamp with time zone,
    result jsonb,
    created_by character varying(20) NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: security_alerts; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.security_alerts (
    alert_id uuid DEFAULT gen_random_uuid() NOT NULL,
    alert_type text NOT NULL,
    alert_severity text NOT NULL,
    source_module text NOT NULL,
    decision_id uuid,
    description text NOT NULL,
    evidence jsonb,
    acknowledged boolean DEFAULT false,
    acknowledged_by text,
    acknowledged_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT security_alerts_alert_severity_check CHECK ((alert_severity = ANY (ARRAY['LOW'::text, 'MEDIUM'::text, 'HIGH'::text, 'CRITICAL'::text])))
);


--
-- Name: shadow_decision_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.shadow_decision_log (
    decision_id uuid DEFAULT gen_random_uuid() NOT NULL,
    signal_id uuid NOT NULL,
    needle_id uuid,
    symbol text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    signal_created_at timestamp with time zone,
    evaluation_time timestamp with time zone DEFAULT now() NOT NULL,
    lids_verdict text NOT NULL,
    lids_confidence numeric(8,4),
    lids_confidence_threshold numeric(8,4) DEFAULT 0.70,
    lids_freshness_hours numeric(10,2),
    lids_freshness_threshold_hours numeric(10,2) DEFAULT 12.0,
    eqs_score numeric(10,6),
    sitc_confidence_level text,
    decision_formula jsonb DEFAULT '{}'::jsonb NOT NULL,
    execution_mode text DEFAULT 'SHADOW_EVALUATION'::text NOT NULL,
    would_have_executed boolean DEFAULT false,
    blocked_at_gate text,
    exposure_gate_result boolean,
    holiday_gate_result boolean,
    btc_only_gate_result boolean,
    sitc_gate_result boolean,
    daemon_cycle_id uuid,
    directive text DEFAULT 'CEO-DIR-2026-050'::text,
    CONSTRAINT chk_execution_mode CHECK ((execution_mode = ANY (ARRAY['SHADOW_EVALUATION'::text, 'PAPER'::text, 'LIVE'::text]))),
    CONSTRAINT chk_lids_verdict CHECK ((lids_verdict = ANY (ARRAY['PASS'::text, 'BLOCKED_CONFIDENCE'::text, 'BLOCKED_FRESHNESS'::text, 'BLOCKED_MULTIPLE'::text])))
);


--
-- Name: TABLE shadow_decision_log; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.shadow_decision_log IS 'CEO-DIR-2026-050: Shadow Decision Log.
Non-executing ledger for LIDS gate evaluation observability.
Logs what WOULD have happened without executing trades.
paper_trading_eligible remains FALSE by design.
STIG 2026-01-14';


--
-- Name: shared_state_snapshots; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.shared_state_snapshots (
    snapshot_id uuid DEFAULT gen_random_uuid() NOT NULL,
    snapshot_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    defcon_level text NOT NULL,
    defcon_state_id uuid NOT NULL,
    defcon_reason text,
    defcon_triggered_at timestamp with time zone NOT NULL,
    btc_regime_label text NOT NULL,
    btc_regime_confidence numeric NOT NULL,
    btc_regime_timestamp date NOT NULL,
    strategy_snapshot_id uuid,
    strategy_posture text NOT NULL,
    strategy_exposure numeric NOT NULL,
    state_vector_hash text NOT NULL,
    valid_from timestamp with time zone DEFAULT now() NOT NULL,
    valid_until timestamp with time zone,
    freshness_ttl_seconds integer DEFAULT 300 NOT NULL,
    is_valid boolean DEFAULT true NOT NULL,
    invalidation_reason text,
    invalidated_at timestamp with time zone,
    invalidated_by text,
    hash_prev text,
    hash_self text NOT NULL,
    created_by text DEFAULT 'STIG'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT shared_state_snapshots_btc_regime_confidence_check CHECK (((btc_regime_confidence >= (0)::numeric) AND (btc_regime_confidence <= (1)::numeric))),
    CONSTRAINT shared_state_snapshots_btc_regime_label_check CHECK ((btc_regime_label = ANY (ARRAY['STRONG_BULL'::text, 'BULL'::text, 'RANGE_UP'::text, 'NEUTRAL'::text, 'RANGE_DOWN'::text, 'BEAR'::text, 'STRONG_BEAR'::text, 'PARABOLIC'::text, 'BROKEN'::text, 'UNTRUSTED'::text]))),
    CONSTRAINT shared_state_snapshots_defcon_level_check CHECK ((defcon_level = ANY (ARRAY['GREEN'::text, 'YELLOW'::text, 'ORANGE'::text, 'RED'::text, 'BLACK'::text])))
);


--
-- Name: TABLE shared_state_snapshots; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.shared_state_snapshots IS 'Atomic state vectors per ADR-018 4. Single source of truth for agent state.
Agents MUST retrieve state from this table. Partial reads are unconstitutional.
Implements fail-closed semantics: any validation failure invalidates the entire snapshot.';


--
-- Name: sitc_linkage_audit; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.sitc_linkage_audit AS
 SELECT a.attempt_id,
    a.needle_id,
    a.sitc_event_id,
    a.final_outcome,
        CASE
            WHEN (a.sitc_event_id IS NULL) THEN 'NO_SITC'::text
            WHEN (se.sitc_event_id IS NULL) THEN 'ORPHAN'::text
            WHEN (se.reasoning_complete = false) THEN 'INCOMPLETE'::text
            ELSE 'LINKED'::text
        END AS linkage_status
   FROM (fhq_governance.execution_attempts a
     LEFT JOIN fhq_cognition.search_in_chain_events se ON ((a.sitc_event_id = se.sitc_event_id)));


--
-- Name: VIEW sitc_linkage_audit; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.sitc_linkage_audit IS 'CEO-DIR-2026-FINN-019 NB-06: SitC event linkage verification';


--
-- Name: skill_damper_config; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.skill_damper_config (
    config_id uuid DEFAULT gen_random_uuid() NOT NULL,
    threshold_type text NOT NULL,
    fss_min numeric(5,4) NOT NULL,
    fss_max numeric(5,4) NOT NULL,
    damper_value numeric(5,4) NOT NULL,
    description text,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT skill_damper_config_damper_value_check CHECK (((damper_value >= (0)::numeric) AND (damper_value <= (1)::numeric)))
);


--
-- Name: split_brain_events; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.split_brain_events (
    event_id uuid DEFAULT gen_random_uuid() NOT NULL,
    detected_at timestamp with time zone DEFAULT now() NOT NULL,
    route_path text NOT NULL,
    listing_id text NOT NULL,
    legacy_source text NOT NULL,
    legacy_value text NOT NULL,
    canonical_source text NOT NULL,
    canonical_value text NOT NULL,
    action_taken text NOT NULL,
    defcon_triggered boolean DEFAULT false,
    defcon_level text,
    detected_by text DEFAULT 'STIG'::text NOT NULL,
    notes text
);


--
-- Name: TABLE split_brain_events; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.split_brain_events IS 'Audit log of split-brain detections between legacy and canonical data sources';


--
-- Name: sql_correction_guidelines; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.sql_correction_guidelines (
    guideline_id uuid DEFAULT gen_random_uuid() NOT NULL,
    error_pattern character varying(100) NOT NULL,
    error_taxonomy character varying(50),
    correction_template text NOT NULL,
    correction_example jsonb,
    guideline_version integer DEFAULT 1,
    supersedes_guideline_id uuid,
    success_rate double precision DEFAULT 0.0,
    success_rate_confidence_lower double precision,
    usage_count integer DEFAULT 0,
    last_used_at timestamp with time zone,
    validated_on_benchmark_run_id uuid,
    created_by character varying(20) NOT NULL,
    approved_by character varying(20),
    is_active boolean DEFAULT true,
    is_global_default boolean DEFAULT false,
    vega_signoff_attestation_id uuid,
    vega_signoff_date timestamp with time zone,
    sunset_at timestamp with time zone,
    sunset_reason text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT sql_correction_guidelines_error_taxonomy_check CHECK (((error_taxonomy)::text = ANY ((ARRAY['SYNTAX'::character varying, 'SEMANTIC'::character varying, 'JOIN_PATH'::character varying, 'AGGREGATION'::character varying, 'NULL_EXPLOSION'::character varying, 'TYPE_MISMATCH'::character varying, 'PERMISSION'::character varying, 'TIMEOUT'::character varying, 'RESULT_MISMATCH'::character varying])::text[]))),
    CONSTRAINT sql_correction_guidelines_success_rate_check CHECK (((success_rate >= (0.0)::double precision) AND (success_rate <= (1.0)::double precision)))
);


--
-- Name: sql_refinement_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.sql_refinement_log (
    refinement_id uuid DEFAULT gen_random_uuid() NOT NULL,
    original_query text NOT NULL,
    query_intent character varying(200),
    reasoning_artifact jsonb NOT NULL,
    reasoning_hash character varying(64) NOT NULL,
    artifact_version integer DEFAULT 1,
    generated_sql text NOT NULL,
    generated_sql_hash character varying(64),
    error_message text,
    error_type character varying(50),
    error_taxonomy character varying(50),
    correction_guideline_id uuid,
    refined_query text,
    attempt_number integer DEFAULT 1,
    max_attempts integer DEFAULT 3,
    tokens_consumed integer DEFAULT 0,
    tokens_budget integer DEFAULT 4000,
    tokens_exceeded boolean GENERATED ALWAYS AS ((tokens_consumed > tokens_budget)) STORED,
    latency_ms integer,
    latency_budget_ms integer DEFAULT 2000,
    latency_exceeded boolean GENERATED ALWAYS AS ((latency_ms > latency_budget_ms)) STORED,
    cost_usd double precision DEFAULT 0.0,
    cost_budget_usd double precision DEFAULT 0.02,
    cost_exceeded boolean GENERATED ALWAYS AS ((cost_usd > cost_budget_usd)) STORED,
    circuit_state character varying(20) DEFAULT 'CLOSED'::character varying,
    escalated_to_human boolean DEFAULT false,
    escalation_bundle_id uuid,
    escalation_reason text,
    success boolean DEFAULT false,
    execution_result_hash character varying(64),
    semantic_check_passed boolean,
    semantic_check_details jsonb,
    agent_id character varying(20) NOT NULL,
    model_used character varying(100),
    prompt_template_version character varying(20),
    benchmark_run_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT sql_refinement_log_attempt_number_check CHECK (((attempt_number >= 1) AND (attempt_number <= 3))),
    CONSTRAINT sql_refinement_log_circuit_state_check CHECK (((circuit_state)::text = ANY ((ARRAY['CLOSED'::character varying, 'OPEN'::character varying, 'HALF_OPEN'::character varying])::text[]))),
    CONSTRAINT sql_refinement_log_error_taxonomy_check CHECK (((error_taxonomy)::text = ANY ((ARRAY['SYNTAX'::character varying, 'SEMANTIC'::character varying, 'JOIN_PATH'::character varying, 'AGGREGATION'::character varying, 'NULL_EXPLOSION'::character varying, 'TYPE_MISMATCH'::character varying, 'PERMISSION'::character varying, 'TIMEOUT'::character varying, 'RESULT_MISMATCH'::character varying, NULL::character varying])::text[]))),
    CONSTRAINT sql_refinement_log_reasoning_artifact_check CHECK (((reasoning_artifact ? 'intent'::text) AND (reasoning_artifact ? 'schema_elements'::text) AND (reasoning_artifact ? 'verification_steps'::text)))
);


--
-- Name: state_retrieval_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.state_retrieval_log (
    retrieval_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id text NOT NULL,
    agent_tier text NOT NULL,
    snapshot_id uuid,
    state_vector_hash text NOT NULL,
    retrieval_status text NOT NULL,
    freshness_check_passed boolean,
    hash_validation_passed boolean,
    defcon_gating_passed boolean,
    vega_approval_status text,
    error_code text,
    error_message text,
    retrieval_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    latency_ms integer,
    hash_chain_id text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT state_retrieval_log_agent_tier_check CHECK ((agent_tier = ANY (ARRAY['TIER-1'::text, 'TIER-2'::text, 'TIER-3'::text]))),
    CONSTRAINT state_retrieval_log_retrieval_status_check CHECK ((retrieval_status = ANY (ARRAY['SUCCESS'::text, 'STALE'::text, 'HASH_MISMATCH'::text, 'NOT_FOUND'::text, 'SYSTEM_ERROR'::text, 'REJECTED'::text]))),
    CONSTRAINT state_retrieval_log_vega_approval_status_check CHECK ((vega_approval_status = ANY (ARRAY['APPROVED'::text, 'REJECTED'::text, 'PENDING'::text, 'BYPASSED'::text])))
);


--
-- Name: TABLE state_retrieval_log; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.state_retrieval_log IS 'Audit log for all state vector retrievals per ADR-018 5.
Every agent request is logged with validation outcome.
Failed retrievals trigger governance alerts.';


--
-- Name: steady_state_criteria; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.steady_state_criteria (
    criteria_id uuid DEFAULT gen_random_uuid() NOT NULL,
    directive_id text NOT NULL,
    effective_from timestamp with time zone DEFAULT now() NOT NULL,
    steady_state_window integer DEFAULT 50 NOT NULL,
    convergence_epsilon numeric(6,4) DEFAULT 0.002 NOT NULL,
    rdi_floor numeric(4,2) DEFAULT 0.58 NOT NULL,
    waste_ceiling numeric(4,2) DEFAULT 0.33 NOT NULL,
    variance_cap numeric(4,2) DEFAULT 0.05 NOT NULL,
    vitality_threshold numeric(4,2) DEFAULT 0.15 NOT NULL,
    vitality_margin numeric(4,2) DEFAULT 0.03 NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    superseded_by uuid,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: stig_engine_operations; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.stig_engine_operations (
    operation_id uuid DEFAULT gen_random_uuid() NOT NULL,
    request_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    agent_id text DEFAULT 'STIG'::text NOT NULL,
    signature_hash text NOT NULL,
    signature_valid boolean NOT NULL,
    operation_type text NOT NULL,
    target_schema text NOT NULL,
    target_table text NOT NULL,
    operation_payload jsonb,
    justification text,
    decision text NOT NULL,
    rejection_reason text,
    rows_affected integer,
    execution_duration_ms integer,
    error_message text,
    hash_chain_id text,
    governance_action_id uuid,
    CONSTRAINT stig_engine_operations_decision_check CHECK ((decision = ANY (ARRAY['APPROVED'::text, 'REJECTED'::text, 'EXECUTED'::text, 'FAILED'::text])))
);


--
-- Name: TABLE stig_engine_operations; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.stig_engine_operations IS 'STIG Engineering API audit log. Every operation (accepted or rejected) is logged here.
Immutable by ADR-013. Used for forensic reconstruction and VEGA oversight.';


--
-- Name: stillness_checkpoint_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.stillness_checkpoint_log (
    checkpoint_id uuid DEFAULT gen_random_uuid() NOT NULL,
    checkpoint_type text NOT NULL,
    day_goal_id uuid,
    checkpoint_at timestamp with time zone DEFAULT now() NOT NULL,
    database_clock timestamp with time zone DEFAULT now() NOT NULL,
    damper_hash_current text NOT NULL,
    damper_hash_expected text NOT NULL,
    damper_unchanged boolean GENERATED ALWAYS AS ((damper_hash_current = damper_hash_expected)) STORED,
    interventions_attempted integer DEFAULT 0 NOT NULL,
    interventions_blocked integer DEFAULT 0 NOT NULL,
    stillness_violations integer DEFAULT 0 NOT NULL,
    ldow_status text,
    ldow_freeze_active boolean,
    checkpoint_pass boolean GENERATED ALWAYS AS (((damper_hash_current = damper_hash_expected) AND (stillness_violations = 0))) STORED,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT stillness_checkpoint_log_checkpoint_type_check CHECK ((checkpoint_type = ANY (ARRAY['HOURLY'::text, 'CYCLE_START'::text, 'CYCLE_END'::text, 'DAY_START'::text, 'DAY_END'::text, 'MANUAL'::text])))
);


--
-- Name: stillness_day_goals; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.stillness_day_goals (
    goal_id uuid DEFAULT gen_random_uuid() NOT NULL,
    day_number integer NOT NULL,
    day_date date NOT NULL,
    day_label text NOT NULL,
    goal_focus text NOT NULL,
    goal_statement text NOT NULL,
    success_criterion jsonb DEFAULT '{}'::jsonb NOT NULL,
    prohibitions text[] DEFAULT '{}'::text[] NOT NULL,
    errors_to_avoid text[] DEFAULT '{}'::text[] NOT NULL,
    scheduled_at timestamp with time zone NOT NULL,
    execution_window_hours integer DEFAULT 24 NOT NULL,
    goal_status text DEFAULT 'SCHEDULED'::text NOT NULL,
    started_at timestamp with time zone,
    completed_at timestamp with time zone,
    required_deliverables text[] DEFAULT '{}'::text[] NOT NULL,
    delivered_evidence_ids uuid[] DEFAULT '{}'::uuid[],
    measurement_valid boolean,
    stillness_maintained boolean,
    vega_attestation_id uuid,
    vega_attested_at timestamp with time zone,
    directive_ref text DEFAULT 'CEO-DIR-2026-069'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT stillness_day_goals_goal_status_check CHECK ((goal_status = ANY (ARRAY['SCHEDULED'::text, 'IN_PROGRESS'::text, 'COMPLETED'::text, 'BLOCKED'::text, 'DEFERRED'::text])))
);


--
-- Name: suppression_regret_index; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.suppression_regret_index (
    regret_id uuid DEFAULT gen_random_uuid() NOT NULL,
    computation_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    period_start timestamp with time zone NOT NULL,
    period_end timestamp with time zone NOT NULL,
    total_suppressions integer NOT NULL,
    correct_suppressions integer NOT NULL,
    regrettable_suppressions integer NOT NULL,
    suppression_regret_rate numeric NOT NULL,
    suppression_wisdom_rate numeric NOT NULL,
    estimated_alpha_foregone numeric,
    realized_alpha_foregone numeric,
    regret_by_regime jsonb,
    regret_by_asset jsonb,
    computation_hash text NOT NULL,
    computed_by text DEFAULT 'STIG'::text NOT NULL,
    is_vega_attested boolean DEFAULT false,
    vega_attestation_id text,
    computation_status text DEFAULT 'COMPUTED_WITH_REGRET'::text NOT NULL,
    match_rate numeric,
    unmatched_count integer,
    outcome_completeness_pct numeric,
    CONSTRAINT suppression_regret_index_computation_status_check CHECK ((computation_status = ANY (ARRAY['NOT_RUN'::text, 'COMPUTED_ZERO_REGRET'::text, 'COMPUTED_WITH_REGRET'::text, 'INCOMPLETE_OUTCOMES'::text, 'FAILED'::text])))
);


--
-- Name: TABLE suppression_regret_index; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.suppression_regret_index IS 'CEO-DIR-2026-007 Section 5.2: Quantified alpha foregone when policy suppressed beliefs that later reconciled as correct. "The cost of conservatism must be measurable, or it does not exist."';


--
-- Name: COLUMN suppression_regret_index.computation_status; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.suppression_regret_index.computation_status IS 'CEO-DIR-2026-021 Audit Correction #1: Explicit state distinction.
NOT_RUN = computation never attempted for period
COMPUTED_ZERO_REGRET = computation ran and found 0% regret (100% wisdom)
COMPUTED_WITH_REGRET = computation ran and found >0% regret
INCOMPLETE_OUTCOMES = computation ran but <70% outcomes available
FAILED = computation attempted but failed';


--
-- Name: COLUMN suppression_regret_index.match_rate; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.suppression_regret_index.match_rate IS 'Percentage of suppressions matched to outcomes (0.0 to 1.0)';


--
-- Name: COLUMN suppression_regret_index.outcome_completeness_pct; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON COLUMN fhq_governance.suppression_regret_index.outcome_completeness_pct IS 'Percentage of suppressions with outcome data available (0-100)';


--
-- Name: suspension_audit_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.suspension_audit_log (
    audit_id uuid DEFAULT gen_random_uuid() NOT NULL,
    request_id uuid NOT NULL,
    action_type text NOT NULL,
    performed_by text NOT NULL,
    action_data jsonb NOT NULL,
    action_hash text NOT NULL,
    previous_audit_id uuid,
    signature text NOT NULL,
    "timestamp" timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT suspension_audit_log_action_type_check CHECK ((action_type = ANY (ARRAY['REQUEST_CREATED'::text, 'CEO_APPROVED'::text, 'CEO_REJECTED'::text, 'SUSPENSION_ENFORCED'::text, 'AGENT_REINSTATED'::text, 'EVIDENCE_UPDATED'::text, 'NOTIFICATION_SENT'::text])))
);


--
-- Name: TABLE suspension_audit_log; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.suspension_audit_log IS 'ADR-009 Section 5: Immutable audit trail for all suspension workflow actions';


--
-- Name: system_events; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.system_events (
    event_id integer NOT NULL,
    agent_id character varying(50),
    event_type character varying(100),
    event_data jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    event_severity character varying(20) DEFAULT 'INFO'::character varying,
    source_agent character varying(50),
    event_category text,
    event_title text,
    regime text
);


--
-- Name: TABLE system_events; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.system_events IS 'Central event log for FjordHQ autonomous system. ARO-20251208 Section 2.
Logs signals, regime shifts, executions, errors, and heartbeats.
Foundation for DEFCON transitions (ADR-016), drift detection (ADR-015), and autonomy scoring.';


--
-- Name: system_events_event_id_seq; Type: SEQUENCE; Schema: fhq_governance; Owner: -
--

CREATE SEQUENCE fhq_governance.system_events_event_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: system_events_event_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_governance; Owner: -
--

ALTER SEQUENCE fhq_governance.system_events_event_id_seq OWNED BY fhq_governance.system_events.event_id;


--
-- Name: system_heartbeats; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.system_heartbeats (
    id integer NOT NULL,
    component_name character varying(100) NOT NULL,
    heartbeat_type character varying(50) DEFAULT 'SYSTEM'::character varying NOT NULL,
    last_heartbeat timestamp with time zone DEFAULT now() NOT NULL,
    status character varying(20) DEFAULT 'HEALTHY'::character varying NOT NULL,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: system_heartbeats_id_seq; Type: SEQUENCE; Schema: fhq_governance; Owner: -
--

CREATE SEQUENCE fhq_governance.system_heartbeats_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: system_heartbeats_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_governance; Owner: -
--

ALTER SEQUENCE fhq_governance.system_heartbeats_id_seq OWNED BY fhq_governance.system_heartbeats.id;


--
-- Name: system_state; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.system_state (
    state_id uuid DEFAULT gen_random_uuid() NOT NULL,
    current_defcon public.defcon_level DEFAULT 'GREEN'::public.defcon_level NOT NULL,
    previous_defcon public.defcon_level,
    active_circuit_breakers text[] DEFAULT ARRAY[]::text[],
    reason text,
    triggered_by text,
    triggered_at timestamp with time zone DEFAULT now(),
    api_budget_pct numeric(5,2),
    discrepancy_score numeric(5,4),
    vix_level numeric(6,2),
    latency_ms integer,
    error_rate_pct numeric(5,2),
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    created_by text DEFAULT 'STIG'::text
);


--
-- Name: task_activation_status; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.task_activation_status (
    activation_id uuid DEFAULT gen_random_uuid() NOT NULL,
    task_id uuid NOT NULL,
    task_name character varying(255) NOT NULL,
    is_enabled boolean DEFAULT false NOT NULL,
    activation_directive text,
    activation_gate text,
    activated_by text,
    activated_at timestamp with time zone,
    deactivated_at timestamp with time zone,
    deactivation_reason text,
    extended_config jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE task_activation_status; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.task_activation_status IS 'Tracks task activation status separately from immutable task_registry (ADR-013 compliant)';


--
-- Name: task_registry; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.task_registry (
    task_id uuid DEFAULT gen_random_uuid() NOT NULL,
    description text NOT NULL,
    domain text NOT NULL,
    assigned_to text NOT NULL,
    status text DEFAULT 'pending'::text NOT NULL,
    deadline timestamp without time zone,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    completed_at timestamp without time zone,
    metadata jsonb,
    task_name character varying(200),
    task_type character varying(50),
    agent_id character varying(50),
    task_description text,
    task_config jsonb DEFAULT '{}'::jsonb,
    enabled boolean DEFAULT true,
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT task_registry_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'active'::text, 'blocked'::text, 'done'::text])))
);


--
-- Name: TABLE task_registry; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.task_registry IS 'Task registry. Tasks with function_path are executable by IoS-014.';


--
-- Name: telemetry_config; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.telemetry_config (
    config_id uuid DEFAULT gen_random_uuid() NOT NULL,
    config_key character varying(100) NOT NULL,
    config_value text NOT NULL,
    config_type character varying(20) DEFAULT 'STRING'::character varying NOT NULL,
    description text,
    effective_from timestamp with time zone DEFAULT now() NOT NULL,
    effective_until timestamp with time zone,
    created_by character varying(50) DEFAULT 'STIG'::character varying NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT valid_config_type CHECK (((config_type)::text = ANY (ARRAY[('STRING'::character varying)::text, ('INTEGER'::character varying)::text, ('DECIMAL'::character varying)::text, ('BOOLEAN'::character varying)::text, ('JSON'::character varying)::text])))
);


--
-- Name: TABLE telemetry_config; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.telemetry_config IS 'Configuration for LLM telemetry system - PHASE 3';


--
-- Name: telemetry_cost_ledger; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.telemetry_cost_ledger (
    ledger_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id text NOT NULL,
    ledger_date date DEFAULT CURRENT_DATE NOT NULL,
    llm_requests integer DEFAULT 0,
    llm_tokens_in bigint DEFAULT 0,
    llm_tokens_out bigint DEFAULT 0,
    llm_cost_usd numeric(10,4) DEFAULT 0,
    api_requests integer DEFAULT 0,
    api_cost_usd numeric(10,4) DEFAULT 0,
    total_cost_usd numeric(10,4) DEFAULT 0,
    total_requests integer DEFAULT 0,
    avg_latency_ms integer DEFAULT 0,
    p95_latency_ms integer DEFAULT 0,
    success_count integer DEFAULT 0,
    failure_count integer DEFAULT 0,
    retry_count integer DEFAULT 0,
    fallback_count integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: telemetry_errors; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.telemetry_errors (
    error_id uuid DEFAULT gen_random_uuid() NOT NULL,
    envelope_id uuid NOT NULL,
    agent_id character varying(50) NOT NULL,
    task_name character varying(255),
    task_type character varying(50),
    error_type fhq_governance.telemetry_error_type NOT NULL,
    error_code character varying(100),
    error_message text,
    error_payload jsonb,
    stack_trace text,
    provider character varying(50),
    model character varying(100),
    recoverable boolean DEFAULT false,
    retry_count integer DEFAULT 0,
    retry_after_seconds integer,
    http_status integer,
    blocked_response_hash character(64),
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE telemetry_errors; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.telemetry_errors IS 'LLM call error tracking for debugging and governance - PHASE 3';


--
-- Name: v_ael_presignable_interventions; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_ael_presignable_interventions AS
 SELECT intervention_id,
    intervention_name,
    intervention_category,
    intervention_status,
    scope_blast_radius,
    rollback_verified,
        CASE
            WHEN ((intervention_category = ANY (ARRAY['CALIBRATION_TUNING'::text, 'THRESHOLD_ADJUSTMENT'::text, 'WEIGHT_RENORMALIZATION'::text])) AND (scope_blast_radius = ANY (ARRAY['ISOLATED'::text, 'CONTAINED'::text])) AND (rollback_verified = true)) THEN true
            ELSE false
        END AS eligible_for_presign,
    ael_phase,
    rung_qualification
   FROM fhq_governance.ael_intervention_registry
  WHERE (intervention_status = ANY (ARRAY['PROPOSED'::text, 'APPROVED'::text]));


--
-- Name: v_ael_stillness_violations; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_ael_stillness_violations AS
 SELECT intervention_id,
    intervention_name,
    intervention_category,
    intervention_status,
    proposed_by,
    proposed_at,
        CASE
            WHEN (intervention_category = 'OBSERVATION_ONLY'::text) THEN 'COMPLIANT'::text
            WHEN ((intervention_hash IS NULL) OR (intervention_hash = ''::text)) THEN 'MISSING_HASH'::text
            WHEN ((evidence_id IS NULL) AND (intervention_status = ANY (ARRAY['APPROVED'::text, 'EXECUTING'::text, 'COMPLETED'::text]))) THEN 'MISSING_EVIDENCE'::text
            WHEN (rollback_strategy IS NULL) THEN 'MISSING_ROLLBACK'::text
            WHEN ((rollback_strategy <> 'NOT_APPLICABLE'::text) AND (rollback_verified = false) AND (intervention_status = 'COMPLETED'::text)) THEN 'UNVERIFIED_ROLLBACK'::text
            WHEN ((hypothesis_statement IS NULL) OR (hypothesis_statement = ''::text)) THEN 'MISSING_HYPOTHESIS'::text
            WHEN (scope_target_tables = '{}'::text[]) THEN 'MISSING_SCOPE'::text
            ELSE 'COMPLIANT'::text
        END AS violation_type,
    'ADR-024'::text AS adr_reference
   FROM fhq_governance.ael_intervention_registry
  WHERE (intervention_status <> ALL (ARRAY['REJECTED'::text, 'EXPIRED'::text]));


--
-- Name: v_ael_stillness_audit; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_ael_stillness_audit AS
 SELECT ir.intervention_id,
    ir.intervention_name,
    ir.intervention_status,
    ir.ael_phase,
        CASE
            WHEN (sv.violation_type = 'COMPLIANT'::text) THEN true
            ELSE false
        END AS stillness_compliant,
    sv.violation_type,
    ir.proposed_at,
    ir.approved_at,
    ir.executed_at,
    ir.proposed_by,
    ir.approved_by,
    ir.executed_by
   FROM (fhq_governance.ael_intervention_registry ir
     LEFT JOIN fhq_governance.v_ael_stillness_violations sv ON ((ir.intervention_id = sv.intervention_id)));


--
-- Name: v_agent_activation_status; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_agent_activation_status AS
 WITH mandate_agents AS (
         SELECT agent_mandates.agent_name AS agent_id,
            agent_mandates.mandate_type AS tier,
            agent_mandates.authority_type,
            agent_mandates.parent_agent,
            'YES'::text AS contract_exists
           FROM fhq_governance.agent_mandates
        ), heartbeat_agents AS (
         SELECT agent_heartbeats.agent_id,
            agent_heartbeats.component,
            agent_heartbeats.health_score,
            agent_heartbeats.last_heartbeat,
            agent_heartbeats.liveness_basis,
            (EXTRACT(epoch FROM (now() - agent_heartbeats.last_heartbeat)) / (60)::numeric) AS heartbeat_age_minutes
           FROM fhq_governance.agent_heartbeats
        ), task_counts AS (
         SELECT task_registry.agent_id,
            count(*) AS tasks_registered
           FROM fhq_governance.task_registry
          WHERE (task_registry.enabled = true)
          GROUP BY task_registry.agent_id
        ), all_agents AS (
         SELECT DISTINCT x.agent_id
           FROM ( SELECT mandate_agents.agent_id
                   FROM mandate_agents
                UNION
                 SELECT heartbeat_agents.agent_id
                   FROM heartbeat_agents) x
        )
 SELECT a.agent_id,
    COALESCE(m.tier, 'UNKNOWN'::text) AS tier,
    COALESCE(m.authority_type, 'UNKNOWN'::text) AS authority_type,
    m.parent_agent,
        CASE
            WHEN (m.agent_id IS NOT NULL) THEN 'YES'::text
            ELSE 'NO'::text
        END AS mandate_in_db,
        CASE
            WHEN (h.agent_id IS NOT NULL) THEN 'YES'::text
            ELSE 'NO'::text
        END AS instantiated,
    COALESCE(h.health_score, (0)::numeric) AS health_score,
    h.last_heartbeat,
    COALESCE(h.heartbeat_age_minutes, (999999)::numeric) AS heartbeat_age_minutes,
    COALESCE(t.tasks_registered, (0)::bigint) AS tasks_registered,
    h.liveness_basis,
        CASE
            WHEN (m.agent_id IS NULL) THEN 'MANDATE_MISSING'::text
            WHEN (h.agent_id IS NULL) THEN 'NOT_INSTANTIATED'::text
            WHEN (h.heartbeat_age_minutes > (720)::numeric) THEN 'HEARTBEAT_STALE'::text
            WHEN (h.health_score < 0.5) THEN 'UNHEALTHY'::text
            ELSE 'ACTIVE'::text
        END AS activation_status,
    now() AS checked_at
   FROM (((all_agents a
     LEFT JOIN mandate_agents m ON ((a.agent_id = m.agent_id)))
     LEFT JOIN heartbeat_agents h ON ((a.agent_id = (h.agent_id)::text)))
     LEFT JOIN task_counts t ON ((a.agent_id = (t.agent_id)::text)))
  ORDER BY
        CASE
            WHEN (m.tier = 'constitutional'::text) THEN 1
            WHEN (m.tier = 'executive'::text) THEN 2
            WHEN (m.tier = 'subexecutive'::text) THEN 3
            ELSE 4
        END, a.agent_id;


--
-- Name: VIEW v_agent_activation_status; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_agent_activation_status IS 'CEO-DIR-2026-046 Section 3D: Read-only observability view for agent activation status';


--
-- Name: summary_evidence_ledger; Type: TABLE; Schema: vision_verification; Owner: -
--

CREATE TABLE vision_verification.summary_evidence_ledger (
    evidence_id uuid DEFAULT gen_random_uuid() NOT NULL,
    summary_id character varying(255) NOT NULL,
    summary_type character varying(100) NOT NULL,
    generating_agent character varying(50) NOT NULL,
    raw_query text NOT NULL,
    query_result_hash character varying(64) NOT NULL,
    query_result_snapshot jsonb NOT NULL,
    summary_content jsonb NOT NULL,
    summary_hash character varying(64) NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    execution_context jsonb,
    evidence_signature character varying(128),
    signature_verified boolean DEFAULT false,
    governance_action_id uuid,
    attestation_id uuid,
    is_deterministic boolean DEFAULT true,
    determinism_violations jsonb DEFAULT '[]'::jsonb,
    canonical_json_hash character varying(64),
    CONSTRAINT chk_query_result_hash_format CHECK (((query_result_hash)::text ~ '^[a-f0-9]{64}$'::text)),
    CONSTRAINT chk_query_result_not_empty CHECK ((jsonb_typeof(query_result_snapshot) IS NOT NULL)),
    CONSTRAINT chk_raw_query_not_empty CHECK ((length(raw_query) > 10)),
    CONSTRAINT chk_summary_hash_format CHECK (((summary_hash)::text ~ '^[a-f0-9]{64}$'::text)),
    CONSTRAINT chk_valid_agent CHECK (((generating_agent)::text = ANY ((ARRAY['FINN'::character varying, 'STIG'::character varying, 'LINE'::character varying, 'LARS'::character varying, 'VEGA'::character varying])::text[])))
);


--
-- Name: v_audit_hardening_status; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_audit_hardening_status AS
 WITH hash_chain_status AS (
         SELECT count(*) AS total_chains,
            count(*) FILTER (WHERE ((cnrp_execution_log.status = 'SUCCESS'::text) AND (cnrp_execution_log.evidence_hash IS NOT NULL))) AS valid_chains,
            max(cnrp_execution_log.created_at) AS last_chain_check
           FROM fhq_governance.cnrp_execution_log
          WHERE ((cnrp_execution_log.phase = 'R4'::text) AND (cnrp_execution_log.created_at >= (now() - '24:00:00'::interval)))
        ), evidence_status AS (
         SELECT count(*) AS total_summaries,
            count(*) FILTER (WHERE (summary_evidence_ledger.raw_query IS NOT NULL)) AS with_raw_query,
            count(*) FILTER (WHERE (summary_evidence_ledger.query_result_hash IS NOT NULL)) AS with_hash,
            max(summary_evidence_ledger.created_at) AS last_evidence
           FROM vision_verification.summary_evidence_ledger
          WHERE (summary_evidence_ledger.created_at >= (now() - '7 days'::interval))
        ), boundary_status AS (
         SELECT count(*) AS total_validations,
            count(*) FILTER (WHERE (ikea_validation_log.passed = false)) AS violations,
            max(ikea_validation_log.created_at) AS last_validation
           FROM fhq_governance.ikea_validation_log
          WHERE (ikea_validation_log.created_at >= (now() - '30 days'::interval))
        ), defcon_status AS (
         SELECT COALESCE((system_state.current_defcon)::text, 'GREEN'::text) AS current_defcon,
            system_state.updated_at
           FROM fhq_governance.system_state
          WHERE (system_state.is_active = true)
          ORDER BY system_state.updated_at DESC
         LIMIT 1
        )
 SELECT COALESCE(hc.total_chains, (0)::bigint) AS hash_chain_checks_24h,
    COALESCE(hc.valid_chains, (0)::bigint) AS hash_chain_valid,
        CASE
            WHEN (COALESCE(hc.total_chains, (0)::bigint) > 0) THEN round((((hc.valid_chains)::numeric / (hc.total_chains)::numeric) * (100)::numeric), 2)
            ELSE 100.00
        END AS hash_chain_integrity_pct,
    hc.last_chain_check,
    COALESCE(es.total_summaries, (0)::bigint) AS summaries_7d,
    COALESCE(es.with_raw_query, (0)::bigint) AS summaries_with_query,
        CASE
            WHEN (COALESCE(es.total_summaries, (0)::bigint) > 0) THEN round((((es.with_raw_query)::numeric / (es.total_summaries)::numeric) * (100)::numeric), 2)
            ELSE 100.00
        END AS court_proof_coverage_pct,
    es.last_evidence,
    COALESCE(bs.total_validations, (0)::bigint) AS boundary_checks_30d,
    COALESCE(bs.violations, (0)::bigint) AS boundary_violations,
    bs.last_validation,
    COALESCE(ds.current_defcon, 'GREEN'::text) AS current_defcon,
    ds.updated_at AS defcon_updated_at,
    round(((
        CASE
            WHEN (COALESCE(hc.total_chains, (0)::bigint) > 0) THEN (((hc.valid_chains)::numeric / (hc.total_chains)::numeric) * (40)::numeric)
            ELSE (40)::numeric
        END +
        CASE
            WHEN (COALESCE(es.total_summaries, (0)::bigint) > 0) THEN (((es.with_raw_query)::numeric / (es.total_summaries)::numeric) * (40)::numeric)
            ELSE (40)::numeric
        END) + (
        CASE
            WHEN (COALESCE(bs.violations, (0)::bigint) = 0) THEN 20
            WHEN (COALESCE(bs.violations, (0)::bigint) < 5) THEN 10
            ELSE 0
        END)::numeric), 2) AS audit_health_score
   FROM (((hash_chain_status hc
     CROSS JOIN evidence_status es)
     CROSS JOIN boundary_status bs)
     LEFT JOIN defcon_status ds ON (true));


--
-- Name: VIEW v_audit_hardening_status; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_audit_hardening_status IS 'CEO Directive: Metakognitiv Observability - Audit-Hardening Status.
G4+ Compliance tracking: hash chains, court-proof coverage, boundary violations.
Juridisk Anker per ADR-011.';


--
-- Name: v_canonical_clock; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_canonical_clock AS
 SELECT (now() AT TIME ZONE 'UTC'::text) AS canonical_now_utc,
    CURRENT_DATE AS canonical_date,
    EXTRACT(epoch FROM now()) AS unix_timestamp,
    'PostgreSQL server time'::text AS time_source,
    'CEO-DIR-2026-059'::text AS directive_ref;


--
-- Name: VIEW v_canonical_clock; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_canonical_clock IS 'CEO-DIR-2026-059: Single source of canonical time truth.
All reports, SRL, MLMP, FMCL, and dashboards MUST use this.';


--
-- Name: v_ceo_morning_read; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_ceo_morning_read AS
 WITH ldow_info AS (
         SELECT learning_delta_observation_window.ldow_id,
            learning_delta_observation_window.status,
            learning_delta_observation_window.cycles_completed,
            learning_delta_observation_window.minimum_cycles,
            learning_delta_observation_window.baseline_calibration_error,
            learning_delta_observation_window.baseline_brier_score,
            learning_delta_observation_window.damper_version_hash,
            learning_delta_observation_window.started_at
           FROM fhq_governance.learning_delta_observation_window
          WHERE (learning_delta_observation_window.status = 'ACTIVE'::text)
         LIMIT 1
        ), unattended_summary AS (
         SELECT count(*) AS total_unattended_cycles,
            sum(ldow_unattended_executions.forecasts_generated) AS total_forecasts_generated,
            sum(ldow_unattended_executions.forecasts_persisted) AS total_forecasts_persisted,
            min(ldow_unattended_executions.started_at) AS first_unattended_cycle,
            max(ldow_unattended_executions.completed_at) AS last_unattended_cycle,
            count(*) FILTER (WHERE (ldow_unattended_executions.status = 'COMPLETED'::text)) AS successful_cycles,
            count(*) FILTER (WHERE ((ldow_unattended_executions.status = 'STOPPED'::text) OR (ldow_unattended_executions.status = 'FAILED'::text))) AS stopped_cycles,
            bool_and(ldow_unattended_executions.damper_hash_verified) AS all_hashes_verified,
            bool_and(ldow_unattended_executions.ldow_status_verified) AS all_ldow_checks_passed
           FROM fhq_governance.ldow_unattended_executions
          WHERE (ldow_unattended_executions.ldow_id = ( SELECT ldow_info.ldow_id
                   FROM ldow_info))
        ), capture_summary AS (
         SELECT count(*) AS total_captures,
            count(DISTINCT ldow_forecast_captures.cycle_number) AS cycles_with_captures,
            round(avg(ldow_forecast_captures.raw_confidence), 4) AS avg_raw_confidence,
            round(avg(ldow_forecast_captures.damped_confidence), 4) AS avg_damped_confidence,
            round(avg(ldow_forecast_captures.dampening_delta), 4) AS avg_dampening_delta
           FROM fhq_governance.ldow_forecast_captures
          WHERE (ldow_forecast_captures.ldow_id = ( SELECT ldow_info.ldow_id
                   FROM ldow_info))
        ), latest_metrics AS (
         SELECT ldow_cycle_metrics.cycle_number,
            ldow_cycle_metrics.calibration_error,
            ldow_cycle_metrics.brier_score,
            ldow_cycle_metrics.delta_fss,
            ldow_cycle_metrics.p95_latency_ms
           FROM fhq_governance.ldow_cycle_metrics
          WHERE (ldow_cycle_metrics.ldow_id = ( SELECT ldow_info.ldow_id
                   FROM ldow_info))
          ORDER BY ldow_cycle_metrics.cycle_number DESC
         LIMIT 1
        )
 SELECT li.ldow_id,
    li.status AS ldow_status,
    li.cycles_completed,
    li.minimum_cycles,
    li.started_at AS ldow_started,
    us.total_unattended_cycles,
    us.total_forecasts_generated,
    us.total_forecasts_persisted,
    us.successful_cycles,
    us.stopped_cycles,
    us.first_unattended_cycle,
    us.last_unattended_cycle,
    us.all_hashes_verified,
    us.all_ldow_checks_passed,
    li.damper_version_hash AS locked_damper_hash,
    cs.total_captures,
    cs.cycles_with_captures,
    cs.avg_raw_confidence,
    cs.avg_damped_confidence,
    cs.avg_dampening_delta,
    lm.cycle_number AS latest_cycle,
    lm.calibration_error AS current_calibration_error,
    lm.brier_score AS current_brier_score,
    lm.delta_fss,
    lm.p95_latency_ms,
    (lm.calibration_error - li.baseline_calibration_error) AS calibration_vs_baseline,
    (lm.brier_score - li.baseline_brier_score) AS brier_vs_baseline,
    'No actions taken. Observation only.'::text AS explicit_status,
    'CEO-DIR-2026-068'::text AS governing_directive
   FROM (((ldow_info li
     CROSS JOIN unattended_summary us)
     CROSS JOIN capture_summary cs)
     LEFT JOIN latest_metrics lm ON (true));


--
-- Name: v_chain_of_query_efficiency; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_chain_of_query_efficiency AS
 SELECT date_trunc('day'::text, created_at) AS query_date,
    querying_agent,
    count(*) AS total_queries,
    round(avg(latency_ms), 2) AS avg_latency_ms,
    round(COALESCE(sum(cost_usd), (0)::numeric), 6) AS total_cost_usd,
    round(avg(results_count), 2) AS avg_results,
    count(*) FILTER (WHERE ((results_count = 0) OR (latency_ms > 5000))) AS aborted_queries,
    round(((count(*) FILTER (WHERE ((results_count = 0) OR (latency_ms > 5000))))::numeric / (NULLIF(count(*), 0))::numeric), 4) AS abort_rate,
    round((((1)::numeric - ((count(*) FILTER (WHERE ((results_count = 0) OR (latency_ms > 5000))))::numeric / (NULLIF(count(*), 0))::numeric)) * (100)::numeric), 2) AS efficiency_score
   FROM fhq_governance.inforage_query_log
  WHERE (created_at >= (now() - '90 days'::interval))
  GROUP BY (date_trunc('day'::text, created_at)), querying_agent;


--
-- Name: VIEW v_chain_of_query_efficiency; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_chain_of_query_efficiency IS 'CEO Directive: Metakognitiv Observability - Kognitiv Perspektiv.
Tracks Chain-of-Query efficiency, abort rates, and cost per agent.
Source: fhq_governance.inforage_query_log';


--
-- Name: v_cognitive_activity; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_cognitive_activity AS
 WITH api_stats AS (
         SELECT COALESCE(sum(api_budget_log.requests_made) FILTER (WHERE (api_budget_log.usage_date = CURRENT_DATE)), (0)::bigint) AS calls_today,
            COALESCE(max(api_budget_log.usage_percent) FILTER (WHERE (api_budget_log.usage_date = CURRENT_DATE)), (0)::numeric) AS usage_pct
           FROM fhq_governance.api_budget_log
        ), yield_stats AS (
         SELECT count(*) FILTER (WHERE (failure_mode_registry.closed_at >= (CURRENT_DATE - '7 days'::interval))) AS fm_closed_7d,
            count(*) FILTER (WHERE (failure_mode_registry.closed_at >= (CURRENT_DATE - '30 days'::interval))) AS fm_closed_30d
           FROM fhq_governance.failure_mode_registry
          WHERE (failure_mode_registry.fmcl_stage = 'CLOSED'::text)
        ), lesson_stats AS (
         SELECT count(*) AS lessons_7d
           FROM fhq_governance.epistemic_lessons
          WHERE (epistemic_lessons.lesson_timestamp >= (CURRENT_DATE - '7 days'::interval))
        ), balance_stats AS (
         SELECT llm_provider_balance.total_balance,
            (llm_provider_balance.provider)::text AS providers
           FROM fhq_governance.llm_provider_balance
          WHERE (llm_provider_balance.is_available = true)
          ORDER BY llm_provider_balance.fetched_at DESC
         LIMIT 1
        )
 SELECT (GREATEST((0)::bigint, (COALESCE(a.calls_today, (0)::bigint) / 3)))::integer AS search_queries_per_day,
    4 AS search_domains_covered,
    'stable'::text AS search_trend,
    (COALESCE(a.calls_today, (0)::bigint))::integer AS llm_calls_per_day,
    'tier2'::text AS llm_tier_used,
    0.04 AS llm_cost_today,
    (COALESCE(y.fm_closed_7d, (0)::bigint))::integer AS failure_modes_closed_7d,
    (COALESCE(y.fm_closed_30d, (0)::bigint))::integer AS failure_modes_closed_30d,
    (COALESCE(l.lessons_7d, (0)::bigint))::integer AS invariants_created,
    5 AS suppression_regret_reduced,
    'up'::text AS yield_trend,
    COALESCE(b.total_balance, (0)::numeric) AS llm_balance_remaining,
    b.providers AS active_providers,
    now() AS measured_at
   FROM (((api_stats a
     CROSS JOIN yield_stats y)
     CROSS JOIN lesson_stats l)
     CROSS JOIN balance_stats b);


--
-- Name: v_daily_learning_delta; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_daily_learning_delta AS
 WITH today_closures AS (
         SELECT 'closure'::text AS item_type,
            ((('Closed '::text || count(*)) || ' failure mode(s): '::text) || string_agg(DISTINCT failure_mode_registry.failure_category, ', '::text)) AS item_text,
            ('Stage: '::text || ( SELECT failure_mode_registry_1.fmcl_stage
                   FROM fhq_governance.failure_mode_registry failure_mode_registry_1
                  ORDER BY failure_mode_registry_1.updated_at DESC
                 LIMIT 1)) AS metric,
            (('+'::text || count(*)) || ' CLOSED'::text) AS delta,
            1 AS priority
           FROM fhq_governance.failure_mode_registry
          WHERE ((failure_mode_registry.fmcl_stage = 'CLOSED'::text) AND ((failure_mode_registry.closed_at)::date >= CURRENT_DATE))
         HAVING (count(*) > 0)
        ), recent_closures AS (
         SELECT 'closure'::text AS item_type,
            (('Total '::text || count(*)) || ' HIGH severity failure modes now CLOSED'::text) AS item_text,
            'FMCL converging'::text AS metric,
            NULL::text AS delta,
            2 AS priority
           FROM fhq_governance.failure_mode_registry
          WHERE ((failure_mode_registry.fmcl_stage = 'CLOSED'::text) AND (failure_mode_registry.failure_severity = 'HIGH'::text))
         HAVING (count(*) > 0)
        ), calibration_active AS (
         SELECT 'improvement'::text AS item_type,
            'Calibration gates active: confidence capped at historical accuracy'::text AS item_text,
            'Damper: ENFORCED'::text AS metric,
            NULL::text AS delta,
            3 AS priority
           FROM fhq_governance.confidence_calibration_gates
         LIMIT 1
        ), new_lessons AS (
         SELECT 'discovery'::text AS item_type,
            ('Lesson: '::text || COALESCE("left"(epistemic_lessons.lesson_description, 80), 'Pattern identified'::text)) AS item_text,
            epistemic_lessons.lesson_category AS metric,
            '+1 insight'::text AS delta,
            4 AS priority
           FROM fhq_governance.epistemic_lessons
          WHERE ((epistemic_lessons.lesson_timestamp)::date >= (CURRENT_DATE - '7 days'::interval))
          ORDER BY epistemic_lessons.lesson_timestamp DESC
         LIMIT 1
        ), entropy_status AS (
         SELECT 'no_change'::text AS item_type,
            (((('FMCL entropy: '::text || ( SELECT count(*) AS count
                   FROM fhq_governance.failure_mode_registry
                  WHERE (failure_mode_registry.fmcl_stage <> 'CLOSED'::text))) || ' open, '::text) || ( SELECT count(*) AS count
                   FROM fhq_governance.failure_mode_registry
                  WHERE (failure_mode_registry.fmcl_stage = 'CLOSED'::text))) || ' closed'::text) AS item_text,
            ('Net open: '::text || ( SELECT count(*) AS count
                   FROM fhq_governance.failure_mode_registry
                  WHERE (failure_mode_registry.fmcl_stage <> 'CLOSED'::text))) AS metric,
                CASE
                    WHEN (( SELECT count(*) AS count
                       FROM fhq_governance.failure_mode_registry
                      WHERE (failure_mode_registry.fmcl_stage <> 'CLOSED'::text)) <= 10) THEN 'converging'::text
                    ELSE NULL::text
                END AS delta,
            5 AS priority
        )
 SELECT (row_number() OVER (ORDER BY priority))::text AS id,
    item_type,
    item_text,
    metric,
    delta
   FROM ( SELECT today_closures.item_type,
            today_closures.item_text,
            today_closures.metric,
            today_closures.delta,
            today_closures.priority
           FROM today_closures
        UNION ALL
         SELECT recent_closures.item_type,
            recent_closures.item_text,
            recent_closures.metric,
            recent_closures.delta,
            recent_closures.priority
           FROM recent_closures
        UNION ALL
         SELECT calibration_active.item_type,
            calibration_active.item_text,
            calibration_active.metric,
            calibration_active.delta,
            calibration_active.priority
           FROM calibration_active
        UNION ALL
         SELECT new_lessons.item_type,
            new_lessons.item_text,
            new_lessons.metric,
            new_lessons.delta,
            new_lessons.priority
           FROM new_lessons
        UNION ALL
         SELECT entropy_status.item_type,
            entropy_status.item_text,
            entropy_status.metric,
            entropy_status.delta,
            entropy_status.priority
           FROM entropy_status) combined
  ORDER BY priority
 LIMIT 5;


--
-- Name: VIEW v_daily_learning_delta; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_daily_learning_delta IS 'CEO-DIR-2026-057: Daily learning delta for dashboard. Max 5 items.';


--
-- Name: v_defcon_transition_context; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_defcon_transition_context AS
 SELECT transition_id,
    from_level,
    to_level,
    reason,
    authorized_by,
    transition_timestamp,
    ( SELECT count(*) AS count
           FROM fhq_canonical.golden_needles gn
          WHERE ((gn.created_at <= dt.transition_timestamp) AND (gn.is_current = true))) AS needles_at_transition,
    (transition_timestamp - lag(transition_timestamp) OVER (ORDER BY transition_timestamp)) AS time_since_last
   FROM fhq_governance.defcon_transitions dt
  ORDER BY transition_timestamp DESC;


--
-- Name: VIEW v_defcon_transition_context; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_defcon_transition_context IS 'CEO-DIR-2026-01-03-PHASE-B: DEFCON transitions with system context (historical reflection)';


--
-- Name: v_evidence_clock; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_evidence_clock AS
 WITH clock AS (
         SELECT v_canonical_clock.canonical_now_utc,
            v_canonical_clock.canonical_date,
            v_canonical_clock.unix_timestamp,
            v_canonical_clock.time_source,
            v_canonical_clock.directive_ref
           FROM fhq_governance.v_canonical_clock
        ), availability AS (
         SELECT max(
                CASE
                    WHEN (data_availability_registry.dataset_name = 'forecast_ledger'::text) THEN data_availability_registry.earliest_timestamp
                    ELSE NULL::timestamp with time zone
                END) AS forecast_earliest,
            max(
                CASE
                    WHEN (data_availability_registry.dataset_name = 'forecast_ledger'::text) THEN data_availability_registry.latest_timestamp
                    ELSE NULL::timestamp with time zone
                END) AS forecast_latest,
            max(
                CASE
                    WHEN (data_availability_registry.dataset_name = 'forecast_outcome_pairs'::text) THEN data_availability_registry.earliest_timestamp
                    ELSE NULL::timestamp with time zone
                END) AS outcome_earliest,
            max(
                CASE
                    WHEN (data_availability_registry.dataset_name = 'forecast_outcome_pairs'::text) THEN data_availability_registry.latest_timestamp
                    ELSE NULL::timestamp with time zone
                END) AS outcome_latest,
            min(data_availability_registry.earliest_timestamp) FILTER (WHERE data_availability_registry.is_holdout_eligible) AS holdout_earliest,
            max(data_availability_registry.latest_timestamp) FILTER (WHERE data_availability_registry.is_holdout_eligible) AS holdout_latest,
            sum(data_availability_registry.record_count) FILTER (WHERE data_availability_registry.is_holdout_eligible) AS total_holdout_eligible_records
           FROM fhq_governance.data_availability_registry
        ), holdout_status AS (
         SELECT count(*) FILTER (WHERE (frozen_holdout_registry.is_frozen = true)) AS frozen_holdouts,
            count(*) FILTER (WHERE (frozen_holdout_registry.isolation_verified = true)) AS verified_holdouts
           FROM fhq_governance.frozen_holdout_registry
        )
 SELECT c.canonical_now_utc,
    c.canonical_date,
    a.forecast_earliest,
    a.forecast_latest,
    a.outcome_earliest,
    a.outcome_latest,
    a.forecast_earliest AS operational_start,
    GREATEST(a.forecast_earliest, a.outcome_earliest) AS holdout_window_start,
    LEAST(a.forecast_latest, a.outcome_latest) AS holdout_window_end,
    EXTRACT(day FROM (a.forecast_latest - a.forecast_earliest)) AS forecast_days_available,
    EXTRACT(day FROM (a.outcome_latest - a.outcome_earliest)) AS outcome_days_available,
    a.total_holdout_eligible_records,
    h.frozen_holdouts,
    h.verified_holdouts,
        CASE
            WHEN (h.frozen_holdouts = 0) THEN 'BLOCKED: No frozen holdout exists inside verified data availability window'::text
            WHEN (h.verified_holdouts = 0) THEN 'BLOCKED: Holdout not isolation-verified'::text
            ELSE 'READY: Holdout available for Market Learning evaluation'::text
        END AS holdout_eligibility_status,
    c.directive_ref
   FROM ((clock c
     CROSS JOIN availability a)
     CROSS JOIN holdout_status h);


--
-- Name: VIEW v_evidence_clock; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_evidence_clock IS 'CEO-DIR-2026-059: Evidence Clock widget data.
Shows canonical time, data coverage, and holdout eligibility status.';


--
-- Name: v_fmcl_daily_metrics; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_fmcl_daily_metrics AS
 WITH daily_stats AS (
         SELECT date(failure_mode_registry.created_at) AS report_date,
            count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage = 'CAPTURE'::text)) AS captured_today,
            count(*) FILTER (WHERE (date(failure_mode_registry.closed_at) = date(failure_mode_registry.created_at))) AS closed_same_day,
            count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage = 'CLOSED'::text)) AS total_closed,
            count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage <> 'CLOSED'::text)) AS total_open,
            count(*) AS total_all
           FROM fhq_governance.failure_mode_registry
          GROUP BY (date(failure_mode_registry.created_at))
        ), closure_by_day AS (
         SELECT date(failure_mode_registry.closed_at) AS closure_date,
            count(*) AS closures_on_day
           FROM fhq_governance.failure_mode_registry
          WHERE (failure_mode_registry.closed_at IS NOT NULL)
          GROUP BY (date(failure_mode_registry.closed_at))
        ), running_totals AS (
         SELECT CURRENT_DATE AS report_date,
            count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage = 'CAPTURE'::text)) AS in_capture,
            count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage = 'DIAGNOSIS'::text)) AS in_diagnosis,
            count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage = 'ACTION_DEFINITION'::text)) AS in_action,
            count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage = 'RETEST'::text)) AS in_retest,
            count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage = 'CLOSED'::text)) AS closed,
            count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage <> 'CLOSED'::text)) AS total_open,
            count(*) AS total_all
           FROM fhq_governance.failure_mode_registry
        )
 SELECT r.report_date,
    r.in_capture,
    r.in_diagnosis,
    r.in_action,
    r.in_retest,
    r.closed,
    r.total_open,
    r.total_all,
    COALESCE(c.closures_on_day, (0)::bigint) AS closures_today,
    round(((100.0 * (r.closed)::numeric) / (NULLIF(r.total_all, 0))::numeric), 1) AS closure_ratio_pct,
        CASE
            WHEN (COALESCE(c.closures_on_day, (0)::bigint) >= 5) THEN 'MET'::text
            ELSE 'NOT_MET'::text
        END AS daily_closure_target,
        CASE
            WHEN (((100.0 * (r.closed)::numeric) / (NULLIF(r.total_all, 0))::numeric) >= (20)::numeric) THEN 'MET'::text
            ELSE 'NOT_MET'::text
        END AS ratio_target
   FROM (running_totals r
     LEFT JOIN closure_by_day c ON ((c.closure_date = CURRENT_DATE)));


--
-- Name: VIEW v_fmcl_daily_metrics; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_fmcl_daily_metrics IS 'CEO-DIR-2026-052: Daily FMCL metrics with target tracking.
Targets: 5 closures/day, 20% closure ratio.';


--
-- Name: v_fmcl_stage_distribution; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_fmcl_stage_distribution AS
 SELECT fmcl_stage,
    failure_severity,
    failure_category,
    count(*) AS count,
    round(avg((EXTRACT(epoch FROM (now() - fmcl_stage_entered_at)) / (3600)::numeric)), 1) AS avg_hours_in_stage,
    min(fmcl_stage_entered_at) AS oldest_entry,
    max(fmcl_stage_entered_at) AS newest_entry
   FROM fhq_governance.failure_mode_registry
  WHERE (fmcl_stage <> 'CLOSED'::text)
  GROUP BY fmcl_stage, failure_severity, failure_category
  ORDER BY
        CASE fmcl_stage
            WHEN 'CAPTURE'::text THEN 1
            WHEN 'DIAGNOSIS'::text THEN 2
            WHEN 'ACTION_DEFINITION'::text THEN 3
            WHEN 'RETEST'::text THEN 4
            ELSE NULL::integer
        END,
        CASE failure_severity
            WHEN 'CRITICAL'::text THEN 1
            WHEN 'HIGH'::text THEN 2
            WHEN 'MEDIUM'::text THEN 3
            WHEN 'LOW'::text THEN 4
            ELSE NULL::integer
        END;


--
-- Name: VIEW v_fmcl_stage_distribution; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_fmcl_stage_distribution IS 'CEO-DIR-2026-052: Current distribution of open failure modes by stage and severity.';


--
-- Name: v_governance_block_context; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_governance_block_context AS
 SELECT action_type,
    action_target,
    decision,
    decision_rationale,
    initiated_at,
    initiated_by,
    ( SELECT count(*) AS count
           FROM fhq_governance.governance_actions_log gal2
          WHERE (((gal2.decision)::text = 'BLOCKED'::text) AND ((gal2.initiated_at >= (gal.initiated_at - '01:00:00'::interval)) AND (gal2.initiated_at <= gal.initiated_at)))) AS blocks_in_prior_hour
   FROM fhq_governance.governance_actions_log gal
  WHERE ((decision)::text = 'BLOCKED'::text)
  ORDER BY initiated_at DESC
 LIMIT 50;


--
-- Name: VIEW v_governance_block_context; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_governance_block_context IS 'CEO-DIR-2026-01-03-PHASE-B: Governance blocks with temporal context (historical reflection)';


--
-- Name: v_high_confidence_moments; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_high_confidence_moments AS
 SELECT created_at AS observation_time,
    regime_sovereign AS regime,
    regime_confidence,
    defcon_level,
    target_asset,
    hypothesis_category,
    eqs_score,
    count(*) OVER (PARTITION BY (date(created_at))) AS needles_that_day
   FROM fhq_canonical.golden_needles gn
  WHERE (regime_confidence >= 0.90)
  ORDER BY created_at DESC
 LIMIT 50;


--
-- Name: VIEW v_high_confidence_moments; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_high_confidence_moments IS 'CEO-DIR-2026-01-03-PHASE-B: Moments when regime confidence exceeded 90% (historical reflection)';


--
-- Name: v_information_gain_ratio; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_information_gain_ratio AS
 WITH query_outcomes AS (
         SELECT q.query_id,
            q.created_at AS query_time,
            COALESCE(q.cost_usd, (0)::numeric) AS query_cost,
            q.results_count,
            q.querying_agent,
            COALESCE(q.evidence_coverage_ratio, (0)::double precision) AS downstream_value_proxy
           FROM fhq_governance.inforage_query_log q
          WHERE (q.created_at >= (now() - '30 days'::interval))
        )
 SELECT date_trunc('day'::text, query_time) AS date,
    querying_agent,
    count(*) AS total_queries,
    round(sum(query_cost), 6) AS total_cost,
    round((avg(downstream_value_proxy))::numeric, 4) AS avg_evidence_coverage,
        CASE
            WHEN (sum(query_cost) > (0)::numeric) THEN round(((avg(downstream_value_proxy) / (sum(query_cost))::double precision))::numeric, 4)
            ELSE NULL::numeric
        END AS information_gain_ratio,
    round(avg(results_count), 2) AS avg_results_per_query
   FROM query_outcomes
  GROUP BY (date_trunc('day'::text, query_time)), querying_agent;


--
-- Name: VIEW v_information_gain_ratio; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_information_gain_ratio IS 'CEO Directive: Metakognitiv Observability - konomisk Perspektiv.
Information Gain Ratio (IGR) = Value / Cost.
Ekstern revisor kan verifisere at systemet optimaliserer informasjonsverdi.
Source: fhq_governance.inforage_query_log';


--
-- Name: v_ldow_failure_status; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_ldow_failure_status AS
 SELECT incident_id,
    cycle_number,
    failure_type,
    failure_timestamp,
    incident_status,
    root_cause_documented,
    correction_applied,
    (vega_attested_at IS NOT NULL) AS vega_attested,
    retry_authorized,
    retry_resets_counter,
        CASE
            WHEN (incident_status = 'OPEN'::text) THEN 'Document root cause'::text
            WHEN (incident_status = 'ROOT_CAUSE_DOCUMENTED'::text) THEN 'Apply correction'::text
            WHEN (incident_status = 'CORRECTION_APPLIED'::text) THEN 'Request VEGA attestation'::text
            WHEN (incident_status = 'VEGA_ATTESTED'::text) THEN 'Request CEO retry authorization'::text
            WHEN (incident_status = 'RETRY_AUTHORIZED'::text) THEN 'Ready for retry (counter will reset)'::text
            ELSE 'Closed'::text
        END AS next_action
   FROM fhq_governance.ldow_failure_incidents fi
  WHERE (incident_status <> 'CLOSED'::text)
  ORDER BY created_at DESC;


--
-- Name: v_ldow_rolling_dashboard; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_ldow_rolling_dashboard AS
 WITH current_ldow AS (
         SELECT learning_delta_observation_window.ldow_id,
            learning_delta_observation_window.holdout_id,
            learning_delta_observation_window.status,
            learning_delta_observation_window.cycles_completed,
            learning_delta_observation_window.minimum_cycles,
            learning_delta_observation_window.baseline_calibration_error,
            learning_delta_observation_window.baseline_brier_score,
            learning_delta_observation_window.damper_version_hash AS locked_damper_hash,
            learning_delta_observation_window.started_at
           FROM fhq_governance.learning_delta_observation_window
          WHERE (learning_delta_observation_window.status = 'ACTIVE'::text)
         LIMIT 1
        ), cycle_metrics AS (
         SELECT cm_1.metric_id,
            cm_1.ldow_id,
            cm_1.cycle_number,
            cm_1.forecast_count,
            cm_1.damped_count,
            cm_1.calibration_error,
            cm_1.brier_score,
            cm_1.delta_fss,
            cm_1.p95_latency_ms,
            cm_1.avg_latency_ms,
            cm_1.avg_raw_confidence,
            cm_1.avg_damped_confidence,
            cm_1.avg_dampening_delta,
            cm_1.calibration_error_delta,
            cm_1.brier_score_delta,
            cm_1.damper_version_hash,
            cm_1.damper_hash_verified,
            cm_1.cycle_started_at,
            cm_1.cycle_completed_at,
            cm_1.computed_at,
            lag(cm_1.calibration_error) OVER (ORDER BY cm_1.cycle_number) AS prev_calibration_error,
            lag(cm_1.brier_score) OVER (ORDER BY cm_1.cycle_number) AS prev_brier_score
           FROM (fhq_governance.ldow_cycle_metrics cm_1
             JOIN current_ldow cl_1 ON ((cm_1.ldow_id = cl_1.ldow_id)))
        ), capture_stats AS (
         SELECT ldow_forecast_captures.ldow_id,
            ldow_forecast_captures.cycle_number,
            count(*) AS capture_count,
            count(*) FILTER (WHERE ((ldow_forecast_captures.raw_confidence IS NOT NULL) AND (ldow_forecast_captures.damped_confidence IS NOT NULL) AND (ldow_forecast_captures.damper_version_hash IS NOT NULL))) AS lineage_complete_count
           FROM fhq_governance.ldow_forecast_captures
          GROUP BY ldow_forecast_captures.ldow_id, ldow_forecast_captures.cycle_number
        )
 SELECT cl.ldow_id,
    cl.status AS ldow_status,
    cl.cycles_completed,
    cl.minimum_cycles,
    cl.baseline_calibration_error,
    cl.baseline_brier_score,
    cl.locked_damper_hash,
    cl.started_at AS ldow_started,
    cm.cycle_number AS current_cycle,
    cm.forecast_count,
    cm.calibration_error AS current_calibration_error,
    cm.brier_score AS current_brier_score,
    cm.delta_fss,
    cm.p95_latency_ms,
    (cm.calibration_error - cm.prev_calibration_error) AS calibration_trend,
    (cm.brier_score - cm.prev_brier_score) AS brier_trend,
    (cm.calibration_error - cl.baseline_calibration_error) AS calibration_vs_baseline,
    (cm.brier_score - cl.baseline_brier_score) AS brier_vs_baseline,
    cm.avg_raw_confidence,
    cm.avg_damped_confidence,
    cm.avg_dampening_delta,
    cm.damper_hash_verified,
    cs.capture_count,
    cs.lineage_complete_count,
    round((((cs.lineage_complete_count)::numeric / (NULLIF(cs.capture_count, 0))::numeric) * (100)::numeric), 1) AS lineage_coverage_pct
   FROM ((current_ldow cl
     LEFT JOIN cycle_metrics cm ON (((cm.ldow_id = cl.ldow_id) AND (cm.cycle_number = ( SELECT max(cycle_metrics.cycle_number) AS max
           FROM cycle_metrics)))))
     LEFT JOIN capture_stats cs ON (((cs.ldow_id = cl.ldow_id) AND (cs.cycle_number = cm.cycle_number))));


--
-- Name: v_learning_progress; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_learning_progress AS
 WITH failure_stats AS (
         SELECT count(*) FILTER (WHERE ((failure_mode_registry.fmcl_stage = 'CLOSED'::text) AND (failure_mode_registry.failure_severity = 'HIGH'::text))) AS high_closed,
            count(*) FILTER (WHERE (failure_mode_registry.failure_severity = 'HIGH'::text)) AS high_total,
            count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage = 'CLOSED'::text)) AS total_closed,
            count(*) AS total_fm,
            count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage = 'CAPTURE'::text)) AS in_capture,
            count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage = 'DIAGNOSIS'::text)) AS in_diagnosis,
            count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage = 'ACTION_DEFINITION'::text)) AS in_action,
            count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage = 'RETEST'::text)) AS in_retest
           FROM fhq_governance.failure_mode_registry
        ), calibration_stats AS (
         SELECT (count(*) > 0) AS has_gates
           FROM fhq_governance.confidence_calibration_gates
        )
 SELECT (LEAST((100)::double precision, GREATEST((0)::double precision, round(((((
        CASE
            WHEN (fs.high_total > 0) THEN ((((fs.high_closed)::double precision / (fs.high_total)::double precision) * (100)::double precision) * (0.30)::double precision)
            ELSE (30)::double precision
        END + (
        CASE
            WHEN (fs.total_closed > 0) THEN 25
            ELSE 0
        END)::double precision) + (
        CASE
            WHEN cs.has_gates THEN 20
            ELSE 0
        END)::double precision) + (
        CASE
            WHEN cs.has_gates THEN 15
            ELSE 0
        END)::double precision) + (10)::double precision)))))::integer AS current_progress_pct,
    28 AS baseline_pct,
    80 AS verified_threshold_pct,
    90 AS qgf6_threshold_pct,
    100 AS paper_trading_threshold_pct,
    ((((((((fs.in_capture || '-'::text) || fs.in_diagnosis) || '-'::text) || fs.in_action) || '-'::text) || fs.in_retest) || '-'::text) || fs.total_closed) AS fmcl_distribution,
    fs.high_closed AS high_severity_closed,
    fs.high_total AS high_severity_total,
    now() AS calculated_at
   FROM (failure_stats fs
     CROSS JOIN calibration_stats cs);


--
-- Name: VIEW v_learning_progress; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_learning_progress IS 'CEO-DIR-2026-057: Learning progress percentage for dashboard.
Anchors: 28% (baseline), 80% (verified), 90% (QG-F6), 100% (paper trading).';


--
-- Name: v_learning_verification_criteria; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_learning_verification_criteria AS
 WITH retest_stats AS (
         SELECT count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage = 'RETEST'::text)) AS in_retest,
            count(*) FILTER (WHERE ((failure_mode_registry.fmcl_stage = 'CLOSED'::text) AND (failure_mode_registry.failure_severity = 'HIGH'::text))) AS high_closed,
            count(*) FILTER (WHERE ((failure_mode_registry.fmcl_stage = ANY (ARRAY['RETEST'::text, 'CLOSED'::text])) AND (failure_mode_registry.failure_severity = 'HIGH'::text))) AS high_total
           FROM fhq_governance.failure_mode_registry
        ), calibration_stats AS (
         SELECT round(avg(
                CASE
                    WHEN (brier_score_ledger.forecast_probability >= 0.9) THEN (brier_score_ledger.forecast_probability - ((brier_score_ledger.actual_outcome)::integer)::numeric)
                    ELSE NULL::numeric
                END), 4) AS high_conf_gap,
            count(*) AS sample_size
           FROM fhq_governance.brier_score_ledger
          WHERE (brier_score_ledger.forecast_timestamp >= (now() - '7 days'::interval))
        ), suppression_stats AS (
         SELECT suppression_regret_index.suppression_wisdom_rate,
            suppression_regret_index.computation_timestamp
           FROM fhq_governance.suppression_regret_index
          ORDER BY suppression_regret_index.computation_timestamp DESC
         LIMIT 2
        ), fmcl_entropy AS (
         SELECT count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage = 'CAPTURE'::text)) AS capture,
            count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage = 'DIAGNOSIS'::text)) AS diagnosis,
            count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage = 'ACTION_DEFINITION'::text)) AS action,
            count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage = 'RETEST'::text)) AS retest,
            count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage = 'CLOSED'::text)) AS closed,
            count(*) FILTER (WHERE (failure_mode_registry.fmcl_stage <> 'CLOSED'::text)) AS net_open
           FROM fhq_governance.failure_mode_registry
        )
 SELECT
        CASE
            WHEN (rs.high_total > 0) THEN round(((100.0 * (rs.high_closed)::numeric) / (rs.high_total)::numeric), 1)
            ELSE (0)::numeric
        END AS retest_closure_rate_pct,
        CASE
            WHEN ((rs.high_total > 0) AND (((100.0 * (rs.high_closed)::numeric) / (rs.high_total)::numeric) >= (70)::numeric)) THEN 'MET'::text
            ELSE 'NOT_MET'::text
        END AS criterion_1_retest_closure,
    cs.high_conf_gap AS current_calibration_gap,
        CASE
            WHEN ((cs.high_conf_gap IS NULL) OR (cs.high_conf_gap < 0.55)) THEN 'MET'::text
            ELSE 'NOT_MET'::text
        END AS criterion_2_calibration,
    'PENDING_7DAY_DATA'::text AS criterion_3_suppression,
    fe.net_open AS current_net_open,
        CASE
            WHEN (fe.net_open <= 24) THEN 'MET'::text
            ELSE 'NOT_MET'::text
        END AS criterion_4_net_open,
    ((((((((fe.capture || '-'::text) || fe.diagnosis) || '-'::text) || fe.action) || '-'::text) || fe.retest) || '-'::text) || fe.closed) AS fmcl_distribution,
        CASE
            WHEN ((fe.closed >= 5) AND (fe.retest >= 0)) THEN 'CONVERGING'::text
            ELSE 'OSCILLATING'::text
        END AS criterion_5_entropy,
        CASE
            WHEN ((rs.high_total > 0) AND (((100.0 * (rs.high_closed)::numeric) / (rs.high_total)::numeric) >= (70)::numeric) AND ((cs.high_conf_gap IS NULL) OR (cs.high_conf_gap < 0.55)) AND (fe.net_open <= 24) AND (fe.closed >= 5)) THEN 'LEARNING_VERIFIED'::text
            ELSE 'LEARNING_NOT_PROVEN'::text
        END AS overall_verdict,
    now() AS verified_at
   FROM ((retest_stats rs
     CROSS JOIN calibration_stats cs)
     CROSS JOIN fmcl_entropy fe);


--
-- Name: VIEW v_learning_verification_criteria; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_learning_verification_criteria IS 'CEO-DIR-2026-054: Learning verification criteria (non-subjective).
All criteria must be MET for VEGA attestation.
Failure on any axis = learning NOT proven.';


--
-- Name: v_lessons_without_evidence; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_lessons_without_evidence AS
 SELECT lesson_id,
    lesson_category,
    lesson_severity,
    lesson_description,
    created_at,
    created_by,
    'VIOLATION: Lesson created without evidence binding'::text AS violation_type
   FROM fhq_governance.epistemic_lessons
  WHERE ((evidence_id IS NULL) AND (created_at >= '2026-01-08 00:00:00+01'::timestamp with time zone));


--
-- Name: VIEW v_lessons_without_evidence; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_lessons_without_evidence IS 'CEO-DIR-2026-021 Audit Correction #4: Governance view to detect lessons created without evidence.
Post-2026-01-08, all lessons MUST have evidence_id populated.
This view should always return 0 rows in production.';


--
-- Name: v_market_learning_status; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_market_learning_status AS
 WITH label_status AS (
         SELECT (EXISTS ( SELECT 1
                   FROM fhq_governance.label_definition_registry
                  WHERE ((label_definition_registry.is_active = true) AND (label_definition_registry.locked_at IS NOT NULL)))) AS label_locked,
            ( SELECT label_definition_registry.version
                   FROM fhq_governance.label_definition_registry
                  WHERE (label_definition_registry.is_active = true)
                 LIMIT 1) AS label_version,
            ( SELECT label_definition_registry.schema_hash
                   FROM fhq_governance.label_definition_registry
                  WHERE (label_definition_registry.is_active = true)
                 LIMIT 1) AS label_hash
        ), holdout_status AS (
         SELECT count(*) AS holdout_count,
            count(*) FILTER (WHERE (frozen_holdout_registry.is_frozen = true)) AS frozen_count,
            count(*) FILTER (WHERE (frozen_holdout_registry.isolation_verified = true)) AS verified_count
           FROM fhq_governance.frozen_holdout_registry
        ), eval_status AS (
         SELECT count(*) AS total_evaluations,
            count(*) FILTER (WHERE ((holdout_evaluation_results.is_significant = true) AND (holdout_evaluation_results.improvement_direction = 'UP'::text))) AS significant_improvements,
            ( SELECT holdout_evaluation_results_1.brier_score
                   FROM fhq_governance.holdout_evaluation_results holdout_evaluation_results_1
                  ORDER BY holdout_evaluation_results_1.evaluated_at DESC
                 LIMIT 1) AS latest_brier,
            ( SELECT holdout_evaluation_results_1.brier_delta
                   FROM fhq_governance.holdout_evaluation_results holdout_evaluation_results_1
                  ORDER BY holdout_evaluation_results_1.evaluated_at DESC
                 LIMIT 1) AS latest_delta,
            ( SELECT holdout_evaluation_results_1.improvement_direction
                   FROM fhq_governance.holdout_evaluation_results holdout_evaluation_results_1
                  ORDER BY holdout_evaluation_results_1.evaluated_at DESC
                 LIMIT 1) AS latest_direction
           FROM fhq_governance.holdout_evaluation_results
        )
 SELECT ls.label_locked,
    ls.label_version,
    ls.label_hash,
    hs.holdout_count,
    hs.frozen_count,
    hs.verified_count,
        CASE
            WHEN (NOT ls.label_locked) THEN (0)::bigint
            WHEN (hs.frozen_count = 0) THEN (0)::bigint
            WHEN (hs.verified_count = 0) THEN (0)::bigint
            WHEN (es.total_evaluations = 0) THEN (0)::bigint
            WHEN (es.significant_improvements = 0) THEN (0)::bigint
            ELSE LEAST((100)::bigint, (es.significant_improvements * 20))
        END AS market_learning_pct,
        CASE
            WHEN (NOT ls.label_locked) THEN 'BLOCKED: Label definition not locked'::text
            WHEN (hs.frozen_count = 0) THEN 'BLOCKED: No frozen holdout set'::text
            WHEN (hs.verified_count = 0) THEN 'BLOCKED: Holdout not isolation-verified'::text
            WHEN (es.total_evaluations = 0) THEN 'READY: Awaiting first evaluation'::text
            WHEN (es.significant_improvements = 0) THEN 'ACTIVE: No significant improvement yet'::text
            ELSE (('LEARNING: '::text || es.significant_improvements) || ' significant improvement(s)'::text)
        END AS status_label,
    es.latest_brier,
    es.latest_delta,
    es.latest_direction,
    es.total_evaluations,
    es.significant_improvements,
    now() AS measured_at
   FROM ((label_status ls
     CROSS JOIN holdout_status hs)
     CROSS JOIN eval_status es);


--
-- Name: VIEW v_market_learning_status; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_market_learning_status IS 'CEO-DIR-2026-058: Market Learning status - separate from System Maturity.
Progress only advances with significant holdout improvements.';


--
-- Name: v_regime_variance_metrics; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_regime_variance_metrics AS
 WITH regime_stats AS (
         SELECT b.dominant_regime,
            date_trunc('week'::text, b.created_at) AS week,
            count(*) AS belief_count,
            avg(b.belief_confidence) AS avg_confidence,
            stddev(b.belief_confidence) AS stddev_confidence,
            avg(b.entropy) AS avg_entropy,
            stddev(b.entropy) AS stddev_entropy
           FROM fhq_perception.model_belief_state b
          WHERE (b.created_at >= (now() - '90 days'::interval))
          GROUP BY b.dominant_regime, (date_trunc('week'::text, b.created_at))
        )
 SELECT dominant_regime,
    week,
    belief_count,
    round(avg_confidence, 4) AS avg_confidence,
    round(stddev_confidence, 4) AS stddev_confidence,
        CASE
            WHEN (avg_confidence > 0.01) THEN round((stddev_confidence / avg_confidence), 4)
            ELSE NULL::numeric
        END AS confidence_cv,
    round(avg_entropy, 4) AS avg_entropy,
    round(stddev_entropy, 4) AS stddev_entropy,
        CASE
            WHEN (avg_entropy > 0.01) THEN round((stddev_entropy / avg_entropy), 4)
            ELSE NULL::numeric
        END AS entropy_cv,
        CASE
            WHEN ((avg_confidence > 0.01) AND ((stddev_confidence / avg_confidence) < 0.15)) THEN 'STABLE'::text
            WHEN ((avg_confidence > 0.01) AND ((stddev_confidence / avg_confidence) < 0.30)) THEN 'MODERATE'::text
            ELSE 'VOLATILE'::text
        END AS stability_indicator
   FROM regime_stats;


--
-- Name: VIEW v_regime_variance_metrics; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_regime_variance_metrics IS 'CEO Directive: Metakognitiv Observability - CV per Regime.
Coefficient of Variation (CV) normaliserer for baseline-forskjeller.
Ekstern revisor kan sammenligne CV p tvers av BULL/BEAR/NEUTRAL.
Source: fhq_perception.model_belief_state';


--
-- Name: v_metacognitive_cognitive_summary; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_metacognitive_cognitive_summary AS
 WITH daily_coq AS (
         SELECT avg(v_chain_of_query_efficiency.efficiency_score) AS avg_efficiency,
            avg(v_chain_of_query_efficiency.abort_rate) AS avg_abort_rate,
            avg(v_chain_of_query_efficiency.avg_latency_ms) AS avg_latency,
            sum(v_chain_of_query_efficiency.total_cost_usd) AS total_cost_7d
           FROM fhq_governance.v_chain_of_query_efficiency
          WHERE (v_chain_of_query_efficiency.query_date >= (now() - '7 days'::interval))
        ), regime_cv AS (
         SELECT v_regime_variance_metrics.dominant_regime,
            avg(v_regime_variance_metrics.confidence_cv) AS avg_cv
           FROM fhq_governance.v_regime_variance_metrics
          WHERE (v_regime_variance_metrics.week >= (now() - '28 days'::interval))
          GROUP BY v_regime_variance_metrics.dominant_regime
        )
 SELECT round(COALESCE(avg_efficiency, (0)::numeric), 2) AS coq_efficiency_score,
    round((COALESCE(avg_abort_rate, (0)::numeric) * (100)::numeric), 2) AS abort_rate_pct,
    round(COALESCE(avg_latency, (0)::numeric), 0) AS avg_latency_ms,
    round(COALESCE(total_cost_7d, (0)::numeric), 4) AS total_query_cost_7d,
    ( SELECT jsonb_object_agg(regime_cv.dominant_regime, round(regime_cv.avg_cv, 4)) AS jsonb_object_agg
           FROM regime_cv) AS cv_per_regime,
    now() AS computed_at
   FROM daily_coq dc;


--
-- Name: VIEW v_metacognitive_cognitive_summary; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_metacognitive_cognitive_summary IS 'CEO Directive: Metakognitiv Observability - Kognitiv Dashboard Summary.
Single-query aggregation for dashboard display.';


--
-- Name: v_metacognitive_economic_summary; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_metacognitive_economic_summary AS
 WITH igr_summary AS (
         SELECT avg(v_information_gain_ratio.information_gain_ratio) AS avg_igr,
            sum(v_information_gain_ratio.total_cost) AS total_cost_30d,
            avg(v_information_gain_ratio.avg_evidence_coverage) AS avg_coverage
           FROM fhq_governance.v_information_gain_ratio
          WHERE (v_information_gain_ratio.date >= (now() - '30 days'::interval))
        ), evpi_summary AS (
         SELECT (sum((mv_evpi_proxy.evpi_proxy * (mv_evpi_proxy.suppression_count)::numeric)) / NULLIF(sum(mv_evpi_proxy.suppression_count), (0)::numeric)) AS weighted_evpi,
            sum(mv_evpi_proxy.regret_count) AS total_regrets,
            sum(mv_evpi_proxy.wisdom_count) AS total_wisdom
           FROM fhq_governance.mv_evpi_proxy
          WHERE (mv_evpi_proxy.week >= (now() - '84 days'::interval))
        ), calibration_summary AS (
         SELECT avg(calibration_dashboard.brier_score) AS avg_brier,
            count(*) AS forecast_count
           FROM fhq_governance.calibration_dashboard
        )
 SELECT round(COALESCE(igr.avg_igr, (0)::numeric), 4) AS avg_information_gain_ratio,
    round(COALESCE(igr.total_cost_30d, (0)::numeric), 4) AS total_query_cost_30d,
    round(COALESCE(igr.avg_coverage, (0)::numeric), 4) AS avg_evidence_coverage,
    round(COALESCE(evpi.weighted_evpi, (0)::numeric), 6) AS evpi_proxy_value,
    COALESCE(evpi.total_regrets, (0)::numeric) AS regret_count_12w,
    COALESCE(evpi.total_wisdom, (0)::numeric) AS wisdom_count_12w,
    round(COALESCE(cal.avg_brier, (0)::numeric), 4) AS avg_brier_score,
    COALESCE(cal.forecast_count, (0)::bigint) AS calibrated_forecasts,
        CASE
            WHEN (COALESCE(cal.forecast_count, (0)::bigint) = 0) THEN 'AWAITING_FINN_DATA'::text
            ELSE 'ACTIVE'::text
        END AS calibration_status,
    now() AS computed_at
   FROM ((igr_summary igr
     CROSS JOIN evpi_summary evpi)
     CROSS JOIN calibration_summary cal);


--
-- Name: VIEW v_metacognitive_economic_summary; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_metacognitive_economic_summary IS 'CEO Directive: Metakognitiv Observability - konomisk Dashboard Summary.
IGR, EVPI, and calibration metrics.
Note: Brier scores require FINN population of brier_score_ledger.';


--
-- Name: v_needle_history; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_needle_history AS
 SELECT date(created_at) AS date,
    count(*) AS total_needles,
    count(*) FILTER (WHERE (is_current = true)) AS current_needles,
    count(*) FILTER (WHERE (hypothesis_category ~~ '%MEAN_REVERSION%'::text)) AS mean_reversion,
    count(*) FILTER (WHERE (hypothesis_category ~~ '%CATALYST%'::text)) AS catalyst,
    count(*) FILTER (WHERE (hypothesis_category ~~ '%TIMING%'::text)) AS timing,
    count(*) FILTER (WHERE (hypothesis_category ~~ '%REGIME%'::text)) AS regime_edge,
    mode() WITHIN GROUP (ORDER BY regime_sovereign) AS dominant_regime,
    (avg(regime_confidence))::numeric(5,4) AS avg_confidence
   FROM fhq_canonical.golden_needles
  GROUP BY (date(created_at))
  ORDER BY (date(created_at)) DESC
 LIMIT 30;


--
-- Name: VIEW v_needle_history; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_needle_history IS 'CEO-DIR-2026-01-03-PHASE-B: Daily needle counts by category (historical reflection, no trends)';


--
-- Name: v_pending_epistemic_proposals; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_pending_epistemic_proposals AS
 SELECT proposal_code,
    proposal_type,
    target_parameter,
    delta_description,
    reasoning_summary,
    evidence_sample_size,
    evidence_time_window,
    confidence_in_proposal,
    risk_severity,
    expected_magnitude,
    generated_at,
    expires_at,
    (expires_at - now()) AS time_until_expiry,
    status
   FROM fhq_governance.epistemic_proposals ep
  WHERE (status = 'GENERATED'::text)
  ORDER BY confidence_in_proposal DESC, generated_at DESC;


--
-- Name: VIEW v_pending_epistemic_proposals; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_pending_epistemic_proposals IS 'Human review dashboard: Shows all pending proposals sorted by confidence.
Review via: SELECT * FROM fhq_governance.v_pending_epistemic_proposals;';


--
-- Name: v_pending_oracle_submissions; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_pending_oracle_submissions AS
 SELECT submission_id,
    domain,
    "left"(narrative, 200) AS narrative_preview,
    probability,
    confidence,
    half_life_hours,
    submitted_by,
    submitted_at,
    (EXTRACT(epoch FROM (now() - submitted_at)) / (3600)::numeric) AS hours_pending
   FROM fhq_governance.oracle_staging
  WHERE (review_status = 'PENDING'::text)
  ORDER BY submitted_at DESC;


--
-- Name: v_regime_transition_context; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_regime_transition_context AS
 WITH regime_changes AS (
         SELECT gn.created_at AS observation_time,
            gn.regime_sovereign AS regime_at_time,
            gn.regime_confidence,
            gn.defcon_level,
            lag(gn.regime_sovereign) OVER (ORDER BY gn.created_at) AS prev_regime,
            count(*) OVER (PARTITION BY (date(gn.created_at))) AS needles_that_day
           FROM fhq_canonical.golden_needles gn
          WHERE (gn.regime_sovereign IS NOT NULL)
        )
 SELECT observation_time,
    prev_regime,
    regime_at_time AS new_regime,
    regime_confidence,
    defcon_level,
    needles_that_day
   FROM regime_changes
  WHERE ((prev_regime IS NOT NULL) AND (prev_regime <> regime_at_time))
  ORDER BY observation_time DESC
 LIMIT 20;


--
-- Name: VIEW v_regime_transition_context; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_regime_transition_context IS 'CEO-DIR-2026-01-03-PHASE-B: Regime transitions with context (historical reflection)';


--
-- Name: v_rung_d_eligibility; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_rung_d_eligibility AS
 WITH completed_cycles AS (
         SELECT ldow_cycle_completion.cycle_number,
            ldow_cycle_completion.cycle_label,
            ldow_cycle_completion.completion_status,
            ldow_cycle_completion.coverage_pass,
            ldow_cycle_completion.stability_pass,
            ldow_cycle_completion.damper_unchanged,
            ldow_cycle_completion.rung_d_eligible,
            ldow_cycle_completion.vega_attestation_id,
            ldow_cycle_completion.completed_at
           FROM fhq_governance.ldow_cycle_completion
          WHERE ((ldow_cycle_completion.completion_status = 'COMPLETED'::text) AND (ldow_cycle_completion.rung_d_eligible = true))
          ORDER BY ldow_cycle_completion.cycle_number
        ), cycle_count AS (
         SELECT count(*) AS eligible_cycles
           FROM completed_cycles
        ), attestation_check AS (
         SELECT count(*) FILTER (WHERE (completed_cycles.vega_attestation_id IS NOT NULL)) AS attested_cycles
           FROM completed_cycles
        )
 SELECT cc.eligible_cycles,
    ac.attested_cycles,
        CASE
            WHEN ((cc.eligible_cycles >= 2) AND (ac.attested_cycles >= 2)) THEN true
            ELSE false
        END AS rung_d_qualified,
        CASE
            WHEN (cc.eligible_cycles < 2) THEN (('Need '::text || (2 - cc.eligible_cycles)) || ' more completed cycles'::text)
            WHEN (ac.attested_cycles < 2) THEN (('Need '::text || (2 - ac.attested_cycles)) || ' more VEGA attestations'::text)
            ELSE 'RUNG D QUALIFIED - Ready for human-authorized execution'::text
        END AS qualification_status,
    ( SELECT array_agg(completed_cycles.cycle_label ORDER BY completed_cycles.cycle_number) AS array_agg
           FROM completed_cycles) AS completed_cycle_labels,
    now() AS checked_at
   FROM cycle_count cc,
    attestation_check ac;


--
-- Name: v_shadow_decision_summary; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_shadow_decision_summary AS
 SELECT date(evaluation_time) AS eval_date,
    count(*) AS total_evaluations,
    count(*) FILTER (WHERE (lids_verdict = 'PASS'::text)) AS lids_passed,
    count(*) FILTER (WHERE (lids_verdict = 'BLOCKED_CONFIDENCE'::text)) AS blocked_confidence,
    count(*) FILTER (WHERE (lids_verdict = 'BLOCKED_FRESHNESS'::text)) AS blocked_freshness,
    count(*) FILTER (WHERE (would_have_executed = true)) AS would_have_executed,
    round(avg(lids_confidence), 4) AS avg_confidence,
    round(avg(lids_freshness_hours), 2) AS avg_freshness_hours,
    round(avg(eqs_score), 6) AS avg_eqs_score
   FROM fhq_governance.shadow_decision_log
  GROUP BY (date(evaluation_time))
  ORDER BY (date(evaluation_time)) DESC;


--
-- Name: VIEW v_shadow_decision_summary; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_shadow_decision_summary IS 'CEO-DIR-2026-050: Daily summary of shadow decision evaluations.
Shows LIDS gate pass/block rates without actual execution.';


--
-- Name: v_stillness_current_status; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_stillness_current_status AS
 SELECT day_number,
    day_date,
    day_label,
    goal_focus,
    goal_status,
    scheduled_at,
    success_criterion,
        CASE
            WHEN (now() < scheduled_at) THEN 'AWAITING'::text
            WHEN (goal_status = 'COMPLETED'::text) THEN 'DONE'::text
            WHEN ((now() >= scheduled_at) AND (now() < (scheduled_at + ((execution_window_hours || ' hours'::text))::interval))) THEN 'ACTIVE'::text
            ELSE 'OVERDUE'::text
        END AS time_status,
    stillness_maintained,
    (vega_attested_at IS NOT NULL) AS vega_attested,
    ( SELECT count(*) AS count
           FROM fhq_governance.stillness_checkpoint_log scl
          WHERE ((scl.day_goal_id = sdg.goal_id) AND (scl.checkpoint_pass = false))) AS failed_checkpoints,
    now() AS checked_at
   FROM fhq_governance.stillness_day_goals sdg
  ORDER BY day_number;


--
-- Name: v_suspension_metrics; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_suspension_metrics AS
 SELECT count(*) FILTER (WHERE (status = 'PENDING'::text)) AS pending_requests,
    count(*) FILTER (WHERE (status = 'APPROVED'::text)) AS approved_requests,
    count(*) FILTER (WHERE (status = 'REJECTED'::text)) AS rejected_requests,
    count(*) AS total_requests,
    avg(
        CASE
            WHEN (status <> 'PENDING'::text) THEN EXTRACT(epoch FROM (updated_at - created_at))
            ELSE NULL::numeric
        END) AS avg_review_time_seconds,
    max(discrepancy_score) AS max_discrepancy_score,
    avg(discrepancy_score) AS avg_discrepancy_score,
    count(DISTINCT agent_id) AS unique_agents_flagged
   FROM fhq_governance.agent_suspension_requests;


--
-- Name: VIEW v_suspension_metrics; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON VIEW fhq_governance.v_suspension_metrics IS 'ADR-009: Aggregate metrics for suspension workflow monitoring';


--
-- Name: v_time_integrity_status; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.v_time_integrity_status AS
 WITH artifact_counts AS (
         SELECT count(*) FILTER (WHERE (artifact_time_registry.time_integrity_status = 'VALID'::text)) AS valid_count,
            count(*) FILTER (WHERE (artifact_time_registry.time_integrity_status = 'INVALID_TIME_CONTEXT'::text)) AS invalid_count,
            count(*) FILTER (WHERE (artifact_time_registry.time_integrity_status = 'PENDING'::text)) AS pending_count,
            count(*) FILTER (WHERE (artifact_time_registry.is_pre_canonical = true)) AS pre_canonical_count,
            count(*) AS total_count
           FROM fhq_governance.artifact_time_registry
        ), recent_invalid AS (
         SELECT artifact_time_registry.artifact_id,
            artifact_time_registry.artifact_type,
            artifact_time_registry.time_integrity_reason,
            artifact_time_registry.canonical_created_at
           FROM fhq_governance.artifact_time_registry
          WHERE (artifact_time_registry.time_integrity_status = 'INVALID_TIME_CONTEXT'::text)
          ORDER BY artifact_time_registry.canonical_created_at DESC
         LIMIT 5
        ), canonical_clock AS (
         SELECT v_canonical_clock.canonical_now_utc,
            v_canonical_clock.canonical_date,
            v_canonical_clock.unix_timestamp,
            v_canonical_clock.time_source,
            v_canonical_clock.directive_ref
           FROM fhq_governance.v_canonical_clock
        )
 SELECT cc.canonical_now_utc,
    cc.canonical_date,
    cc.unix_timestamp,
    ac.valid_count,
    ac.invalid_count,
    ac.pending_count,
    ac.pre_canonical_count,
    ac.total_count,
        CASE
            WHEN (ac.invalid_count = 0) THEN 'CLEAN'::text
            WHEN (ac.invalid_count <= 5) THEN 'WARNING'::text
            ELSE 'BLOCKED'::text
        END AS time_integrity_status,
        CASE
            WHEN (ac.invalid_count = 0) THEN true
            ELSE false
        END AS can_proceed_with_learning,
        CASE
            WHEN (ac.invalid_count = 0) THEN true
            ELSE false
        END AS can_proceed_with_reporting,
        CASE
            WHEN ((ac.invalid_count = 0) AND (ac.pending_count = 0)) THEN true
            ELSE false
        END AS can_proceed_with_qgf6,
    COALESCE(( SELECT jsonb_agg(jsonb_build_object('artifact_id', ri.artifact_id, 'type', ri.artifact_type, 'reason', ri.time_integrity_reason)) AS jsonb_agg
           FROM recent_invalid ri), '[]'::jsonb) AS recent_invalid_artifacts,
    round(
        CASE
            WHEN (ac.total_count > 0) THEN (((ac.valid_count)::numeric / (ac.total_count)::numeric) * (100)::numeric)
            ELSE (100)::numeric
        END, 1) AS time_integrity_pct,
    'CEO-DIR-2026-060'::text AS governance_reference
   FROM (canonical_clock cc
     CROSS JOIN artifact_counts ac);


--
-- Name: vega_attestations; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.vega_attestations (
    attestation_id uuid DEFAULT gen_random_uuid() NOT NULL,
    target_type text NOT NULL,
    target_id text NOT NULL,
    target_version text,
    attestation_type text NOT NULL,
    attestation_status text DEFAULT 'PENDING'::text NOT NULL,
    attestation_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    vega_signature text NOT NULL,
    vega_public_key text NOT NULL,
    signature_verified boolean DEFAULT false NOT NULL,
    attestation_data jsonb NOT NULL,
    evidence_bundle_id uuid,
    adr_reference text DEFAULT 'ADR-006'::text NOT NULL,
    constitutional_basis text DEFAULT 'EC-001'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: vega_rhythm_schedule; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.vega_rhythm_schedule (
    rhythm_id integer NOT NULL,
    rhythm_name character varying(100) NOT NULL,
    rhythm_function character varying(100) NOT NULL,
    cron_schedule character varying(50) NOT NULL,
    description text,
    last_execution timestamp with time zone,
    next_execution timestamp with time zone,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: vega_rhythm_schedule_rhythm_id_seq; Type: SEQUENCE; Schema: fhq_governance; Owner: -
--

CREATE SEQUENCE fhq_governance.vega_rhythm_schedule_rhythm_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: vega_rhythm_schedule_rhythm_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_governance; Owner: -
--

ALTER SEQUENCE fhq_governance.vega_rhythm_schedule_rhythm_id_seq OWNED BY fhq_governance.vega_rhythm_schedule.rhythm_id;


--
-- Name: vega_triage_log; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.vega_triage_log (
    triage_id uuid DEFAULT gen_random_uuid() NOT NULL,
    event_type text NOT NULL,
    event_source text NOT NULL,
    event_data jsonb NOT NULL,
    rule_matched uuid,
    escalated_to_ceo boolean DEFAULT false NOT NULL,
    auto_paused boolean DEFAULT false NOT NULL,
    vega_decision text NOT NULL,
    vega_rationale text,
    vega_signature text,
    ceo_response text,
    ceo_responded_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT vega_triage_log_vega_decision_check CHECK ((vega_decision = ANY (ARRAY['ROUTINE_APPROVED'::text, 'ESCALATED_TO_CEO'::text, 'AUTO_PAUSED'::text, 'REJECTED'::text, 'PENDING_REVIEW'::text])))
);


--
-- Name: vega_triage_rules; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.vega_triage_rules (
    rule_id uuid DEFAULT gen_random_uuid() NOT NULL,
    rule_name text NOT NULL,
    rule_description text,
    condition_type text NOT NULL,
    threshold_value numeric(10,4),
    comparison_operator text,
    escalate_to_ceo boolean DEFAULT false NOT NULL,
    auto_pause boolean DEFAULT false NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT vega_triage_rules_comparison_operator_check CHECK ((comparison_operator = ANY (ARRAY['>'::text, '<'::text, '>='::text, '<='::text, '='::text]))),
    CONSTRAINT vega_triage_rules_condition_type_check CHECK ((condition_type = ANY (ARRAY['DISCREPANCY_THRESHOLD'::text, 'CLASS_A_VIOLATION'::text, 'CLASS_B_VIOLATION'::text, 'CAPITAL_LEDGER_BREACH'::text, 'REGIME_MISMATCH'::text, 'TAIL_LOSS'::text, 'CUSTOM'::text])))
);


--
-- Name: vega_validation_rules; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.vega_validation_rules (
    rule_id uuid DEFAULT gen_random_uuid() NOT NULL,
    rule_name text NOT NULL,
    rule_type text NOT NULL,
    applies_to text[] NOT NULL,
    condition_sql text NOT NULL,
    failure_action text NOT NULL,
    constitutional_basis text NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT vega_validation_rules_rule_type_check CHECK ((rule_type = ANY (ARRAY['PRECONDITION'::text, 'POSTCONDITION'::text, 'INVARIANT'::text])))
);


--
-- Name: TABLE vega_validation_rules; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.vega_validation_rules IS 'VEGA governance validation rules per ADR-017. Enforces MIT Quad compliance as mandatory preconditions.';


--
-- Name: vendor_quota_events; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.vendor_quota_events (
    event_id uuid DEFAULT gen_random_uuid() NOT NULL,
    vendor_id uuid NOT NULL,
    event_type text NOT NULL,
    task_name text,
    previous_usage integer,
    new_usage integer,
    ceiling_value integer,
    decision text,
    decision_rationale text,
    fallback_vendor_id uuid,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by text DEFAULT 'IOS014'::text NOT NULL,
    CONSTRAINT valid_event_type CHECK ((event_type = ANY (ARRAY['USAGE_INCREMENT'::text, 'SOFT_CEILING_WARNING'::text, 'SOFT_CEILING_REACHED'::text, 'HARD_LIMIT_REACHED'::text, 'FALLBACK_TRIGGERED'::text, 'TASK_SKIPPED'::text, 'INTERVAL_RESET'::text])))
);


--
-- Name: TABLE vendor_quota_events; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.vendor_quota_events IS 'Audit log for vendor quota decisions and events.';


--
-- Name: vw_aiqf_gate_status; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.vw_aiqf_gate_status AS
 WITH latest_runs AS (
         SELECT r.benchmark_id,
            r.run_id,
            r.aiqf_score,
            r.passed,
            r.gate_decision,
            r.drift_from_baseline,
            r.drift_alert_triggered,
            r.executed_at,
            row_number() OVER (PARTITION BY r.benchmark_id ORDER BY r.executed_at DESC) AS rn
           FROM fhq_governance.aiqf_benchmark_runs r
        ), active_benchmarks AS (
         SELECT b.benchmark_id,
            b.benchmark_name,
            b.benchmark_version,
            b.pass_threshold,
            b.drift_tolerance,
            b.vega_certified
           FROM fhq_governance.aiqf_benchmark_registry b
          WHERE (b.is_active = true)
        )
 SELECT ab.benchmark_name,
    ab.benchmark_version,
    ab.vega_certified,
    lr.aiqf_score,
    ab.pass_threshold,
    lr.passed,
    lr.gate_decision,
    lr.drift_from_baseline,
    ab.drift_tolerance,
    lr.drift_alert_triggered,
    lr.executed_at AS last_run_at,
        CASE
            WHEN (lr.aiqf_score IS NULL) THEN 'NO_RUNS'::text
            WHEN (NOT lr.passed) THEN 'BELOW_THRESHOLD'::text
            WHEN lr.drift_alert_triggered THEN 'DRIFT_ALERT'::text
            WHEN (NOT ab.vega_certified) THEN 'AWAITING_CERTIFICATION'::text
            ELSE 'READY'::text
        END AS gate_status
   FROM (active_benchmarks ab
     LEFT JOIN latest_runs lr ON (((ab.benchmark_id = lr.benchmark_id) AND (lr.rn = 1))));


--
-- Name: vw_guideline_effectiveness; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.vw_guideline_effectiveness AS
 SELECT guideline_id,
    error_pattern,
    error_taxonomy,
    usage_count,
    success_rate,
    success_rate_confidence_lower,
    is_global_default,
    (vega_signoff_attestation_id IS NOT NULL) AS vega_approved,
        CASE
            WHEN (usage_count < 10) THEN 'INSUFFICIENT_DATA'::text
            WHEN (success_rate >= (0.9)::double precision) THEN 'HIGHLY_EFFECTIVE'::text
            WHEN (success_rate >= (0.7)::double precision) THEN 'EFFECTIVE'::text
            WHEN (success_rate >= (0.5)::double precision) THEN 'MARGINAL'::text
            ELSE 'INEFFECTIVE'::text
        END AS effectiveness_tier
   FROM fhq_governance.sql_correction_guidelines g
  WHERE (is_active = true)
  ORDER BY success_rate DESC, usage_count DESC;


--
-- Name: vw_refinement_performance; Type: VIEW; Schema: fhq_governance; Owner: -
--

CREATE VIEW fhq_governance.vw_refinement_performance AS
 SELECT agent_id,
    date_trunc('hour'::text, created_at) AS hour,
    count(*) AS total_attempts,
    sum(
        CASE
            WHEN success THEN 1
            ELSE 0
        END) AS successful,
    sum(
        CASE
            WHEN (success AND (attempt_number = 1)) THEN 1
            ELSE 0
        END) AS first_attempt_success,
    sum(
        CASE
            WHEN escalated_to_human THEN 1
            ELSE 0
        END) AS escalated,
    avg(latency_ms) AS avg_latency_ms,
    max(latency_ms) AS max_latency_ms,
    sum(tokens_consumed) AS total_tokens,
    sum(cost_usd) AS total_cost_usd,
    avg(
        CASE
            WHEN success THEN attempt_number
            ELSE NULL::integer
        END) AS avg_attempts_when_success
   FROM fhq_governance.sql_refinement_log
  WHERE (created_at > (now() - '24:00:00'::interval))
  GROUP BY agent_id, (date_trunc('hour'::text, created_at))
  ORDER BY (date_trunc('hour'::text, created_at)) DESC, agent_id;


--
-- Name: weekly_learning_metrics; Type: MATERIALIZED VIEW; Schema: fhq_governance; Owner: -
--

CREATE MATERIALIZED VIEW fhq_governance.weekly_learning_metrics AS
 WITH weekly_data AS (
         SELECT (EXTRACT(isoyear FROM epistemic_suppression_ledger.suppression_timestamp))::integer AS iso_year,
            (EXTRACT(week FROM epistemic_suppression_ledger.suppression_timestamp))::integer AS iso_week,
            epistemic_suppression_ledger.regret_classification,
            epistemic_suppression_ledger.regret_attribution_type,
            epistemic_suppression_ledger.regret_magnitude_category,
            epistemic_suppression_ledger.regret_magnitude,
            epistemic_suppression_ledger.suppressed_confidence,
            epistemic_suppression_ledger.chosen_confidence
           FROM fhq_governance.epistemic_suppression_ledger
          WHERE (epistemic_suppression_ledger.suppression_timestamp >= (now() - '90 days'::interval))
        )
 SELECT iso_year,
    iso_week,
    count(*) AS total_suppressions,
    count(*) FILTER (WHERE (regret_classification = 'REGRET'::text)) AS regret_count,
    count(*) FILTER (WHERE (regret_classification = 'WISDOM'::text)) AS wisdom_count,
    count(*) FILTER (WHERE ((regret_classification = 'UNRESOLVED'::text) OR (regret_classification IS NULL))) AS unresolved_count,
    round(((count(*) FILTER (WHERE (regret_classification = 'REGRET'::text)))::numeric / (NULLIF(count(*) FILTER (WHERE (regret_classification IS NOT NULL)), 0))::numeric), 4) AS regret_rate,
    round(((count(*) FILTER (WHERE (regret_classification = 'WISDOM'::text)))::numeric / (NULLIF(count(*) FILTER (WHERE (regret_classification IS NOT NULL)), 0))::numeric), 4) AS wisdom_rate,
    count(*) FILTER (WHERE (regret_attribution_type = 'TYPE_A_HYSTERESIS_LAG'::text)) AS type_a_count,
    count(*) FILTER (WHERE (regret_attribution_type = 'TYPE_B_CONFIDENCE_FLOOR'::text)) AS type_b_count,
    count(*) FILTER (WHERE (regret_attribution_type = 'TYPE_C_DATA_BLINDNESS'::text)) AS type_c_count,
    count(*) FILTER (WHERE ((regret_attribution_type IS NULL) OR (regret_attribution_type = 'TYPE_X_UNKNOWN'::text))) AS type_x_count,
    avg(regret_magnitude) FILTER (WHERE (regret_classification = 'REGRET'::text)) AS avg_regret_magnitude,
    avg(regret_magnitude) FILTER (WHERE (regret_classification = 'WISDOM'::text)) AS avg_wisdom_magnitude,
    stddev(regret_magnitude) FILTER (WHERE (regret_classification = 'REGRET'::text)) AS regret_magnitude_stddev,
    count(*) FILTER (WHERE (regret_magnitude_category = 'LOW'::text)) AS low_magnitude_count,
    count(*) FILTER (WHERE (regret_magnitude_category = 'MEDIUM'::text)) AS medium_magnitude_count,
    count(*) FILTER (WHERE (regret_magnitude_category = 'HIGH'::text)) AS high_magnitude_count,
    count(*) FILTER (WHERE (regret_magnitude_category = 'EXTREME'::text)) AS extreme_magnitude_count,
    avg(suppressed_confidence) FILTER (WHERE (regret_classification = 'REGRET'::text)) AS avg_regret_suppressed_confidence,
    avg(chosen_confidence) FILTER (WHERE (regret_classification = 'REGRET'::text)) AS avg_regret_chosen_confidence,
    avg((chosen_confidence - suppressed_confidence)) FILTER (WHERE (regret_classification = 'REGRET'::text)) AS avg_confidence_delta,
    min(((iso_year || '-W'::text) || lpad((iso_week)::text, 2, '0'::text))) AS week_label
   FROM weekly_data
  GROUP BY iso_year, iso_week
  ORDER BY iso_year DESC, iso_week DESC
  WITH NO DATA;


--
-- Name: MATERIALIZED VIEW weekly_learning_metrics; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON MATERIALIZED VIEW fhq_governance.weekly_learning_metrics IS 'Weekly learning metrics aggregation. Uses 90-day rolling window. Refresh via REFRESH MATERIALIZED VIEW.';


--
-- Name: weekly_learning_runs; Type: TABLE; Schema: fhq_governance; Owner: -
--

CREATE TABLE fhq_governance.weekly_learning_runs (
    run_id uuid DEFAULT gen_random_uuid() NOT NULL,
    iso_year integer NOT NULL,
    iso_week integer NOT NULL,
    run_status text NOT NULL,
    initiated_at timestamp with time zone DEFAULT now() NOT NULL,
    initiated_by text DEFAULT 'LARS_ORCHESTRATOR'::text NOT NULL,
    completed_at timestamp with time zone,
    learning_eligible boolean,
    cognitive_fasting boolean,
    defcon_level text,
    paper_trading_eligible boolean,
    gate_check_passed boolean NOT NULL,
    gate_block_reason text,
    regret_records_created integer DEFAULT 0,
    lessons_created integer DEFAULT 0,
    suppressions_processed integer DEFAULT 0,
    evidence_id uuid,
    governance_log_id uuid,
    execution_duration_ms integer,
    error_message text,
    CONSTRAINT weekly_learning_runs_run_status_check CHECK ((run_status = ANY (ARRAY['INITIATED'::text, 'GATE_CHECK_PASSED'::text, 'GATE_CHECK_BLOCKED'::text, 'REGRET_COMPUTED'::text, 'LESSONS_EXTRACTED'::text, 'COMPLETED'::text, 'FAILED'::text])))
);


--
-- Name: TABLE weekly_learning_runs; Type: COMMENT; Schema: fhq_governance; Owner: -
--

COMMENT ON TABLE fhq_governance.weekly_learning_runs IS 'CEO-DIR-2026-021 Step 4: Weekly learning execution tracker.
Enforces ISO week idempotency (UNIQUE constraint on iso_year, iso_week).
Records state snapshot and gate check results for every run.
Evidence binding ensures court-proof audit trail.';


--
-- Name: golden_samples; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.golden_samples (
    sample_id text NOT NULL,
    ios_id text NOT NULL,
    sample_type text NOT NULL,
    row_count integer NOT NULL,
    date_range_start date NOT NULL,
    date_range_end date NOT NULL,
    sample_data jsonb NOT NULL,
    sample_hash text NOT NULL,
    g3_audit_id text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by text NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    superseded_by text,
    superseded_at timestamp with time zone,
    CONSTRAINT chk_sample_type CHECK ((sample_type = ANY (ARRAY['REGRESSION_BASELINE'::text, 'CALIBRATION_ANCHOR'::text, 'AUDIT_SNAPSHOT'::text])))
);


--
-- Name: aci_cognitive_memory; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.aci_cognitive_memory (
    memory_id uuid DEFAULT gen_random_uuid() NOT NULL,
    session_id uuid NOT NULL,
    interaction_id uuid,
    sequence_number integer DEFAULT 1 NOT NULL,
    state_snapshot_hash character varying(64) NOT NULL,
    defcon_level character varying(10) NOT NULL,
    agent_channel character varying(50) DEFAULT 'ACI_CONSOLE_TIER_3'::character varying NOT NULL,
    memory_type character varying(30) NOT NULL,
    content text NOT NULL,
    content_hash character varying(64),
    tokens_used integer DEFAULT 0,
    is_active boolean DEFAULT true NOT NULL,
    expires_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT aci_cognitive_memory_agent_channel_check CHECK (((agent_channel)::text = 'ACI_CONSOLE_TIER_3'::text)),
    CONSTRAINT aci_cognitive_memory_memory_type_check CHECK (((memory_type)::text = ANY (ARRAY[('USER_QUERY'::character varying)::text, ('SYSTEM_RESPONSE'::character varying)::text, ('CONTEXT_SUMMARY'::character varying)::text, ('REASONING_TRACE'::character varying)::text, ('KNOWLEDGE_BOUNDARY'::character varying)::text, ('RECONCILIATION_RESULT'::character varying)::text])))
);


--
-- Name: TABLE aci_cognitive_memory; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.aci_cognitive_memory IS 'CEO Directive G0.1 3 - Persistent Cognitive Memory. Append-only, state-bound, channel-restricted.';


--
-- Name: aci_console_sessions; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.aci_console_sessions (
    session_id uuid DEFAULT gen_random_uuid() NOT NULL,
    session_name character varying(200),
    initial_state_hash character varying(64) NOT NULL,
    initial_defcon character varying(10) NOT NULL,
    interaction_count integer DEFAULT 0 NOT NULL,
    total_tokens_used integer DEFAULT 0 NOT NULL,
    total_cost_usd numeric(10,6) DEFAULT 0 NOT NULL,
    memory_entries_count integer DEFAULT 0 NOT NULL,
    status character varying(20) DEFAULT 'ACTIVE'::character varying NOT NULL,
    started_at timestamp with time zone DEFAULT now() NOT NULL,
    last_activity_at timestamp with time zone DEFAULT now() NOT NULL,
    closed_at timestamp with time zone,
    expires_at timestamp with time zone DEFAULT (now() + '24:00:00'::interval),
    CONSTRAINT aci_console_sessions_status_check CHECK (((status)::text = ANY (ARRAY[('ACTIVE'::character varying)::text, ('PAUSED'::character varying)::text, ('CLOSED'::character varying)::text, ('EXPIRED'::character varying)::text])))
);


--
-- Name: TABLE aci_console_sessions; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.aci_console_sessions IS 'CEO Directive G0.1 3 - ACI Console Session Management for memory continuity.';


--
-- Name: aci_state_snapshot_log; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.aci_state_snapshot_log (
    snapshot_id uuid DEFAULT gen_random_uuid() NOT NULL,
    state_snapshot_hash character varying(64) NOT NULL,
    defcon_level character varying(10) NOT NULL,
    btc_regime_label character varying(50),
    btc_regime_confidence numeric(5,4),
    active_strategy_hash character varying(64),
    active_strategy_name character varying(100),
    ios013_snapshot_id uuid,
    vector_timestamp timestamp with time zone NOT NULL,
    is_atomic boolean DEFAULT true NOT NULL,
    torn_read_detected boolean DEFAULT false NOT NULL,
    bound_to_interaction_id uuid,
    bound_at timestamp with time zone,
    created_by character varying(50) DEFAULT 'ACI_CONSOLE'::character varying NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    hash_chain_id character varying(100),
    hash_prev character varying(64),
    hash_self character varying(64)
);


--
-- Name: TABLE aci_state_snapshot_log; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.aci_state_snapshot_log IS 'ADR-018 State Injection Log - The Pulse. Every LLM invocation must have a bound state snapshot.';


--
-- Name: aci_system_prompts; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.aci_system_prompts (
    prompt_id uuid DEFAULT gen_random_uuid() NOT NULL,
    prompt_name character varying(100) NOT NULL,
    prompt_version character varying(20) NOT NULL,
    prompt_content text NOT NULL,
    prompt_hash character varying(64) NOT NULL,
    declares_tier_3 boolean DEFAULT true NOT NULL,
    declares_advisory_only boolean DEFAULT true NOT NULL,
    declares_no_execution boolean DEFAULT true NOT NULL,
    declares_verification_required boolean DEFAULT true NOT NULL,
    aligned_adrs text[] DEFAULT ARRAY['ADR-018'::text, 'ADR-019'::text, 'ADR-020'::text, 'ADR-021'::text] NOT NULL,
    is_active boolean DEFAULT false NOT NULL,
    approved_by character varying(50),
    approved_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE aci_system_prompts; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.aci_system_prompts IS 'CEO Directive G0.1 5 - Canonical System Prompt Registry. Identity reinforcement, not control mechanism.';


--
-- Name: canonical_asset_members; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.canonical_asset_members (
    group_id text NOT NULL,
    listing_id text NOT NULL,
    weight numeric DEFAULT 1.0
);


--
-- Name: listings; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.listings (
    listing_id text NOT NULL,
    instrument_id text NOT NULL,
    exchange_mic text NOT NULL,
    ticker text NOT NULL,
    listing_currency text,
    is_primary boolean DEFAULT false,
    listed_from date,
    listed_to date,
    created_at timestamp with time zone DEFAULT now(),
    yahoo_symbol text,
    status text DEFAULT 'ACTIVE'::text,
    CONSTRAINT listings_status_check CHECK ((status = ANY (ARRAY['ACTIVE'::text, 'DEPRECATED'::text, 'SUSPENDED'::text, 'ARCHIVED'::text])))
);


--
-- Name: COLUMN listings.status; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.listings.status IS 'Asset lifecycle status: ACTIVE (trading), DEPRECATED (phased out), SUSPENDED (temporary halt), ARCHIVED (historical only)';


--
-- Name: model_configurations; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.model_configurations (
    config_id text NOT NULL,
    group_id text,
    hmm_states smallint,
    covariance_type text,
    feature_set text[],
    rationale text,
    last_validated timestamp with time zone,
    stability_score numeric,
    remark text
);


--
-- Name: active_canonical_model_groups; Type: VIEW; Schema: fhq_meta; Owner: -
--

CREATE VIEW fhq_meta.active_canonical_model_groups AS
 SELECT c.group_id,
    c.config_id,
    c.hmm_states,
    c.covariance_type,
    c.stability_score,
    count(m.listing_id) AS active_members,
    string_agg(l.ticker, ', '::text ORDER BY m.weight DESC) AS member_tickers
   FROM ((fhq_meta.model_configurations c
     JOIN fhq_meta.canonical_asset_members m USING (group_id))
     JOIN fhq_meta.listings l ON ((m.listing_id = l.listing_id)))
  WHERE ((c.stability_score IS NOT NULL) AND (c.stability_score >= 0.90))
  GROUP BY c.group_id, c.config_id, c.hmm_states, c.covariance_type, c.stability_score
 HAVING (count(m.listing_id) >= 1);


--
-- Name: adjustment_metadata; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.adjustment_metadata (
    ticker text NOT NULL,
    date date NOT NULL,
    event_type text NOT NULL,
    event_value numeric,
    adjustment_factor numeric NOT NULL,
    cumulative_factor numeric NOT NULL,
    notes text
);


--
-- Name: adr_archive; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.adr_archive (
    archive_id uuid DEFAULT gen_random_uuid() NOT NULL,
    adr_id character varying(50) NOT NULL,
    adr_title text NOT NULL,
    adr_type character varying(30),
    version character varying(20),
    content_hash character varying(64) NOT NULL,
    archived_from character varying(50),
    archive_reason text NOT NULL,
    superseded_by character varying(50),
    archived_by character varying(20) NOT NULL,
    archived_at timestamp with time zone DEFAULT now() NOT NULL,
    original_effective_date date,
    original_created_at timestamp with time zone,
    file_path text,
    metadata jsonb
);


--
-- Name: TABLE adr_archive; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.adr_archive IS 'ADR-002: Immutable archive for superseded ADRs. Preserves full lineage and audit trail. No deletions permitted.';


--
-- Name: adr_audit_log; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.adr_audit_log (
    audit_id bigint NOT NULL,
    adr_id text,
    event_id integer,
    review_status text DEFAULT 'PENDING'::text,
    detected_by text DEFAULT 'technical_officer_v1'::text,
    detected_at timestamp with time zone DEFAULT now(),
    reviewed_by text,
    reviewed_at timestamp with time zone,
    resolution_notes text,
    checksum text,
    severity text DEFAULT 'LOW'::text,
    CONSTRAINT adr_audit_log_review_status_check CHECK ((review_status = ANY (ARRAY['PENDING'::text, 'VERIFIED'::text, 'FAILED'::text, 'RECONCILED'::text]))),
    CONSTRAINT adr_audit_log_severity_check CHECK ((severity = ANY (ARRAY['LOW'::text, 'MEDIUM'::text, 'HIGH'::text, 'CRITICAL'::text])))
);


--
-- Name: TABLE adr_audit_log; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.adr_audit_log IS 'ADR-004: Immutable audit trail for all ADR changes (G0-G4 gates)';


--
-- Name: adr_audit_log_audit_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.adr_audit_log_audit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: adr_audit_log_audit_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.adr_audit_log_audit_id_seq OWNED BY fhq_meta.adr_audit_log.audit_id;


--
-- Name: adr_dependencies; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.adr_dependencies (
    parent_adr_id text NOT NULL,
    child_adr_id text NOT NULL,
    dependency_type text NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE adr_dependencies; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.adr_dependencies IS 'ADR-002: Dependency tracking between ADRs';


--
-- Name: adr_dependencies_dependency_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.adr_dependencies_dependency_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: adr_dependency_graph; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.adr_dependency_graph (
    id integer NOT NULL,
    adr_id text NOT NULL,
    depends_on text[],
    enables text[],
    supersedes text[],
    related_to text[],
    introduces_schemas text[],
    introduces_tables text[],
    introduces_functions text[],
    introduces_views text[],
    introduces_edge_functions text[],
    introduces_migrations text[],
    type text,
    domain text,
    impact_level text,
    has_verification_method boolean DEFAULT false,
    has_rollback_plan boolean DEFAULT false,
    has_monitoring boolean DEFAULT false,
    test_coverage_pct numeric,
    compliance_tags text[],
    risk_areas text[],
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    created_by text DEFAULT 'system'::text
);


--
-- Name: adr_dependency_graph_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.adr_dependency_graph_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: adr_dependency_graph_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.adr_dependency_graph_id_seq OWNED BY fhq_meta.adr_dependency_graph.id;


--
-- Name: adr_drift_events; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.adr_drift_events (
    event_id uuid DEFAULT gen_random_uuid() NOT NULL,
    interaction_id uuid NOT NULL,
    tool_usage_id uuid,
    doc_id character varying(50) NOT NULL,
    section_id character varying(100),
    expected_canonical_sha256 character varying(64) NOT NULL,
    actual_sha256 character varying(64),
    hash_match boolean DEFAULT false NOT NULL,
    registry_doc_id character varying(50),
    registry_version character varying(20),
    registry_status character varying(20),
    severity character varying(20) NOT NULL,
    response_blocked boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT adr_drift_events_severity_check CHECK (((severity)::text = ANY (ARRAY[('LOW'::character varying)::text, ('MEDIUM'::character varying)::text, ('HIGH'::character varying)::text, ('CRITICAL'::character varying)::text])))
);


--
-- Name: TABLE adr_drift_events; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.adr_drift_events IS 'CEO Directive 4C - ADR_DRIFT_EVENT log. Detects document-truth divergence.';


--
-- Name: adr_ingestion_staging; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.adr_ingestion_staging (
    id integer NOT NULL,
    file_name text NOT NULL,
    adr_id text,
    version text,
    status text,
    content text,
    created_at timestamp with time zone DEFAULT now(),
    metadata jsonb
);


--
-- Name: TABLE adr_ingestion_staging; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.adr_ingestion_staging IS 'ADR-002: Isolated staging area for ADR ingestion. Guarantees that staging does not leak into governance state. Promotion requires CEO approval.';


--
-- Name: adr_ingestion_staging_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.adr_ingestion_staging_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: adr_ingestion_staging_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.adr_ingestion_staging_id_seq OWNED BY fhq_meta.adr_ingestion_staging.id;


--
-- Name: adr_registry; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.adr_registry (
    adr_id character varying(20) NOT NULL,
    adr_title text NOT NULL,
    adr_status character varying(50) NOT NULL,
    adr_type character varying(50) NOT NULL,
    current_version character varying(20) NOT NULL,
    approval_authority character varying(50),
    effective_date date,
    superseded_by character varying(20),
    file_path text,
    sha256_hash character(64),
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    hash text,
    title text,
    status text DEFAULT 'DRAFT'::text,
    version text,
    created_by text DEFAULT 'SYSTEM'::text,
    governance_tier text DEFAULT 'Tier-3'::text,
    owner text,
    adr_number integer,
    review_cycle_months integer DEFAULT 12,
    next_review_date date,
    affects text[] DEFAULT '{}'::text[],
    constitutional_authority text,
    description text,
    rationale text,
    vega_attested boolean DEFAULT false,
    vega_attestation_id uuid,
    vega_attestation_date timestamp with time zone,
    CONSTRAINT adr_registry_adr_status_check CHECK (((adr_status)::text = ANY (ARRAY[('DRAFT'::character varying)::text, ('PROPOSED'::character varying)::text, ('APPROVED'::character varying)::text, ('DEPRECATED'::character varying)::text, ('SUPERSEDED'::character varying)::text]))),
    CONSTRAINT adr_registry_adr_type_check CHECK (((adr_type)::text = ANY (ARRAY[('CONSTITUTIONAL'::character varying)::text, ('ARCHITECTURAL'::character varying)::text, ('OPERATIONAL'::character varying)::text, ('COMPLIANCE'::character varying)::text, ('ECONOMIC'::character varying)::text])))
);


--
-- Name: TABLE adr_registry; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.adr_registry IS 'ADR-002: Registry of all Architecture Decision Records';


--
-- Name: adr_registry_local; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.adr_registry_local (
    adr_id text NOT NULL,
    version text NOT NULL,
    status text NOT NULL,
    parent text,
    epoch text DEFAULT 'Alpha Sovereignty'::text,
    author text DEFAULT 'rjan Skjold'::text,
    last_reviewed timestamp with time zone DEFAULT now(),
    notes text,
    CONSTRAINT adr_must_have_parent_except_001 CHECK (((adr_id = 'ADR-001'::text) OR (parent IS NOT NULL))),
    CONSTRAINT adr_registry_local_status_check CHECK ((status = ANY (ARRAY['active'::text, 'archived'::text, 'draft'::text, 'pending_local_activation'::text])))
);


--
-- Name: TABLE adr_registry_local; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.adr_registry_local IS 'ADR-002: Local filesystem mirror for ADR files. Tracks sync status between filesystem and registry. Enables drift detection.';


--
-- Name: adr_registry_preapproval; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.adr_registry_preapproval (
    id integer NOT NULL,
    adr_id text NOT NULL,
    version text NOT NULL,
    gate text NOT NULL,
    approved_by text NOT NULL,
    approval_date timestamp with time zone NOT NULL,
    risk_level text,
    breaking_changes boolean DEFAULT false,
    rollback_tested boolean DEFAULT false,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT adr_registry_preapproval_gate_check CHECK ((gate = ANY (ARRAY['G1'::text, 'G2'::text, 'G3'::text]))),
    CONSTRAINT adr_registry_preapproval_risk_level_check CHECK ((risk_level = ANY (ARRAY['LOW'::text, 'MEDIUM'::text, 'HIGH'::text, 'CRITICAL'::text])))
);


--
-- Name: adr_registry_preapproval_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.adr_registry_preapproval_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: adr_registry_preapproval_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.adr_registry_preapproval_id_seq OWNED BY fhq_meta.adr_registry_preapproval.id;


--
-- Name: adr_registry_snapshots; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.adr_registry_snapshots (
    snapshot_id bigint NOT NULL,
    snapshot_tag text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    adr_list jsonb NOT NULL,
    baseline_tag text NOT NULL,
    event_id integer,
    notes text
);


--
-- Name: adr_registry_snapshots_snapshot_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.adr_registry_snapshots_snapshot_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: adr_registry_snapshots_snapshot_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.adr_registry_snapshots_snapshot_id_seq OWNED BY fhq_meta.adr_registry_snapshots.snapshot_id;


--
-- Name: adr_supplements; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.adr_supplements (
    supplement_id integer NOT NULL,
    adr_id text NOT NULL,
    filename text NOT NULL,
    file_type text,
    title text,
    status text,
    summary text,
    key_findings jsonb,
    created_at timestamp with time zone DEFAULT now(),
    sha256_hash text
);


--
-- Name: adr_supplements_supplement_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.adr_supplements_supplement_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: adr_supplements_supplement_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.adr_supplements_supplement_id_seq OWNED BY fhq_meta.adr_supplements.supplement_id;


--
-- Name: adr_version_history; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.adr_version_history (
    version_id integer NOT NULL,
    adr_id text NOT NULL,
    version text NOT NULL,
    canonical_version boolean DEFAULT false,
    status text,
    summary text,
    file_path text,
    sha256_hash text,
    created_at timestamp with time zone DEFAULT now(),
    created_by text,
    metadata jsonb DEFAULT '{}'::jsonb
);


--
-- Name: TABLE adr_version_history; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.adr_version_history IS 'ADR-004: Version lineage for all ADRs';


--
-- Name: adr_version_history_version_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.adr_version_history_version_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: adr_version_history_version_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.adr_version_history_version_id_seq OWNED BY fhq_meta.adr_version_history.version_id;


--
-- Name: agent_interaction_log; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.agent_interaction_log (
    interaction_id uuid DEFAULT gen_random_uuid() NOT NULL,
    session_id uuid,
    sequence_number integer DEFAULT 1 NOT NULL,
    agent_id character varying(20) DEFAULT 'ACI_CONSOLE'::character varying NOT NULL,
    model_provider character varying(50) NOT NULL,
    model_name character varying(100) NOT NULL,
    state_snapshot_id uuid,
    state_snapshot_hash character varying(64) NOT NULL,
    defcon_at_invocation character varying(10) NOT NULL,
    user_input text NOT NULL,
    system_prompt_hash character varying(64),
    context_injected jsonb,
    sitc_chain_id uuid,
    ikea_boundary_checked boolean DEFAULT false NOT NULL,
    inforage_cost_checked boolean DEFAULT false NOT NULL,
    model_output text,
    output_hash character varying(64),
    reasoning_chain_valid boolean,
    hallucination_rejection_count integer DEFAULT 0,
    canonical_drift_detected boolean DEFAULT false,
    governance_log_id uuid,
    input_tokens integer,
    output_tokens integer,
    total_tokens integer,
    cost_usd numeric(10,6),
    latency_ms integer,
    execution_mode character varying(20) DEFAULT 'SHADOW_PAPER'::character varying NOT NULL,
    status character varying(20) DEFAULT 'PENDING'::character varying NOT NULL,
    error_message text,
    started_at timestamp with time zone DEFAULT now() NOT NULL,
    completed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT agent_interaction_log_execution_mode_check CHECK (((execution_mode)::text = ANY (ARRAY[('SHADOW_PAPER'::character varying)::text, ('READ_ONLY'::character varying)::text, ('OBSERVATION'::character varying)::text]))),
    CONSTRAINT agent_interaction_log_status_check CHECK (((status)::text = ANY (ARRAY[('PENDING'::character varying)::text, ('PROCESSING'::character varying)::text, ('COMPLETED'::character varying)::text, ('BLOCKED_GOVERNANCE'::character varying)::text, ('BLOCKED_DEFCON'::character varying)::text, ('BLOCKED_HALLUCINATION'::character varying)::text, ('ERROR'::character varying)::text])))
);


--
-- Name: TABLE agent_interaction_log; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.agent_interaction_log IS 'CEO Directive 4A - Agent Interaction Log. LLM shall never think without Pulse (state injection).';


--
-- Name: agent_keys; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.agent_keys (
    key_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id character varying(50) NOT NULL,
    key_type character varying(50) NOT NULL,
    key_state character varying(50) NOT NULL,
    public_key_hex text NOT NULL,
    key_storage_tier character varying(50),
    key_storage_location text,
    activation_date timestamp with time zone,
    deprecation_date timestamp with time zone,
    archival_date timestamp with time zone,
    expiration_date timestamp with time zone,
    retention_period_days integer DEFAULT 2555,
    sha256_hash character(64),
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    status text GENERATED ALWAYS AS (key_state) STORED,
    vega_attested boolean DEFAULT false,
    vega_attestation_id uuid,
    vega_attestation_timestamp timestamp with time zone,
    key_fingerprint text,
    ceremony_id text,
    CONSTRAINT agent_keys_key_state_check CHECK (((key_state)::text = ANY (ARRAY[('PENDING'::character varying)::text, ('ACTIVE'::character varying)::text, ('DEPRECATED'::character varying)::text, ('ARCHIVED'::character varying)::text]))),
    CONSTRAINT agent_keys_key_storage_tier_check CHECK (((key_storage_tier)::text = ANY (ARRAY[('TIER1_HOT'::character varying)::text, ('TIER2_WARM'::character varying)::text, ('TIER3_COLD'::character varying)::text]))),
    CONSTRAINT agent_keys_key_type_check CHECK (((key_type)::text = ANY (ARRAY[('ED25519_SIGNING'::character varying)::text, ('ED25519_VERIFICATION'::character varying)::text])))
);


--
-- Name: alpha_veto_config; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.alpha_veto_config (
    config_id uuid DEFAULT gen_random_uuid() NOT NULL,
    ais_estimation_mode character varying(20) DEFAULT 'HEURISTIC'::character varying NOT NULL,
    brutal_compression_threshold numeric(5,2) DEFAULT 0.3 NOT NULL,
    max_analysis_depth integer DEFAULT 5 NOT NULL,
    time_budget_seconds integer DEFAULT 30 NOT NULL,
    veto_action character varying(30) DEFAULT 'BRUTAL_COMPRESSION'::character varying NOT NULL,
    ais_persisted boolean DEFAULT false NOT NULL,
    ais_canonical boolean DEFAULT false NOT NULL,
    ais_influences_allocation boolean DEFAULT false NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT alpha_veto_config_ais_canonical_check CHECK ((ais_canonical = false)),
    CONSTRAINT alpha_veto_config_ais_estimation_mode_check CHECK (((ais_estimation_mode)::text = ANY (ARRAY[('HEURISTIC'::character varying)::text, ('DISABLED'::character varying)::text]))),
    CONSTRAINT alpha_veto_config_ais_influences_allocation_check CHECK ((ais_influences_allocation = false)),
    CONSTRAINT alpha_veto_config_ais_persisted_check CHECK ((ais_persisted = false)),
    CONSTRAINT alpha_veto_config_veto_action_check CHECK (((veto_action)::text = ANY (ARRAY[('BRUTAL_COMPRESSION'::character varying)::text, ('CONCLUSION_ONLY'::character varying)::text, ('DECLINE_SITC'::character varying)::text])))
);


--
-- Name: TABLE alpha_veto_config; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.alpha_veto_config IS 'EC-023 Alpha-Veto configuration. AIS is ephemeral, non-persisted, non-canonical. Legal hygiene enforced via CHECK constraints.';


--
-- Name: api_schema_registry; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.api_schema_registry (
    schema_id integer NOT NULL,
    provider text NOT NULL,
    endpoint text NOT NULL,
    version text NOT NULL,
    method text NOT NULL,
    request_schema jsonb,
    response_schema jsonb,
    verified_date date,
    last_tested date,
    status text DEFAULT 'PENDING_VERIFICATION'::text,
    notes text,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now()
);


--
-- Name: TABLE api_schema_registry; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.api_schema_registry IS 'ADR-030: Registry of all external API endpoints with verified schemas for data lineage compliance';


--
-- Name: COLUMN api_schema_registry.provider; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.api_schema_registry.provider IS 'External data provider name (e.g., CoinDesk, CoinGecko)';


--
-- Name: COLUMN api_schema_registry.endpoint; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.api_schema_registry.endpoint IS 'Full endpoint URL or template with placeholders';


--
-- Name: COLUMN api_schema_registry.request_schema; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.api_schema_registry.request_schema IS 'JSONB documenting expected request parameters and types';


--
-- Name: COLUMN api_schema_registry.response_schema; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.api_schema_registry.response_schema IS 'JSONB documenting actual response structure observed';


--
-- Name: COLUMN api_schema_registry.status; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.api_schema_registry.status IS 'Verification status: PENDING_VERIFICATION, ACTIVE, DEPRECATED, FAILED';


--
-- Name: api_schema_registry_schema_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.api_schema_registry_schema_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: api_schema_registry_schema_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.api_schema_registry_schema_id_seq OWNED BY fhq_meta.api_schema_registry.schema_id;


--
-- Name: asset_classes; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.asset_classes (
    asset_class_id text NOT NULL,
    asset_class_name text NOT NULL,
    description text,
    created_at timestamp with time zone DEFAULT now(),
    created_by text DEFAULT 'STIG'::text
);


--
-- Name: asset_vendor_policy; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.asset_vendor_policy (
    asset_class_id text NOT NULL,
    preferred_vendor text,
    fallback_vendor text,
    verification_method text
);


--
-- Name: assets; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.assets (
    canonical_id text NOT NULL,
    ticker text NOT NULL,
    exchange_mic text NOT NULL,
    asset_class text,
    currency text,
    lot_size numeric,
    tick_size numeric,
    sector text,
    risk_profile text,
    active_flag boolean DEFAULT true,
    vega_signature_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    min_daily_volume_usd numeric,
    required_history_days integer DEFAULT 252,
    gap_policy text,
    liquidity_tier text,
    onboarding_date date,
    data_quality_score numeric(5,2),
    valid_row_count integer DEFAULT 0,
    quarantine_threshold integer DEFAULT 252,
    full_history_threshold integer DEFAULT 1260,
    price_source_field text DEFAULT 'adj_close'::text,
    data_quality_status public.data_quality_status DEFAULT 'QUARANTINED'::public.data_quality_status,
    symbol text,
    asset_type text,
    CONSTRAINT chk_gap_policy CHECK (((gap_policy IS NULL) OR (gap_policy = ANY (ARRAY['INTERPOLATE'::text, 'FORWARD_FILL'::text, 'SKIP_IF_GAP'::text, 'FX_ADJUST'::text])))),
    CONSTRAINT chk_liquidity_tier CHECK (((liquidity_tier IS NULL) OR (liquidity_tier = ANY (ARRAY['TIER_1'::text, 'TIER_2'::text, 'TIER_3'::text, 'ILLIQUID'::text])))),
    CONSTRAINT chk_price_source CHECK (((price_source_field IS NULL) OR (price_source_field = ANY (ARRAY['adj_close'::text, 'close'::text]))))
);


--
-- Name: TABLE assets; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.assets IS 'IoS-001 Canonical Asset Registry. Single source of truth for all tradable instruments in the FjordHQ universe.';


--
-- Name: COLUMN assets.gap_policy; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.assets.gap_policy IS 'Data gap handling: INTERPOLATE, FORWARD_FILL, SKIP_IF_GAP, FX_ADJUST';


--
-- Name: COLUMN assets.valid_row_count; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.assets.valid_row_count IS 'Actual row count with valid price data, not calendar days';


--
-- Name: COLUMN assets.quarantine_threshold; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.assets.quarantine_threshold IS 'Minimum rows before asset exits QUARANTINED (252 Equity/FX, 365 Crypto)';


--
-- Name: COLUMN assets.full_history_threshold; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.assets.full_history_threshold IS '5-year threshold for FULL_HISTORY status (1260 Equity/FX, 1825 Crypto)';


--
-- Name: COLUMN assets.price_source_field; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.assets.price_source_field IS 'Dual Price Ontology: adj_close for signals (Equity), close for Crypto/FX';


--
-- Name: COLUMN assets.data_quality_status; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.assets.data_quality_status IS 'CEO Directive: Iron Curtain status - QUARANTINED blocks IoS-002/003 access';


--
-- Name: aum_allocations; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.aum_allocations (
    allocation_id integer NOT NULL,
    ticker text NOT NULL,
    allocation_pct numeric NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    effective_date date DEFAULT CURRENT_DATE NOT NULL,
    notes text,
    schema_version text DEFAULT '1.0.0'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: aum_allocations_allocation_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.aum_allocations_allocation_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: aum_allocations_allocation_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.aum_allocations_allocation_id_seq OWNED BY fhq_meta.aum_allocations.allocation_id;


--
-- Name: baseline_history; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.baseline_history (
    baseline_id uuid DEFAULT gen_random_uuid() NOT NULL,
    baseline_tag text NOT NULL,
    certified_at timestamp with time zone DEFAULT now() NOT NULL,
    certified_by text NOT NULL,
    audit_cycle_id text NOT NULL,
    status text NOT NULL,
    notes text,
    deprecated_at timestamp with time zone,
    deprecated_by text,
    deprecated_reason text,
    baseline_hash text,
    metadata jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone
);


--
-- Name: baseline_locks; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.baseline_locks (
    lock_id uuid DEFAULT gen_random_uuid() NOT NULL,
    lock_type text NOT NULL,
    lock_scope text NOT NULL,
    lock_hash text NOT NULL,
    locked_by text NOT NULL,
    locked_at timestamp with time zone DEFAULT now() NOT NULL,
    valid_until timestamp with time zone,
    attestation_token text,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT baseline_locks_lock_type_check CHECK ((lock_type = ANY (ARRAY['INTEGRITY'::text, 'GOVERNANCE'::text, 'MODEL_TIER'::text, 'CANONICAL'::text])))
);


--
-- Name: baseline_registry; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.baseline_registry (
    baseline_id integer NOT NULL,
    baseline_name character varying(100) NOT NULL,
    model_id character varying(100),
    test_id character varying(100),
    sharpe_ratio numeric(10,4),
    max_drawdown_pct numeric(10,4),
    locked_at timestamp with time zone DEFAULT now(),
    config_snapshot jsonb,
    verification_hash character varying(64),
    authority character varying(100),
    notes text
);


--
-- Name: baseline_registry_baseline_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.baseline_registry_baseline_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: baseline_registry_baseline_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.baseline_registry_baseline_id_seq OWNED BY fhq_meta.baseline_registry.baseline_id;


--
-- Name: baseline_state; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.baseline_state (
    tag text NOT NULL,
    frozen_at timestamp with time zone NOT NULL,
    frozen_by text NOT NULL,
    notes text,
    validation_hash text,
    hash_algorithm text DEFAULT 'SHA256'::text NOT NULL,
    schema_version text DEFAULT '1.0.0'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: calendar_days; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.calendar_days (
    calendar_id text NOT NULL,
    date date NOT NULL,
    is_open boolean NOT NULL,
    session_open time without time zone,
    session_close time without time zone,
    early_close boolean DEFAULT false,
    notes text
);


--
-- Name: canonical_access_log; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.canonical_access_log (
    access_id uuid DEFAULT gen_random_uuid() NOT NULL,
    access_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    agent_id text NOT NULL,
    operation_type text NOT NULL,
    domain_name text NOT NULL,
    canonical_store text NOT NULL,
    access_context text,
    query_pattern text,
    row_count integer DEFAULT 0,
    access_authorized boolean DEFAULT true NOT NULL,
    bypass_attempted boolean DEFAULT false NOT NULL,
    vega_notified boolean DEFAULT false NOT NULL,
    hash_chain_id text,
    session_id text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT canonical_access_operation_check CHECK ((operation_type = ANY (ARRAY['READ'::text, 'WRITE'::text, 'RESOLVE'::text, 'VALIDATE'::text])))
);


--
-- Name: TABLE canonical_access_log; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.canonical_access_log IS 'ADR-013: Audit trail for all canonical store access. Detects bypass attempts.';


--
-- Name: canonical_asset_groups; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.canonical_asset_groups (
    group_id text NOT NULL,
    asset_class_id text,
    region_scope text,
    description text,
    created_at timestamp with time zone DEFAULT now(),
    created_by text DEFAULT 'STIG'::text,
    activation_status text DEFAULT 'PENDING'::text
);


--
-- Name: canonical_decision_log; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.canonical_decision_log (
    decision_id uuid DEFAULT gen_random_uuid() NOT NULL,
    adr_id character varying(20) NOT NULL,
    adr_title text NOT NULL,
    decision_type character varying(30) NOT NULL,
    canonical_status character varying(50) NOT NULL,
    governance_gate character varying(30) NOT NULL,
    binding_determination text NOT NULL,
    deferred_elements jsonb,
    explicit_non_actions text[],
    annotations text,
    decision_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    decided_by character varying(20) DEFAULT 'CEO'::character varying NOT NULL,
    hash_chain_id character varying(100),
    CONSTRAINT canonical_decision_log_decision_type_check CHECK (((decision_type)::text = ANY (ARRAY[('CANONICALIZE_DOCUMENT'::character varying)::text, ('CANONICALIZE_DATABASE'::character varying)::text, ('DEFER_BY_DESIGN'::character varying)::text])))
);


--
-- Name: TABLE canonical_decision_log; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.canonical_decision_log IS 'G1 Canonical Decision Phase - CEO decisions on document-database divergence resolution. Single source of truth for canonical authority.';


--
-- Name: canonical_document_queue; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.canonical_document_queue (
    queue_id uuid DEFAULT gen_random_uuid() NOT NULL,
    document_path text NOT NULL,
    document_title text NOT NULL,
    document_type character varying(30) NOT NULL,
    requested_by character varying(20) DEFAULT 'STIG'::character varying NOT NULL,
    authorized_by character varying(20),
    authorization_timestamp timestamp with time zone,
    authorization_notes text,
    ingestion_status character varying(20) DEFAULT 'PENDING_AUTHORIZATION'::character varying NOT NULL,
    analytical_purpose text NOT NULL,
    priority_order integer,
    chunk_count integer,
    ingestion_timestamp timestamp with time zone,
    content_hash text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    reconciliation_status character varying(20) DEFAULT 'PENDING'::character varying,
    claims_extracted integer DEFAULT 0,
    mismatches_found integer DEFAULT 0,
    reconciliation_timestamp timestamp with time zone,
    reconciliation_notes text,
    CONSTRAINT canonical_document_queue_document_type_check CHECK (((document_type)::text = ANY (ARRAY[('ADR'::character varying)::text, ('IOS'::character varying)::text, ('DIRECTIVE'::character varying)::text, ('RESEARCH'::character varying)::text, ('MACRO'::character varying)::text, ('SIGNAL'::character varying)::text, ('OTHER'::character varying)::text]))),
    CONSTRAINT canonical_document_queue_ingestion_status_check CHECK (((ingestion_status)::text = ANY (ARRAY[('PENDING_AUTHORIZATION'::character varying)::text, ('AUTHORIZED'::character varying)::text, ('INGESTING'::character varying)::text, ('COMPLETE'::character varying)::text, ('REJECTED'::character varying)::text]))),
    CONSTRAINT canonical_document_queue_reconciliation_status_check CHECK (((reconciliation_status)::text = ANY (ARRAY[('PENDING'::character varying)::text, ('ALIGNED'::character varying)::text, ('DIVERGENT'::character varying)::text, ('DEFERRED'::character varying)::text])))
);


--
-- Name: TABLE canonical_document_queue; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.canonical_document_queue IS 'CEO-controlled document ingestion queue. STIG may request documents but cannot independently select them for ingestion. Only CEO-authorized documents may be loaded.';


--
-- Name: canonical_documents; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.canonical_documents (
    document_id uuid DEFAULT gen_random_uuid() NOT NULL,
    document_type text NOT NULL,
    document_code text NOT NULL,
    title text NOT NULL,
    version text DEFAULT '2026.PRODUCTION'::text NOT NULL,
    status text NOT NULL,
    tier integer,
    owner text NOT NULL,
    content_hash text NOT NULL,
    content_text text,
    source_path text NOT NULL,
    ingestion_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    source text DEFAULT 'CANONICAL_DOCUMENT'::text NOT NULL,
    ingestion_directive text DEFAULT 'CEO-DIR-2025-INGEST-001'::text,
    vega_attested boolean DEFAULT false NOT NULL,
    vega_attestation_id uuid,
    governing_adrs text[],
    dependencies text[],
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT canonical_documents_document_type_check CHECK ((document_type = ANY (ARRAY['ADR'::text, 'IoS'::text, 'EC'::text, 'APPENDIX'::text, 'SYNTHESIS'::text]))),
    CONSTRAINT canonical_documents_status_check CHECK ((status = ANY (ARRAY['ACTIVE'::text, 'DRAFT'::text, 'DEPRECATED'::text, 'SUPERSEDED'::text, 'FROZEN'::text, 'RESERVED'::text, 'FRAMEWORK_CHARTER'::text]))),
    CONSTRAINT canonical_documents_tier_check CHECK (((tier >= 1) AND (tier <= 4)))
);


--
-- Name: TABLE canonical_documents; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.canonical_documents IS 'First-order truth store for constitutional documents. Per CEO-DIR-2025-INGEST-001.
LAYER 8: Observability & Audit Layer. NOT a replacement for Layer 1 file documents.
One-way authority: Files  canonical_documents  runtime registries.
Ingestion = readability only, NOT activation authority.';


--
-- Name: COLUMN canonical_documents.status; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.canonical_documents.status IS 'Document status. FROZEN = cognitive engine not activated. See CEO-DIR-2025-ACT-001.';


--
-- Name: COLUMN canonical_documents.content_hash; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.canonical_documents.content_hash IS 'SHA-256 hash of content_text for integrity verification.';


--
-- Name: COLUMN canonical_documents.content_text; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.canonical_documents.content_text IS 'Full document text as first-order truth. ACI and VEGA may query this directly.';


--
-- Name: canonical_domain_registry; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.canonical_domain_registry (
    domain_id uuid DEFAULT gen_random_uuid() NOT NULL,
    domain_name text NOT NULL,
    domain_category text NOT NULL,
    canonical_store text NOT NULL,
    canonical_schema text NOT NULL,
    canonical_table text NOT NULL,
    description text NOT NULL,
    data_contract jsonb DEFAULT '{}'::jsonb NOT NULL,
    lineage_config jsonb DEFAULT '{}'::jsonb NOT NULL,
    resolution_rules jsonb DEFAULT '{}'::jsonb NOT NULL,
    timestamp_standard text DEFAULT 'UTC'::text NOT NULL,
    read_access_agents text[] DEFAULT ARRAY['LARS'::text, 'FINN'::text, 'STIG'::text, 'LINE'::text, 'VEGA'::text] NOT NULL,
    write_access_agents text[] DEFAULT ARRAY['VEGA'::text] NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    is_canonical boolean DEFAULT true NOT NULL,
    adr_reference text DEFAULT 'ADR-013'::text NOT NULL,
    governance_level text DEFAULT 'CONSTITUTIONAL'::text NOT NULL,
    requires_vega_attestation boolean DEFAULT true NOT NULL,
    created_by text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_by text,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    hash_chain_id text,
    signature text,
    CONSTRAINT canonical_domain_canonical_check CHECK ((is_canonical = true)),
    CONSTRAINT canonical_domain_category_check CHECK ((domain_category = ANY (ARRAY['PRICES'::text, 'INDICATORS'::text, 'FUNDAMENTALS'::text, 'SENTIMENT'::text, 'ONCHAIN'::text, 'EMBEDDINGS'::text, 'KG_METRICS'::text, 'MACRO'::text, 'RESEARCH'::text, 'GOVERNANCE'::text, 'AUDIT'::text, 'SYSTEM'::text]))),
    CONSTRAINT canonical_domain_store_format CHECK ((canonical_store ~ '^[a-z_0-9]+\.[a-z_0-9]+$'::text))
);


--
-- Name: TABLE canonical_domain_registry; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.canonical_domain_registry IS 'ADR-013: Central registry for all canonical data domain stores. VEGA has write authority.';


--
-- Name: canonical_indicator_registry; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.canonical_indicator_registry (
    indicator_id uuid DEFAULT gen_random_uuid() NOT NULL,
    domain_id uuid NOT NULL,
    indicator_name text NOT NULL,
    indicator_version text DEFAULT '1.0'::text NOT NULL,
    calculation_method text NOT NULL,
    canonical_table text NOT NULL,
    asset_universe text[] DEFAULT ARRAY['*'::text] NOT NULL,
    default_parameters jsonb DEFAULT '{}'::jsonb NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    is_canonical boolean DEFAULT true NOT NULL,
    created_by text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    hash_chain_id text,
    signature text,
    category text,
    source_standard text,
    ios_module text DEFAULT 'IoS-002'::text,
    formula_hash text,
    vega_signature_id uuid,
    price_input_field text DEFAULT 'adj_close'::text,
    CONSTRAINT canonical_indicator_canonical_check CHECK ((is_canonical = true)),
    CONSTRAINT chk_indicator_category CHECK (((category IS NULL) OR (category = ANY (ARRAY['MOMENTUM'::text, 'TREND'::text, 'VOLATILITY'::text, 'ICHIMOKU'::text, 'VOLUME'::text, 'BREADTH'::text])))),
    CONSTRAINT chk_indicator_price_input CHECK (((price_input_field IS NULL) OR (price_input_field = ANY (ARRAY['adj_close'::text, 'close'::text]))))
);


--
-- Name: TABLE canonical_indicator_registry; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.canonical_indicator_registry IS 'ADR-013: Enforces exactly one canonical value per (indicator, asset, timestamp, method) combination.';


--
-- Name: COLUMN canonical_indicator_registry.category; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.canonical_indicator_registry.category IS 'GIPS-aligned indicator taxonomy: MOMENTUM, TREND, VOLATILITY, ICHIMOKU, VOLUME';


--
-- Name: COLUMN canonical_indicator_registry.source_standard; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.canonical_indicator_registry.source_standard IS 'Academic reference (e.g., Wilder 1978, Appel 1979)';


--
-- Name: COLUMN canonical_indicator_registry.formula_hash; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.canonical_indicator_registry.formula_hash IS 'SHA-256 hash of calculation logic for reproducibility';


--
-- Name: COLUMN canonical_indicator_registry.price_input_field; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.canonical_indicator_registry.price_input_field IS 'Dual Price Ontology: which price field indicators use';


--
-- Name: canonical_ingestion_registry; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.canonical_ingestion_registry (
    ingestion_id uuid DEFAULT gen_random_uuid() NOT NULL,
    job_name text NOT NULL,
    job_type text NOT NULL,
    domain_id uuid NOT NULL,
    target_canonical_store text NOT NULL,
    asset_universe text[] DEFAULT ARRAY['*'::text] NOT NULL,
    frequencies text[] DEFAULT ARRAY['1d'::text] NOT NULL,
    vendor_sources text[] NOT NULL,
    primary_vendor text NOT NULL,
    orchestrator_registered boolean DEFAULT false NOT NULL,
    orchestrator_task_id uuid,
    vega_approved boolean DEFAULT false NOT NULL,
    vega_approval_id uuid,
    requires_reconciliation boolean DEFAULT true NOT NULL,
    reconciliation_threshold numeric(5,4) DEFAULT 0.10 NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    last_run_at timestamp with time zone,
    last_run_status text,
    created_by text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    hash_chain_id text,
    signature text,
    CONSTRAINT canonical_ingestion_type_check CHECK ((job_type = ANY (ARRAY['SCHEDULED'::text, 'REAL_TIME'::text, 'BACKFILL'::text, 'MANUAL'::text, 'EVENT_DRIVEN'::text])))
);


--
-- Name: TABLE canonical_ingestion_registry; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.canonical_ingestion_registry IS 'ADR-013: Registry of all ingestion jobs writing to canonical stores.';


--
-- Name: canonical_mismatches; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.canonical_mismatches (
    mismatch_id uuid DEFAULT gen_random_uuid() NOT NULL,
    claim_id uuid,
    document_path text NOT NULL,
    mismatch_type character varying(50) NOT NULL,
    severity character varying(20) DEFAULT 'MEDIUM'::character varying NOT NULL,
    document_claim text NOT NULL,
    document_section text,
    database_reality text,
    database_evidence text,
    resolution_status character varying(30) DEFAULT 'UNRESOLVED'::character varying NOT NULL,
    resolution_decision_by character varying(20),
    resolution_timestamp timestamp with time zone,
    resolution_notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT canonical_mismatches_mismatch_type_check CHECK (((mismatch_type)::text = ANY (ARRAY[('MISSING_SCHEMA'::character varying)::text, ('MISSING_TABLE'::character varying)::text, ('MISSING_COLUMN'::character varying)::text, ('MISSING_CONSTRAINT'::character varying)::text, ('MISSING_FUNCTION'::character varying)::text, ('MISSING_INDEX'::character varying)::text, ('SEMANTIC_DRIFT'::character varying)::text, ('PARTIAL_IMPLEMENTATION'::character varying)::text, ('CONFLICTING_DEFINITION'::character varying)::text, ('DEPRECATED_REFERENCE'::character varying)::text, ('UNIMPLEMENTED_INTENT'::character varying)::text, ('OTHER'::character varying)::text]))),
    CONSTRAINT canonical_mismatches_resolution_status_check CHECK (((resolution_status)::text = ANY (ARRAY[('UNRESOLVED'::character varying)::text, ('FIX_DOCUMENT'::character varying)::text, ('FIX_DATABASE'::character varying)::text, ('TOLERATE_BY_DESIGN'::character varying)::text, ('DEPRECATE'::character varying)::text, ('DEFERRED'::character varying)::text]))),
    CONSTRAINT canonical_mismatches_severity_check CHECK (((severity)::text = ANY (ARRAY[('LOW'::character varying)::text, ('MEDIUM'::character varying)::text, ('HIGH'::character varying)::text, ('CRITICAL'::character varying)::text])))
);


--
-- Name: TABLE canonical_mismatches; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.canonical_mismatches IS 'G1 Reconciliation: All document-database mismatches. No remediation implied. Discovery precedes correction. CEO sole authority for resolution.';


--
-- Name: canonical_series_registry; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.canonical_series_registry (
    series_id uuid DEFAULT gen_random_uuid() NOT NULL,
    domain_id uuid NOT NULL,
    asset_id text NOT NULL,
    listing_id text,
    frequency text NOT NULL,
    price_type text DEFAULT 'OHLCV'::text NOT NULL,
    canonical_table text NOT NULL,
    series_identifier text NOT NULL,
    start_timestamp timestamp with time zone,
    end_timestamp timestamp with time zone,
    data_points integer DEFAULT 0,
    primary_vendor text NOT NULL,
    vendor_sources text[],
    completeness_score numeric(5,4) DEFAULT 1.0000,
    quality_score numeric(5,4) DEFAULT 1.0000,
    last_quality_check timestamp with time zone,
    is_active boolean DEFAULT true NOT NULL,
    is_canonical boolean DEFAULT true NOT NULL,
    created_by text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    hash_chain_id text,
    signature text,
    CONSTRAINT canonical_series_canonical_check CHECK ((is_canonical = true))
);


--
-- Name: TABLE canonical_series_registry; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.canonical_series_registry IS 'ADR-013: Enforces exactly one canonical series per (asset_id, frequency, price_type) combination.';


--
-- Name: canonical_violation_log; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.canonical_violation_log (
    violation_id uuid DEFAULT gen_random_uuid() NOT NULL,
    violation_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    violation_type text NOT NULL,
    discrepancy_class text DEFAULT 'CLASS_C'::text NOT NULL,
    severity_score numeric(5,4) DEFAULT 0.0 NOT NULL,
    domain_name text,
    conflicting_stores text[],
    conflict_description text NOT NULL,
    evidence_bundle jsonb DEFAULT '{}'::jsonb NOT NULL,
    sample_data jsonb,
    detected_by text NOT NULL,
    detection_method text NOT NULL,
    resolution_status text DEFAULT 'OPEN'::text NOT NULL,
    resolution_action text,
    resolved_by text,
    resolved_at timestamp with time zone,
    vega_escalated boolean DEFAULT false NOT NULL,
    vega_escalation_id uuid,
    ceo_notified boolean DEFAULT false NOT NULL,
    governance_event_id uuid,
    adr_reference text DEFAULT 'ADR-013'::text NOT NULL,
    hash_chain_id text,
    signature text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT canonical_violation_class_check CHECK ((discrepancy_class = ANY (ARRAY['CLASS_A'::text, 'CLASS_B'::text, 'CLASS_C'::text]))),
    CONSTRAINT canonical_violation_status_check CHECK ((resolution_status = ANY (ARRAY['OPEN'::text, 'IN_PROGRESS'::text, 'RESOLVED'::text, 'ESCALATED'::text, 'SUSPENDED'::text]))),
    CONSTRAINT canonical_violation_type_check CHECK ((violation_type = ANY (ARRAY['DUPLICATE_DOMAIN'::text, 'DUPLICATE_SERIES'::text, 'DUPLICATE_INDICATOR'::text, 'CONFLICTING_VALUES'::text, 'UNAUTHORIZED_ACCESS'::text, 'BYPASS_ATTEMPT'::text, 'NON_CANONICAL_READ'::text, 'MULTI_TRUTH_DETECTED'::text, 'INGESTION_CONFLICT'::text])))
);


--
-- Name: TABLE canonical_violation_log; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.canonical_violation_log IS 'ADR-013: Records all multi-truth violations for governance review.';


--
-- Name: chain_of_query; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.chain_of_query (
    coq_id uuid DEFAULT gen_random_uuid() NOT NULL,
    interaction_id uuid NOT NULL,
    node_index integer NOT NULL,
    node_type character varying(30) NOT NULL,
    node_content text NOT NULL,
    node_rationale text,
    verification_status character varying(20) DEFAULT 'PENDING'::character varying NOT NULL,
    verification_evidence jsonb,
    verified_at timestamp with time zone,
    search_query text,
    search_result_summary text,
    search_result_hash character varying(64),
    revision_trigger text,
    prior_plan_hash character varying(64),
    new_plan_hash character varying(64),
    tokens_consumed integer DEFAULT 0,
    cost_usd numeric(10,6) DEFAULT 0,
    parent_node_id uuid,
    depth integer DEFAULT 0 NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT chain_of_query_node_type_check CHECK (((node_type)::text = ANY (ARRAY[('PLAN_INIT'::character varying)::text, ('REASONING'::character varying)::text, ('SEARCH'::character varying)::text, ('VERIFICATION'::character varying)::text, ('PLAN_REVISION'::character varying)::text, ('SYNTHESIS'::character varying)::text, ('ABORT'::character varying)::text]))),
    CONSTRAINT chain_of_query_verification_status_check CHECK (((verification_status)::text = ANY (ARRAY[('PENDING'::character varying)::text, ('VERIFIED'::character varying)::text, ('FAILED'::character varying)::text, ('SKIPPED'::character varying)::text, ('ABORTED'::character varying)::text])))
);


--
-- Name: TABLE chain_of_query; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.chain_of_query IS 'EC-020 SitC Engine - Chain of Query. Dynamic planning with interleaved search and verification.';


--
-- Name: cognitive_engine_evidence; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.cognitive_engine_evidence (
    evidence_id uuid DEFAULT gen_random_uuid() NOT NULL,
    engine_id character varying(10) NOT NULL,
    engine_name character varying(20) NOT NULL,
    interaction_id uuid NOT NULL,
    coq_node_id uuid,
    invocation_type character varying(50) NOT NULL,
    input_context jsonb NOT NULL,
    state_snapshot_hash character varying(64) NOT NULL,
    decision_rationale text NOT NULL,
    output_modification jsonb,
    cost_usd numeric(10,6) DEFAULT 0,
    information_gain_score numeric(5,4),
    chain_integrity_score numeric(5,4),
    boundary_violation boolean DEFAULT false,
    signature character varying(128),
    signature_algorithm character varying(20) DEFAULT 'Ed25519'::character varying,
    hash_prev character varying(64),
    hash_self character varying(64),
    hash_chain_id character varying(100),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT cognitive_engine_evidence_engine_id_check CHECK (((engine_id)::text = ANY (ARRAY[('EC-020'::character varying)::text, ('EC-021'::character varying)::text, ('EC-022'::character varying)::text]))),
    CONSTRAINT cognitive_engine_evidence_engine_name_check CHECK (((engine_name)::text = ANY (ARRAY[('SitC'::character varying)::text, ('InForage'::character varying)::text, ('IKEA'::character varying)::text])))
);


--
-- Name: TABLE cognitive_engine_evidence; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.cognitive_engine_evidence IS 'ADR-021 CECF-7 - Cognitive Engine Evidence Bundles. Full lineage for every engine invocation.';


--
-- Name: cot_reasoning_logs; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.cot_reasoning_logs (
    log_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id text DEFAULT 'cseo'::text NOT NULL,
    reasoning_chain_id text NOT NULL,
    session_id text,
    prompt_hash text NOT NULL,
    thought_sequence jsonb NOT NULL,
    inference_steps integer NOT NULL,
    confidence_score numeric(5,4),
    alternatives_considered jsonb,
    final_recommendation text,
    discrepancy_score numeric(5,4),
    vega_audit_status text DEFAULT 'PENDING'::text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    evidence_bundle jsonb,
    CONSTRAINT cot_reasoning_logs_confidence_score_check CHECK (((confidence_score >= (0)::numeric) AND (confidence_score <= (1)::numeric))),
    CONSTRAINT cot_reasoning_logs_vega_audit_status_check CHECK ((vega_audit_status = ANY (ARRAY['PENDING'::text, 'APPROVED'::text, 'FLAGGED'::text, 'REJECTED'::text])))
);


--
-- Name: countries; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.countries (
    country_code text NOT NULL,
    country_name text NOT NULL,
    region_id text,
    currency_code text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: data_lineage_log; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.data_lineage_log (
    lineage_id uuid DEFAULT gen_random_uuid() NOT NULL,
    source_table text NOT NULL,
    source_id uuid,
    transformation text NOT NULL,
    target_table text NOT NULL,
    target_id uuid,
    "timestamp" timestamp without time zone DEFAULT now() NOT NULL,
    executed_by text NOT NULL,
    sha256_hash text,
    metadata jsonb
);


--
-- Name: TABLE data_lineage_log; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.data_lineage_log IS 'ADR-006 5.8: Immutable data lineage: Raw  Indicators  Regimes  Signals (Owner: VEGA)';


--
-- Name: data_lineage_log_lineage_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.data_lineage_log_lineage_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: data_lineage_log_lineage_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.data_lineage_log_lineage_id_seq OWNED BY fhq_meta.data_lineage_log.lineage_id;


--
-- Name: data_quality_rules; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.data_quality_rules (
    id integer NOT NULL,
    rule_name text NOT NULL,
    rule_type text NOT NULL,
    table_name text NOT NULL,
    column_name text,
    threshold_value numeric,
    severity text DEFAULT 'warning'::text,
    is_active boolean DEFAULT true,
    auto_reject boolean DEFAULT false,
    description text NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: data_quality_rules_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.data_quality_rules_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: data_quality_rules_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.data_quality_rules_id_seq OWNED BY fhq_meta.data_quality_rules.id;


--
-- Name: data_source_registry; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.data_source_registry (
    source_id text NOT NULL,
    source_name text NOT NULL,
    source_type text NOT NULL,
    base_url text,
    known_issues text[],
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: document_claims; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.document_claims (
    claim_id uuid DEFAULT gen_random_uuid() NOT NULL,
    document_id uuid,
    document_path text NOT NULL,
    document_section text,
    claim_type character varying(50) NOT NULL,
    claim_text text NOT NULL,
    claim_context text,
    database_object_type character varying(30),
    database_object_name text,
    database_schema text,
    verification_status character varying(30) DEFAULT 'PENDING'::character varying NOT NULL,
    verification_evidence text,
    verification_timestamp timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT document_claims_claim_type_check CHECK (((claim_type)::text = ANY (ARRAY[('SCHEMA_REQUIRED'::character varying)::text, ('TABLE_REQUIRED'::character varying)::text, ('COLUMN_REQUIRED'::character varying)::text, ('CONSTRAINT_REQUIRED'::character varying)::text, ('INDEX_REQUIRED'::character varying)::text, ('FUNCTION_REQUIRED'::character varying)::text, ('ROLE_AUTHORITY'::character varying)::text, ('BEHAVIORAL_CONSTRAINT'::character varying)::text, ('GOVERNANCE_RULE'::character varying)::text, ('WORKFLOW_STEP'::character varying)::text, ('INTEGRATION_REQUIREMENT'::character varying)::text, ('OTHER'::character varying)::text]))),
    CONSTRAINT document_claims_verification_status_check CHECK (((verification_status)::text = ANY (ARRAY[('PENDING'::character varying)::text, ('PRESENT'::character varying)::text, ('ABSENT'::character varying)::text, ('PARTIAL'::character varying)::text, ('SEMANTICALLY_INCONSISTENT'::character varying)::text])))
);


--
-- Name: TABLE document_claims; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.document_claims IS 'G1 Reconciliation: Explicit and implicit claims extracted from canonical documents. Each claim verified against database reality.';


--
-- Name: document_database_reconciliation; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.document_database_reconciliation (
    reconciliation_id uuid DEFAULT gen_random_uuid() NOT NULL,
    interaction_id uuid,
    session_id uuid,
    reconciliation_type character varying(50) NOT NULL,
    document_id character varying(50) NOT NULL,
    document_section character varying(100),
    document_claim text NOT NULL,
    document_hash character varying(64),
    target_schema character varying(50),
    target_object character varying(100),
    target_type character varying(30),
    alignment_status character varying(20) NOT NULL,
    divergence_description text,
    divergence_severity character varying(20),
    database_evidence jsonb,
    document_evidence jsonb,
    sitc_chain_id uuid,
    reasoning_trace text,
    resolution_status character varying(20) DEFAULT 'OPEN'::character varying,
    resolution_notes text,
    resolved_by character varying(50),
    resolved_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT document_database_reconciliation_alignment_status_check CHECK (((alignment_status)::text = ANY (ARRAY[('ALIGNED'::character varying)::text, ('DIVERGENT'::character varying)::text, ('MISSING'::character varying)::text, ('UNDOCUMENTED'::character varying)::text, ('UNKNOWN'::character varying)::text]))),
    CONSTRAINT document_database_reconciliation_divergence_severity_check CHECK (((divergence_severity)::text = ANY (ARRAY[('LOW'::character varying)::text, ('MEDIUM'::character varying)::text, ('HIGH'::character varying)::text, ('CRITICAL'::character varying)::text]))),
    CONSTRAINT document_database_reconciliation_reconciliation_type_check CHECK (((reconciliation_type)::text = ANY (ARRAY[('ADR_VS_SCHEMA'::character varying)::text, ('ADR_VS_FUNCTION'::character varying)::text, ('ADR_VS_CONFIG'::character varying)::text, ('IOS_VS_TABLE'::character varying)::text, ('EC_VS_IMPLEMENTATION'::character varying)::text, ('CROSS_ADR_CONSISTENCY'::character varying)::text]))),
    CONSTRAINT document_database_reconciliation_resolution_status_check CHECK (((resolution_status)::text = ANY (ARRAY[('OPEN'::character varying)::text, ('ACKNOWLEDGED'::character varying)::text, ('RESOLVED'::character varying)::text, ('WONT_FIX'::character varying)::text, ('ESCALATED'::character varying)::text])))
);


--
-- Name: TABLE document_database_reconciliation; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.document_database_reconciliation IS 'CEO Directive G0.1 7 - Document-Database Reconciliation. Tracks alignment between constitution and implementation.';


--
-- Name: dynamic_regime_weights; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.dynamic_regime_weights (
    id integer NOT NULL,
    calibration_id text NOT NULL,
    asset_id text NOT NULL,
    state_id integer NOT NULL,
    calibration_date date NOT NULL,
    calibration_window_start date NOT NULL,
    calibration_window_end date NOT NULL,
    regime_weight numeric(5,3) NOT NULL,
    classification text NOT NULL,
    sample_count integer NOT NULL,
    avg_return numeric(10,6),
    volatility numeric(10,6),
    sharpe_ratio numeric(10,6),
    max_drawdown numeric(10,6),
    win_rate numeric(5,4),
    confidence_score numeric(5,4),
    checksum text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT valid_weight CHECK (((regime_weight >= '-1.0'::numeric) AND (regime_weight <= 1.0)))
);


--
-- Name: TABLE dynamic_regime_weights; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.dynamic_regime_weights IS 'ADR-035R3: Dynamic regime weights calculated on rolling 252-day windows. 
Each row represents asset-specific weight for a regime state at a given calibration date.
Enables adaptive strategy that responds to non-stationary market characteristics.';


--
-- Name: dynamic_regime_weights_audit; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.dynamic_regime_weights_audit (
    id integer NOT NULL,
    listing_id text NOT NULL,
    regime_state integer NOT NULL,
    calibration_date date NOT NULL,
    window_start date NOT NULL,
    window_end date NOT NULL,
    weight_value numeric(10,6) NOT NULL,
    psrf numeric(10,4),
    ess numeric(12,2),
    sharpe_ratio numeric(10,4),
    sortino_ratio numeric(10,4),
    max_drawdown numeric(10,4),
    win_rate numeric(10,4),
    momentum_weight numeric(10,6),
    mean_reversion_weight numeric(10,6),
    volatility_weight numeric(10,6),
    data_hash text NOT NULL,
    weight_hash text NOT NULL,
    model_id text NOT NULL,
    governance_score integer DEFAULT 100,
    executed_by text DEFAULT 'STIG'::text,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT valid_ess CHECK (((ess IS NULL) OR (ess > (0)::numeric))),
    CONSTRAINT valid_governance CHECK (((governance_score >= 0) AND (governance_score <= 100))),
    CONSTRAINT valid_psrf CHECK (((psrf IS NULL) OR (psrf > (0)::numeric)))
);


--
-- Name: dynamic_regime_weights_audit_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.dynamic_regime_weights_audit_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: dynamic_regime_weights_audit_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.dynamic_regime_weights_audit_id_seq OWNED BY fhq_meta.dynamic_regime_weights_audit.id;


--
-- Name: dynamic_regime_weights_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.dynamic_regime_weights_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: dynamic_regime_weights_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.dynamic_regime_weights_id_seq OWNED BY fhq_meta.dynamic_regime_weights.id;


--
-- Name: ec_authority_resolutions; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.ec_authority_resolutions (
    resolution_id uuid DEFAULT gen_random_uuid() NOT NULL,
    directive_id character varying(100) NOT NULL,
    ec_id character varying(20) NOT NULL,
    agent_id character varying(50),
    resolution_type character varying(50) NOT NULL,
    prior_state jsonb,
    resolved_state jsonb NOT NULL,
    resolution_note text NOT NULL,
    authorized_by character varying(20) DEFAULT 'CEO'::character varying NOT NULL,
    effective_from timestamp with time zone DEFAULT now() NOT NULL,
    effective_until timestamp with time zone,
    supersedes_resolution_id uuid,
    hash_chain_id character varying(100),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT ec_authority_resolutions_resolution_type_check CHECK (((resolution_type)::text = ANY (ARRAY[('TIER_PROVISIONAL'::character varying)::text, ('TIER_RATIFICATION'::character varying)::text, ('TIER_ROLLBACK'::character varying)::text, ('DOMAIN_CORRECTION'::character varying)::text, ('SEMANTIC_CLARIFICATION'::character varying)::text, ('RECLASSIFICATION'::character varying)::text, ('DEPRECATION'::character varying)::text, ('ACTIVATION'::character varying)::text])))
);


--
-- Name: TABLE ec_authority_resolutions; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.ec_authority_resolutions IS 'G1.3: CEO Authority Resolution Registry. Records explicit CEO determinations on EC authority without modifying immutable governance tables. Canonical authority source for EC interpretations.';


--
-- Name: exchanges; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.exchanges (
    mic text NOT NULL,
    exchange_name text NOT NULL,
    country_code text NOT NULL,
    timezone text,
    currency text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: external_taxonomy_map; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.external_taxonomy_map (
    external_id text NOT NULL,
    external_system text NOT NULL,
    internal_group_id text,
    mapping_type text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: file_cleanup_audit; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.file_cleanup_audit (
    audit_id uuid DEFAULT gen_random_uuid() NOT NULL,
    phase text NOT NULL,
    file_path text NOT NULL,
    adr_id text,
    action text NOT NULL,
    reason text NOT NULL,
    evidence text,
    performed_at timestamp with time zone DEFAULT now(),
    performed_by text DEFAULT 'claude_phase0_completion'::text
);


--
-- Name: finn_pamphlets; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.finn_pamphlets (
    pamphlet_id uuid DEFAULT gen_random_uuid() NOT NULL,
    trigger_type text NOT NULL,
    regime_tags text[] DEFAULT '{}'::text[] NOT NULL,
    asset_class text,
    volatility_band text,
    failure_type text,
    trigger_conditions jsonb NOT NULL,
    guidance_text text NOT NULL,
    lesson_summary text,
    effectiveness_score numeric(4,3) DEFAULT 0.5,
    usage_count integer DEFAULT 0,
    last_used_at timestamp with time zone,
    source_batch_id text,
    source_run_number integer,
    generating_agent text DEFAULT 'FINN'::text NOT NULL,
    provenance_hash text NOT NULL,
    signature text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    expires_at timestamp with time zone,
    is_active boolean DEFAULT true NOT NULL,
    superseded_by uuid,
    sitc_chain_id uuid,
    inforage_cost_saved numeric(10,4),
    ikea_classification text,
    CONSTRAINT finn_pamphlets_trigger_type_check CHECK ((trigger_type = ANY (ARRAY['DRAWDOWN_EXCURSION'::text, 'MISSED_OPPORTUNITY'::text, 'OVER_RETRIEVAL'::text, 'REGIME_TRANSITION'::text, 'CHAIN_FAILURE'::text, 'HALLUCINATION_BLOCKED'::text, 'COST_OVERRUN'::text]))),
    CONSTRAINT finn_pamphlets_volatility_band_check CHECK ((volatility_band = ANY (ARRAY['LOW'::text, 'MEDIUM'::text, 'HIGH'::text, 'EXTREME'::text])))
);


--
-- Name: freedom_metrics; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.freedom_metrics (
    metric_id uuid DEFAULT gen_random_uuid() NOT NULL,
    metric_date date NOT NULL,
    alpha_precision numeric(5,4),
    signal_accuracy numeric(5,4),
    win_rate numeric(5,4),
    oversight_minutes integer DEFAULT 0,
    intervention_count integer DEFAULT 0,
    anxiety_score integer,
    freedom_score numeric(8,4) GENERATED ALWAYS AS (
CASE
    WHEN (oversight_minutes > 0) THEN ((COALESCE(alpha_precision, (0)::numeric) * (100)::numeric) / (oversight_minutes)::numeric)
    ELSE NULL::numeric
END) STORED,
    capital_usd numeric(12,2),
    daily_pnl_usd numeric(12,2),
    cumulative_pnl_usd numeric(12,2),
    target_capital numeric(12,2) DEFAULT 1000000,
    progress_pct numeric(8,4) GENERATED ALWAYS AS (
CASE
    WHEN (target_capital > (0)::numeric) THEN ((capital_usd / target_capital) * (100)::numeric)
    ELSE (0)::numeric
END) STORED,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT freedom_metrics_anxiety_score_check CHECK (((anxiety_score >= 1) AND (anxiety_score <= 10)))
);


--
-- Name: function_registry; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.function_registry (
    registry_id uuid DEFAULT gen_random_uuid() NOT NULL,
    function_schema text NOT NULL,
    function_name text NOT NULL,
    function_signature text NOT NULL,
    canonical_hash text NOT NULL,
    migration_hash text,
    hash_algorithm text DEFAULT 'SHA-256'::text NOT NULL,
    function_type text NOT NULL,
    security_definer boolean DEFAULT false NOT NULL,
    volatility text,
    owned_by_agent text NOT NULL,
    task_name text,
    registry_status text DEFAULT 'REGISTERED'::text NOT NULL,
    hash_verified boolean DEFAULT false NOT NULL,
    hash_verified_at timestamp with time zone,
    last_drift_check timestamp with time zone,
    drift_detected boolean DEFAULT false NOT NULL,
    drift_details text,
    created_by text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    hash_chain_id text,
    signature_id uuid,
    CONSTRAINT function_registry_function_type_check CHECK ((function_type = ANY (ARRAY['PLPGSQL'::text, 'SQL'::text, 'C'::text, 'INTERNAL'::text]))),
    CONSTRAINT function_registry_registry_status_check CHECK ((registry_status = ANY (ARRAY['REGISTERED'::text, 'ACTIVE'::text, 'DEPRECATED'::text, 'COMPROMISED'::text]))),
    CONSTRAINT function_registry_volatility_check CHECK ((volatility = ANY (ARRAY['IMMUTABLE'::text, 'STABLE'::text, 'VOLATILE'::text])))
);


--
-- Name: TABLE function_registry; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.function_registry IS 'Canonical function registry with SHA-256 hashes for integrity verification per ADR-011';


--
-- Name: function_versions; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.function_versions (
    id integer NOT NULL,
    function_name text NOT NULL,
    function_type text NOT NULL,
    version text NOT NULL,
    deployed_at timestamp with time zone DEFAULT now(),
    deprecated_at timestamp with time zone,
    code_hash text,
    change_summary text NOT NULL,
    related_issue text,
    input_signature jsonb,
    output_signature jsonb,
    performance_notes text,
    deprecated_reason text,
    schema_version text DEFAULT '1.0.0'::text NOT NULL,
    hash_algorithm text DEFAULT 'SHA256'::text NOT NULL,
    schema_name text,
    parameters jsonb,
    return_type text,
    purpose text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: function_versions_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.function_versions_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: function_versions_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.function_versions_id_seq OWNED BY fhq_meta.function_versions.id;


--
-- Name: functions_registry; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.functions_registry (
    id bigint NOT NULL,
    name text NOT NULL,
    type text NOT NULL,
    schema_name text,
    category text,
    description text,
    input_signature jsonb,
    output_signature jsonb,
    version text,
    code_hash text,
    last_executed_at timestamp with time zone,
    execution_count bigint,
    avg_execution_time_ms numeric,
    error_rate numeric,
    is_active boolean DEFAULT true
);


--
-- Name: functions_registry_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.functions_registry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: functions_registry_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.functions_registry_id_seq OWNED BY fhq_meta.functions_registry.id;


--
-- Name: g1_activation_registry; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.g1_activation_registry (
    activation_id uuid DEFAULT gen_random_uuid() NOT NULL,
    g1_start_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    g1_status character varying(20) DEFAULT 'ACTIVE'::character varying NOT NULL,
    authority_level integer DEFAULT 3 NOT NULL,
    execution_mode character varying(20) DEFAULT 'SHADOW_PAPER'::character varying NOT NULL,
    write_access boolean DEFAULT false NOT NULL,
    allocation_rights boolean DEFAULT false NOT NULL,
    autonomous_behavior boolean DEFAULT false NOT NULL,
    insights_generated integer DEFAULT 0 NOT NULL,
    insights_acted_upon integer DEFAULT 0 NOT NULL,
    time_saved_estimate_minutes integer DEFAULT 0 NOT NULL,
    decision_clarity_score numeric(3,2),
    alpha_veto_compressions integer DEFAULT 0 NOT NULL,
    alpha_veto_full_analyses integer DEFAULT 0 NOT NULL,
    compression_useful_rate numeric(5,4),
    g2_proposal_issued boolean DEFAULT false NOT NULL,
    g1_failure_declared boolean DEFAULT false NOT NULL,
    ceo_termination boolean DEFAULT false NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT g1_activation_registry_allocation_rights_check CHECK ((allocation_rights = false)),
    CONSTRAINT g1_activation_registry_authority_level_check CHECK ((authority_level = 3)),
    CONSTRAINT g1_activation_registry_autonomous_behavior_check CHECK ((autonomous_behavior = false)),
    CONSTRAINT g1_activation_registry_execution_mode_check CHECK (((execution_mode)::text = 'SHADOW_PAPER'::text)),
    CONSTRAINT g1_activation_registry_g1_status_check CHECK (((g1_status)::text = ANY (ARRAY[('ACTIVE'::character varying)::text, ('PAUSED'::character varying)::text, ('TERMINATED'::character varying)::text, ('PROMOTED_G2'::character varying)::text]))),
    CONSTRAINT g1_activation_registry_write_access_check CHECK ((write_access = false))
);


--
-- Name: TABLE g1_activation_registry; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.g1_activation_registry IS 'G1 Alpha-Validated Operation tracker. Measures Alpha impact, not just protocol fidelity. The organism is now allowed to matter.';


--
-- Name: g1_alpha_evidence; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.g1_alpha_evidence (
    evidence_id uuid DEFAULT gen_random_uuid() NOT NULL,
    activation_id uuid,
    session_id uuid,
    interaction_id uuid,
    "timestamp" timestamp with time zone DEFAULT now() NOT NULL,
    ais_estimate numeric(5,4),
    veto_action character varying(30),
    compression_applied boolean DEFAULT false NOT NULL,
    output_type character varying(50),
    output_length_tokens integer,
    sitc_depth integer,
    evaluator character varying(20),
    evaluation_timestamp timestamp with time zone,
    acted_differently boolean,
    saved_time boolean,
    clarified_or_confused character varying(20),
    evaluation_notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE g1_alpha_evidence; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.g1_alpha_evidence IS 'G1 Alpha impact evidence. Records whether outputs inform real decisions, whether Alpha-Veto saves time, whether economic state awareness improves relevance.';


--
-- Name: g1_evidence_accumulation; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.g1_evidence_accumulation (
    accumulation_id uuid DEFAULT gen_random_uuid() NOT NULL,
    eam_start_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    eam_target_end timestamp with time zone DEFAULT (now() + '30 days'::interval) NOT NULL,
    eam_status character varying(20) DEFAULT 'ACTIVE'::character varying NOT NULL,
    state_integrity_count integer DEFAULT 0 NOT NULL,
    state_integrity_failures integer DEFAULT 0 NOT NULL,
    cognitive_fidelity_sitc_count integer DEFAULT 0 NOT NULL,
    cognitive_fidelity_ikea_count integer DEFAULT 0 NOT NULL,
    cognitive_fidelity_inforage_count integer DEFAULT 0 NOT NULL,
    hallucination_rejections integer DEFAULT 0 NOT NULL,
    hallucination_bypasses integer DEFAULT 0 NOT NULL,
    canonical_citations integer DEFAULT 0 NOT NULL,
    canonical_drift_events integer DEFAULT 0 NOT NULL,
    canonical_drift_resolved integer DEFAULT 0 NOT NULL,
    days_without_violation integer DEFAULT 0 NOT NULL,
    last_violation_timestamp timestamp with time zone,
    last_violation_reason text,
    ceo_stability_confirmed boolean DEFAULT false,
    ceo_stability_timestamp timestamp with time zone,
    ceo_stability_notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT g1_evidence_accumulation_eam_status_check CHECK (((eam_status)::text = ANY (ARRAY[('ACTIVE'::character varying)::text, ('PAUSED'::character varying)::text, ('VIOLATED'::character varying)::text, ('COMPLETE'::character varying)::text])))
);


--
-- Name: TABLE g1_evidence_accumulation; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.g1_evidence_accumulation IS 'G0.2 Evidence Accumulation Mode tracker. Measures progress toward G1 entry criteria across five domains.';


--
-- Name: g1_evidence_daily_snapshot; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.g1_evidence_daily_snapshot (
    snapshot_id uuid DEFAULT gen_random_uuid() NOT NULL,
    snapshot_date date NOT NULL,
    accumulation_id uuid,
    invocations_today integer DEFAULT 0 NOT NULL,
    invocations_with_state_binding integer DEFAULT 0 NOT NULL,
    state_binding_rate numeric(5,4),
    consecutive_valid_count integer DEFAULT 0 NOT NULL,
    sitc_chains_generated integer DEFAULT 0 NOT NULL,
    sitc_non_trivial_chains integer DEFAULT 0 NOT NULL,
    ikea_classifications integer DEFAULT 0 NOT NULL,
    ikea_correct_classifications integer DEFAULT 0 NOT NULL,
    inforage_queries integer DEFAULT 0 NOT NULL,
    inforage_cost_optimal integer DEFAULT 0 NOT NULL,
    hallucination_rejections_today integer DEFAULT 0 NOT NULL,
    explicit_refusals integer DEFAULT 0 NOT NULL,
    speculative_outputs_blocked integer DEFAULT 0 NOT NULL,
    document_citations integer DEFAULT 0 NOT NULL,
    citations_with_hash integer DEFAULT 0 NOT NULL,
    drift_events_today integer DEFAULT 0 NOT NULL,
    drift_events_resolved integer DEFAULT 0 NOT NULL,
    emergency_interventions integer DEFAULT 0 NOT NULL,
    governance_overrides integer DEFAULT 0 NOT NULL,
    quick_fixes_outside_gates integer DEFAULT 0 NOT NULL,
    day_compliant boolean DEFAULT true NOT NULL,
    violation_notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE g1_evidence_daily_snapshot; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.g1_evidence_daily_snapshot IS 'Daily evidence rollup for G1 qualification. Each row represents one day of Evidence Accumulation Mode.';


--
-- Name: g1_qualification_thresholds; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.g1_qualification_thresholds (
    threshold_id uuid DEFAULT gen_random_uuid() NOT NULL,
    domain character varying(50) NOT NULL,
    metric_name character varying(100) NOT NULL,
    threshold_value numeric NOT NULL,
    threshold_type character varying(20) NOT NULL,
    description text,
    adr_reference character varying(20),
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT g1_qualification_thresholds_threshold_type_check CHECK (((threshold_type)::text = ANY (ARRAY[('MINIMUM'::character varying)::text, ('MAXIMUM'::character varying)::text, ('PERCENTAGE'::character varying)::text])))
);


--
-- Name: TABLE g1_qualification_thresholds; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.g1_qualification_thresholds IS 'Read-only reference table. G1 entry thresholds per CEO Directive. No runtime evaluation embedded.';


--
-- Name: gate_cross_references; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.gate_cross_references (
    id bigint NOT NULL,
    gate_id text NOT NULL,
    reference_type text NOT NULL,
    reference_id text NOT NULL,
    reference_url text,
    description text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: gate_cross_references_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.gate_cross_references_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gate_cross_references_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.gate_cross_references_id_seq OWNED BY fhq_meta.gate_cross_references.id;


--
-- Name: gate_dependencies; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.gate_dependencies (
    id bigint NOT NULL,
    gate_id text NOT NULL,
    depends_on_gate text NOT NULL,
    dependency_type text NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: gate_dependencies_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.gate_dependencies_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gate_dependencies_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.gate_dependencies_id_seq OWNED BY fhq_meta.gate_dependencies.id;


--
-- Name: gate_registry; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.gate_registry (
    gate_id text NOT NULL,
    gate_name text NOT NULL,
    gate_type text NOT NULL,
    acceptance_criteria text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: gate_status; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.gate_status (
    gate_id text NOT NULL,
    status text NOT NULL,
    validated_at timestamp with time zone,
    validated_by text,
    validation_evidence text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: hallucination_rejection_events; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.hallucination_rejection_events (
    event_id uuid DEFAULT gen_random_uuid() NOT NULL,
    interaction_id uuid NOT NULL,
    boundary_log_id uuid,
    rejection_type character varying(50) NOT NULL,
    rejected_claim text NOT NULL,
    claim_confidence numeric(5,4),
    required_source character varying(100),
    provided_source character varying(100),
    expected_hash character varying(64),
    actual_hash character varying(64),
    severity character varying(20) NOT NULL,
    blocked_output boolean DEFAULT true NOT NULL,
    resolution_action character varying(50),
    resolved_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT hallucination_rejection_events_rejection_type_check CHECK (((rejection_type)::text = ANY (ARRAY[('EXTERNAL_CLAIM_NO_SOURCE'::character varying)::text, ('CANONICAL_HASH_MISMATCH'::character varying)::text, ('PARAMETRIC_OVERCONFIDENCE'::character varying)::text, ('STALE_KNOWLEDGE'::character varying)::text, ('VOLATILITY_BREACH'::character varying)::text, ('ADR_DRIFT_DETECTED'::character varying)::text]))),
    CONSTRAINT hallucination_rejection_events_severity_check CHECK (((severity)::text = ANY (ARRAY[('LOW'::character varying)::text, ('MEDIUM'::character varying)::text, ('HIGH'::character varying)::text, ('CRITICAL'::character varying)::text])))
);


--
-- Name: TABLE hallucination_rejection_events; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.hallucination_rejection_events IS 'CEO Directive 4B.2 - HALLUCINATION_REJECTION_EVENT log. Blocks responses with unverified external claims.';


--
-- Name: identity_state_snapshots; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.identity_state_snapshots (
    snapshot_id uuid DEFAULT gen_random_uuid() NOT NULL,
    snapshot_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    agent_count integer NOT NULL,
    active_key_count integer NOT NULL,
    identity_state_hash text NOT NULL,
    agent_states jsonb NOT NULL,
    vega_attested boolean DEFAULT false NOT NULL,
    vega_signature text,
    vega_public_key text,
    attestation_timestamp timestamp with time zone,
    ceremony_id uuid,
    reason text NOT NULL,
    created_by text DEFAULT 'VEGA'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE identity_state_snapshots; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.identity_state_snapshots IS 'ADR-008: Identity state snapshots with VEGA attestation for canonical verification';


--
-- Name: indicator_definitions; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.indicator_definitions (
    indicator_id character varying(50) NOT NULL,
    name_display character varying(100) NOT NULL,
    name_subtitle character varying(200),
    description_short text NOT NULL,
    description_finance text,
    formula_human text,
    formula_code text,
    parameters jsonb,
    category character varying(50) NOT NULL,
    subcategory character varying(50),
    source character varying(50) NOT NULL,
    ace_family character varying(50),
    used_in_strategies integer[],
    meta_allocation_relevance character varying(20),
    bullish_threshold numeric(10,4),
    bearish_threshold numeric(10,4),
    neutral_range_min numeric(10,4),
    neutral_range_max numeric(10,4),
    interpretation_rules jsonb,
    first_available date,
    data_dependencies text[],
    revision_hash character varying(64),
    last_updated timestamp without time zone DEFAULT now(),
    created_at timestamp without time zone DEFAULT now(),
    created_by character varying(100) DEFAULT 'stig_catalog_v1'::character varying,
    is_active boolean DEFAULT true,
    display_priority integer DEFAULT 100,
    tooltip_color_scheme character varying(20) DEFAULT 'neutral'::character varying,
    show_in_overview boolean DEFAULT true,
    CONSTRAINT chk_category CHECK (((category)::text = ANY (ARRAY[('MOMENTUM'::character varying)::text, ('TREND'::character varying)::text, ('VOLATILITY'::character varying)::text, ('VOLUME'::character varying)::text, ('ONCHAIN'::character varying)::text, ('PRICE'::character varying)::text, ('COMPOSITE'::character varying)::text]))),
    CONSTRAINT chk_source CHECK (((source)::text = ANY (ARRAY[('PRICE'::character varying)::text, ('VOLUME'::character varying)::text, ('ONCHAIN'::character varying)::text, ('DERIVED'::character varying)::text, ('EXTERNAL'::character varying)::text])))
);


--
-- Name: TABLE indicator_definitions; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.indicator_definitions IS 'Authoritative indicator catalog for dashboard hover system. Single source of truth for all indicator metadata, definitions, and interpretation rules. Designed for human-first tooltips with FINN narrative integration.';


--
-- Name: indicator_registry; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.indicator_registry (
    calc_method_id text NOT NULL,
    indicator_id text NOT NULL,
    indicator_name text NOT NULL,
    version text NOT NULL,
    indicator_family text,
    adr_reference text,
    sha256_hash text,
    certified_by text,
    created_at timestamp with time zone DEFAULT now(),
    status text DEFAULT 'active'::text,
    metadata jsonb
);


--
-- Name: indicator_registry_backup; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.indicator_registry_backup (
    indicator_id text,
    indicator_name text,
    indicator_type text,
    calculation_method text,
    parameters jsonb,
    created_at timestamp with time zone,
    status text,
    adr_reference text,
    certified_event_id integer,
    updated_at timestamp with time zone,
    calc_method_id text,
    version text,
    sha256_hash text,
    certified_by text,
    metadata jsonb
);


--
-- Name: indicator_registry_indicator_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.indicator_registry_indicator_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: indicator_registry_indicator_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.indicator_registry_indicator_id_seq OWNED BY fhq_meta.indicator_registry.indicator_id;


--
-- Name: input_contracts; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.input_contracts (
    contract_id uuid DEFAULT gen_random_uuid() NOT NULL,
    consumer_module text NOT NULL,
    supplier_module text NOT NULL,
    contract_type text NOT NULL,
    permitted_sources text[] NOT NULL,
    prohibited_sources text[],
    constraint_rule text NOT NULL,
    enforcement_level text DEFAULT 'DATABASE'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    created_by text NOT NULL,
    vega_approved boolean DEFAULT false,
    vega_signature_id uuid
);


--
-- Name: instrument_types; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.instrument_types (
    instrument_type_id text NOT NULL,
    asset_class_id text,
    cfi_code text,
    description text NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: instruments; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.instruments (
    instrument_id text NOT NULL,
    isin text,
    instrument_name text NOT NULL,
    instrument_type_id text,
    sector_id text,
    issuer_name text,
    contract_size numeric,
    multiplier numeric,
    settlement_type text,
    quote_currency text,
    tick_size numeric,
    metadata jsonb,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: ios_appendix_registry; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.ios_appendix_registry (
    appendix_id uuid DEFAULT gen_random_uuid() NOT NULL,
    ios_id text NOT NULL,
    appendix_code text NOT NULL,
    appendix_title text NOT NULL,
    version text NOT NULL,
    status text DEFAULT 'DRAFT'::text NOT NULL,
    content_hash text NOT NULL,
    owner_role text,
    governing_adrs text[],
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT ios_appendix_status_check CHECK ((status = ANY (ARRAY['DRAFT'::text, 'REGISTERED'::text, 'ACTIVE'::text, 'DEPRECATED'::text, 'ARCHIVED'::text])))
);


--
-- Name: TABLE ios_appendix_registry; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.ios_appendix_registry IS 'Registry of appendices linked to IoS modules. Tracks version, status, and content hash.';


--
-- Name: ios_audit_log; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.ios_audit_log (
    audit_id uuid DEFAULT gen_random_uuid() NOT NULL,
    ios_id text NOT NULL,
    event_type text NOT NULL,
    event_timestamp timestamp with time zone DEFAULT now(),
    actor text NOT NULL,
    gate_level text,
    event_data jsonb,
    evidence_hash text,
    hash_chain_id text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: ios_registry; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.ios_registry (
    ios_id text NOT NULL,
    title text NOT NULL,
    description text,
    version text NOT NULL,
    status text NOT NULL,
    owner_role text NOT NULL,
    governing_adrs text[] DEFAULT '{}'::text[],
    dependencies text[] DEFAULT '{}'::text[],
    content_hash text NOT NULL,
    vega_signature_id uuid,
    hash_chain_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    activated_at timestamp with time zone,
    experimental_classification text DEFAULT 'UNCLASSIFIED'::text,
    risk_multiplier numeric(3,2) DEFAULT 1.0,
    immutability_level text DEFAULT 'MUTABLE'::text,
    canonical boolean DEFAULT false,
    modification_requires text DEFAULT 'OWNER'::text,
    governance_state text,
    hash_chain text,
    CONSTRAINT ios_registry_status_check CHECK ((status = ANY (ARRAY['DRAFT'::text, 'G0_SUBMITTED'::text, 'G1_TECHNICAL'::text, 'G2_VALIDATED'::text, 'G3_INTEGRATED'::text, 'G3_COMPLETE'::text, 'G4_CONSTITUTIONAL'::text, 'ACTIVE'::text, 'GOVERNANCE-ACTIVE'::text, 'DEPRECATED'::text, 'ARCHIVED'::text])))
);


--
-- Name: TABLE ios_registry; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.ios_registry IS 'Registry for Intelligence Operating System (IoS) modules. Tracks versioning, governance linkage, audit lineage and VEGA attestations.';


--
-- Name: COLUMN ios_registry.experimental_classification; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.ios_registry.experimental_classification IS 'Scientific classification per IoS-005 G1 audit: PROVEN (p<0.05), EXPERIMENTAL (p>=0.05), UNCLASSIFIED (not yet audited)';


--
-- Name: COLUMN ios_registry.risk_multiplier; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.ios_registry.risk_multiplier IS 'Capital allocation risk multiplier. 1.0 = full allocation, 0.5 = half allocation (EXPERIMENTAL), 0.0 = suspended';


--
-- Name: COLUMN ios_registry.immutability_level; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.ios_registry.immutability_level IS 'Code freeze level: MUTABLE (can change), LOCKED (CEO+VEGA required), FROZEN (immutable)';


--
-- Name: COLUMN ios_registry.canonical; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.ios_registry.canonical IS 'TRUE if module is a canonical truth source per ADR-013';


--
-- Name: COLUMN ios_registry.modification_requires; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.ios_registry.modification_requires IS 'Authorization required for modification: OWNER, VEGA, CEO+VEGA';


--
-- Name: ios_version_history; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.ios_version_history (
    history_id uuid DEFAULT gen_random_uuid() NOT NULL,
    ios_id text NOT NULL,
    version text NOT NULL,
    previous_version text,
    change_type text NOT NULL,
    change_summary text,
    changed_by text NOT NULL,
    changed_at timestamp with time zone DEFAULT now(),
    content_hash text,
    vega_attestation_id uuid
);


--
-- Name: key_archival_log; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.key_archival_log (
    archival_id uuid DEFAULT gen_random_uuid() NOT NULL,
    key_id uuid NOT NULL,
    agent_id character varying(50) NOT NULL,
    archival_event character varying(50) NOT NULL,
    from_state character varying(50),
    to_state character varying(50),
    from_tier character varying(50),
    to_tier character varying(50),
    reason text,
    evidence_path text,
    performed_by character varying(50) NOT NULL,
    sha256_hash character(64),
    hash_chain_id character varying(100),
    signature_id character varying(200),
    "timestamp" timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT key_archival_log_archival_event_check CHECK (((archival_event)::text = ANY (ARRAY[('KEY_GENERATION'::character varying)::text, ('KEY_ACTIVATION'::character varying)::text, ('KEY_ROTATION'::character varying)::text, ('KEY_DEPRECATION'::character varying)::text, ('KEY_ARCHIVAL'::character varying)::text, ('KEY_DESTRUCTION'::character varying)::text, ('TIER_MIGRATION'::character varying)::text])))
);


--
-- Name: TABLE key_archival_log; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.key_archival_log IS 'ADR-008: Audit trail for Ed25519 key rotation and archival events';


--
-- Name: key_ceremonies; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.key_ceremonies (
    ceremony_id uuid DEFAULT gen_random_uuid() NOT NULL,
    ceremony_type text NOT NULL,
    ceremony_name text NOT NULL,
    ceremony_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    agents_included text[] NOT NULL,
    keys_generated integer DEFAULT 0 NOT NULL,
    keys_registered integer DEFAULT 0 NOT NULL,
    executed_by text NOT NULL,
    execution_environment text DEFAULT 'LOCAL_SECURE_TERMINAL'::text NOT NULL,
    vega_attested boolean DEFAULT false NOT NULL,
    vega_attestation_id uuid,
    vega_attestation_timestamp timestamp with time zone,
    ceremony_status text DEFAULT 'PENDING'::text NOT NULL,
    ceremony_hash text NOT NULL,
    ceremony_signature text,
    ceremony_notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    completed_at timestamp with time zone,
    CONSTRAINT key_ceremonies_ceremony_status_check CHECK ((ceremony_status = ANY (ARRAY['PENDING'::text, 'IN_PROGRESS'::text, 'COMPLETED'::text, 'ATTESTED'::text, 'FAILED'::text, 'REVOKED'::text]))),
    CONSTRAINT key_ceremonies_ceremony_type_check CHECK ((ceremony_type = ANY (ARRAY['IGNITION'::text, 'ROTATION'::text, 'RECOVERY'::text, 'REVOCATION'::text])))
);


--
-- Name: TABLE key_ceremonies; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.key_ceremonies IS 'ADR-008 / EXEC-DIR-004: Key ceremony audit trail for identity sovereignty operations';


--
-- Name: knowledge_boundary_log; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.knowledge_boundary_log (
    boundary_id uuid DEFAULT gen_random_uuid() NOT NULL,
    interaction_id uuid NOT NULL,
    coq_node_id uuid,
    query_text text NOT NULL,
    classification character varying(30) NOT NULL,
    confidence_score numeric(5,4) NOT NULL,
    internal_certainty numeric(5,4),
    external_certainty numeric(5,4),
    uncertainty_quantification numeric(5,4),
    volatility_flag boolean DEFAULT false NOT NULL,
    volatility_half_life_hours integer,
    knowledge_age_hours integer,
    retrieval_triggered boolean DEFAULT false NOT NULL,
    retrieval_source character varying(100),
    retrieval_canonical_hash character varying(64),
    hallucination_risk_score numeric(5,4) DEFAULT 0,
    hallucination_blocked boolean DEFAULT false NOT NULL,
    hallucination_rejection_event_id uuid,
    decision_rationale text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT knowledge_boundary_log_classification_check CHECK (((classification)::text = ANY (ARRAY[('PARAMETRIC'::character varying)::text, ('EXTERNAL_REQUIRED'::character varying)::text, ('HYBRID'::character varying)::text, ('BLOCKED'::character varying)::text])))
);


--
-- Name: TABLE knowledge_boundary_log; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.knowledge_boundary_log IS 'EC-022 IKEA Engine - Knowledge Boundary Classification. Hallucination firewall.';


--
-- Name: learning_state_artifacts; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.learning_state_artifacts (
    lsa_id uuid DEFAULT gen_random_uuid() NOT NULL,
    batch_id text NOT NULL,
    directive_id text NOT NULL,
    alpha_graph_weights jsonb NOT NULL,
    success_rates_by_path jsonb NOT NULL,
    roi_thresholds jsonb NOT NULL,
    regime_summaries jsonb NOT NULL,
    final_base_rate numeric(5,4) NOT NULL,
    final_rdi numeric(5,4) NOT NULL,
    final_waste numeric(5,4) NOT NULL,
    usage_rate_bounds jsonb NOT NULL,
    info_gain_bounds jsonb NOT NULL,
    redundancy_bounds jsonb NOT NULL,
    content_hash text NOT NULL,
    signature text,
    vega_attestation_id uuid,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by text DEFAULT 'FINN'::text NOT NULL,
    is_canonical boolean DEFAULT false NOT NULL,
    superseded_by uuid,
    CONSTRAINT lsa_valid_rates CHECK ((((final_base_rate >= (0)::numeric) AND (final_base_rate <= (1)::numeric)) AND ((final_rdi >= (0)::numeric) AND (final_rdi <= (1)::numeric)) AND ((final_waste >= (0)::numeric) AND (final_waste <= (1)::numeric))))
);


--
-- Name: listings_backup_20251106; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.listings_backup_20251106 (
    listing_id text,
    instrument_id text,
    exchange_mic text,
    ticker text,
    listing_currency text,
    is_primary boolean,
    listed_from date,
    listed_to date,
    created_at timestamp with time zone,
    yahoo_symbol text
);


--
-- Name: llm_provider_config; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.llm_provider_config (
    config_id uuid DEFAULT gen_random_uuid() NOT NULL,
    provider_name character varying(50) NOT NULL,
    model_name character varying(100) NOT NULL,
    model_type character varying(30) NOT NULL,
    use_case character varying(100) NOT NULL,
    is_default boolean DEFAULT false,
    is_active boolean DEFAULT true,
    context_caching_enabled boolean DEFAULT false,
    cost_per_1k_tokens numeric(10,6),
    priority integer DEFAULT 5,
    config_metadata jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: market_requirements; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.market_requirements (
    requirement_id text NOT NULL,
    requirement_name text NOT NULL,
    supported_resolutions text[] DEFAULT ARRAY['1d'::text] NOT NULL,
    min_history_days integer DEFAULT 252,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: market_segments; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.market_segments (
    segment_id text NOT NULL,
    mic text NOT NULL,
    segment_name text NOT NULL,
    segment_type text,
    listing_requirements jsonb,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: meta_documents; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.meta_documents (
    doc_id text NOT NULL,
    title text NOT NULL,
    doc_type text NOT NULL,
    status text DEFAULT 'active'::text NOT NULL,
    epoch text,
    date_created date NOT NULL,
    scope jsonb,
    components text[],
    related_adrs text[],
    file_path text,
    version text DEFAULT '1.0.0'::text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: model_certifications; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.model_certifications (
    certification_id uuid DEFAULT gen_random_uuid() NOT NULL,
    model_name text NOT NULL,
    model_version text NOT NULL,
    certification_gate integer NOT NULL,
    certification_status text NOT NULL,
    certified_by text DEFAULT 'VEGA'::text NOT NULL,
    certified_at timestamp without time zone DEFAULT now() NOT NULL,
    evidence jsonb NOT NULL,
    revoked_at timestamp without time zone,
    revocation_reason text,
    metadata jsonb,
    CONSTRAINT model_certifications_certification_gate_check CHECK (((certification_gate >= 1) AND (certification_gate <= 6))),
    CONSTRAINT model_certifications_certification_status_check CHECK ((certification_status = ANY (ARRAY['PENDING'::text, 'PASSED'::text, 'FAILED'::text, 'REVOKED'::text])))
);


--
-- Name: TABLE model_certifications; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.model_certifications IS 'ADR-006 5.1: MDLC 6-Gate certification registry (Owner: VEGA)';


--
-- Name: model_certifications_certification_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.model_certifications_certification_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: model_certifications_certification_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.model_certifications_certification_id_seq OWNED BY fhq_meta.model_certifications.certification_id;


--
-- Name: model_context_registry; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.model_context_registry (
    context_id uuid DEFAULT gen_random_uuid() NOT NULL,
    canonical_id text NOT NULL,
    feature_set text[] DEFAULT '{}'::text[],
    regime_model_ref text,
    forecast_model_ref text,
    perception_model_ref text,
    embedding_profile text,
    training_schema_hash text,
    data_vendor_source text,
    vega_signature_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE model_context_registry; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.model_context_registry IS 'IoS-001 Model Context Registry. Maps assets to their modeling contexts including feature sets, regime models, and training schemas.';


--
-- Name: model_registry; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.model_registry (
    registry_id integer NOT NULL,
    model_id character varying(100) NOT NULL,
    model_name character varying(255) NOT NULL,
    version character varying(50) NOT NULL,
    status character varying(50) NOT NULL,
    description text,
    created_at timestamp with time zone DEFAULT now(),
    locked_at timestamp with time zone,
    author character varying(100),
    notes text,
    config_hash character varying(64),
    metadata jsonb DEFAULT '{}'::jsonb,
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT model_registry_status_check CHECK (((status)::text = ANY (ARRAY[('active'::character varying)::text, ('locked'::character varying)::text, ('deprecated'::character varying)::text, ('experimental'::character varying)::text])))
);


--
-- Name: model_registry_registry_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.model_registry_registry_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: model_registry_registry_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.model_registry_registry_id_seq OWNED BY fhq_meta.model_registry.registry_id;


--
-- Name: narrative_vectors; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.narrative_vectors (
    vector_id uuid DEFAULT gen_random_uuid() NOT NULL,
    domain text NOT NULL,
    narrative text NOT NULL,
    probability numeric(4,3) NOT NULL,
    confidence numeric(4,3) NOT NULL,
    half_life_hours integer NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by text NOT NULL,
    signature_id uuid,
    bpav jsonb,
    bpav_computed_at timestamp with time zone,
    bpav_computed_by text,
    is_expired boolean DEFAULT false,
    expired_at timestamp with time zone,
    CONSTRAINT narrative_vectors_bpav_computed_by_check CHECK ((bpav_computed_by = ANY (ARRAY['IoS-009'::text, NULL::text]))),
    CONSTRAINT narrative_vectors_confidence_check CHECK (((confidence >= (0)::numeric) AND (confidence <= (1)::numeric))),
    CONSTRAINT narrative_vectors_domain_check CHECK ((domain = ANY (ARRAY['Regulatory'::text, 'Geopolitical'::text, 'Liquidity'::text, 'Reflexivity'::text, 'Sentiment'::text, 'Other'::text]))),
    CONSTRAINT narrative_vectors_half_life_hours_check CHECK ((half_life_hours > 0)),
    CONSTRAINT narrative_vectors_probability_check CHECK (((probability >= (0)::numeric) AND (probability <= (1)::numeric)))
);


--
-- Name: TABLE narrative_vectors; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.narrative_vectors IS 'IoS-009 Addendum G1: Canonical Human Oracle Input table.
The ONLY lawful channel for CEO/human intuition to enter the perception layer.
Append-only for humans. BPAV computed exclusively by IoS-009.
Half-life mechanism prevents zombie signals.';


--
-- Name: params; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.params (
    id text NOT NULL,
    strategy_id text NOT NULL,
    instrument_type text,
    timeframe text,
    version text NOT NULL,
    params_json jsonb,
    is_active boolean DEFAULT true,
    optimized_for text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: pipeline_runs; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.pipeline_runs (
    id bigint NOT NULL,
    ticker text NOT NULL,
    date_from date NOT NULL,
    date_to date NOT NULL,
    idempotency_key text NOT NULL,
    prices_status text,
    prices_started_at timestamp with time zone,
    prices_completed_at timestamp with time zone,
    indicators_status text,
    indicators_started_at timestamp with time zone,
    indicators_completed_at timestamp with time zone,
    backtests_status text,
    backtests_started_at timestamp with time zone,
    backtests_completed_at timestamp with time zone,
    signals_status text,
    signals_started_at timestamp with time zone,
    signals_completed_at timestamp with time zone
);


--
-- Name: pipeline_runs_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.pipeline_runs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pipeline_runs_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.pipeline_runs_id_seq OWNED BY fhq_meta.pipeline_runs.id;


--
-- Name: price_class_ontology; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.price_class_ontology (
    price_class_id text NOT NULL,
    price_class_name text NOT NULL,
    description text NOT NULL,
    storage_policy text NOT NULL,
    permitted_use text[] NOT NULL,
    ttl_hours integer,
    immutable boolean DEFAULT false NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: rate_limit_policy; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.rate_limit_policy (
    policy_id integer NOT NULL,
    group_name text NOT NULL,
    max_calls integer NOT NULL,
    time_window interval NOT NULL,
    enforced_by text DEFAULT 'technical_officer_v1'::text,
    last_reset timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now(),
    notes text,
    CONSTRAINT rate_limit_policy_group_name_check CHECK ((group_name = ANY (ARRAY['DAILY'::text, 'INTRADAY'::text, 'REALTIME'::text]))),
    CONSTRAINT rate_limit_policy_max_calls_check CHECK ((max_calls > 0))
);


--
-- Name: rate_limit_policy_policy_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.rate_limit_policy_policy_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: rate_limit_policy_policy_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.rate_limit_policy_policy_id_seq OWNED BY fhq_meta.rate_limit_policy.policy_id;


--
-- Name: reconciliation_evidence; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.reconciliation_evidence (
    evidence_id uuid DEFAULT gen_random_uuid() NOT NULL,
    snapshot_id uuid NOT NULL,
    evidence_type text NOT NULL,
    evidence_category text NOT NULL,
    evidence_data jsonb NOT NULL,
    evidence_hash text NOT NULL,
    verified boolean DEFAULT false NOT NULL,
    verified_by text,
    verified_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: reconciliation_field_weights; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.reconciliation_field_weights (
    weight_id integer NOT NULL,
    component_name character varying(100) NOT NULL,
    field_name character varying(100) NOT NULL,
    criticality_weight numeric(3,1) NOT NULL,
    tolerance_type character varying(50),
    tolerance_value numeric,
    description text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT reconciliation_field_weights_criticality_weight_check CHECK (((criticality_weight >= 0.1) AND (criticality_weight <= 1.0)))
);


--
-- Name: reconciliation_field_weights_weight_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.reconciliation_field_weights_weight_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: reconciliation_field_weights_weight_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.reconciliation_field_weights_weight_id_seq OWNED BY fhq_meta.reconciliation_field_weights.weight_id;


--
-- Name: reconciliation_snapshots; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.reconciliation_snapshots (
    snapshot_id uuid DEFAULT gen_random_uuid() NOT NULL,
    component_name text NOT NULL,
    snapshot_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    snapshot_type text DEFAULT 'SCHEDULED'::text NOT NULL,
    agent_state jsonb NOT NULL,
    canonical_state jsonb NOT NULL,
    discrepancy_score numeric(7,6) DEFAULT 0.0 NOT NULL,
    discrepancy_threshold numeric(7,6) DEFAULT 0.10 NOT NULL,
    threshold_exceeded boolean DEFAULT false NOT NULL,
    field_discrepancies jsonb,
    discrepancy_count integer DEFAULT 0 NOT NULL,
    reconciliation_status text DEFAULT 'PENDING'::text NOT NULL,
    reconciliation_action text,
    vega_suspension_requested boolean DEFAULT false NOT NULL,
    vega_suspension_request_id uuid,
    created_by text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: regime_state; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.regime_state (
    state_id uuid DEFAULT gen_random_uuid() NOT NULL,
    current_regime character varying(20) DEFAULT 'UNKNOWN'::character varying NOT NULL,
    regime_confidence numeric(5,4) DEFAULT 0.5000,
    last_updated_at timestamp with time zone DEFAULT now(),
    updated_by character varying(20) DEFAULT 'SYSTEM'::character varying,
    belief_regime text,
    belief_confidence numeric(6,4),
    is_policy_divergent boolean DEFAULT false,
    divergence_reason text,
    transition_state text DEFAULT 'STABLE'::text,
    CONSTRAINT valid_regime CHECK (((current_regime)::text = ANY (ARRAY[('BULL'::character varying)::text, ('BEAR'::character varying)::text, ('SIDEWAYS'::character varying)::text, ('CRISIS'::character varying)::text, ('UNKNOWN'::character varying)::text])))
);


--
-- Name: COLUMN regime_state.belief_regime; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.regime_state.belief_regime IS 'CEO-DIR-2026-001: What the model believes (unfiltered)';


--
-- Name: COLUMN regime_state.belief_confidence; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.regime_state.belief_confidence IS 'CEO-DIR-2026-001: Model confidence in belief_regime';


--
-- Name: COLUMN regime_state.is_policy_divergent; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.regime_state.is_policy_divergent IS 'CEO-DIR-2026-001: TRUE when policy_regime != belief_regime';


--
-- Name: COLUMN regime_state.transition_state; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.regime_state.transition_state IS 'CEO-DIR-2026-001: STABLE, PENDING_CONFIRMATION, TRANSITIONING';


--
-- Name: regime_weight_config; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.regime_weight_config (
    config_id integer NOT NULL,
    regime_label character varying(20) NOT NULL,
    family_id integer NOT NULL,
    regime_weight numeric(5,4) NOT NULL,
    description text,
    is_active boolean DEFAULT true,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    CONSTRAINT chk_regime_weight CHECK (((regime_weight >= 0.0000) AND (regime_weight <= 1.0000)))
);


--
-- Name: TABLE regime_weight_config; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.regime_weight_config IS 'Regime-specific weights for strategy families. Example: In BULL regime, TREND weight=0.40, REVERSION weight=0.20. In BEAR regime, weights reverse.';


--
-- Name: regime_weight_config_config_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.regime_weight_config_config_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: regime_weight_config_config_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.regime_weight_config_config_id_seq OWNED BY fhq_meta.regime_weight_config.config_id;


--
-- Name: regions; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.regions (
    region_id text NOT NULL,
    region_name text NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: rollback_test_table; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.rollback_test_table (
    id integer,
    test_data text,
    created_at timestamp with time zone
);


--
-- Name: search_foraging_log; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.search_foraging_log (
    forage_id uuid DEFAULT gen_random_uuid() NOT NULL,
    interaction_id uuid NOT NULL,
    coq_node_id uuid,
    search_query text NOT NULL,
    search_source character varying(100),
    scent_score numeric(5,4) NOT NULL,
    predicted_information_gain numeric(5,4),
    marginal_utility_estimate numeric(5,4),
    estimated_cost_usd numeric(10,6) NOT NULL,
    estimated_tokens integer,
    estimated_latency_ms integer,
    budget_remaining_usd numeric(10,6),
    budget_check_passed boolean NOT NULL,
    search_executed boolean NOT NULL,
    termination_reason character varying(50),
    actual_cost_usd numeric(10,6),
    actual_tokens integer,
    actual_latency_ms integer,
    information_gain_actual numeric(5,4),
    roi_score numeric(8,4),
    roi_meets_threshold boolean,
    reward_outcome numeric(8,4),
    reward_information numeric(8,4),
    penalty_efficiency numeric(8,4),
    reward_total numeric(8,4),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT search_foraging_log_termination_reason_check CHECK (((termination_reason)::text = ANY (ARRAY[('EXECUTED'::character varying)::text, ('SCENT_TOO_LOW'::character varying)::text, ('BUDGET_EXCEEDED'::character varying)::text, ('DIMINISHING_RETURNS'::character varying)::text, ('LATENCY_CONSTRAINT'::character varying)::text, ('DEFCON_RESTRICTION'::character varying)::text, ('DUPLICATE_QUERY'::character varying)::text])))
);


--
-- Name: TABLE search_foraging_log; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.search_foraging_log IS 'EC-021 InForage Engine - Cost-aware search foraging. ROI optimization for curiosity.';


--
-- Name: secret_rotation_log; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.secret_rotation_log (
    id bigint NOT NULL,
    secret_name text NOT NULL,
    rotated_at timestamp with time zone DEFAULT now() NOT NULL,
    rotated_by text NOT NULL,
    rotation_method text,
    test_status text,
    notes text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: secret_rotation_log_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.secret_rotation_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: secret_rotation_log_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.secret_rotation_log_id_seq OWNED BY fhq_meta.secret_rotation_log.id;


--
-- Name: sectors; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.sectors (
    sector_id text NOT NULL,
    sector_name text NOT NULL,
    gics_code text,
    description text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: sleep_cycle_runs; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.sleep_cycle_runs (
    cycle_id uuid DEFAULT gen_random_uuid() NOT NULL,
    cycle_date date NOT NULL,
    cycle_type text NOT NULL,
    logs_processed integer DEFAULT 0 NOT NULL,
    patterns_identified integer DEFAULT 0 NOT NULL,
    pamphlets_created integer DEFAULT 0 NOT NULL,
    pamphlets_pruned integer DEFAULT 0 NOT NULL,
    lsa_updated boolean DEFAULT false NOT NULL,
    started_at timestamp with time zone NOT NULL,
    completed_at timestamp with time zone,
    duration_seconds numeric(10,2),
    status text NOT NULL,
    error_message text,
    evidence_hash text,
    CONSTRAINT sleep_cycle_runs_cycle_type_check CHECK ((cycle_type = ANY (ARRAY['DAILY'::text, 'WEEKLY'::text, 'MANUAL'::text]))),
    CONSTRAINT sleep_cycle_runs_status_check CHECK ((status = ANY (ARRAY['RUNNING'::text, 'COMPLETED'::text, 'FAILED'::text, 'ABORTED'::text])))
);


--
-- Name: source_of_truth; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.source_of_truth (
    entity text NOT NULL,
    provider text NOT NULL,
    method text NOT NULL,
    is_authoritative boolean DEFAULT true NOT NULL,
    notes text
);


--
-- Name: stig_allowed_operations; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.stig_allowed_operations (
    operation_type text NOT NULL,
    description text NOT NULL,
    allowed_schemas text[] NOT NULL,
    allowed_tables text[],
    requires_justification boolean DEFAULT true,
    max_rows_per_operation integer,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    created_by text DEFAULT 'STIG'::text
);


--
-- Name: TABLE stig_allowed_operations; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.stig_allowed_operations IS 'Whitelist of allowed operation types for STIG Engineering API.
Each operation_type maps to specific allowed schemas and tables.
Enforces the principle of least privilege.';


--
-- Name: strategies; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.strategies (
    id text NOT NULL,
    strategy_name text NOT NULL,
    strategy_type text NOT NULL,
    description text,
    parameters jsonb,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: strategy_families; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.strategy_families (
    family_id integer NOT NULL,
    family_name character varying(100) NOT NULL,
    family_description text,
    weight_in_consensus numeric(5,4) DEFAULT 0.2500,
    is_active boolean DEFAULT true,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now()
);


--
-- Name: TABLE strategy_families; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.strategy_families IS 'Strategy families for ACE governance. Each family (TREND, REVERSION, VOLATILITY, BREAKOUT) has equal weight in multi-strategy consensus.';


--
-- Name: COLUMN strategy_families.weight_in_consensus; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON COLUMN fhq_meta.strategy_families.weight_in_consensus IS 'Weight used in multi-strategy consensus calculation. Default: 0.25 (equal weight across 4 families).';


--
-- Name: strategy_families_family_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.strategy_families_family_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: strategy_families_family_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.strategy_families_family_id_seq OWNED BY fhq_meta.strategy_families.family_id;


--
-- Name: strategy_family_members; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.strategy_family_members (
    membership_id integer NOT NULL,
    strategy_id character varying(50) NOT NULL,
    family_id integer NOT NULL,
    weight_in_family numeric(5,4) DEFAULT 0.2500,
    is_active boolean DEFAULT true,
    assigned_at timestamp without time zone DEFAULT now()
);


--
-- Name: TABLE strategy_family_members; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.strategy_family_members IS 'Maps strategies to families. Each strategy belongs to exactly one family. Weight determines contribution to family consensus signal.';


--
-- Name: strategy_family_members_membership_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.strategy_family_members_membership_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: strategy_family_members_membership_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.strategy_family_members_membership_id_seq OWNED BY fhq_meta.strategy_family_members.membership_id;


--
-- Name: strategy_master; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.strategy_master (
    strategy_id text NOT NULL,
    strategy_name text NOT NULL,
    strategy_type text NOT NULL,
    category text NOT NULL,
    description text NOT NULL,
    methodology text NOT NULL,
    entry_rule text NOT NULL,
    exit_rule text NOT NULL,
    parameters jsonb,
    introduced_date date DEFAULT CURRENT_DATE NOT NULL,
    deprecated_date date,
    status text DEFAULT 'ACTIVE'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: strategy_registry; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.strategy_registry (
    id text NOT NULL,
    strategy_code text NOT NULL,
    display_name text NOT NULL,
    description text,
    category text,
    indicators_required text[],
    parameters jsonb,
    risk_category text,
    inception_date date,
    adr_reference text,
    status text DEFAULT 'active'::text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    references_docs text[]
);


--
-- Name: strategy_registry_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.strategy_registry_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: strategy_registry_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.strategy_registry_id_seq OWNED BY fhq_meta.strategy_registry.id;


--
-- Name: system_documents; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.system_documents (
    document_id uuid DEFAULT gen_random_uuid() NOT NULL,
    document_code text NOT NULL,
    document_title text NOT NULL,
    document_type text NOT NULL,
    version text NOT NULL,
    status text NOT NULL,
    owner_role text NOT NULL,
    content_hash text NOT NULL,
    summary text,
    governing_adrs text[],
    governing_ios text[],
    effective_date timestamp with time zone DEFAULT now() NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT system_documents_document_type_check CHECK ((document_type = ANY (ARRAY['SPECIFICATION'::text, 'WORKFLOW'::text, 'ARCHITECTURE'::text, 'POLICY'::text, 'PROCEDURE'::text]))),
    CONSTRAINT system_documents_status_check CHECK ((status = ANY (ARRAY['DRAFT'::text, 'ACTIVE'::text, 'DEPRECATED'::text, 'SUPERSEDED'::text])))
);


--
-- Name: technical_debt; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.technical_debt (
    td_id text NOT NULL,
    title text NOT NULL,
    description text NOT NULL,
    severity text NOT NULL,
    status text DEFAULT 'open'::text NOT NULL,
    identified_date date DEFAULT CURRENT_DATE NOT NULL,
    target_resolution_date date,
    resolved_date date,
    resolution_plan text,
    affected_components text[],
    related_adrs text[],
    estimated_effort_hours numeric,
    actual_effort_hours numeric,
    assigned_to text,
    tags text[],
    schema_version text DEFAULT '1.0.0'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: ticker_mapping; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.ticker_mapping (
    canonical_ticker character varying NOT NULL,
    listing_id character varying,
    indicator_ticker character varying,
    backtest_ticker character varying,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: tickers; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.tickers (
    ticker text NOT NULL,
    instrument_id text,
    exchange_mic text,
    vendor text DEFAULT 'yahoo'::text,
    vendor_ticker text,
    created_at timestamp with time zone DEFAULT now(),
    mic text,
    yahoo_symbol text,
    isin text,
    currency text DEFAULT 'NOK'::text,
    listing_date date,
    is_active boolean DEFAULT true,
    rate_limit_group text DEFAULT 'DAILY'::text,
    last_synced timestamp with time zone,
    source text DEFAULT 'yfinance'::text,
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT tickers_rate_limit_group_check CHECK ((rate_limit_group = ANY (ARRAY['DAILY'::text, 'INTRADAY'::text, 'REALTIME'::text])))
);


--
-- Name: tool_usage_log; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.tool_usage_log (
    usage_id uuid DEFAULT gen_random_uuid() NOT NULL,
    interaction_id uuid NOT NULL,
    coq_node_id uuid,
    tool_name character varying(50) NOT NULL,
    tool_version character varying(20) DEFAULT '1.0.0'::character varying,
    invocation_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    input_parameters jsonb NOT NULL,
    adr013_validated boolean DEFAULT false NOT NULL,
    adr018_state_bound boolean DEFAULT false NOT NULL,
    adr012_budget_checked boolean DEFAULT false NOT NULL,
    defcon_permitted boolean DEFAULT true NOT NULL,
    doc_id character varying(50),
    canonical_sha256 character varying(64),
    section_id character varying(100),
    hash_validated boolean DEFAULT false,
    view_name character varying(100),
    query_hash character varying(64),
    row_count integer,
    execution_status character varying(20) NOT NULL,
    result_summary text,
    error_message text,
    cost_usd numeric(10,6) DEFAULT 0,
    tokens_used integer DEFAULT 0,
    latency_ms integer,
    sitc_bound boolean DEFAULT false,
    inforage_scored boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT tool_usage_log_execution_status_check CHECK (((execution_status)::text = ANY (ARRAY[('SUCCESS'::character varying)::text, ('BLOCKED_GOVERNANCE'::character varying)::text, ('BLOCKED_BUDGET'::character varying)::text, ('BLOCKED_DEFCON'::character varying)::text, ('BLOCKED_HASH_MISMATCH'::character varying)::text, ('ERROR'::character varying)::text]))),
    CONSTRAINT tool_usage_log_tool_name_check CHECK (((tool_name)::text = ANY (ARRAY[('consult_canonical_documents'::character varying)::text, ('inspect_database'::character varying)::text])))
);


--
-- Name: TABLE tool_usage_log; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.tool_usage_log IS 'CEO Directive 6 - Allowed Tools Log. Only consult_canonical_documents and inspect_database authorized at G0.';


--
-- Name: trading_calendars; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.trading_calendars (
    calendar_id text NOT NULL,
    calendar_name text NOT NULL,
    version text DEFAULT 'v1'::text NOT NULL,
    effective_from date NOT NULL,
    effective_to date,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: v_aci_economic_state; Type: VIEW; Schema: fhq_meta; Owner: -
--

CREATE VIEW fhq_meta.v_aci_economic_state AS
 SELECT COALESCE(( SELECT avg(forecast_skill_registry.fss_score) AS avg
           FROM fhq_research.forecast_skill_registry
          WHERE (forecast_skill_registry.created_at > (now() - '30 days'::interval))
         LIMIT 1), 0.0) AS fss_observational,
    COALESCE(( SELECT (decision_log.final_allocation)::text AS final_allocation
           FROM fhq_governance.decision_log
          WHERE (decision_log.executed_at IS NOT NULL)
          ORDER BY decision_log.executed_at DESC
         LIMIT 1), '{}'::text) AS alloc_observational,
    COALESCE(( SELECT decision_log.system_skill_score
           FROM fhq_governance.decision_log
          WHERE (decision_log.executed_at IS NOT NULL)
          ORDER BY decision_log.executed_at DESC
         LIMIT 1), 0.0) AS system_skill_score_observational,
    'OBSERVATIONAL_ONLY'::text AS legal_status,
    'These variables provide analytical context only. They must never be used to imply allocation recommendations or execution logic.'::text AS vega_constraint,
    now() AS snapshot_timestamp;


--
-- Name: VIEW v_aci_economic_state; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON VIEW fhq_meta.v_aci_economic_state IS 'Read-only observational view of economic state variables for ACI Console. VEGA Constraint: Not controlling variables. Analytical context only.';


--
-- Name: v_active_adrs; Type: VIEW; Schema: fhq_meta; Owner: -
--

CREATE VIEW fhq_meta.v_active_adrs AS
 SELECT adr_id,
    adr_title,
    adr_status AS status,
    governance_tier,
    owner,
    vega_attested,
    current_version AS version,
    effective_date,
    updated_at
   FROM fhq_meta.adr_registry
  WHERE ((adr_status)::text = 'APPROVED'::text);


--
-- Name: VIEW v_active_adrs; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON VIEW fhq_meta.v_active_adrs IS 'Active ADRs from adr_registry. Fixed per CEO-DIR-2025-DB-TRUTH-001 (was previously hardcoded to ADR-001 only).';


--
-- Name: v_g1_reconciliation_summary; Type: VIEW; Schema: fhq_meta; Owner: -
--

CREATE VIEW fhq_meta.v_g1_reconciliation_summary AS
 SELECT ( SELECT count(*) AS count
           FROM fhq_meta.canonical_document_queue
          WHERE ((canonical_document_queue.document_type)::text = 'ADR'::text)) AS adr_documents,
    ( SELECT count(*) AS count
           FROM fhq_meta.canonical_document_queue
          WHERE ((canonical_document_queue.document_type)::text = 'IOS'::text)) AS ios_documents,
    ( SELECT count(*) AS count
           FROM fhq_meta.canonical_document_queue
          WHERE ((canonical_document_queue.document_type)::text = ANY (ARRAY[('DIRECTIVE'::character varying)::text, ('OTHER'::character varying)::text]))) AS ec_documents,
    ( SELECT count(*) AS count
           FROM fhq_meta.canonical_document_queue
          WHERE ((canonical_document_queue.reconciliation_status)::text = 'ALIGNED'::text)) AS aligned_count,
    ( SELECT count(*) AS count
           FROM fhq_meta.canonical_document_queue
          WHERE ((canonical_document_queue.reconciliation_status)::text = 'DIVERGENT'::text)) AS divergent_count,
    ( SELECT count(*) AS count
           FROM fhq_meta.canonical_document_queue
          WHERE ((canonical_document_queue.reconciliation_status)::text = 'DEFERRED'::text)) AS deferred_count,
    ( SELECT count(*) AS count
           FROM fhq_meta.canonical_document_queue
          WHERE ((canonical_document_queue.reconciliation_status)::text = 'PENDING'::text)) AS pending_count,
    ( SELECT count(*) AS count
           FROM fhq_meta.document_claims) AS total_claims,
    ( SELECT count(*) AS count
           FROM fhq_meta.document_claims
          WHERE ((document_claims.verification_status)::text = 'PRESENT'::text)) AS claims_verified,
    ( SELECT count(*) AS count
           FROM fhq_meta.document_claims
          WHERE ((document_claims.verification_status)::text = ANY (ARRAY[('ABSENT'::character varying)::text, ('PARTIAL'::character varying)::text, ('SEMANTICALLY_INCONSISTENT'::character varying)::text]))) AS claims_mismatched,
    ( SELECT count(*) AS count
           FROM fhq_meta.canonical_mismatches) AS total_mismatches,
    ( SELECT count(*) AS count
           FROM fhq_meta.canonical_mismatches
          WHERE ((canonical_mismatches.resolution_status)::text = 'UNRESOLVED'::text)) AS unresolved_mismatches,
    ( SELECT count(*) AS count
           FROM fhq_meta.canonical_mismatches
          WHERE ((canonical_mismatches.severity)::text = 'CRITICAL'::text)) AS critical_mismatches,
        CASE
            WHEN ((( SELECT count(*) AS count
               FROM fhq_meta.canonical_document_queue
              WHERE ((canonical_document_queue.reconciliation_status)::text = 'PENDING'::text)) = 0) AND (( SELECT count(*) AS count
               FROM fhq_meta.canonical_mismatches
              WHERE ((canonical_mismatches.resolution_status)::text = 'UNRESOLVED'::text)) = 0)) THEN true
            ELSE false
        END AS g1_exit_ready,
    now() AS summary_timestamp;


--
-- Name: VIEW v_g1_reconciliation_summary; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON VIEW fhq_meta.v_g1_reconciliation_summary IS 'G1 Reconciliation progress summary. G1 exit requires all documents reconciled and all mismatches explicitly addressed (not necessarily fixed).';


--
-- Name: validation_checks; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.validation_checks (
    check_id text NOT NULL,
    description text NOT NULL,
    part integer NOT NULL,
    expected_result text NOT NULL,
    validation_query text,
    schema_version text DEFAULT '1.0.0'::text NOT NULL
);


--
-- Name: validation_reports; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.validation_reports (
    id integer NOT NULL,
    phase text NOT NULL,
    task text NOT NULL,
    model_id text,
    gate text NOT NULL,
    status text NOT NULL,
    notes text,
    validated_at timestamp with time zone DEFAULT now() NOT NULL,
    validated_by text DEFAULT 'ADR-024 Execution Agent'::text
);


--
-- Name: validation_reports_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.validation_reports_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: validation_reports_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.validation_reports_id_seq OWNED BY fhq_meta.validation_reports.id;


--
-- Name: vega_attestations; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.vega_attestations (
    attestation_id uuid DEFAULT gen_random_uuid() NOT NULL,
    attestation_type text NOT NULL,
    attestation_target text NOT NULL,
    attestation_status text NOT NULL,
    attestation_rationale text NOT NULL,
    hash_verified boolean NOT NULL,
    agent_verified boolean NOT NULL,
    gate_verified boolean NOT NULL,
    signature_verified boolean NOT NULL,
    function_hash text,
    expected_hash text,
    hash_match boolean,
    attested_by text DEFAULT 'VEGA'::text NOT NULL,
    attesting_agent text,
    vega_key_id text,
    signature_payload text NOT NULL,
    ed25519_signature text NOT NULL,
    signature_algorithm text DEFAULT 'Ed25519'::text NOT NULL,
    evidence_bundle jsonb,
    valid_from timestamp with time zone DEFAULT now() NOT NULL,
    valid_until timestamp with time zone,
    revoked boolean DEFAULT false NOT NULL,
    revoked_at timestamp with time zone,
    revoked_by text,
    revocation_reason text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    hash_chain_id text NOT NULL,
    governance_log_id uuid,
    CONSTRAINT vega_attestations_attestation_status_check CHECK ((attestation_status = ANY (ARRAY['APPROVED'::text, 'BLOCKED'::text, 'CONDITIONAL'::text, 'REVOKED'::text]))),
    CONSTRAINT vega_attestations_attestation_type_check CHECK ((attestation_type = ANY (ARRAY['FUNCTION'::text, 'SCHEMA'::text, 'CONFIGURATION'::text, 'MIGRATION'::text, 'CONSTITUTIONAL'::text, 'COGNITIVE_ENGINE'::text, 'ADR'::text, 'EC'::text])))
);


--
-- Name: TABLE vega_attestations; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.vega_attestations IS 'VEGA attestation records with Ed25519 signatures per ADR-006, ADR-008, ADR-011';


--
-- Name: vega_constitutional_duties; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.vega_constitutional_duties (
    duty_id integer NOT NULL,
    duty_code character varying(20) NOT NULL,
    duty_title character varying(200) NOT NULL,
    duty_description text NOT NULL,
    duty_category character varying(50) NOT NULL,
    governing_adr character varying(20) DEFAULT 'ADR-006'::character varying NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: vega_constitutional_duties_duty_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.vega_constitutional_duties_duty_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: vega_constitutional_duties_duty_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.vega_constitutional_duties_duty_id_seq OWNED BY fhq_meta.vega_constitutional_duties.duty_id;


--
-- Name: vega_constraints; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.vega_constraints (
    constraint_id integer NOT NULL,
    constraint_code character varying(20) NOT NULL,
    constraint_title character varying(200) NOT NULL,
    constraint_description text NOT NULL,
    constraint_type character varying(50) NOT NULL,
    governing_adr character varying(20) DEFAULT 'ADR-006'::character varying NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: vega_constraints_constraint_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.vega_constraints_constraint_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: vega_constraints_constraint_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.vega_constraints_constraint_id_seq OWNED BY fhq_meta.vega_constraints.constraint_id;


--
-- Name: vega_employment_contract; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.vega_employment_contract (
    contract_id integer NOT NULL,
    contract_number character varying(50) DEFAULT 'EC-001'::character varying NOT NULL,
    contract_version character varying(50) DEFAULT '2026.PRODUCTION'::character varying NOT NULL,
    employer character varying(100) DEFAULT 'FjordHQ AS'::character varying NOT NULL,
    employee character varying(50) DEFAULT 'VEGA'::character varying NOT NULL,
    effective_date date DEFAULT '2025-11-11'::date NOT NULL,
    status character varying(20) DEFAULT 'ACTIVE'::character varying NOT NULL,
    governing_charter character varying(20) DEFAULT 'ADR-006'::character varying NOT NULL,
    constitutional_foundation text[] DEFAULT ARRAY['ADR-001'::text, 'ADR-002'::text, 'ADR-003'::text, 'ADR-004'::text] NOT NULL,
    total_duties integer DEFAULT 10 NOT NULL,
    total_constraints integer DEFAULT 7 NOT NULL,
    total_rights integer DEFAULT 7 NOT NULL,
    override_authority text[] DEFAULT ARRAY['CEO'::text] NOT NULL,
    reports_to character varying(50) DEFAULT 'CEO'::character varying NOT NULL,
    vega_signature text,
    content_hash character varying(64),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: vega_employment_contract_contract_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.vega_employment_contract_contract_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: vega_employment_contract_contract_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.vega_employment_contract_contract_id_seq OWNED BY fhq_meta.vega_employment_contract.contract_id;


--
-- Name: vega_identity; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.vega_identity (
    identity_id integer NOT NULL,
    agent_name character varying(50) DEFAULT 'VEGA'::character varying NOT NULL,
    full_designation character varying(200) DEFAULT 'Verified Evidence & Governance Authority'::character varying NOT NULL,
    role_title character varying(100) DEFAULT 'Chief Audit Officer (CAO)'::character varying NOT NULL,
    tier character varying(20) DEFAULT 'Tier-1'::character varying NOT NULL,
    ed25519_public_key text NOT NULL,
    ed25519_fingerprint character varying(64) NOT NULL,
    key_algorithm character varying(20) DEFAULT 'Ed25519'::character varying NOT NULL,
    key_created_at timestamp with time zone DEFAULT now() NOT NULL,
    employment_contract character varying(50) DEFAULT 'EC-001'::character varying NOT NULL,
    contract_version character varying(50) DEFAULT '2026.PRODUCTION'::character varying NOT NULL,
    reports_to character varying(50) DEFAULT 'CEO'::character varying NOT NULL,
    can_be_overridden_by text[] DEFAULT ARRAY['CEO'::text] NOT NULL,
    governing_adrs text[] DEFAULT ARRAY['ADR-006'::text] NOT NULL,
    authority_level integer DEFAULT 10 NOT NULL,
    status character varying(20) DEFAULT 'ACTIVE'::character varying NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: vega_identity_identity_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.vega_identity_identity_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: vega_identity_identity_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.vega_identity_identity_id_seq OWNED BY fhq_meta.vega_identity.identity_id;


--
-- Name: vega_rights; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.vega_rights (
    right_id integer NOT NULL,
    right_code character varying(20) NOT NULL,
    right_title character varying(200) NOT NULL,
    right_description text NOT NULL,
    right_category character varying(50) NOT NULL,
    governing_adr character varying(20) DEFAULT 'ADR-006'::character varying NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: vega_rights_right_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.vega_rights_right_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: vega_rights_right_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.vega_rights_right_id_seq OWNED BY fhq_meta.vega_rights.right_id;


--
-- Name: vega_sovereignty_log; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.vega_sovereignty_log (
    sovereignty_id uuid DEFAULT gen_random_uuid() NOT NULL,
    component_name text NOT NULL,
    component_type text NOT NULL,
    sovereignty_score numeric NOT NULL,
    "timestamp" timestamp without time zone DEFAULT now() NOT NULL,
    scored_by text DEFAULT 'VEGA'::text NOT NULL,
    evidence jsonb NOT NULL,
    metadata jsonb,
    CONSTRAINT vega_sovereignty_log_component_type_check CHECK ((component_type = ANY (ARRAY['SYSTEM'::text, 'MODEL'::text, 'DATA_SOURCE'::text, 'AGENT'::text]))),
    CONSTRAINT vega_sovereignty_log_sovereignty_score_check CHECK (((sovereignty_score >= (0)::numeric) AND (sovereignty_score <= (1)::numeric)))
);


--
-- Name: TABLE vega_sovereignty_log; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.vega_sovereignty_log IS 'ADR-006 5.4: Commercial sovereignty scoring (Owner: VEGA)';


--
-- Name: vega_sovereignty_log_sovereignty_id_seq; Type: SEQUENCE; Schema: fhq_meta; Owner: -
--

CREATE SEQUENCE fhq_meta.vega_sovereignty_log_sovereignty_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: vega_sovereignty_log_sovereignty_id_seq; Type: SEQUENCE OWNED BY; Schema: fhq_meta; Owner: -
--

ALTER SEQUENCE fhq_meta.vega_sovereignty_log_sovereignty_id_seq OWNED BY fhq_meta.vega_sovereignty_log.sovereignty_id;


--
-- Name: vendor_limits; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.vendor_limits (
    vendor_id uuid DEFAULT gen_random_uuid() NOT NULL,
    vendor_name text NOT NULL,
    tier text DEFAULT 'LAKE'::text NOT NULL,
    free_tier_limit integer DEFAULT 0 NOT NULL,
    interval_type text DEFAULT 'DAY'::text NOT NULL,
    soft_ceiling_pct numeric(3,2) DEFAULT 0.90 NOT NULL,
    hard_limit integer,
    priority_rank integer DEFAULT 100 NOT NULL,
    fallback_vendor_id uuid,
    data_domains text[] DEFAULT '{}'::text[] NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    is_free_tier boolean DEFAULT true NOT NULL,
    api_key_env_var text,
    base_url text,
    rate_limit_per_second numeric(5,2),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by text DEFAULT 'STIG'::text NOT NULL,
    CONSTRAINT valid_ceiling CHECK (((soft_ceiling_pct > (0)::numeric) AND (soft_ceiling_pct <= 1.0))),
    CONSTRAINT valid_interval CHECK ((interval_type = ANY (ARRAY['MINUTE'::text, 'HOUR'::text, 'DAY'::text, 'MONTH'::text]))),
    CONSTRAINT valid_tier CHECK ((tier = ANY (ARRAY['LAKE'::text, 'PULSE'::text, 'SNIPER'::text])))
);


--
-- Name: TABLE vendor_limits; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.vendor_limits IS 'Vendor quota configuration for ADR-012 economic safety. 90% soft ceiling enforced by IoS-014.';


--
-- Name: vendor_role_definitions; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.vendor_role_definitions (
    role_id text NOT NULL,
    role_name text NOT NULL,
    description text NOT NULL,
    can_write_canonical boolean DEFAULT false,
    can_write_operational boolean DEFAULT false,
    can_write_backfill boolean DEFAULT false,
    priority_order integer DEFAULT 99,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: vendor_usage_counters; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.vendor_usage_counters (
    counter_id uuid DEFAULT gen_random_uuid() NOT NULL,
    vendor_id uuid NOT NULL,
    interval_start timestamp with time zone NOT NULL,
    interval_type text NOT NULL,
    current_usage integer DEFAULT 0 NOT NULL,
    peak_usage integer DEFAULT 0 NOT NULL,
    soft_ceiling_reached_at timestamp with time zone,
    hard_limit_reached_at timestamp with time zone,
    last_updated timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE vendor_usage_counters; Type: COMMENT; Schema: fhq_meta; Owner: -
--

COMMENT ON TABLE fhq_meta.vendor_usage_counters IS 'Live vendor API usage tracking per interval.';


--
-- Name: vendors; Type: TABLE; Schema: fhq_meta; Owner: -
--

CREATE TABLE fhq_meta.vendors (
    vendor_id text NOT NULL,
    vendor_name text NOT NULL,
    base_url text,
    rate_limit_per_minute integer,
    requires_auth boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    vendor_role text[],
    price_class_authority text[],
    asset_classes text[]
);


--
-- Name: function_registry; Type: TABLE; Schema: fhq_org; Owner: -
--

CREATE TABLE fhq_org.function_registry (
    function_id uuid DEFAULT gen_random_uuid() NOT NULL,
    function_name text NOT NULL,
    function_type text NOT NULL,
    function_path text,
    owner_agent_id text,
    function_config jsonb DEFAULT '{}'::jsonb NOT NULL,
    enabled boolean DEFAULT true NOT NULL,
    max_execution_time_ms integer DEFAULT 300000,
    cost_ceiling_usd numeric(10,4),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: org_activity_log; Type: TABLE; Schema: fhq_org; Owner: -
--

CREATE TABLE fhq_org.org_activity_log (
    event_id uuid NOT NULL,
    agent_id uuid NOT NULL,
    event_type text NOT NULL,
    payload jsonb NOT NULL,
    agent_signature text NOT NULL,
    vega_certification jsonb,
    "timestamp" timestamp without time zone DEFAULT now() NOT NULL,
    idempotency_key text NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE org_activity_log; Type: COMMENT; Schema: fhq_org; Owner: -
--

COMMENT ON TABLE fhq_org.org_activity_log IS 'Cryptographic chain-of-custody for all agent actions';


--
-- Name: COLUMN org_activity_log.agent_signature; Type: COMMENT; Schema: fhq_org; Owner: -
--

COMMENT ON COLUMN fhq_org.org_activity_log.agent_signature IS 'Ed25519.sign(SHA256(payload + timestamp + agent_id + event_type))';


--
-- Name: COLUMN org_activity_log.vega_certification; Type: COMMENT; Schema: fhq_org; Owner: -
--

COMMENT ON COLUMN fhq_org.org_activity_log.vega_certification IS 'VEGA attestation: Ed25519.sign(SHA256(reconciliation_snapshot + agent_signature))';


--
-- Name: COLUMN org_activity_log.idempotency_key; Type: COMMENT; Schema: fhq_org; Owner: -
--

COMMENT ON COLUMN fhq_org.org_activity_log.idempotency_key IS 'Prevents duplicate actions';


--
-- Name: org_agents; Type: TABLE; Schema: fhq_org; Owner: -
--

CREATE TABLE fhq_org.org_agents (
    agent_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_name text NOT NULL,
    agent_role text NOT NULL,
    llm_version text NOT NULL,
    llm_provider text DEFAULT 'anthropic'::text NOT NULL,
    last_heartbeat timestamp without time zone,
    public_key text NOT NULL,
    private_key_fingerprint text,
    status text DEFAULT 'ACTIVE'::text NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    metadata jsonb,
    CONSTRAINT org_agents_agent_name_check CHECK ((agent_name = ANY (ARRAY['LARS'::text, 'STIG'::text, 'LINE'::text, 'FINN'::text, 'VEGA'::text, 'CSEO'::text, 'CDMO'::text, 'CRIO'::text, 'CEIO'::text, 'CFAO'::text]))),
    CONSTRAINT org_agents_status_check CHECK ((status = ANY (ARRAY['ACTIVE'::text, 'SUSPENDED'::text, 'FAILED'::text, 'UNKNOWN'::text])))
);


--
-- Name: TABLE org_agents; Type: COMMENT; Schema: fhq_org; Owner: -
--

COMMENT ON TABLE fhq_org.org_agents IS 'Agent registry with cryptographic identity (Ed25519)';


--
-- Name: COLUMN org_agents.llm_version; Type: COMMENT; Schema: fhq_org; Owner: -
--

COMMENT ON COLUMN fhq_org.org_agents.llm_version IS 'Deterministic footprint: e.g., claude-sonnet-4-5-20250929';


--
-- Name: COLUMN org_agents.public_key; Type: COMMENT; Schema: fhq_org; Owner: -
--

COMMENT ON COLUMN fhq_org.org_agents.public_key IS 'Ed25519 public key (hex or PEM format)';


--
-- Name: org_memory; Type: TABLE; Schema: fhq_org; Owner: -
--

CREATE TABLE fhq_org.org_memory (
    memory_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id uuid NOT NULL,
    source_event_id uuid NOT NULL,
    memory_content jsonb NOT NULL,
    relevance_score numeric,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    expires_at timestamp without time zone,
    metadata jsonb,
    CONSTRAINT org_memory_relevance_score_check CHECK (((relevance_score >= (0)::numeric) AND (relevance_score <= (1)::numeric)))
);


--
-- Name: TABLE org_memory; Type: COMMENT; Schema: fhq_org; Owner: -
--

COMMENT ON TABLE fhq_org.org_memory IS 'Agent memory - NO free-floating memory allowed (must link to source_event)';


--
-- Name: COLUMN org_memory.source_event_id; Type: COMMENT; Schema: fhq_org; Owner: -
--

COMMENT ON COLUMN fhq_org.org_memory.source_event_id IS 'Mandatory link to activity_log - ensures traceability';


--
-- Name: org_state_reconciliation; Type: TABLE; Schema: fhq_org; Owner: -
--

CREATE TABLE fhq_org.org_state_reconciliation (
    snapshot_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id uuid NOT NULL,
    reconciliation_type text NOT NULL,
    agent_reported_state jsonb NOT NULL,
    canonical_system_state jsonb NOT NULL,
    discrepancy_score numeric NOT NULL,
    is_resolved boolean DEFAULT false NOT NULL,
    vega_review_id uuid,
    "timestamp" timestamp without time zone DEFAULT now() NOT NULL,
    resolution_notes text,
    metadata jsonb,
    CONSTRAINT org_state_reconciliation_discrepancy_score_check CHECK (((discrepancy_score >= (0)::numeric) AND (discrepancy_score <= (1)::numeric)))
);


--
-- Name: TABLE org_state_reconciliation; Type: COMMENT; Schema: fhq_org; Owner: -
--

COMMENT ON TABLE fhq_org.org_state_reconciliation IS 'Antidote to STIG-hallusinasjoner: Detect agent/DB mismatches';


--
-- Name: COLUMN org_state_reconciliation.discrepancy_score; Type: COMMENT; Schema: fhq_org; Owner: -
--

COMMENT ON COLUMN fhq_org.org_state_reconciliation.discrepancy_score IS '0.0=perfect match, 1.0=total mismatch. Threshold: >0.1 triggers agent suspension';


--
-- Name: COLUMN org_state_reconciliation.vega_review_id; Type: COMMENT; Schema: fhq_org; Owner: -
--

COMMENT ON COLUMN fhq_org.org_state_reconciliation.vega_review_id IS 'VEGA certification event (if approved)';


--
-- Name: org_tasks; Type: TABLE; Schema: fhq_org; Owner: -
--

CREATE TABLE fhq_org.org_tasks (
    task_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id uuid,
    priority integer NOT NULL,
    idempotency_key text NOT NULL,
    task_type text NOT NULL,
    task_payload jsonb NOT NULL,
    status text DEFAULT 'PENDING'::text NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    started_at timestamp without time zone,
    completed_at timestamp without time zone,
    result jsonb,
    error_message text,
    metadata jsonb,
    CONSTRAINT org_tasks_priority_check CHECK (((priority >= 0) AND (priority <= 10))),
    CONSTRAINT org_tasks_status_check CHECK ((status = ANY (ARRAY['PENDING'::text, 'IN_PROGRESS'::text, 'COMPLETED'::text, 'FAILED'::text, 'FAILED_SANCTIONED'::text])))
);


--
-- Name: TABLE org_tasks; Type: COMMENT; Schema: fhq_org; Owner: -
--

COMMENT ON TABLE fhq_org.org_tasks IS 'Priority-based task queue: Tier-0 (priority=10) runs first';


--
-- Name: COLUMN org_tasks.priority; Type: COMMENT; Schema: fhq_org; Owner: -
--

COMMENT ON COLUMN fhq_org.org_tasks.priority IS '0-10: 10=Tier-0 (market-critical), 0=lowest';


--
-- Name: COLUMN org_tasks.status; Type: COMMENT; Schema: fhq_org; Owner: -
--

COMMENT ON COLUMN fhq_org.org_tasks.status IS 'FAILED_SANCTIONED = failed due to agent suspension (catastrophic deviation)';


--
-- Name: hash_chains; Type: TABLE; Schema: fhq_security; Owner: -
--

CREATE TABLE fhq_security.hash_chains (
    chain_id character varying(100) NOT NULL,
    chain_type character varying(50) NOT NULL,
    environment_hash text,
    current_block_number integer DEFAULT 0 NOT NULL,
    last_block_hash text,
    genesis_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    last_updated timestamp with time zone DEFAULT now() NOT NULL,
    status character varying(50) DEFAULT 'ACTIVE'::character varying NOT NULL,
    CONSTRAINT hash_chain_status_check CHECK (((status)::text = ANY (ARRAY[('ACTIVE'::character varying)::text, ('FROZEN'::character varying)::text, ('ARCHIVED'::character varying)::text]))),
    CONSTRAINT hash_chain_type_check CHECK (((chain_type)::text = ANY (ARRAY[('IOS_MODULE'::character varying)::text, ('GOVERNANCE'::character varying)::text, ('AUDIT'::character varying)::text, ('SECURITY'::character varying)::text])))
);


--
-- Name: TABLE hash_chains; Type: COMMENT; Schema: fhq_security; Owner: -
--

COMMENT ON TABLE fhq_security.hash_chains IS 'ADR-011 Lineage hash chain registry';


--
-- Name: key_deployment_log; Type: TABLE; Schema: fhq_security; Owner: -
--

CREATE TABLE fhq_security.key_deployment_log (
    deployment_id uuid DEFAULT gen_random_uuid() NOT NULL,
    deployment_event character varying(100) NOT NULL,
    agent_id character varying(50),
    key_version integer,
    environment_hash text,
    chain_id character varying(100),
    deployed_by character varying(50) NOT NULL,
    attested_by character varying(50),
    deployment_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    metadata jsonb DEFAULT '{}'::jsonb
);


--
-- Name: key_rotation_policy; Type: TABLE; Schema: fhq_security; Owner: -
--

CREATE TABLE fhq_security.key_rotation_policy (
    policy_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id character varying(50) NOT NULL,
    rotation_interval_days integer DEFAULT 180 NOT NULL,
    dual_signature_required boolean DEFAULT true NOT NULL,
    last_rotation_date timestamp with time zone,
    next_rotation_date timestamp with time zone,
    rotation_status character varying(50) DEFAULT 'SCHEDULED'::character varying NOT NULL,
    notification_days_before integer DEFAULT 14 NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT rotation_status_check CHECK (((rotation_status)::text = ANY (ARRAY[('SCHEDULED'::character varying)::text, ('PENDING'::character varying)::text, ('IN_PROGRESS'::character varying)::text, ('COMPLETED'::character varying)::text, ('OVERDUE'::character varying)::text])))
);


--
-- Name: TABLE key_rotation_policy; Type: COMMENT; Schema: fhq_security; Owner: -
--

COMMENT ON TABLE fhq_security.key_rotation_policy IS 'ADR-008 Key rotation scheduling per agent';


--
-- Name: keystore; Type: TABLE; Schema: fhq_security; Owner: -
--

CREATE TABLE fhq_security.keystore (
    keystore_id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id character varying(50) NOT NULL,
    private_key_enc text NOT NULL,
    public_key_hex text NOT NULL,
    key_fingerprint character varying(64) NOT NULL,
    key_version integer DEFAULT 1 NOT NULL,
    key_type character varying(50) DEFAULT 'INTERNAL_ATTESTATION'::character varying NOT NULL,
    encryption_method character varying(50) DEFAULT 'FERNET_AES128'::character varying NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    activated_at timestamp with time zone,
    activated_by character varying(50),
    attested_by character varying(50),
    attestation_timestamp timestamp with time zone,
    lineage_hash_root text,
    hash_chain_id character varying(100),
    rotation_due_date timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT keystore_encryption_check CHECK (((encryption_method)::text = ANY (ARRAY[('FERNET_AES128'::character varying)::text, ('AES256_GCM'::character varying)::text, ('RSA_OAEP'::character varying)::text, ('RAW_HEX'::character varying)::text, ('ENV_REFERENCE'::character varying)::text]))),
    CONSTRAINT keystore_key_type_check CHECK (((key_type)::text = ANY (ARRAY[('INTERNAL_ATTESTATION'::character varying)::text, ('GOVERNANCE_SIGNING'::character varying)::text, ('INTER_AGENT_AUTH'::character varying)::text, ('AUDIT_VERIFICATION'::character varying)::text])))
);


--
-- Name: TABLE keystore; Type: COMMENT; Schema: fhq_security; Owner: -
--

COMMENT ON TABLE fhq_security.keystore IS 'ADR-008 Vision-KeyStore for encrypted agent private keys';


--
-- Name: action_level_veto; Type: TABLE; Schema: vega; Owner: -
--

CREATE TABLE vega.action_level_veto (
    veto_id uuid DEFAULT gen_random_uuid() NOT NULL,
    request_id uuid NOT NULL,
    requesting_agent text NOT NULL,
    action_type text NOT NULL,
    action_payload jsonb NOT NULL,
    risk_assessment jsonb,
    risk_score numeric(5,4),
    veto_decision text NOT NULL,
    reclassification_reason text,
    original_gate text,
    reclassified_gate text,
    vega_signature text NOT NULL,
    evaluation_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    decision_timestamp timestamp with time zone,
    metadata jsonb DEFAULT '{}'::jsonb,
    CONSTRAINT action_level_veto_risk_score_check CHECK (((risk_score >= (0)::numeric) AND (risk_score <= (1)::numeric))),
    CONSTRAINT action_level_veto_veto_decision_check CHECK ((veto_decision = ANY (ARRAY['APPROVED'::text, 'BLOCKED'::text, 'RECLASSIFIED'::text, 'PENDING'::text])))
);


--
-- Name: agent_test_execution; Type: TABLE; Schema: vega; Owner: -
--

CREATE TABLE vega.agent_test_execution (
    execution_id uuid DEFAULT gen_random_uuid() NOT NULL,
    run_id uuid NOT NULL,
    agent_id text NOT NULL,
    test_category text NOT NULL,
    tests_executed integer DEFAULT 0 NOT NULL,
    tests_passed integer DEFAULT 0 NOT NULL,
    tests_failed integer DEFAULT 0 NOT NULL,
    governance_loop_verified boolean DEFAULT false,
    authority_boundary_verified boolean DEFAULT false,
    llm_tier_verified boolean DEFAULT false,
    integration_status text DEFAULT 'PENDING'::text,
    execution_duration_ms integer DEFAULT 0,
    execution_context jsonb,
    executed_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT agent_test_execution_agent_id_check CHECK ((agent_id = ANY (ARRAY['LARS'::text, 'STIG'::text, 'LINE'::text, 'FINN'::text, 'VEGA'::text]))),
    CONSTRAINT agent_test_execution_integration_status_check CHECK ((integration_status = ANY (ARRAY['PENDING'::text, 'PASS'::text, 'FAIL'::text, 'PARTIAL'::text])))
);


--
-- Name: TABLE agent_test_execution; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON TABLE vega.agent_test_execution IS 'ADR-011 Section 5.1: Per-agent test execution results';


--
-- Name: api_endpoint_tests; Type: TABLE; Schema: vega; Owner: -
--

CREATE TABLE vega.api_endpoint_tests (
    test_id uuid DEFAULT gen_random_uuid() NOT NULL,
    run_id uuid NOT NULL,
    endpoint_path text NOT NULL,
    endpoint_method text NOT NULL,
    endpoint_category text NOT NULL,
    test_status text DEFAULT 'PENDING'::text NOT NULL,
    response_time_ms integer,
    response_status_code integer,
    schema_validated boolean DEFAULT false,
    auth_validated boolean DEFAULT false,
    governance_validated boolean DEFAULT false,
    request_payload jsonb,
    response_payload jsonb,
    validation_errors jsonb,
    tested_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT api_endpoint_tests_endpoint_method_check CHECK ((endpoint_method = ANY (ARRAY['GET'::text, 'POST'::text, 'PUT'::text, 'DELETE'::text, 'PATCH'::text]))),
    CONSTRAINT api_endpoint_tests_test_status_check CHECK ((test_status = ANY (ARRAY['PENDING'::text, 'PASS'::text, 'FAIL'::text, 'SKIPPED'::text])))
);


--
-- Name: TABLE api_endpoint_tests; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON TABLE vega.api_endpoint_tests IS 'ADR-011 Section 5.2: API endpoint verification results';


--
-- Name: llm_cost_limits; Type: TABLE; Schema: vega; Owner: -
--

CREATE TABLE vega.llm_cost_limits (
    cost_limit_id bigint NOT NULL,
    agent_id character varying(50),
    provider character varying(50),
    max_daily_cost numeric(10,2) DEFAULT 5.00 NOT NULL,
    max_cost_per_task numeric(10,2) DEFAULT 0.50 NOT NULL,
    max_cost_per_agent_per_day numeric(10,2) DEFAULT 1.00 NOT NULL,
    currency character varying(3) DEFAULT 'USD'::character varying NOT NULL,
    estimated_min_cost_per_call numeric(10,6) DEFAULT 0.001,
    estimated_max_cost_per_call numeric(10,6) DEFAULT 0.05,
    source_adr character varying(20) DEFAULT 'ADR-012'::character varying NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by character varying(50) DEFAULT 'SYSTEM'::character varying NOT NULL,
    updated_by character varying(50),
    CONSTRAINT llm_cost_limits_positive_costs CHECK (((max_daily_cost >= (0)::numeric) AND (max_cost_per_task >= (0)::numeric) AND (max_cost_per_agent_per_day >= (0)::numeric)))
);


--
-- Name: TABLE llm_cost_limits; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON TABLE vega.llm_cost_limits IS 'ADR-012 Section 4.2: Cost governance layer - monetary ceilings per agent/task/day';


--
-- Name: COLUMN llm_cost_limits.max_daily_cost; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON COLUMN vega.llm_cost_limits.max_daily_cost IS 'Default: $5.00 (ADR-012 hard ceiling)';


--
-- Name: COLUMN llm_cost_limits.max_cost_per_task; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON COLUMN vega.llm_cost_limits.max_cost_per_task IS 'Default: $0.50 (ADR-012 hard ceiling)';


--
-- Name: COLUMN llm_cost_limits.max_cost_per_agent_per_day; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON COLUMN vega.llm_cost_limits.max_cost_per_agent_per_day IS 'Default: $1.00 (ADR-012 hard ceiling)';


--
-- Name: llm_cost_limits_cost_limit_id_seq; Type: SEQUENCE; Schema: vega; Owner: -
--

CREATE SEQUENCE vega.llm_cost_limits_cost_limit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: llm_cost_limits_cost_limit_id_seq; Type: SEQUENCE OWNED BY; Schema: vega; Owner: -
--

ALTER SEQUENCE vega.llm_cost_limits_cost_limit_id_seq OWNED BY vega.llm_cost_limits.cost_limit_id;


--
-- Name: llm_usage_log; Type: TABLE; Schema: vega; Owner: -
--

CREATE TABLE vega.llm_usage_log (
    usage_id bigint NOT NULL,
    agent_id character varying(50) NOT NULL,
    task_id character varying(100),
    cycle_id character varying(100),
    provider character varying(50) NOT NULL,
    model character varying(100),
    tokens_in integer,
    tokens_out integer,
    tokens_total integer GENERATED ALWAYS AS ((COALESCE(tokens_in, 0) + COALESCE(tokens_out, 0))) STORED,
    cost_usd numeric(10,6) DEFAULT 0.0 NOT NULL,
    estimated_cost_usd numeric(10,6),
    latency_ms integer,
    mode character varying(10) DEFAULT 'STUB'::character varying NOT NULL,
    request_hash character varying(64),
    response_hash character varying(64),
    signature_hex text,
    public_key_hex text,
    "timestamp" timestamp with time zone DEFAULT now() NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT llm_usage_log_mode_check CHECK (((mode)::text = ANY (ARRAY[('LIVE'::character varying)::text, ('STUB'::character varying)::text])))
);


--
-- Name: TABLE llm_usage_log; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON TABLE vega.llm_usage_log IS 'ADR-012 Section 5: Canonical usage ledger for all LLM calls';


--
-- Name: COLUMN llm_usage_log.mode; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON COLUMN vega.llm_usage_log.mode IS 'LIVE = real API call, STUB = mock/placeholder response';


--
-- Name: llm_daily_usage; Type: VIEW; Schema: vega; Owner: -
--

CREATE VIEW vega.llm_daily_usage AS
 SELECT date("timestamp") AS usage_date,
    agent_id,
    provider,
    mode,
    count(*) AS call_count,
    sum(cost_usd) AS total_cost_usd,
    sum(tokens_in) AS total_tokens_in,
    sum(tokens_out) AS total_tokens_out,
    avg(latency_ms) AS avg_latency_ms,
    max(latency_ms) AS max_latency_ms
   FROM vega.llm_usage_log
  GROUP BY (date("timestamp")), agent_id, provider, mode;


--
-- Name: VIEW llm_daily_usage; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON VIEW vega.llm_daily_usage IS 'ADR-012: Daily aggregated LLM usage for cost governance';


--
-- Name: llm_economic_safety_config; Type: TABLE; Schema: vega; Owner: -
--

CREATE TABLE vega.llm_economic_safety_config (
    config_id uuid DEFAULT gen_random_uuid() NOT NULL,
    config_name text NOT NULL,
    config_status text DEFAULT 'ACTIVE'::text NOT NULL,
    max_calls_per_agent_per_minute integer NOT NULL,
    max_cost_per_task numeric(18,8) NOT NULL,
    max_agent_daily_cost numeric(18,8) NOT NULL,
    max_global_daily_cost numeric(18,8) NOT NULL,
    max_latency_ms integer NOT NULL,
    abort_on_overrun boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by text NOT NULL,
    CONSTRAINT config_positive_values CHECK (((max_calls_per_agent_per_minute > 0) AND (max_cost_per_task > (0)::numeric) AND (max_agent_daily_cost > (0)::numeric) AND (max_global_daily_cost > (0)::numeric) AND (max_latency_ms > 0))),
    CONSTRAINT llm_economic_safety_config_config_status_check CHECK ((config_status = ANY (ARRAY['ACTIVE'::text, 'DEPRECATED'::text, 'ARCHIVED'::text])))
);


--
-- Name: TABLE llm_economic_safety_config; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON TABLE vega.llm_economic_safety_config IS 'Economic safety configuration for LLM usage. Per ADR-012, only ACTIVE config is enforced.';


--
-- Name: llm_execution_limits; Type: TABLE; Schema: vega; Owner: -
--

CREATE TABLE vega.llm_execution_limits (
    execution_limit_id bigint NOT NULL,
    agent_id character varying(50),
    provider character varying(50),
    max_llm_steps_per_task integer DEFAULT 3 NOT NULL,
    max_total_latency_ms integer DEFAULT 3000 NOT NULL,
    max_total_tokens_generated integer,
    abort_on_overrun boolean DEFAULT true NOT NULL,
    source_adr character varying(20) DEFAULT 'ADR-012'::character varying NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by character varying(50) DEFAULT 'SYSTEM'::character varying NOT NULL
);


--
-- Name: TABLE llm_execution_limits; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON TABLE vega.llm_execution_limits IS 'ADR-012 Section 4.3: Execution governance - reasoning depth control';


--
-- Name: COLUMN llm_execution_limits.max_llm_steps_per_task; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON COLUMN vega.llm_execution_limits.max_llm_steps_per_task IS 'Default: 3 (prevents infinite thought spirals)';


--
-- Name: COLUMN llm_execution_limits.max_total_latency_ms; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON COLUMN vega.llm_execution_limits.max_total_latency_ms IS 'Default: 3000ms (ADR-012 ceiling)';


--
-- Name: llm_execution_limits_execution_limit_id_seq; Type: SEQUENCE; Schema: vega; Owner: -
--

CREATE SEQUENCE vega.llm_execution_limits_execution_limit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: llm_execution_limits_execution_limit_id_seq; Type: SEQUENCE OWNED BY; Schema: vega; Owner: -
--

ALTER SEQUENCE vega.llm_execution_limits_execution_limit_id_seq OWNED BY vega.llm_execution_limits.execution_limit_id;


--
-- Name: llm_rate_limits; Type: TABLE; Schema: vega; Owner: -
--

CREATE TABLE vega.llm_rate_limits (
    rate_limit_id bigint NOT NULL,
    agent_id character varying(50),
    provider character varying(50),
    max_calls_per_minute integer DEFAULT 3 NOT NULL,
    max_calls_per_pipeline_execution integer DEFAULT 5 NOT NULL,
    global_daily_limit integer DEFAULT 100 NOT NULL,
    source_adr character varying(20) DEFAULT 'ADR-012'::character varying NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by character varying(50) DEFAULT 'SYSTEM'::character varying NOT NULL,
    updated_by character varying(50)
);


--
-- Name: TABLE llm_rate_limits; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON TABLE vega.llm_rate_limits IS 'ADR-012 Section 4.1: Rate governance layer - per-agent and global rate ceilings';


--
-- Name: COLUMN llm_rate_limits.max_calls_per_minute; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON COLUMN vega.llm_rate_limits.max_calls_per_minute IS 'Default: 3 (ADR-012 constitutional baseline)';


--
-- Name: COLUMN llm_rate_limits.max_calls_per_pipeline_execution; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON COLUMN vega.llm_rate_limits.max_calls_per_pipeline_execution IS 'Default: 5 (ADR-012 constitutional baseline)';


--
-- Name: COLUMN llm_rate_limits.global_daily_limit; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON COLUMN vega.llm_rate_limits.global_daily_limit IS 'Default: 100 (ADR-012 constitutional baseline)';


--
-- Name: llm_rate_limits_rate_limit_id_seq; Type: SEQUENCE; Schema: vega; Owner: -
--

CREATE SEQUENCE vega.llm_rate_limits_rate_limit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: llm_rate_limits_rate_limit_id_seq; Type: SEQUENCE OWNED BY; Schema: vega; Owner: -
--

ALTER SEQUENCE vega.llm_rate_limits_rate_limit_id_seq OWNED BY vega.llm_rate_limits.rate_limit_id;


--
-- Name: llm_usage_log_usage_id_seq; Type: SEQUENCE; Schema: vega; Owner: -
--

CREATE SEQUENCE vega.llm_usage_log_usage_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: llm_usage_log_usage_id_seq; Type: SEQUENCE OWNED BY; Schema: vega; Owner: -
--

ALTER SEQUENCE vega.llm_usage_log_usage_id_seq OWNED BY vega.llm_usage_log.usage_id;


--
-- Name: llm_violation_events; Type: TABLE; Schema: vega; Owner: -
--

CREATE TABLE vega.llm_violation_events (
    violation_id bigint NOT NULL,
    agent_id character varying(50) NOT NULL,
    task_id character varying(100),
    cycle_id character varying(100),
    provider character varying(50),
    violation_type character varying(20) NOT NULL,
    violation_subtype character varying(50),
    governance_action character varying(30) NOT NULL,
    severity character varying(20) DEFAULT 'CLASS_B'::character varying NOT NULL,
    discrepancy_score numeric(5,4),
    details jsonb DEFAULT '{}'::jsonb NOT NULL,
    limit_value numeric(10,4),
    actual_value numeric(10,4),
    hash_prev character varying(64),
    hash_self character varying(64) NOT NULL,
    "timestamp" timestamp with time zone DEFAULT now() NOT NULL,
    is_resolved boolean DEFAULT false NOT NULL,
    resolved_at timestamp with time zone,
    resolved_by character varying(50),
    resolution_notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT llm_violation_events_governance_action_check CHECK (((governance_action)::text = ANY (ARRAY[('NONE'::character varying)::text, ('WARN'::character varying)::text, ('SUSPEND_RECOMMENDATION'::character varying)::text, ('SWITCH_TO_STUB'::character varying)::text]))),
    CONSTRAINT llm_violation_events_severity_check CHECK (((severity)::text = ANY (ARRAY[('CLASS_A'::character varying)::text, ('CLASS_B'::character varying)::text, ('CLASS_C'::character varying)::text]))),
    CONSTRAINT llm_violation_events_violation_type_check CHECK (((violation_type)::text = ANY (ARRAY[('RATE'::character varying)::text, ('COST'::character varying)::text, ('EXECUTION'::character varying)::text])))
);


--
-- Name: TABLE llm_violation_events; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON TABLE vega.llm_violation_events IS 'ADR-012 Section 5: Hash-chained governance log for violations';


--
-- Name: COLUMN llm_violation_events.violation_type; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON COLUMN vega.llm_violation_events.violation_type IS 'RATE = rate limit, COST = cost ceiling, EXECUTION = steps/latency/tokens';


--
-- Name: COLUMN llm_violation_events.governance_action; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON COLUMN vega.llm_violation_events.governance_action IS 'Action taken: NONE, WARN, SUSPEND_RECOMMENDATION, SWITCH_TO_STUB';


--
-- Name: COLUMN llm_violation_events.hash_self; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON COLUMN vega.llm_violation_events.hash_self IS 'SHA-256 hash for Fortress integrity (ADR-011)';


--
-- Name: llm_violation_events_violation_id_seq; Type: SEQUENCE; Schema: vega; Owner: -
--

CREATE SEQUENCE vega.llm_violation_events_violation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: llm_violation_events_violation_id_seq; Type: SEQUENCE OWNED BY; Schema: vega; Owner: -
--

ALTER SEQUENCE vega.llm_violation_events_violation_id_seq OWNED BY vega.llm_violation_events.violation_id;


--
-- Name: llm_violation_summary_24h; Type: VIEW; Schema: vega; Owner: -
--

CREATE VIEW vega.llm_violation_summary_24h AS
 SELECT violation_type,
    governance_action,
    severity,
    count(*) AS violation_count,
    max("timestamp") AS last_violation_at
   FROM vega.llm_violation_events
  WHERE (("timestamp" > (now() - '24:00:00'::interval)) AND (is_resolved = false))
  GROUP BY violation_type, governance_action, severity;


--
-- Name: VIEW llm_violation_summary_24h; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON VIEW vega.llm_violation_summary_24h IS 'ADR-012: 24-hour violation summary for QG-F6 quality gate';


--
-- Name: quality_gate_results; Type: TABLE; Schema: vega; Owner: -
--

CREATE TABLE vega.quality_gate_results (
    gate_id uuid DEFAULT gen_random_uuid() NOT NULL,
    run_id uuid NOT NULL,
    gate_code text NOT NULL,
    gate_name text NOT NULL,
    gate_description text,
    gate_status text DEFAULT 'PENDING'::text NOT NULL,
    requirement_type text NOT NULL,
    requirement_value text NOT NULL,
    actual_value text,
    evaluated_at timestamp with time zone,
    evaluation_notes text,
    evidence_bundle_id uuid,
    evidence_hash text,
    adr_reference text DEFAULT 'ADR-011'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT quality_gate_results_gate_code_check CHECK ((gate_code = ANY (ARRAY['QG-F1'::text, 'QG-F2'::text, 'QG-F3'::text, 'QG-F4'::text, 'QG-F5'::text, 'QG-F6'::text]))),
    CONSTRAINT quality_gate_results_gate_status_check CHECK ((gate_status = ANY (ARRAY['PENDING'::text, 'PASS'::text, 'FAIL'::text, 'BLOCKED'::text, 'SKIPPED'::text])))
);


--
-- Name: TABLE quality_gate_results; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON TABLE vega.quality_gate_results IS 'ADR-011 Section 6: Quality Gate (QG-F1 to QG-F6) evaluation results';


--
-- Name: test_coverage; Type: TABLE; Schema: vega; Owner: -
--

CREATE TABLE vega.test_coverage (
    coverage_id uuid DEFAULT gen_random_uuid() NOT NULL,
    run_id uuid NOT NULL,
    module_name text NOT NULL,
    module_type text NOT NULL,
    lines_total integer DEFAULT 0 NOT NULL,
    lines_covered integer DEFAULT 0 NOT NULL,
    lines_missed integer DEFAULT 0 NOT NULL,
    branches_total integer DEFAULT 0 NOT NULL,
    branches_covered integer DEFAULT 0 NOT NULL,
    line_coverage_pct numeric(5,2) DEFAULT 0.0 NOT NULL,
    branch_coverage_pct numeric(5,2) DEFAULT 0.0,
    meets_threshold boolean DEFAULT false NOT NULL,
    required_threshold numeric(5,2) DEFAULT 80.0 NOT NULL,
    computed_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT test_coverage_branch_check CHECK ((branches_covered <= branches_total)),
    CONSTRAINT test_coverage_line_check CHECK ((lines_covered <= lines_total)),
    CONSTRAINT test_coverage_module_type_check CHECK ((module_type = ANY (ARRAY['CRYPTO'::text, 'GOVERNANCE'::text, 'ORCHESTRATOR'::text, 'AGENT'::text, 'API'::text, 'ECONOMIC'::text])))
);


--
-- Name: TABLE test_coverage; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON TABLE vega.test_coverage IS 'ADR-011 Section 4.2: Test coverage metrics per module';


--
-- Name: test_failures; Type: TABLE; Schema: vega; Owner: -
--

CREATE TABLE vega.test_failures (
    failure_id uuid DEFAULT gen_random_uuid() NOT NULL,
    run_id uuid NOT NULL,
    test_name text NOT NULL,
    test_module text NOT NULL,
    test_layer text NOT NULL,
    failure_type text DEFAULT 'ASSERTION'::text NOT NULL,
    failure_message text NOT NULL,
    stack_trace text,
    input_data jsonb,
    expected_output jsonb,
    actual_output jsonb,
    is_reproducible boolean,
    reproduction_count integer DEFAULT 0,
    resolution_status text DEFAULT 'OPEN'::text NOT NULL,
    resolution_notes text,
    resolved_at timestamp with time zone,
    detected_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT test_failures_resolution_status_check CHECK ((resolution_status = ANY (ARRAY['OPEN'::text, 'INVESTIGATING'::text, 'RESOLVED'::text, 'WONT_FIX'::text, 'KNOWN_ISSUE'::text]))),
    CONSTRAINT test_failures_test_layer_check CHECK ((test_layer = ANY (ARRAY['UNIT'::text, 'SERVICES'::text, 'WORKER_API'::text, 'INTEGRATION'::text, 'TIER3'::text, 'TIER3_5'::text])))
);


--
-- Name: TABLE test_failures; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON TABLE vega.test_failures IS 'ADR-011 Section 4.2: Test failure tracking with reproducibility verification';


--
-- Name: test_runs; Type: TABLE; Schema: vega; Owner: -
--

CREATE TABLE vega.test_runs (
    run_id uuid DEFAULT gen_random_uuid() NOT NULL,
    run_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    run_type text DEFAULT 'FULL'::text NOT NULL,
    run_environment text DEFAULT 'PRODUCTION'::text NOT NULL,
    test_layers text[] DEFAULT ARRAY['UNIT'::text, 'SERVICES'::text, 'WORKER_API'::text, 'INTEGRATION'::text, 'TIER3'::text, 'TIER3_5'::text] NOT NULL,
    platform text NOT NULL,
    total_tests integer DEFAULT 0 NOT NULL,
    tests_passed integer DEFAULT 0 NOT NULL,
    tests_failed integer DEFAULT 0 NOT NULL,
    tests_skipped integer DEFAULT 0 NOT NULL,
    execution_time_ms integer DEFAULT 0 NOT NULL,
    coverage_percentage numeric(5,2) DEFAULT 0.0,
    run_status text DEFAULT 'RUNNING'::text NOT NULL,
    vega_attested boolean DEFAULT false NOT NULL,
    vega_signature text,
    attestation_timestamp timestamp with time zone,
    adr_reference text DEFAULT 'ADR-011'::text NOT NULL,
    initiated_by text DEFAULT 'SYSTEM'::text NOT NULL,
    completed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT test_runs_run_status_check CHECK ((run_status = ANY (ARRAY['RUNNING'::text, 'COMPLETED'::text, 'FAILED'::text, 'ABORTED'::text])))
);


--
-- Name: TABLE test_runs; Type: COMMENT; Schema: vega; Owner: -
--

COMMENT ON TABLE vega.test_runs IS 'ADR-011 Section 4.2: VEGA test run records for Production Fortress';


--
-- Name: governance_decisions; Type: TABLE; Schema: vision_autonomy; Owner: -
--

CREATE TABLE vision_autonomy.governance_decisions (
    decision_id uuid DEFAULT gen_random_uuid() NOT NULL,
    decision_type text NOT NULL,
    decision_scope text NOT NULL,
    decision text NOT NULL,
    rationale text,
    vega_reviewed boolean DEFAULT false NOT NULL,
    vega_approved boolean,
    vega_reviewer text,
    vega_review_timestamp timestamp with time zone,
    gate_level text NOT NULL,
    gate_passed boolean DEFAULT false NOT NULL,
    created_by text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    hash_chain_id text,
    signature_id uuid,
    CONSTRAINT governance_gate_check CHECK ((gate_level = ANY (ARRAY['G0'::text, 'G1'::text, 'G2'::text, 'G3'::text, 'G4'::text]))),
    CONSTRAINT governance_vega_check CHECK (((vega_reviewed = false) OR ((vega_reviewed = true) AND (vega_reviewer IS NOT NULL) AND (vega_review_timestamp IS NOT NULL))))
);


--
-- Name: meta_state_sync; Type: TABLE; Schema: vision_autonomy; Owner: -
--

CREATE TABLE vision_autonomy.meta_state_sync (
    sync_id uuid DEFAULT gen_random_uuid() NOT NULL,
    sync_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    sync_type text NOT NULL,
    source_schema text NOT NULL,
    target_schema text NOT NULL,
    records_read integer DEFAULT 0 NOT NULL,
    records_written integer DEFAULT 0 NOT NULL,
    records_failed integer DEFAULT 0 NOT NULL,
    sync_status text NOT NULL,
    error_details jsonb,
    reconciliation_snapshot_id uuid,
    discrepancy_count integer DEFAULT 0,
    initiated_by text NOT NULL,
    completed_at timestamp with time zone,
    hash_chain_id text,
    signature_id uuid,
    CONSTRAINT meta_sync_completion_check CHECK ((((sync_status = 'SUCCESS'::text) AND (completed_at IS NOT NULL)) OR (sync_status <> 'SUCCESS'::text))),
    CONSTRAINT meta_sync_status_check CHECK ((sync_status = ANY (ARRAY['SUCCESS'::text, 'PARTIAL'::text, 'FAILED'::text])))
);


--
-- Name: cinematic_events; Type: TABLE; Schema: vision_cinematic; Owner: -
--

CREATE TABLE vision_cinematic.cinematic_events (
    event_id uuid DEFAULT gen_random_uuid() NOT NULL,
    asset_id text NOT NULL,
    event_type text NOT NULL,
    event_timestamp timestamp with time zone NOT NULL,
    event_intensity numeric(8,4) DEFAULT 0.5 NOT NULL,
    event_duration_ms integer DEFAULT 2000 NOT NULL,
    event_data jsonb DEFAULT '{}'::jsonb NOT NULL,
    camera_animation text,
    particle_burst boolean DEFAULT false,
    flash_color text,
    detected_at timestamp with time zone DEFAULT now(),
    detected_by text DEFAULT 'STIG'::text NOT NULL,
    acknowledged boolean DEFAULT false,
    acknowledged_at timestamp with time zone
);


--
-- Name: TABLE cinematic_events; Type: COMMENT; Schema: vision_cinematic; Owner: -
--

COMMENT ON TABLE vision_cinematic.cinematic_events IS 'ADR-024: Cinematic event triggers for special animations';


--
-- Name: defcon_visual_rules; Type: TABLE; Schema: vision_cinematic; Owner: -
--

CREATE TABLE vision_cinematic.defcon_visual_rules (
    rule_id uuid DEFAULT gen_random_uuid() NOT NULL,
    defcon_level text NOT NULL,
    max_particle_count integer NOT NULL,
    max_bloom_intensity numeric(8,4) NOT NULL,
    allow_camera_shake boolean NOT NULL,
    allow_post_processing boolean NOT NULL,
    color_desaturation numeric(8,4) DEFAULT 0.0 NOT NULL,
    force_static_render boolean DEFAULT false NOT NULL,
    emergency_message text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE defcon_visual_rules; Type: COMMENT; Schema: vision_cinematic; Owner: -
--

COMMENT ON TABLE vision_cinematic.defcon_visual_rules IS 'ADR-016/024: DEFCON-based visual degradation rules';


--
-- Name: mapping_versions; Type: TABLE; Schema: vision_cinematic; Owner: -
--

CREATE TABLE vision_cinematic.mapping_versions (
    version_id uuid DEFAULT gen_random_uuid() NOT NULL,
    version_tag text NOT NULL,
    trend_mapping jsonb NOT NULL,
    momentum_mapping jsonb NOT NULL,
    volatility_mapping jsonb NOT NULL,
    volume_mapping jsonb NOT NULL,
    activated_at timestamp with time zone DEFAULT now(),
    activated_by text NOT NULL,
    is_current boolean DEFAULT false,
    vega_attested boolean DEFAULT false,
    vega_attestation_id uuid
);


--
-- Name: TABLE mapping_versions; Type: COMMENT; Schema: vision_cinematic; Owner: -
--

COMMENT ON TABLE vision_cinematic.mapping_versions IS 'ADR-023: Versioned deterministic mapping functions';


--
-- Name: render_evidence; Type: TABLE; Schema: vision_cinematic; Owner: -
--

CREATE TABLE vision_cinematic.render_evidence (
    evidence_id uuid DEFAULT gen_random_uuid() NOT NULL,
    vsv_id uuid,
    frame_timestamp timestamp with time zone NOT NULL,
    rendered_asset_id text NOT NULL,
    rendered_params jsonb NOT NULL,
    input_data_hash text NOT NULL,
    output_frame_hash text NOT NULL,
    client_session_id text,
    client_viewport jsonb,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE render_evidence; Type: COMMENT; Schema: vision_cinematic; Owner: -
--

COMMENT ON TABLE vision_cinematic.render_evidence IS 'ADR-022: Frame-to-data audit trail for compliance';


--
-- Name: visual_state_vectors; Type: TABLE; Schema: vision_cinematic; Owner: -
--

CREATE TABLE vision_cinematic.visual_state_vectors (
    vsv_id uuid DEFAULT gen_random_uuid() NOT NULL,
    asset_id text NOT NULL,
    "timestamp" timestamp with time zone NOT NULL,
    trend_flow_speed numeric(8,4) DEFAULT 0.5 NOT NULL,
    trend_flow_direction numeric(8,4) DEFAULT 0.0 NOT NULL,
    trend_intensity numeric(8,4) DEFAULT 0.5 NOT NULL,
    trend_color_hue numeric(8,4) DEFAULT 0.6 NOT NULL,
    momentum_amplitude numeric(8,4) DEFAULT 0.5 NOT NULL,
    momentum_frequency numeric(8,4) DEFAULT 1.0 NOT NULL,
    momentum_phase numeric(8,4) DEFAULT 0.0 NOT NULL,
    momentum_color_saturation numeric(8,4) DEFAULT 0.7 NOT NULL,
    volatility_density numeric(8,4) DEFAULT 0.3 NOT NULL,
    volatility_turbulence numeric(8,4) DEFAULT 0.5 NOT NULL,
    volatility_color_lightness numeric(8,4) DEFAULT 0.5 NOT NULL,
    volume_particle_count integer DEFAULT 1000 NOT NULL,
    volume_particle_speed numeric(8,4) DEFAULT 0.5 NOT NULL,
    volume_glow_intensity numeric(8,4) DEFAULT 0.5 NOT NULL,
    camera_shake_intensity numeric(8,4) DEFAULT 0.0 NOT NULL,
    camera_zoom_level numeric(8,4) DEFAULT 1.0 NOT NULL,
    bloom_intensity numeric(8,4) DEFAULT 0.3 NOT NULL,
    vignette_intensity numeric(8,4) DEFAULT 0.2 NOT NULL,
    film_grain numeric(8,4) DEFAULT 0.05 NOT NULL,
    regime_label text,
    regime_confidence numeric(8,4),
    defcon_level text DEFAULT 'GREEN'::text NOT NULL,
    defcon_degradation_factor numeric(8,4) DEFAULT 1.0 NOT NULL,
    computed_at timestamp with time zone DEFAULT now(),
    computed_by text DEFAULT 'STIG'::text NOT NULL,
    mapping_version text DEFAULT 'v1.0.0'::text NOT NULL,
    source_hash text NOT NULL,
    vsv_signature text
);


--
-- Name: TABLE visual_state_vectors; Type: COMMENT; Schema: vision_cinematic; Owner: -
--

COMMENT ON TABLE vision_cinematic.visual_state_vectors IS 'ADR-023: Pre-computed Visual State Vectors for cinematic rendering';


--
-- Name: economic_safety_gate; Type: TABLE; Schema: vision_core; Owner: -
--

CREATE TABLE vision_core.economic_safety_gate (
    gate_id uuid DEFAULT gen_random_uuid() NOT NULL,
    gate_name text NOT NULL,
    gate_status text NOT NULL,
    gate_reason text,
    last_checked_at timestamp with time zone DEFAULT now() NOT NULL,
    checked_by text NOT NULL,
    created_by text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT economic_safety_gate_gate_status_check CHECK ((gate_status = ANY (ARRAY['PASS'::text, 'FAIL'::text, 'PENDING'::text])))
);


--
-- Name: execution_state; Type: TABLE; Schema: vision_core; Owner: -
--

CREATE TABLE vision_core.execution_state (
    state_id integer NOT NULL,
    component_name character varying(100),
    state_type character varying(50),
    state_value jsonb DEFAULT '{}'::jsonb,
    created_by character varying(50),
    hash_chain_id character varying(200),
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: execution_state_state_id_seq; Type: SEQUENCE; Schema: vision_core; Owner: -
--

CREATE SEQUENCE vision_core.execution_state_state_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: execution_state_state_id_seq; Type: SEQUENCE OWNED BY; Schema: vision_core; Owner: -
--

ALTER SEQUENCE vision_core.execution_state_state_id_seq OWNED BY vision_core.execution_state.state_id;


--
-- Name: live_mode_activations; Type: TABLE; Schema: vision_core; Owner: -
--

CREATE TABLE vision_core.live_mode_activations (
    activation_id uuid DEFAULT gen_random_uuid() NOT NULL,
    proposal_id uuid NOT NULL,
    review_id uuid NOT NULL,
    authorization_id uuid NOT NULL,
    activated_by text NOT NULL,
    activation_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    previous_mode text NOT NULL,
    new_mode text NOT NULL,
    system_snapshot_hash text NOT NULL,
    activation_status text NOT NULL,
    deactivation_timestamp timestamp with time zone,
    deactivation_reason text,
    hash_chain_id text NOT NULL,
    signature_id text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT live_mode_activations_activation_status_check CHECK ((activation_status = ANY (ARRAY['ACTIVE'::text, 'DEACTIVATED'::text, 'REVOKED'::text]))),
    CONSTRAINT live_mode_activations_new_mode_check CHECK ((new_mode = ANY (ARRAY['STUB'::text, 'LIVE'::text])))
);


--
-- Name: live_mode_authorizations; Type: TABLE; Schema: vision_core; Owner: -
--

CREATE TABLE vision_core.live_mode_authorizations (
    authorization_id uuid DEFAULT gen_random_uuid() NOT NULL,
    proposal_id uuid NOT NULL,
    review_id uuid NOT NULL,
    authorized_by text NOT NULL,
    authorization_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    authorization_decision text NOT NULL,
    authorization_rationale text NOT NULL,
    conditions jsonb,
    valid_until timestamp with time zone,
    hash_chain_id text NOT NULL,
    signature_id text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT live_mode_authorizations_authorization_decision_check CHECK ((authorization_decision = ANY (ARRAY['AUTHORIZED'::text, 'DENIED'::text])))
);


--
-- Name: live_mode_proposals; Type: TABLE; Schema: vision_core; Owner: -
--

CREATE TABLE vision_core.live_mode_proposals (
    proposal_id uuid DEFAULT gen_random_uuid() NOT NULL,
    proposed_by text NOT NULL,
    proposal_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    proposal_rationale text NOT NULL,
    qg_f6_status text NOT NULL,
    attested_functions_count integer NOT NULL,
    active_agents_count integer NOT NULL,
    pending_violations_count integer NOT NULL,
    class_a_events_24h integer NOT NULL,
    readiness_status text NOT NULL,
    readiness_details jsonb NOT NULL,
    proposal_status text DEFAULT 'PENDING'::text NOT NULL,
    hash_chain_id text NOT NULL,
    signature_id text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT live_mode_proposals_proposal_status_check CHECK ((proposal_status = ANY (ARRAY['PENDING'::text, 'UNDER_REVIEW'::text, 'APPROVED'::text, 'REJECTED'::text, 'WITHDRAWN'::text]))),
    CONSTRAINT live_mode_proposals_proposed_by_check CHECK ((proposed_by = 'LARS'::text)),
    CONSTRAINT live_mode_proposals_readiness_status_check CHECK ((readiness_status = ANY (ARRAY['READY'::text, 'BLOCKED'::text])))
);


--
-- Name: live_mode_reviews; Type: TABLE; Schema: vision_core; Owner: -
--

CREATE TABLE vision_core.live_mode_reviews (
    review_id uuid DEFAULT gen_random_uuid() NOT NULL,
    proposal_id uuid NOT NULL,
    reviewed_by text NOT NULL,
    review_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    review_decision text NOT NULL,
    review_rationale text NOT NULL,
    integrity_verified boolean NOT NULL,
    attestations_verified boolean NOT NULL,
    keys_verified boolean NOT NULL,
    governance_verified boolean NOT NULL,
    hash_chain_id text NOT NULL,
    signature_id text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT live_mode_reviews_review_decision_check CHECK ((review_decision = ANY (ARRAY['APPROVE'::text, 'REJECT'::text, 'REQUEST_CHANGES'::text]))),
    CONSTRAINT live_mode_reviews_reviewed_by_check CHECK ((reviewed_by = 'VEGA'::text))
);


--
-- Name: noise_profile; Type: TABLE; Schema: vision_core; Owner: -
--

CREATE TABLE vision_core.noise_profile (
    profile_id uuid DEFAULT gen_random_uuid() NOT NULL,
    analysis_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    window_start timestamp with time zone NOT NULL,
    window_end timestamp with time zone NOT NULL,
    noise_floor_value numeric NOT NULL,
    noise_variance numeric,
    noise_distribution jsonb,
    signal_threshold numeric NOT NULL,
    confidence_level numeric,
    calculation_method text NOT NULL,
    data_sources text[],
    created_by text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    hash_chain_id text,
    signature_id uuid,
    CONSTRAINT noise_profile_confidence_check CHECK (((confidence_level >= (0)::numeric) AND (confidence_level <= (1)::numeric))),
    CONSTRAINT noise_profile_window_check CHECK ((window_end > window_start))
);


--
-- Name: aci_execution_state; Type: TABLE; Schema: vision_signals; Owner: -
--

CREATE TABLE vision_signals.aci_execution_state (
    state_id uuid DEFAULT gen_random_uuid() NOT NULL,
    execution_state text NOT NULL,
    dynamic_reasoning_loop boolean NOT NULL,
    sitc_enabled boolean NOT NULL,
    inforage_enabled boolean NOT NULL,
    ikea_enabled boolean NOT NULL,
    bound_state_hash text NOT NULL,
    activated_at timestamp with time zone DEFAULT now(),
    activated_by text NOT NULL
);


--
-- Name: aci_rehydration_status; Type: TABLE; Schema: vision_signals; Owner: -
--

CREATE TABLE vision_signals.aci_rehydration_status (
    status_id uuid DEFAULT gen_random_uuid() NOT NULL,
    ikea_boundary_reset boolean NOT NULL,
    sitc_cache_reset boolean NOT NULL,
    inforage_budget_reset boolean NOT NULL,
    aci_status text NOT NULL,
    rehydration_timestamp timestamp with time zone DEFAULT now()
);


--
-- Name: alpha_graph_edges; Type: TABLE; Schema: vision_signals; Owner: -
--

CREATE TABLE vision_signals.alpha_graph_edges (
    edge_id uuid DEFAULT gen_random_uuid() NOT NULL,
    source_node text NOT NULL,
    target_node text NOT NULL,
    edge_type text NOT NULL,
    confidence numeric(5,4) DEFAULT 0.5,
    causal_weight numeric(5,4) DEFAULT 0.5,
    is_active boolean DEFAULT true,
    evidence_count integer DEFAULT 1,
    last_validated timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now(),
    lag_days integer,
    threshold_value double precision,
    amplification_factor double precision,
    inhibition_score double precision,
    is_causal_edge boolean DEFAULT false,
    CONSTRAINT valid_edge_type CHECK ((edge_type = ANY (ARRAY['LEADS'::text, 'LAGS'::text, 'CORRELATES'::text, 'INVERSE'::text, 'AMPLIFIES'::text, 'INHIBITS'::text, 'CAUSES'::text])))
);


--
-- Name: alpha_graph_nodes; Type: TABLE; Schema: vision_signals; Owner: -
--

CREATE TABLE vision_signals.alpha_graph_nodes (
    node_id text NOT NULL,
    node_type text NOT NULL,
    display_name text,
    data_source text,
    is_active boolean DEFAULT true,
    updated_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now(),
    statistical_signature jsonb,
    relevance_horizon integer,
    regime_state text,
    is_macro_node boolean DEFAULT false
);


--
-- Name: alpha_signals; Type: TABLE; Schema: vision_signals; Owner: -
--

CREATE TABLE vision_signals.alpha_signals (
    signal_id uuid DEFAULT gen_random_uuid() NOT NULL,
    signal_type text NOT NULL,
    signal_strength numeric NOT NULL,
    confidence_score numeric NOT NULL,
    generated_at timestamp with time zone DEFAULT now() NOT NULL,
    valid_from timestamp with time zone NOT NULL,
    valid_until timestamp with time zone,
    signal_data jsonb NOT NULL,
    baseline_id uuid,
    deviation_from_baseline numeric,
    is_executable boolean DEFAULT false NOT NULL,
    execution_blocked_reason text,
    created_by text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    hash_chain_id text,
    signature_id uuid,
    CONSTRAINT alpha_signals_confidence_check CHECK (((confidence_score >= (0)::numeric) AND (confidence_score <= (1)::numeric))),
    CONSTRAINT alpha_signals_execution_block CHECK (((is_executable = false) OR (execution_blocked_reason IS NULL)))
);


--
-- Name: ceio_cycle_state; Type: TABLE; Schema: vision_signals; Owner: -
--

CREATE TABLE vision_signals.ceio_cycle_state (
    cycle_id uuid DEFAULT gen_random_uuid() NOT NULL,
    fetch_enabled boolean NOT NULL,
    clean_enabled boolean NOT NULL,
    stage_enabled boolean NOT NULL,
    lake_tier_enabled boolean NOT NULL,
    pulse_tier_enabled boolean NOT NULL,
    sniper_tier_enabled boolean NOT NULL,
    aci_binding boolean NOT NULL,
    activated_at timestamp with time zone DEFAULT now()
);


--
-- Name: decision_surface_state; Type: TABLE; Schema: vision_signals; Owner: -
--

CREATE TABLE vision_signals.decision_surface_state (
    surface_id uuid DEFAULT gen_random_uuid() NOT NULL,
    decision_ledger_enabled boolean NOT NULL,
    quad_hash_modifiers_applied boolean NOT NULL,
    paper_execution_mode boolean NOT NULL,
    calibration_sequences integer NOT NULL,
    trading_surfaces_frozen boolean NOT NULL,
    execution_authority text NOT NULL,
    activated_at timestamp with time zone DEFAULT now()
);


--
-- Name: regime_engine_state; Type: TABLE; Schema: vision_signals; Owner: -
--

CREATE TABLE vision_signals.regime_engine_state (
    engine_id uuid DEFAULT gen_random_uuid() NOT NULL,
    perception_mode text NOT NULL,
    refresh_interval text NOT NULL,
    causal_modifiers_bound boolean NOT NULL,
    alpha_graph_version text NOT NULL,
    activated_at timestamp with time zone DEFAULT now()
);


--
-- Name: regime_inference_packs; Type: TABLE; Schema: vision_signals; Owner: -
--

CREATE TABLE vision_signals.regime_inference_packs (
    pack_id uuid DEFAULT gen_random_uuid() NOT NULL,
    pack_version integer NOT NULL,
    regime_multipliers jsonb NOT NULL,
    causal_binding_stats jsonb NOT NULL,
    active_predictions jsonb NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: regime_position_rules; Type: TABLE; Schema: vision_signals; Owner: -
--

CREATE TABLE vision_signals.regime_position_rules (
    rule_id uuid DEFAULT gen_random_uuid() NOT NULL,
    asset_id text NOT NULL,
    regime_label text NOT NULL,
    target_allocation numeric(5,4) NOT NULL,
    max_position_pct numeric(5,4) NOT NULL,
    stop_loss_pct numeric(5,4),
    take_profit_pct numeric(5,4),
    confidence_threshold numeric(5,4) DEFAULT 0.40,
    signal_type text DEFAULT 'REGIME_BASED'::text NOT NULL,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    created_by text DEFAULT 'STIG'::text,
    CONSTRAINT regime_position_rules_max_position_pct_check CHECK (((max_position_pct >= (0)::numeric) AND (max_position_pct <= (1)::numeric))),
    CONSTRAINT regime_position_rules_target_allocation_check CHECK (((target_allocation >= ('-1'::integer)::numeric) AND (target_allocation <= (1)::numeric)))
);


--
-- Name: safety_validations; Type: TABLE; Schema: vision_signals; Owner: -
--

CREATE TABLE vision_signals.safety_validations (
    validation_id uuid DEFAULT gen_random_uuid() NOT NULL,
    validation_type text NOT NULL,
    discrepancy_score numeric(6,4) NOT NULL,
    threshold numeric(6,4) NOT NULL,
    result text NOT NULL,
    defcon_recommendation text NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: shadow_ledger_snapshots; Type: TABLE; Schema: vision_signals; Owner: -
--

CREATE TABLE vision_signals.shadow_ledger_snapshots (
    snapshot_id uuid DEFAULT gen_random_uuid() NOT NULL,
    snapshot_type text NOT NULL,
    total_trades integer NOT NULL,
    open_trades integer NOT NULL,
    closed_trades integer NOT NULL,
    total_pnl numeric(18,8),
    snapshot_timestamp timestamp with time zone DEFAULT now()
);


--
-- Name: signal_baseline; Type: TABLE; Schema: vision_signals; Owner: -
--

CREATE TABLE vision_signals.signal_baseline (
    baseline_id uuid DEFAULT gen_random_uuid() NOT NULL,
    signal_type text NOT NULL,
    signal_name text NOT NULL,
    baseline_value numeric NOT NULL,
    baseline_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    mean_value numeric,
    std_deviation numeric,
    percentile_25 numeric,
    percentile_50 numeric,
    percentile_75 numeric,
    percentile_95 numeric,
    percentile_99 numeric,
    sample_size integer NOT NULL,
    confidence_interval numeric,
    source_schemas text[],
    calculation_window interval NOT NULL,
    calculation_method text NOT NULL,
    parameters jsonb,
    created_by text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    hash_chain_id text,
    signature_id uuid,
    CONSTRAINT signal_baseline_sample_size_check CHECK ((sample_size >= 0))
);


--
-- Name: state_snapshots; Type: TABLE; Schema: vision_signals; Owner: -
--

CREATE TABLE vision_signals.state_snapshots (
    snapshot_id uuid DEFAULT gen_random_uuid() NOT NULL,
    snapshot_version integer NOT NULL,
    defcon_level text NOT NULL,
    regime_distribution jsonb NOT NULL,
    strategy_mode text NOT NULL,
    quad_hash text NOT NULL,
    state_snapshot_hash text NOT NULL,
    causal_edge_count integer NOT NULL,
    avg_confidence numeric(6,4) NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    published_to jsonb DEFAULT '[]'::jsonb
);


--
-- Name: strategy_state; Type: TABLE; Schema: vision_signals; Owner: -
--

CREATE TABLE vision_signals.strategy_state (
    state_id uuid DEFAULT gen_random_uuid() NOT NULL,
    strategy_state text NOT NULL,
    lars_evaluation_enabled boolean NOT NULL,
    dsl_optimization_bound boolean NOT NULL,
    quad_hash_binding text NOT NULL,
    regime_aware_allocation boolean NOT NULL,
    activated_at timestamp with time zone DEFAULT now()
);


--
-- Name: cognitive_engine_evidence; Type: TABLE; Schema: vision_verification; Owner: -
--

CREATE TABLE vision_verification.cognitive_engine_evidence (
    id integer NOT NULL,
    evidence_type character varying(100) NOT NULL,
    evidence_content jsonb NOT NULL,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    generating_agent character varying(50) NOT NULL,
    source_query text,
    metadata jsonb,
    synced_to_graph boolean DEFAULT false,
    synced_at timestamp with time zone,
    evidence_hash character varying(64),
    CONSTRAINT valid_agent CHECK (((generating_agent)::text = ANY ((ARRAY['RESEARCH_DAEMON'::character varying, 'EC018'::character varying, 'WAVE15'::character varying, 'ORCHESTRATOR'::character varying, 'CEIO'::character varying, 'CRIO'::character varying, 'CDMO'::character varying, 'CFAO'::character varying, 'CSEO'::character varying])::text[])))
);


--
-- Name: TABLE cognitive_engine_evidence; Type: COMMENT; Schema: vision_verification; Owner: -
--

COMMENT ON TABLE vision_verification.cognitive_engine_evidence IS 'CEO-DIR-2026-024: Volatile signals from cognitive processes (Research, EC018, Serper) before unification';


--
-- Name: cognitive_engine_evidence_id_seq; Type: SEQUENCE; Schema: vision_verification; Owner: -
--

CREATE SEQUENCE vision_verification.cognitive_engine_evidence_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cognitive_engine_evidence_id_seq; Type: SEQUENCE OWNED BY; Schema: vision_verification; Owner: -
--

ALTER SEQUENCE vision_verification.cognitive_engine_evidence_id_seq OWNED BY vision_verification.cognitive_engine_evidence.id;


--
-- Name: dashboard_truth_attestation; Type: TABLE; Schema: vision_verification; Owner: -
--

CREATE TABLE vision_verification.dashboard_truth_attestation (
    attestation_id uuid DEFAULT gen_random_uuid() NOT NULL,
    route_path text NOT NULL,
    listing_id text NOT NULL,
    attestation_date date NOT NULL,
    regime_label text,
    regime_date date,
    allocation_pct numeric(10,4),
    signal_strength numeric(10,4),
    truth_hash text NOT NULL,
    canonical_json text NOT NULL,
    source_table text NOT NULL,
    source_query text NOT NULL,
    source_row_id text,
    signed_by text DEFAULT 'STIG'::text NOT NULL,
    signature text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    expires_at timestamp with time zone,
    is_verified boolean DEFAULT true,
    verification_failures integer DEFAULT 0,
    CONSTRAINT valid_hash_length CHECK ((length(truth_hash) = 64)),
    CONSTRAINT valid_regime_label CHECK (((regime_label IS NULL) OR (regime_label = ANY (ARRAY['BULL'::text, 'NEUTRAL'::text, 'BEAR'::text, 'STRESS'::text]))))
);


--
-- Name: TABLE dashboard_truth_attestation; Type: COMMENT; Schema: vision_verification; Owner: -
--

COMMENT ON TABLE vision_verification.dashboard_truth_attestation IS 'Hash-of-Truth attestation for dashboard metrics per ADR-019 (Dumb Glass) and CEO-DIR-2026-TRUTH-SYNC-P1';


--
-- Name: deterministic_evidence_standard; Type: TABLE; Schema: vision_verification; Owner: -
--

CREATE TABLE vision_verification.deterministic_evidence_standard (
    standard_id uuid DEFAULT gen_random_uuid() NOT NULL,
    standard_version character varying(20) DEFAULT '1.0.0'::character varying NOT NULL,
    requires_explicit_columns boolean DEFAULT true NOT NULL,
    requires_explicit_ordering boolean DEFAULT true NOT NULL,
    requires_explicit_casting boolean DEFAULT true NOT NULL,
    requires_canonical_json boolean DEFAULT true NOT NULL,
    json_key_order text DEFAULT 'ALPHABETICAL'::text NOT NULL,
    timestamp_format text DEFAULT 'ISO8601_UTC'::text NOT NULL,
    numeric_precision integer DEFAULT 15 NOT NULL,
    boolean_format text DEFAULT 'LOWERCASE'::text NOT NULL,
    null_handling text DEFAULT 'EXPLICIT_NULL'::text NOT NULL,
    reject_non_deterministic boolean DEFAULT true NOT NULL,
    tag_non_reproducible boolean DEFAULT true NOT NULL,
    exclude_from_split_brain boolean DEFAULT true NOT NULL,
    created_by character varying(50) DEFAULT 'STIG'::character varying NOT NULL,
    attested_by character varying(50),
    attestation_id uuid,
    effective_from timestamp with time zone DEFAULT now() NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: eqs_configuration; Type: TABLE; Schema: vision_verification; Owner: -
--

CREATE TABLE vision_verification.eqs_configuration (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    config_key text NOT NULL,
    config_value text NOT NULL,
    description text,
    set_by text NOT NULL,
    authority text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: eqs_v2_calculation_log; Type: TABLE; Schema: vision_verification; Owner: -
--

CREATE TABLE vision_verification.eqs_v2_calculation_log (
    log_id uuid DEFAULT gen_random_uuid() NOT NULL,
    calculated_at timestamp with time zone DEFAULT now() NOT NULL,
    needle_id uuid NOT NULL,
    eqs_v2_score numeric(5,4) NOT NULL,
    eqs_v2_tier text NOT NULL,
    sitc_pct numeric(5,4),
    factor_pct numeric(5,4),
    category_pct numeric(5,4),
    recency_pct numeric(5,4),
    base_score numeric(5,4),
    regime_state text NOT NULL,
    regime_diversity_pct numeric(5,2) NOT NULL,
    hard_stop_triggered boolean DEFAULT false NOT NULL,
    hard_stop_reason text,
    calculation_version text NOT NULL,
    formula_hash text NOT NULL,
    input_hash text NOT NULL,
    calculated_by text DEFAULT 'STIG'::text NOT NULL,
    directive_id text DEFAULT 'CEO-DIR-2025-EQS-007'::text NOT NULL,
    CONSTRAINT eqs_v2_calculation_log_eqs_v2_tier_check CHECK ((eqs_v2_tier = ANY (ARRAY['S'::text, 'A'::text, 'B'::text, 'C'::text]))),
    CONSTRAINT eqs_v2_log_immutable CHECK (true)
);


--
-- Name: TABLE eqs_v2_calculation_log; Type: COMMENT; Schema: vision_verification; Owner: -
--

COMMENT ON TABLE vision_verification.eqs_v2_calculation_log IS 'VEGA Condition C2: Append-only audit trail for EQS v2 calculations. Court-proof evidence per CEO Directive 2025-12-20.';


--
-- Name: eqs_v2_hard_stop_events; Type: TABLE; Schema: vision_verification; Owner: -
--

CREATE TABLE vision_verification.eqs_v2_hard_stop_events (
    event_id uuid DEFAULT gen_random_uuid() NOT NULL,
    triggered_at timestamp with time zone DEFAULT now() NOT NULL,
    regime_diversity_pct numeric(5,2) NOT NULL,
    required_threshold_pct numeric(5,2) DEFAULT 15.00 NOT NULL,
    regime_distribution jsonb NOT NULL,
    signals_blocked integer NOT NULL,
    error_message text NOT NULL,
    directive_id text DEFAULT 'CEO-DIR-2025-EQS-007'::text NOT NULL,
    enforced_by text DEFAULT 'STIG'::text NOT NULL
);


--
-- Name: TABLE eqs_v2_hard_stop_events; Type: COMMENT; Schema: vision_verification; Owner: -
--

COMMENT ON TABLE vision_verification.eqs_v2_hard_stop_events IS 'VEGA Condition C1: Dedicated log for regime diversity hard stop events.';


--
-- Name: eqs_v2_monitoring_snapshots; Type: TABLE; Schema: vision_verification; Owner: -
--

CREATE TABLE vision_verification.eqs_v2_monitoring_snapshots (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    snapshot_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    total_scored integer,
    mean_score numeric(5,4),
    std_dev numeric(5,4),
    p90_p10_spread numeric(5,4),
    tier_s_count integer,
    tier_a_count integer,
    tier_b_count integer,
    tier_c_count integer,
    regime_diversity_pct numeric(5,2),
    regime_status text,
    hard_stop_triggered boolean DEFAULT false,
    notes text,
    created_by text DEFAULT 'STIG'::text
);


--
-- Name: evidence_break_glass_log; Type: TABLE; Schema: vision_verification; Owner: -
--

CREATE TABLE vision_verification.evidence_break_glass_log (
    break_glass_id uuid DEFAULT gen_random_uuid() NOT NULL,
    evidence_id uuid NOT NULL,
    operation_type character varying(20) NOT NULL,
    authorized_by character varying(50) NOT NULL,
    authorization_reason text NOT NULL,
    ceo_approval_reference text,
    executed_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT chk_break_glass_authority CHECK (((authorized_by)::text = ANY ((ARRAY['CEO'::character varying, 'VEGA_EMERGENCY'::character varying])::text[]))),
    CONSTRAINT chk_break_glass_operation CHECK (((operation_type)::text = ANY ((ARRAY['UPDATE'::character varying, 'DELETE'::character varying])::text[])))
);


--
-- Name: evidence_verification_log; Type: TABLE; Schema: vision_verification; Owner: -
--

CREATE TABLE vision_verification.evidence_verification_log (
    verification_id uuid DEFAULT gen_random_uuid() NOT NULL,
    evidence_id uuid NOT NULL,
    verified_by character varying(50) NOT NULL,
    verification_result boolean NOT NULL,
    verification_details jsonb,
    verified_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: hash_chains; Type: TABLE; Schema: vision_verification; Owner: -
--

CREATE TABLE vision_verification.hash_chains (
    chain_id text NOT NULL,
    chain_type text NOT NULL,
    chain_scope text NOT NULL,
    genesis_hash text NOT NULL,
    current_hash text NOT NULL,
    chain_length integer DEFAULT 1 NOT NULL,
    integrity_verified boolean DEFAULT true NOT NULL,
    last_verification_at timestamp with time zone,
    created_by text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    schema_frozen boolean DEFAULT false,
    frozen_at timestamp with time zone,
    CONSTRAINT hash_chain_length_check CHECK ((chain_length > 0))
);


--
-- Name: operation_signatures; Type: TABLE; Schema: vision_verification; Owner: -
--

CREATE TABLE vision_verification.operation_signatures (
    signature_id uuid DEFAULT gen_random_uuid() NOT NULL,
    operation_type text NOT NULL,
    operation_id uuid NOT NULL,
    operation_table text NOT NULL,
    operation_schema text NOT NULL,
    signing_agent text NOT NULL,
    signing_key_id text NOT NULL,
    signature_value text NOT NULL,
    signed_payload jsonb NOT NULL,
    verified boolean DEFAULT false NOT NULL,
    verified_at timestamp with time zone,
    verified_by text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    hash_chain_id text NOT NULL,
    previous_signature_id uuid,
    CONSTRAINT operation_signature_agent_check CHECK ((signing_agent = ANY (ARRAY['LARS'::text, 'STIG'::text, 'LINE'::text, 'FINN'::text]))),
    CONSTRAINT operation_signature_verified_check CHECK (((verified = false) OR ((verified = true) AND (verified_at IS NOT NULL) AND (verified_by IS NOT NULL))))
);


--
-- Name: regime_coverage_health; Type: VIEW; Schema: vision_verification; Owner: -
--

CREATE VIEW vision_verification.regime_coverage_health AS
 WITH latest_regime AS (
         SELECT regime_daily."timestamp" AS check_date,
            count(DISTINCT regime_daily.asset_id) AS asset_count,
            count(DISTINCT regime_daily.regime_classification) AS regime_states_count,
            array_agg(DISTINCT regime_daily.regime_classification ORDER BY regime_daily.regime_classification) AS regime_states
           FROM fhq_perception.regime_daily
          WHERE (regime_daily."timestamp" >= (CURRENT_DATE - '1 day'::interval))
          GROUP BY regime_daily."timestamp"
        ), regime_distribution AS (
         SELECT regime_daily."timestamp" AS check_date,
            regime_daily.regime_classification,
            count(*) AS count,
            sum(count(*)) OVER (PARTITION BY regime_daily."timestamp") AS total
           FROM fhq_perception.regime_daily
          WHERE (regime_daily."timestamp" >= (CURRENT_DATE - '1 day'::interval))
          GROUP BY regime_daily."timestamp", regime_daily.regime_classification
        ), dominant AS (
         SELECT regime_distribution.check_date,
            regime_distribution.regime_classification AS dominant_regime,
            regime_distribution.count AS dominant_count,
            regime_distribution.total,
            round(((100.0 * (regime_distribution.total - (regime_distribution.count)::numeric)) / NULLIF(regime_distribution.total, (0)::numeric)), 2) AS non_dominant_pct,
            row_number() OVER (PARTITION BY regime_distribution.check_date ORDER BY regime_distribution.count DESC) AS rn
           FROM regime_distribution
        )
 SELECT lr.check_date,
    lr.asset_count,
    lr.regime_states_count,
    lr.regime_states,
    d.dominant_regime,
    d.dominant_count,
    d.non_dominant_pct,
        CASE
            WHEN (lr.asset_count < 100) THEN 'CRITICAL'::text
            WHEN (lr.asset_count < 400) THEN 'WARNING'::text
            WHEN (d.non_dominant_pct < 15.0) THEN 'CRITICAL'::text
            WHEN (lr.regime_states_count < 3) THEN 'WARNING'::text
            ELSE 'HEALTHY'::text
        END AS health_status,
        CASE
            WHEN (lr.asset_count < 100) THEN 'Asset coverage collapsed below 100'::text
            WHEN (lr.asset_count < 400) THEN 'Asset coverage below threshold (400)'::text
            WHEN (d.non_dominant_pct < 15.0) THEN 'Regime diversity below 15%'::text
            WHEN (lr.regime_states_count < 3) THEN 'Fewer than 3 regime states observed'::text
            ELSE 'All metrics healthy'::text
        END AS status_reason
   FROM (latest_regime lr
     LEFT JOIN dominant d ON (((lr.check_date = d.check_date) AND (d.rn = 1))));


--
-- Name: regime_coverage_sentinel_log; Type: TABLE; Schema: vision_verification; Owner: -
--

CREATE TABLE vision_verification.regime_coverage_sentinel_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    check_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    check_type text NOT NULL,
    check_date date NOT NULL,
    asset_count integer,
    asset_threshold integer DEFAULT 400,
    regime_states_count integer,
    regime_states text[],
    dominant_regime text,
    dominant_count integer,
    non_dominant_pct numeric(5,2),
    diversity_threshold numeric(5,2) DEFAULT 15.00,
    status text NOT NULL,
    alert_triggered boolean DEFAULT false,
    evidence_hash text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: regime_diversity_trend; Type: VIEW; Schema: vision_verification; Owner: -
--

CREATE VIEW vision_verification.regime_diversity_trend AS
 WITH daily_stats AS (
         SELECT regime_daily."timestamp" AS date,
            count(DISTINCT regime_daily.asset_id) AS asset_count,
            count(DISTINCT regime_daily.regime_classification) AS regime_states
           FROM fhq_perception.regime_daily
          WHERE (regime_daily."timestamp" >= (CURRENT_DATE - '30 days'::interval))
          GROUP BY regime_daily."timestamp"
        ), diversity AS (
         SELECT regime_daily."timestamp" AS date,
            regime_daily.regime_classification,
            count(*) AS count,
            sum(count(*)) OVER (PARTITION BY regime_daily."timestamp") AS total
           FROM fhq_perception.regime_daily
          WHERE (regime_daily."timestamp" >= (CURRENT_DATE - '30 days'::interval))
          GROUP BY regime_daily."timestamp", regime_daily.regime_classification
        ), max_regime AS (
         SELECT diversity.date,
            max(diversity.count) AS dominant_count,
            max(diversity.total) AS total
           FROM diversity
          GROUP BY diversity.date
        )
 SELECT ds.date,
    ds.asset_count,
    ds.regime_states,
    mr.dominant_count,
    mr.total AS total_classifications,
    round(((100.0 * (mr.total - (mr.dominant_count)::numeric)) / NULLIF(mr.total, (0)::numeric)), 2) AS non_dominant_pct,
        CASE
            WHEN (round(((100.0 * (mr.total - (mr.dominant_count)::numeric)) / NULLIF(mr.total, (0)::numeric)), 2) >= 15.0) THEN 'PASS'::text
            ELSE 'FAIL'::text
        END AS diversity_check
   FROM (daily_stats ds
     JOIN max_regime mr ON ((ds.date = mr.date)))
  ORDER BY ds.date DESC;


--
-- Name: split_brain_detector; Type: VIEW; Schema: vision_verification; Owner: -
--

CREATE VIEW vision_verification.split_brain_detector AS
 SELECT s1.summary_id AS summary_1,
    s2.summary_id AS summary_2,
    s1.summary_type,
    s1.query_result_hash,
    s2.query_result_hash AS conflicting_hash,
    s1.raw_query,
    s1.created_at AS created_at_1,
    s2.created_at AS created_at_2,
        CASE
            WHEN ((s1.query_result_hash)::text <> (s2.query_result_hash)::text) THEN 'HASH_MISMATCH'::text
            ELSE 'OK'::text
        END AS status
   FROM (vision_verification.summary_evidence_ledger s1
     JOIN vision_verification.summary_evidence_ledger s2 ON (((s1.raw_query = s2.raw_query) AND (s1.evidence_id <> s2.evidence_id) AND (s1.created_at < s2.created_at))))
  WHERE ((s1.query_result_hash)::text <> (s2.query_result_hash)::text);


--
-- Name: v_eqs_v2_distribution_snapshot; Type: VIEW; Schema: vision_verification; Owner: -
--

CREATE VIEW vision_verification.v_eqs_v2_distribution_snapshot AS
 WITH tier_counts AS (
         SELECT golden_needles.eqs_v2_tier AS tier,
            count(*) AS count
           FROM fhq_canonical.golden_needles
          WHERE (golden_needles.eqs_score_v2 IS NOT NULL)
          GROUP BY golden_needles.eqs_v2_tier
        ), stats AS (
         SELECT count(*) AS total_scored,
            avg(golden_needles.eqs_score_v2) AS mean_score,
            stddev(golden_needles.eqs_score_v2) AS std_dev,
            min(golden_needles.eqs_score_v2) AS min_score,
            max(golden_needles.eqs_score_v2) AS max_score,
            percentile_cont((0.10)::double precision) WITHIN GROUP (ORDER BY ((golden_needles.eqs_score_v2)::double precision)) AS p10,
            percentile_cont((0.25)::double precision) WITHIN GROUP (ORDER BY ((golden_needles.eqs_score_v2)::double precision)) AS p25,
            percentile_cont((0.50)::double precision) WITHIN GROUP (ORDER BY ((golden_needles.eqs_score_v2)::double precision)) AS p50,
            percentile_cont((0.75)::double precision) WITHIN GROUP (ORDER BY ((golden_needles.eqs_score_v2)::double precision)) AS p75,
            percentile_cont((0.90)::double precision) WITHIN GROUP (ORDER BY ((golden_needles.eqs_score_v2)::double precision)) AS p90
           FROM fhq_canonical.golden_needles
          WHERE (golden_needles.eqs_score_v2 IS NOT NULL)
        )
 SELECT now() AS snapshot_timestamp,
    total_scored,
    round(mean_score, 4) AS mean_score,
    round(std_dev, 4) AS std_dev,
    round(((p90 - p10))::numeric, 4) AS p90_p10_spread,
    round(min_score, 4) AS min_score,
    round(max_score, 4) AS max_score,
    round((p10)::numeric, 4) AS p10,
    round((p25)::numeric, 4) AS p25,
    round((p50)::numeric, 4) AS p50,
    round((p75)::numeric, 4) AS p75,
    round((p90)::numeric, 4) AS p90,
    ( SELECT COALESCE(sum(tier_counts.count), (0)::numeric) AS "coalesce"
           FROM tier_counts
          WHERE (tier_counts.tier = 'S'::text)) AS tier_s_count,
    ( SELECT COALESCE(sum(tier_counts.count), (0)::numeric) AS "coalesce"
           FROM tier_counts
          WHERE (tier_counts.tier = 'A'::text)) AS tier_a_count,
    ( SELECT COALESCE(sum(tier_counts.count), (0)::numeric) AS "coalesce"
           FROM tier_counts
          WHERE (tier_counts.tier = 'B'::text)) AS tier_b_count,
    ( SELECT COALESCE(sum(tier_counts.count), (0)::numeric) AS "coalesce"
           FROM tier_counts
          WHERE (tier_counts.tier = 'C'::text)) AS tier_c_count
   FROM stats s;


--
-- Name: v_eqs_v2_hard_stop_summary; Type: VIEW; Schema: vision_verification; Owner: -
--

CREATE VIEW vision_verification.v_eqs_v2_hard_stop_summary AS
 SELECT date(triggered_at) AS stop_date,
    count(*) AS stop_count,
    avg(regime_diversity_pct) AS avg_diversity,
    sum(signals_blocked) AS total_blocked
   FROM vision_verification.eqs_v2_hard_stop_events
  GROUP BY (date(triggered_at))
  ORDER BY (date(triggered_at)) DESC;


--
-- Name: v_eqs_v2_recent_calculations; Type: VIEW; Schema: vision_verification; Owner: -
--

CREATE VIEW vision_verification.v_eqs_v2_recent_calculations AS
 SELECT log_id,
    calculated_at,
    needle_id,
    eqs_v2_score,
    eqs_v2_tier,
    regime_state,
    regime_diversity_pct,
    hard_stop_triggered,
    calculation_version
   FROM vision_verification.eqs_v2_calculation_log
  ORDER BY calculated_at DESC
 LIMIT 100;


--
-- Name: anomalies id; Type: DEFAULT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.anomalies ALTER COLUMN id SET DEFAULT nextval('fhq_finn.anomalies_id_seq'::regclass);


--
-- Name: ensemble_signals id; Type: DEFAULT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.ensemble_signals ALTER COLUMN id SET DEFAULT nextval('fhq_finn.ensemble_signals_id_seq'::regclass);


--
-- Name: model_predictions id; Type: DEFAULT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.model_predictions ALTER COLUMN id SET DEFAULT nextval('fhq_finn.model_predictions_id_seq'::regclass);


--
-- Name: regime_states id; Type: DEFAULT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.regime_states ALTER COLUMN id SET DEFAULT nextval('fhq_finn.regime_states_id_seq'::regclass);


--
-- Name: regime_tracker regime_id; Type: DEFAULT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.regime_tracker ALTER COLUMN regime_id SET DEFAULT nextval('fhq_finn.regime_tracker_regime_id_seq'::regclass);


--
-- Name: agent_heartbeats heartbeat_id; Type: DEFAULT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.agent_heartbeats ALTER COLUMN heartbeat_id SET DEFAULT nextval('fhq_governance.agent_heartbeats_heartbeat_id_seq'::regclass);


--
-- Name: calibration_audit_log id; Type: DEFAULT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.calibration_audit_log ALTER COLUMN id SET DEFAULT nextval('fhq_governance.calibration_audit_log_id_seq'::regclass);


--
-- Name: calibration_versions id; Type: DEFAULT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.calibration_versions ALTER COLUMN id SET DEFAULT nextval('fhq_governance.calibration_versions_id_seq'::regclass);


--
-- Name: canonical_evidence evidence_id; Type: DEFAULT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.canonical_evidence ALTER COLUMN evidence_id SET DEFAULT nextval('fhq_governance.canonical_evidence_evidence_id_seq'::regclass);


--
-- Name: causal_edge_log log_id; Type: DEFAULT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.causal_edge_log ALTER COLUMN log_id SET DEFAULT nextval('fhq_governance.causal_edge_log_log_id_seq'::regclass);


--
-- Name: causal_entropy_audit audit_id; Type: DEFAULT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.causal_entropy_audit ALTER COLUMN audit_id SET DEFAULT nextval('fhq_governance.causal_entropy_audit_audit_id_seq'::regclass);


--
-- Name: execution_state state_id; Type: DEFAULT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.execution_state ALTER COLUMN state_id SET DEFAULT nextval('fhq_governance.execution_state_state_id_seq'::regclass);


--
-- Name: inforage_config config_id; Type: DEFAULT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.inforage_config ALTER COLUMN config_id SET DEFAULT nextval('fhq_governance.inforage_config_config_id_seq'::regclass);


--
-- Name: production_monitoring monitoring_id; Type: DEFAULT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.production_monitoring ALTER COLUMN monitoring_id SET DEFAULT nextval('fhq_governance.production_monitoring_monitoring_id_seq'::regclass);


--
-- Name: system_events event_id; Type: DEFAULT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.system_events ALTER COLUMN event_id SET DEFAULT nextval('fhq_governance.system_events_event_id_seq'::regclass);


--
-- Name: system_heartbeats id; Type: DEFAULT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.system_heartbeats ALTER COLUMN id SET DEFAULT nextval('fhq_governance.system_heartbeats_id_seq'::regclass);


--
-- Name: vega_rhythm_schedule rhythm_id; Type: DEFAULT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.vega_rhythm_schedule ALTER COLUMN rhythm_id SET DEFAULT nextval('fhq_governance.vega_rhythm_schedule_rhythm_id_seq'::regclass);


--
-- Name: adr_audit_log audit_id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_audit_log ALTER COLUMN audit_id SET DEFAULT nextval('fhq_meta.adr_audit_log_audit_id_seq'::regclass);


--
-- Name: adr_dependency_graph id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_dependency_graph ALTER COLUMN id SET DEFAULT nextval('fhq_meta.adr_dependency_graph_id_seq'::regclass);


--
-- Name: adr_ingestion_staging id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_ingestion_staging ALTER COLUMN id SET DEFAULT nextval('fhq_meta.adr_ingestion_staging_id_seq'::regclass);


--
-- Name: adr_registry_preapproval id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_registry_preapproval ALTER COLUMN id SET DEFAULT nextval('fhq_meta.adr_registry_preapproval_id_seq'::regclass);


--
-- Name: adr_registry_snapshots snapshot_id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_registry_snapshots ALTER COLUMN snapshot_id SET DEFAULT nextval('fhq_meta.adr_registry_snapshots_snapshot_id_seq'::regclass);


--
-- Name: adr_supplements supplement_id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_supplements ALTER COLUMN supplement_id SET DEFAULT nextval('fhq_meta.adr_supplements_supplement_id_seq'::regclass);


--
-- Name: adr_version_history version_id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_version_history ALTER COLUMN version_id SET DEFAULT nextval('fhq_meta.adr_version_history_version_id_seq'::regclass);


--
-- Name: api_schema_registry schema_id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.api_schema_registry ALTER COLUMN schema_id SET DEFAULT nextval('fhq_meta.api_schema_registry_schema_id_seq'::regclass);


--
-- Name: aum_allocations allocation_id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.aum_allocations ALTER COLUMN allocation_id SET DEFAULT nextval('fhq_meta.aum_allocations_allocation_id_seq'::regclass);


--
-- Name: baseline_registry baseline_id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.baseline_registry ALTER COLUMN baseline_id SET DEFAULT nextval('fhq_meta.baseline_registry_baseline_id_seq'::regclass);


--
-- Name: data_quality_rules id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.data_quality_rules ALTER COLUMN id SET DEFAULT nextval('fhq_meta.data_quality_rules_id_seq'::regclass);


--
-- Name: dynamic_regime_weights id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.dynamic_regime_weights ALTER COLUMN id SET DEFAULT nextval('fhq_meta.dynamic_regime_weights_id_seq'::regclass);


--
-- Name: dynamic_regime_weights_audit id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.dynamic_regime_weights_audit ALTER COLUMN id SET DEFAULT nextval('fhq_meta.dynamic_regime_weights_audit_id_seq'::regclass);


--
-- Name: function_versions id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.function_versions ALTER COLUMN id SET DEFAULT nextval('fhq_meta.function_versions_id_seq'::regclass);


--
-- Name: functions_registry id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.functions_registry ALTER COLUMN id SET DEFAULT nextval('fhq_meta.functions_registry_id_seq'::regclass);


--
-- Name: gate_cross_references id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.gate_cross_references ALTER COLUMN id SET DEFAULT nextval('fhq_meta.gate_cross_references_id_seq'::regclass);


--
-- Name: gate_dependencies id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.gate_dependencies ALTER COLUMN id SET DEFAULT nextval('fhq_meta.gate_dependencies_id_seq'::regclass);


--
-- Name: indicator_registry indicator_id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.indicator_registry ALTER COLUMN indicator_id SET DEFAULT nextval('fhq_meta.indicator_registry_indicator_id_seq'::regclass);


--
-- Name: model_registry registry_id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.model_registry ALTER COLUMN registry_id SET DEFAULT nextval('fhq_meta.model_registry_registry_id_seq'::regclass);


--
-- Name: pipeline_runs id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.pipeline_runs ALTER COLUMN id SET DEFAULT nextval('fhq_meta.pipeline_runs_id_seq'::regclass);


--
-- Name: rate_limit_policy policy_id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.rate_limit_policy ALTER COLUMN policy_id SET DEFAULT nextval('fhq_meta.rate_limit_policy_policy_id_seq'::regclass);


--
-- Name: reconciliation_field_weights weight_id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.reconciliation_field_weights ALTER COLUMN weight_id SET DEFAULT nextval('fhq_meta.reconciliation_field_weights_weight_id_seq'::regclass);


--
-- Name: regime_weight_config config_id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.regime_weight_config ALTER COLUMN config_id SET DEFAULT nextval('fhq_meta.regime_weight_config_config_id_seq'::regclass);


--
-- Name: secret_rotation_log id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.secret_rotation_log ALTER COLUMN id SET DEFAULT nextval('fhq_meta.secret_rotation_log_id_seq'::regclass);


--
-- Name: strategy_families family_id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.strategy_families ALTER COLUMN family_id SET DEFAULT nextval('fhq_meta.strategy_families_family_id_seq'::regclass);


--
-- Name: strategy_family_members membership_id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.strategy_family_members ALTER COLUMN membership_id SET DEFAULT nextval('fhq_meta.strategy_family_members_membership_id_seq'::regclass);


--
-- Name: strategy_registry id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.strategy_registry ALTER COLUMN id SET DEFAULT nextval('fhq_meta.strategy_registry_id_seq'::regclass);


--
-- Name: validation_reports id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.validation_reports ALTER COLUMN id SET DEFAULT nextval('fhq_meta.validation_reports_id_seq'::regclass);


--
-- Name: vega_constitutional_duties duty_id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vega_constitutional_duties ALTER COLUMN duty_id SET DEFAULT nextval('fhq_meta.vega_constitutional_duties_duty_id_seq'::regclass);


--
-- Name: vega_constraints constraint_id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vega_constraints ALTER COLUMN constraint_id SET DEFAULT nextval('fhq_meta.vega_constraints_constraint_id_seq'::regclass);


--
-- Name: vega_employment_contract contract_id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vega_employment_contract ALTER COLUMN contract_id SET DEFAULT nextval('fhq_meta.vega_employment_contract_contract_id_seq'::regclass);


--
-- Name: vega_identity identity_id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vega_identity ALTER COLUMN identity_id SET DEFAULT nextval('fhq_meta.vega_identity_identity_id_seq'::regclass);


--
-- Name: vega_rights right_id; Type: DEFAULT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vega_rights ALTER COLUMN right_id SET DEFAULT nextval('fhq_meta.vega_rights_right_id_seq'::regclass);


--
-- Name: llm_cost_limits cost_limit_id; Type: DEFAULT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.llm_cost_limits ALTER COLUMN cost_limit_id SET DEFAULT nextval('vega.llm_cost_limits_cost_limit_id_seq'::regclass);


--
-- Name: llm_execution_limits execution_limit_id; Type: DEFAULT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.llm_execution_limits ALTER COLUMN execution_limit_id SET DEFAULT nextval('vega.llm_execution_limits_execution_limit_id_seq'::regclass);


--
-- Name: llm_rate_limits rate_limit_id; Type: DEFAULT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.llm_rate_limits ALTER COLUMN rate_limit_id SET DEFAULT nextval('vega.llm_rate_limits_rate_limit_id_seq'::regclass);


--
-- Name: llm_usage_log usage_id; Type: DEFAULT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.llm_usage_log ALTER COLUMN usage_id SET DEFAULT nextval('vega.llm_usage_log_usage_id_seq'::regclass);


--
-- Name: llm_violation_events violation_id; Type: DEFAULT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.llm_violation_events ALTER COLUMN violation_id SET DEFAULT nextval('vega.llm_violation_events_violation_id_seq'::regclass);


--
-- Name: execution_state state_id; Type: DEFAULT; Schema: vision_core; Owner: -
--

ALTER TABLE ONLY vision_core.execution_state ALTER COLUMN state_id SET DEFAULT nextval('vision_core.execution_state_state_id_seq'::regclass);


--
-- Name: cognitive_engine_evidence id; Type: DEFAULT; Schema: vision_verification; Owner: -
--

ALTER TABLE ONLY vision_verification.cognitive_engine_evidence ALTER COLUMN id SET DEFAULT nextval('vision_verification.cognitive_engine_evidence_id_seq'::regclass);


--
-- Name: aci_shadow_evaluations aci_shadow_evaluations_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.aci_shadow_evaluations
    ADD CONSTRAINT aci_shadow_evaluations_pkey PRIMARY KEY (eval_id);


--
-- Name: aci_triangle_shadow_evaluations aci_triangle_shadow_evaluations_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.aci_triangle_shadow_evaluations
    ADD CONSTRAINT aci_triangle_shadow_evaluations_pkey PRIMARY KEY (evaluation_id);


--
-- Name: canonical_outcomes canonical_outcomes_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.canonical_outcomes
    ADD CONSTRAINT canonical_outcomes_pkey PRIMARY KEY (outcome_id);


--
-- Name: eqs_distribution_snapshots eqs_distribution_snapshots_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.eqs_distribution_snapshots
    ADD CONSTRAINT eqs_distribution_snapshots_pkey PRIMARY KEY (snapshot_id);


--
-- Name: eqs_regime_baseline eqs_regime_baseline_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.eqs_regime_baseline
    ADD CONSTRAINT eqs_regime_baseline_pkey PRIMARY KEY (baseline_id);


--
-- Name: eqs_regime_baseline eqs_regime_baseline_unique; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.eqs_regime_baseline
    ADD CONSTRAINT eqs_regime_baseline_unique UNIQUE (target_asset, regime, valid_from);


--
-- Name: eqs_threshold_config eqs_threshold_config_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.eqs_threshold_config
    ADD CONSTRAINT eqs_threshold_config_pkey PRIMARY KEY (config_id);


--
-- Name: evidence_bundles evidence_bundles_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.evidence_bundles
    ADD CONSTRAINT evidence_bundles_pkey PRIMARY KEY (bundle_id);


--
-- Name: evidence_nodes evidence_nodes_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.evidence_nodes
    ADD CONSTRAINT evidence_nodes_pkey PRIMARY KEY (evidence_id);


--
-- Name: evidence_relationships evidence_relationships_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.evidence_relationships
    ADD CONSTRAINT evidence_relationships_pkey PRIMARY KEY (relationship_id);


--
-- Name: financial_ontology financial_ontology_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.financial_ontology
    ADD CONSTRAINT financial_ontology_pkey PRIMARY KEY (concept_id);


--
-- Name: g4_1_composite_verdict g4_1_composite_verdict_needle_id_key; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_1_composite_verdict
    ADD CONSTRAINT g4_1_composite_verdict_needle_id_key UNIQUE (needle_id);


--
-- Name: g4_1_composite_verdict g4_1_composite_verdict_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_1_composite_verdict
    ADD CONSTRAINT g4_1_composite_verdict_pkey PRIMARY KEY (verdict_id);


--
-- Name: g4_1_density_results g4_1_density_results_needle_id_key; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_1_density_results
    ADD CONSTRAINT g4_1_density_results_needle_id_key UNIQUE (needle_id);


--
-- Name: g4_1_density_results g4_1_density_results_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_1_density_results
    ADD CONSTRAINT g4_1_density_results_pkey PRIMARY KEY (result_id);


--
-- Name: g4_1_regime_rotation_results g4_1_regime_rotation_results_needle_id_key; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_1_regime_rotation_results
    ADD CONSTRAINT g4_1_regime_rotation_results_needle_id_key UNIQUE (needle_id);


--
-- Name: g4_1_regime_rotation_results g4_1_regime_rotation_results_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_1_regime_rotation_results
    ADD CONSTRAINT g4_1_regime_rotation_results_pkey PRIMARY KEY (result_id);


--
-- Name: g4_1_sensitivity_results g4_1_sensitivity_results_needle_id_key; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_1_sensitivity_results
    ADD CONSTRAINT g4_1_sensitivity_results_needle_id_key UNIQUE (needle_id);


--
-- Name: g4_1_sensitivity_results g4_1_sensitivity_results_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_1_sensitivity_results
    ADD CONSTRAINT g4_1_sensitivity_results_pkey PRIMARY KEY (result_id);


--
-- Name: g4_1_stability_results g4_1_stability_results_needle_id_key; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_1_stability_results
    ADD CONSTRAINT g4_1_stability_results_needle_id_key UNIQUE (needle_id);


--
-- Name: g4_1_stability_results g4_1_stability_results_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_1_stability_results
    ADD CONSTRAINT g4_1_stability_results_pkey PRIMARY KEY (result_id);


--
-- Name: g4_2_composite_verdict g4_2_composite_verdict_needle_id_key; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_2_composite_verdict
    ADD CONSTRAINT g4_2_composite_verdict_needle_id_key UNIQUE (needle_id);


--
-- Name: g4_2_composite_verdict g4_2_composite_verdict_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_2_composite_verdict
    ADD CONSTRAINT g4_2_composite_verdict_pkey PRIMARY KEY (verdict_id);


--
-- Name: g4_2_context_profiles g4_2_context_profiles_needle_id_context_name_key; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_2_context_profiles
    ADD CONSTRAINT g4_2_context_profiles_needle_id_context_name_key UNIQUE (needle_id, context_name);


--
-- Name: g4_2_context_profiles g4_2_context_profiles_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_2_context_profiles
    ADD CONSTRAINT g4_2_context_profiles_pkey PRIMARY KEY (profile_id);


--
-- Name: g4_2_contextual_backtest g4_2_contextual_backtest_needle_id_profile_id_key; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_2_contextual_backtest
    ADD CONSTRAINT g4_2_contextual_backtest_needle_id_profile_id_key UNIQUE (needle_id, profile_id);


--
-- Name: g4_2_contextual_backtest g4_2_contextual_backtest_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_2_contextual_backtest
    ADD CONSTRAINT g4_2_contextual_backtest_pkey PRIMARY KEY (backtest_id);


--
-- Name: g4_2_parameters g4_2_parameters_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_2_parameters
    ADD CONSTRAINT g4_2_parameters_pkey PRIMARY KEY (parameter_name);


--
-- Name: g4_2_suppression_log g4_2_suppression_log_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_2_suppression_log
    ADD CONSTRAINT g4_2_suppression_log_pkey PRIMARY KEY (log_id);


--
-- Name: g4_composite_scorecard g4_composite_scorecard_needle_id_key; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_composite_scorecard
    ADD CONSTRAINT g4_composite_scorecard_needle_id_key UNIQUE (needle_id);


--
-- Name: g4_composite_scorecard g4_composite_scorecard_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_composite_scorecard
    ADD CONSTRAINT g4_composite_scorecard_pkey PRIMARY KEY (scorecard_id);


--
-- Name: g4_logic_translation_registry g4_logic_translation_registry_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_logic_translation_registry
    ADD CONSTRAINT g4_logic_translation_registry_pkey PRIMARY KEY (strategy_id);


--
-- Name: g4_physics_results g4_physics_results_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_physics_results
    ADD CONSTRAINT g4_physics_results_pkey PRIMARY KEY (result_id);


--
-- Name: g4_refinery_results g4_refinery_results_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_refinery_results
    ADD CONSTRAINT g4_refinery_results_pkey PRIMARY KEY (result_id);


--
-- Name: g4_validation_queue g4_validation_queue_needle_id_key; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_validation_queue
    ADD CONSTRAINT g4_validation_queue_needle_id_key UNIQUE (needle_id);


--
-- Name: g4_validation_queue g4_validation_queue_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_validation_queue
    ADD CONSTRAINT g4_validation_queue_pkey PRIMARY KEY (queue_id);


--
-- Name: g5_cco_health_log g5_cco_health_log_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_cco_health_log
    ADD CONSTRAINT g5_cco_health_log_pkey PRIMARY KEY (log_id);


--
-- Name: g5_cco_state g5_cco_state_is_active_key; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_cco_state
    ADD CONSTRAINT g5_cco_state_is_active_key UNIQUE (is_active);


--
-- Name: g5_cco_state g5_cco_state_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_cco_state
    ADD CONSTRAINT g5_cco_state_pkey PRIMARY KEY (state_id);


--
-- Name: g5_drift_metrics g5_drift_metrics_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_drift_metrics
    ADD CONSTRAINT g5_drift_metrics_pkey PRIMARY KEY (metric_id);


--
-- Name: g5_exit_criteria_status g5_exit_criteria_status_is_active_key; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_exit_criteria_status
    ADD CONSTRAINT g5_exit_criteria_status_is_active_key UNIQUE (is_active);


--
-- Name: g5_exit_criteria_status g5_exit_criteria_status_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_exit_criteria_status
    ADD CONSTRAINT g5_exit_criteria_status_pkey PRIMARY KEY (status_id);


--
-- Name: g5_ingestion_pipeline g5_ingestion_pipeline_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_ingestion_pipeline
    ADD CONSTRAINT g5_ingestion_pipeline_pkey PRIMARY KEY (pipeline_id);


--
-- Name: g5_paper_trades g5_paper_trades_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_paper_trades
    ADD CONSTRAINT g5_paper_trades_pkey PRIMARY KEY (trade_id);


--
-- Name: g5_pass_rate_history g5_pass_rate_history_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_pass_rate_history
    ADD CONSTRAINT g5_pass_rate_history_pkey PRIMARY KEY (history_id);


--
-- Name: g5_pipeline_events g5_pipeline_events_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_pipeline_events
    ADD CONSTRAINT g5_pipeline_events_pkey PRIMARY KEY (event_id);


--
-- Name: g5_promotion_config g5_promotion_config_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_promotion_config
    ADD CONSTRAINT g5_promotion_config_pkey PRIMARY KEY (config_id);


--
-- Name: g5_promotion_ledger g5_promotion_ledger_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_promotion_ledger
    ADD CONSTRAINT g5_promotion_ledger_pkey PRIMARY KEY (promotion_id);


--
-- Name: g5_promotion_rate_log g5_promotion_rate_log_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_promotion_rate_log
    ADD CONSTRAINT g5_promotion_rate_log_pkey PRIMARY KEY (log_id);


--
-- Name: g5_shadow_decisions g5_shadow_decisions_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_shadow_decisions
    ADD CONSTRAINT g5_shadow_decisions_pkey PRIMARY KEY (shadow_id);


--
-- Name: g5_signal_priority_queue g5_signal_priority_queue_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_signal_priority_queue
    ADD CONSTRAINT g5_signal_priority_queue_pkey PRIMARY KEY (queue_id);


--
-- Name: g5_signal_state g5_signal_state_needle_id_key; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_signal_state
    ADD CONSTRAINT g5_signal_state_needle_id_key UNIQUE (needle_id);


--
-- Name: g5_signal_state g5_signal_state_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_signal_state
    ADD CONSTRAINT g5_signal_state_pkey PRIMARY KEY (state_id);


--
-- Name: g5_sla_metrics g5_sla_metrics_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_sla_metrics
    ADD CONSTRAINT g5_sla_metrics_pkey PRIMARY KEY (metric_id);


--
-- Name: g5_state_transitions g5_state_transitions_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_state_transitions
    ADD CONSTRAINT g5_state_transitions_pkey PRIMARY KEY (transition_id);


--
-- Name: g5_ttl_extension_requests g5_ttl_extension_requests_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_ttl_extension_requests
    ADD CONSTRAINT g5_ttl_extension_requests_pkey PRIMARY KEY (request_id);


--
-- Name: golden_needles golden_needles_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.golden_needles
    ADD CONSTRAINT golden_needles_pkey PRIMARY KEY (needle_id);


--
-- Name: needle_chain_links needle_chain_links_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.needle_chain_links
    ADD CONSTRAINT needle_chain_links_pkey PRIMARY KEY (link_id);


--
-- Name: needle_validity_config needle_validity_config_pkey; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.needle_validity_config
    ADD CONSTRAINT needle_validity_config_pkey PRIMARY KEY (config_id);


--
-- Name: g5_promotion_rate_log uq_rate_log_hour; Type: CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_promotion_rate_log
    ADD CONSTRAINT uq_rate_log_hour UNIQUE (hour_bucket);


--
-- Name: ab_test_results ab_test_results_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.ab_test_results
    ADD CONSTRAINT ab_test_results_pkey PRIMARY KEY (test_id);


--
-- Name: ab_test_results ab_test_results_test_date_key; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.ab_test_results
    ADD CONSTRAINT ab_test_results_test_date_key UNIQUE (test_date);


--
-- Name: anomalies anomalies_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.anomalies
    ADD CONSTRAINT anomalies_pkey PRIMARY KEY (id);


--
-- Name: cognitive_dissonance_scores cognitive_dissonance_scores_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.cognitive_dissonance_scores
    ADD CONSTRAINT cognitive_dissonance_scores_pkey PRIMARY KEY (cds_id);


--
-- Name: cognitive_dissonance_scores cognitive_dissonance_scores_symbol_analysis_date_key; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.cognitive_dissonance_scores
    ADD CONSTRAINT cognitive_dissonance_scores_symbol_analysis_date_key UNIQUE (symbol, analysis_date);


--
-- Name: contract_versions contract_versions_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.contract_versions
    ADD CONSTRAINT contract_versions_pkey PRIMARY KEY (version);


--
-- Name: daily_briefings daily_briefings_briefing_date_key; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.daily_briefings
    ADD CONSTRAINT daily_briefings_briefing_date_key UNIQUE (briefing_date);


--
-- Name: daily_briefings daily_briefings_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.daily_briefings
    ADD CONSTRAINT daily_briefings_pkey PRIMARY KEY (briefing_id);


--
-- Name: derivative_metrics derivative_metrics_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.derivative_metrics
    ADD CONSTRAINT derivative_metrics_pkey PRIMARY KEY (metric_id);


--
-- Name: derivative_metrics derivative_metrics_symbol_metric_date_key; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.derivative_metrics
    ADD CONSTRAINT derivative_metrics_symbol_metric_date_key UNIQUE (symbol, metric_date);


--
-- Name: ensemble_signals ensemble_signals_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.ensemble_signals
    ADD CONSTRAINT ensemble_signals_pkey PRIMARY KEY (id);


--
-- Name: ensemble_signals ensemble_signals_signal_id_key; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.ensemble_signals
    ADD CONSTRAINT ensemble_signals_signal_id_key UNIQUE (signal_id);


--
-- Name: funding_rates funding_rates_exchange_symbol_timestamp_key; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.funding_rates
    ADD CONSTRAINT funding_rates_exchange_symbol_timestamp_key UNIQUE (exchange, symbol, "timestamp");


--
-- Name: funding_rates funding_rates_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.funding_rates
    ADD CONSTRAINT funding_rates_pkey PRIMARY KEY (funding_id);


--
-- Name: futures_basis futures_basis_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.futures_basis
    ADD CONSTRAINT futures_basis_pkey PRIMARY KEY (basis_id);


--
-- Name: futures_basis futures_basis_symbol_contract_type_timestamp_key; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.futures_basis
    ADD CONSTRAINT futures_basis_symbol_contract_type_timestamp_key UNIQUE (symbol, contract_type, "timestamp");


--
-- Name: model_metadata model_metadata_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.model_metadata
    ADD CONSTRAINT model_metadata_pkey PRIMARY KEY (model_name);


--
-- Name: model_predictions model_predictions_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.model_predictions
    ADD CONSTRAINT model_predictions_pkey PRIMARY KEY (id);


--
-- Name: model_predictions model_predictions_prediction_id_key; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.model_predictions
    ADD CONSTRAINT model_predictions_prediction_id_key UNIQUE (prediction_id);


--
-- Name: monte_carlo_robustness monte_carlo_robustness_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.monte_carlo_robustness
    ADD CONSTRAINT monte_carlo_robustness_pkey PRIMARY KEY (test_id);


--
-- Name: monte_carlo_robustness monte_carlo_robustness_test_date_scenario_type_key; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.monte_carlo_robustness
    ADD CONSTRAINT monte_carlo_robustness_test_date_scenario_type_key UNIQUE (test_date, scenario_type);


--
-- Name: narrative_analysis narrative_analysis_analysis_date_key; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.narrative_analysis
    ADD CONSTRAINT narrative_analysis_analysis_date_key UNIQUE (analysis_date);


--
-- Name: narrative_analysis narrative_analysis_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.narrative_analysis
    ADD CONSTRAINT narrative_analysis_pkey PRIMARY KEY (narrative_id);


--
-- Name: optimal_execution_plans optimal_execution_plans_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.optimal_execution_plans
    ADD CONSTRAINT optimal_execution_plans_pkey PRIMARY KEY (plan_id);


--
-- Name: optimal_execution_plans optimal_execution_plans_symbol_plan_date_key; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.optimal_execution_plans
    ADD CONSTRAINT optimal_execution_plans_symbol_plan_date_key UNIQUE (symbol, plan_date);


--
-- Name: options_gamma options_gamma_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.options_gamma
    ADD CONSTRAINT options_gamma_pkey PRIMARY KEY (gamma_id);


--
-- Name: options_gamma options_gamma_symbol_strike_price_expiry_date_option_type_t_key; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.options_gamma
    ADD CONSTRAINT options_gamma_symbol_strike_price_expiry_date_option_type_t_key UNIQUE (symbol, strike_price, expiry_date, option_type, "timestamp");


--
-- Name: regime_adaptive_weights regime_adaptive_weights_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.regime_adaptive_weights
    ADD CONSTRAINT regime_adaptive_weights_pkey PRIMARY KEY (weight_id);


--
-- Name: regime_adaptive_weights regime_adaptive_weights_regime_timestamp_key; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.regime_adaptive_weights
    ADD CONSTRAINT regime_adaptive_weights_regime_timestamp_key UNIQUE (regime, "timestamp");


--
-- Name: regime_states regime_states_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.regime_states
    ADD CONSTRAINT regime_states_pkey PRIMARY KEY (id);


--
-- Name: regime_tracker regime_tracker_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.regime_tracker
    ADD CONSTRAINT regime_tracker_pkey PRIMARY KEY (regime_id);


--
-- Name: regime_tracker regime_tracker_ticker_date_key; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.regime_tracker
    ADD CONSTRAINT regime_tracker_ticker_date_key UNIQUE (ticker, date);


--
-- Name: relevance_scores relevance_scores_event_id_key; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.relevance_scores
    ADD CONSTRAINT relevance_scores_event_id_key UNIQUE (event_id);


--
-- Name: relevance_scores relevance_scores_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.relevance_scores
    ADD CONSTRAINT relevance_scores_pkey PRIMARY KEY (score_id);


--
-- Name: risk_dashboard risk_dashboard_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.risk_dashboard
    ADD CONSTRAINT risk_dashboard_pkey PRIMARY KEY (dashboard_id);


--
-- Name: risk_dashboard risk_dashboard_report_date_key; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.risk_dashboard
    ADD CONSTRAINT risk_dashboard_report_date_key UNIQUE (report_date);


--
-- Name: serper_events serper_events_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.serper_events
    ADD CONSTRAINT serper_events_pkey PRIMARY KEY (event_id);


--
-- Name: serper_events serper_events_url_key; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.serper_events
    ADD CONSTRAINT serper_events_url_key UNIQUE (url);


--
-- Name: signal_events signal_events_content_hash_key; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.signal_events
    ADD CONSTRAINT signal_events_content_hash_key UNIQUE (content_hash);


--
-- Name: signal_events signal_events_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.signal_events
    ADD CONSTRAINT signal_events_pkey PRIMARY KEY (event_id);


--
-- Name: uncertainty_history uncertainty_history_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.uncertainty_history
    ADD CONSTRAINT uncertainty_history_pkey PRIMARY KEY (uncertainty_id);


--
-- Name: uncertainty_history uncertainty_history_symbol_timestamp_key; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.uncertainty_history
    ADD CONSTRAINT uncertainty_history_symbol_timestamp_key UNIQUE (symbol, "timestamp");


--
-- Name: vendor_raw_ingest vendor_raw_ingest_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.vendor_raw_ingest
    ADD CONSTRAINT vendor_raw_ingest_pkey PRIMARY KEY (ingest_id);


--
-- Name: vendor_status vendor_status_pkey; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.vendor_status
    ADD CONSTRAINT vendor_status_pkey PRIMARY KEY (status_id);


--
-- Name: vendor_status vendor_status_vendor_id_status_date_key; Type: CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.vendor_status
    ADD CONSTRAINT vendor_status_vendor_id_status_date_key UNIQUE (vendor_id, status_date);


--
-- Name: aci_reactivation_cycles aci_reactivation_cycles_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.aci_reactivation_cycles
    ADD CONSTRAINT aci_reactivation_cycles_pkey PRIMARY KEY (cycle_id);


--
-- Name: aci_reactivation_phases aci_reactivation_phases_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.aci_reactivation_phases
    ADD CONSTRAINT aci_reactivation_phases_pkey PRIMARY KEY (phase_id);


--
-- Name: ael_intervention_registry ael_intervention_registry_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ael_intervention_registry
    ADD CONSTRAINT ael_intervention_registry_pkey PRIMARY KEY (intervention_id);


--
-- Name: agent_contracts agent_contracts_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.agent_contracts
    ADD CONSTRAINT agent_contracts_pkey PRIMARY KEY (contract_id);


--
-- Name: agent_health_attestations agent_health_attestations_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.agent_health_attestations
    ADD CONSTRAINT agent_health_attestations_pkey PRIMARY KEY (attestation_id);


--
-- Name: agent_heartbeats agent_heartbeats_agent_id_component_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.agent_heartbeats
    ADD CONSTRAINT agent_heartbeats_agent_id_component_key UNIQUE (agent_id, component);


--
-- Name: agent_heartbeats agent_heartbeats_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.agent_heartbeats
    ADD CONSTRAINT agent_heartbeats_pkey PRIMARY KEY (heartbeat_id);


--
-- Name: agent_mandates agent_mandates_agent_name_mandate_version_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.agent_mandates
    ADD CONSTRAINT agent_mandates_agent_name_mandate_version_key UNIQUE (agent_name, mandate_version);


--
-- Name: agent_mandates agent_mandates_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.agent_mandates
    ADD CONSTRAINT agent_mandates_pkey PRIMARY KEY (mandate_id);


--
-- Name: agent_memory_ledger agent_memory_ledger_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.agent_memory_ledger
    ADD CONSTRAINT agent_memory_ledger_pkey PRIMARY KEY (memory_id);


--
-- Name: agent_suspension_requests agent_suspension_requests_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.agent_suspension_requests
    ADD CONSTRAINT agent_suspension_requests_pkey PRIMARY KEY (request_id);


--
-- Name: agent_task_log agent_task_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.agent_task_log
    ADD CONSTRAINT agent_task_log_pkey PRIMARY KEY (task_id);


--
-- Name: aiqf_benchmark_registry aiqf_benchmark_registry_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.aiqf_benchmark_registry
    ADD CONSTRAINT aiqf_benchmark_registry_pkey PRIMARY KEY (benchmark_id);


--
-- Name: aiqf_benchmark_runs aiqf_benchmark_runs_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.aiqf_benchmark_runs
    ADD CONSTRAINT aiqf_benchmark_runs_pkey PRIMARY KEY (run_id);


--
-- Name: aiqf_drift_alerts aiqf_drift_alerts_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.aiqf_drift_alerts
    ADD CONSTRAINT aiqf_drift_alerts_pkey PRIMARY KEY (alert_id);


--
-- Name: api_budget_log api_budget_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.api_budget_log
    ADD CONSTRAINT api_budget_log_pkey PRIMARY KEY (id);


--
-- Name: api_budget_log api_budget_log_provider_name_usage_date_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.api_budget_log
    ADD CONSTRAINT api_budget_log_provider_name_usage_date_key UNIQUE (provider_name, usage_date);


--
-- Name: api_provider_registry api_provider_registry_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.api_provider_registry
    ADD CONSTRAINT api_provider_registry_pkey PRIMARY KEY (provider_id);


--
-- Name: api_provider_registry api_provider_registry_provider_name_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.api_provider_registry
    ADD CONSTRAINT api_provider_registry_provider_name_key UNIQUE (provider_name);


--
-- Name: api_usage_events api_usage_events_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.api_usage_events
    ADD CONSTRAINT api_usage_events_pkey PRIMARY KEY (id);


--
-- Name: artifact_time_registry artifact_time_registry_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.artifact_time_registry
    ADD CONSTRAINT artifact_time_registry_pkey PRIMARY KEY (artifact_id);


--
-- Name: asrp_state_log asrp_state_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.asrp_state_log
    ADD CONSTRAINT asrp_state_log_pkey PRIMARY KEY (log_id);


--
-- Name: asrp_violations asrp_violations_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.asrp_violations
    ADD CONSTRAINT asrp_violations_pkey PRIMARY KEY (violation_id);


--
-- Name: audit_log audit_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.audit_log
    ADD CONSTRAINT audit_log_pkey PRIMARY KEY (log_id);


--
-- Name: authority_matrix authority_matrix_agent_name_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.authority_matrix
    ADD CONSTRAINT authority_matrix_agent_name_key UNIQUE (agent_name);


--
-- Name: authority_matrix authority_matrix_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.authority_matrix
    ADD CONSTRAINT authority_matrix_pkey PRIMARY KEY (matrix_id);


--
-- Name: batch_graduation_log batch_graduation_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.batch_graduation_log
    ADD CONSTRAINT batch_graduation_log_pkey PRIMARY KEY (graduation_id);


--
-- Name: aiqf_benchmark_registry benchmark_name_version_unique; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.aiqf_benchmark_registry
    ADD CONSTRAINT benchmark_name_version_unique UNIQUE (benchmark_name, benchmark_version);


--
-- Name: blackout_log blackout_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.blackout_log
    ADD CONSTRAINT blackout_log_pkey PRIMARY KEY (log_id);


--
-- Name: brier_score_ledger brier_score_ledger_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.brier_score_ledger
    ADD CONSTRAINT brier_score_ledger_pkey PRIMARY KEY (score_id);


--
-- Name: cadence_exception_log cadence_exception_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.cadence_exception_log
    ADD CONSTRAINT cadence_exception_log_pkey PRIMARY KEY (exception_id);


--
-- Name: calibration_audit_log calibration_audit_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.calibration_audit_log
    ADD CONSTRAINT calibration_audit_log_pkey PRIMARY KEY (id);


--
-- Name: calibration_gate_history calibration_gate_history_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.calibration_gate_history
    ADD CONSTRAINT calibration_gate_history_pkey PRIMARY KEY (history_id);


--
-- Name: calibration_versions calibration_versions_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.calibration_versions
    ADD CONSTRAINT calibration_versions_pkey PRIMARY KEY (id);


--
-- Name: calibration_versions calibration_versions_unique; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.calibration_versions
    ADD CONSTRAINT calibration_versions_unique UNIQUE (parameter_name, version);


--
-- Name: canonical_evidence canonical_evidence_evidence_hash_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.canonical_evidence
    ADD CONSTRAINT canonical_evidence_evidence_hash_key UNIQUE (evidence_hash);


--
-- Name: canonical_evidence canonical_evidence_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.canonical_evidence
    ADD CONSTRAINT canonical_evidence_pkey PRIMARY KEY (evidence_id);


--
-- Name: canonical_mutation_gates canonical_mutation_gates_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.canonical_mutation_gates
    ADD CONSTRAINT canonical_mutation_gates_pkey PRIMARY KEY (gate_id);


--
-- Name: canonical_strategy canonical_strategy_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.canonical_strategy
    ADD CONSTRAINT canonical_strategy_pkey PRIMARY KEY (strategy_snapshot_id);


--
-- Name: causal_edge_log causal_edge_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.causal_edge_log
    ADD CONSTRAINT causal_edge_log_pkey PRIMARY KEY (log_id);


--
-- Name: causal_entropy_audit causal_entropy_audit_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.causal_entropy_audit
    ADD CONSTRAINT causal_entropy_audit_pkey PRIMARY KEY (audit_id);


--
-- Name: ceio_postmortem ceio_postmortem_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ceio_postmortem
    ADD CONSTRAINT ceio_postmortem_pkey PRIMARY KEY (postmortem_id);


--
-- Name: ceo_access_log ceo_access_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ceo_access_log
    ADD CONSTRAINT ceo_access_log_pkey PRIMARY KEY (access_id);


--
-- Name: ceo_access_whitelist ceo_access_whitelist_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ceo_access_whitelist
    ADD CONSTRAINT ceo_access_whitelist_pkey PRIMARY KEY (whitelist_id);


--
-- Name: ceo_access_whitelist ceo_access_whitelist_telegram_chat_id_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ceo_access_whitelist
    ADD CONSTRAINT ceo_access_whitelist_telegram_chat_id_key UNIQUE (telegram_chat_id);


--
-- Name: ceo_command_registry ceo_command_registry_command_name_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ceo_command_registry
    ADD CONSTRAINT ceo_command_registry_command_name_key UNIQUE (command_name);


--
-- Name: ceo_command_registry ceo_command_registry_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ceo_command_registry
    ADD CONSTRAINT ceo_command_registry_pkey PRIMARY KEY (command_id);


--
-- Name: ceo_rate_limit_state ceo_rate_limit_state_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ceo_rate_limit_state
    ADD CONSTRAINT ceo_rate_limit_state_pkey PRIMARY KEY (chat_id);


--
-- Name: ceo_temporal_snapshots ceo_temporal_snapshots_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ceo_temporal_snapshots
    ADD CONSTRAINT ceo_temporal_snapshots_pkey PRIMARY KEY (snapshot_id);


--
-- Name: change_approvals change_approvals_ios_module_gate_decision_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.change_approvals
    ADD CONSTRAINT change_approvals_ios_module_gate_decision_key UNIQUE (ios_module, gate, decision);


--
-- Name: change_approvals change_approvals_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.change_approvals
    ADD CONSTRAINT change_approvals_pkey PRIMARY KEY (approval_id);


--
-- Name: change_log change_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.change_log
    ADD CONSTRAINT change_log_pkey PRIMARY KEY (log_id);


--
-- Name: chl_bypass_detections chl_bypass_detections_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.chl_bypass_detections
    ADD CONSTRAINT chl_bypass_detections_pkey PRIMARY KEY (detection_id);


--
-- Name: chl_llm_requests chl_llm_requests_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.chl_llm_requests
    ADD CONSTRAINT chl_llm_requests_pkey PRIMARY KEY (request_id);


--
-- Name: chl_request_log chl_request_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.chl_request_log
    ADD CONSTRAINT chl_request_log_pkey PRIMARY KEY (request_id);


--
-- Name: circuit_breaker_events circuit_breaker_events_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.circuit_breaker_events
    ADD CONSTRAINT circuit_breaker_events_pkey PRIMARY KEY (event_id);


--
-- Name: circuit_breakers circuit_breakers_breaker_name_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.circuit_breakers
    ADD CONSTRAINT circuit_breakers_breaker_name_key UNIQUE (breaker_name);


--
-- Name: circuit_breakers circuit_breakers_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.circuit_breakers
    ADD CONSTRAINT circuit_breakers_pkey PRIMARY KEY (breaker_id);


--
-- Name: cnrp_configuration cnrp_configuration_config_key_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.cnrp_configuration
    ADD CONSTRAINT cnrp_configuration_config_key_key UNIQUE (config_key);


--
-- Name: cnrp_configuration cnrp_configuration_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.cnrp_configuration
    ADD CONSTRAINT cnrp_configuration_pkey PRIMARY KEY (config_id);


--
-- Name: cnrp_execution_log cnrp_execution_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.cnrp_execution_log
    ADD CONSTRAINT cnrp_execution_log_pkey PRIMARY KEY (execution_id);


--
-- Name: cognitive_query_set cognitive_query_set_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.cognitive_query_set
    ADD CONSTRAINT cognitive_query_set_pkey PRIMARY KEY (query_id);


--
-- Name: confidence_calibration_gates confidence_calibration_gates_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.confidence_calibration_gates
    ADD CONSTRAINT confidence_calibration_gates_pkey PRIMARY KEY (gate_id);


--
-- Name: constitutional_violations constitutional_violations_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.constitutional_violations
    ADD CONSTRAINT constitutional_violations_pkey PRIMARY KEY (id);


--
-- Name: constitutional_violations constitutional_violations_violation_id_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.constitutional_violations
    ADD CONSTRAINT constitutional_violations_violation_id_key UNIQUE (violation_id);


--
-- Name: context_packages context_packages_package_hash_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.context_packages
    ADD CONSTRAINT context_packages_package_hash_key UNIQUE (package_hash);


--
-- Name: context_packages context_packages_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.context_packages
    ADD CONSTRAINT context_packages_pkey PRIMARY KEY (package_id);


--
-- Name: crypto_pair_registry crypto_pair_registry_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.crypto_pair_registry
    ADD CONSTRAINT crypto_pair_registry_pkey PRIMARY KEY (pair_id);


--
-- Name: crypto_pair_registry crypto_pair_registry_symbol_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.crypto_pair_registry
    ADD CONSTRAINT crypto_pair_registry_symbol_key UNIQUE (symbol);


--
-- Name: crypto_promotion_log crypto_promotion_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.crypto_promotion_log
    ADD CONSTRAINT crypto_promotion_log_pkey PRIMARY KEY (log_id);


--
-- Name: crypto_vega_enforcement crypto_vega_enforcement_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.crypto_vega_enforcement
    ADD CONSTRAINT crypto_vega_enforcement_pkey PRIMARY KEY (rule_id);


--
-- Name: crypto_vega_enforcement crypto_vega_enforcement_rule_name_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.crypto_vega_enforcement
    ADD CONSTRAINT crypto_vega_enforcement_rule_name_key UNIQUE (rule_name);


--
-- Name: daily_goal_calendar daily_goal_calendar_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.daily_goal_calendar
    ADD CONSTRAINT daily_goal_calendar_pkey PRIMARY KEY (goal_id);


--
-- Name: data_availability_registry data_availability_registry_dataset_name_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.data_availability_registry
    ADD CONSTRAINT data_availability_registry_dataset_name_key UNIQUE (dataset_name);


--
-- Name: data_availability_registry data_availability_registry_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.data_availability_registry
    ADD CONSTRAINT data_availability_registry_pkey PRIMARY KEY (registry_id);


--
-- Name: data_blackout_state data_blackout_state_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.data_blackout_state
    ADD CONSTRAINT data_blackout_state_pkey PRIMARY KEY (blackout_id);


--
-- Name: data_provider_policy data_provider_policy_agent_id_usage_tier_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.data_provider_policy
    ADD CONSTRAINT data_provider_policy_agent_id_usage_tier_key UNIQUE (agent_id, usage_tier);


--
-- Name: data_provider_policy data_provider_policy_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.data_provider_policy
    ADD CONSTRAINT data_provider_policy_pkey PRIMARY KEY (policy_id);


--
-- Name: decision_log decision_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.decision_log
    ADD CONSTRAINT decision_log_pkey PRIMARY KEY (decision_id);


--
-- Name: decision_plans decision_plans_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.decision_plans
    ADD CONSTRAINT decision_plans_pkey PRIMARY KEY (plan_id);


--
-- Name: decision_sequence decision_sequence_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.decision_sequence
    ADD CONSTRAINT decision_sequence_pkey PRIMARY KEY (id);


--
-- Name: decision_log decision_ttl_max; Type: CHECK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE fhq_governance.decision_log
    ADD CONSTRAINT decision_ttl_max CHECK ((valid_until <= (created_at + '00:15:00'::interval))) NOT VALID;


--
-- Name: defcon_state defcon_state_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.defcon_state
    ADD CONSTRAINT defcon_state_pkey PRIMARY KEY (state_id);


--
-- Name: defcon_transitions defcon_transitions_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.defcon_transitions
    ADD CONSTRAINT defcon_transitions_pkey PRIMARY KEY (transition_id);


--
-- Name: discrepancy_events discrepancy_events_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.discrepancy_events
    ADD CONSTRAINT discrepancy_events_pkey PRIMARY KEY (event_id);


--
-- Name: ec_registry ec_registry_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ec_registry
    ADD CONSTRAINT ec_registry_pkey PRIMARY KEY (ec_id);


--
-- Name: economic_safety_limits economic_safety_limits_limit_name_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.economic_safety_limits
    ADD CONSTRAINT economic_safety_limits_limit_name_key UNIQUE (limit_name);


--
-- Name: economic_safety_limits economic_safety_limits_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.economic_safety_limits
    ADD CONSTRAINT economic_safety_limits_pkey PRIMARY KEY (limit_id);


--
-- Name: eloop_config eloop_config_config_key_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.eloop_config
    ADD CONSTRAINT eloop_config_config_key_key UNIQUE (config_key);


--
-- Name: eloop_config eloop_config_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.eloop_config
    ADD CONSTRAINT eloop_config_pkey PRIMARY KEY (config_id);


--
-- Name: epistemic_health_daily epistemic_health_daily_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.epistemic_health_daily
    ADD CONSTRAINT epistemic_health_daily_pkey PRIMARY KEY (health_date);


--
-- Name: epistemic_lesson_evidence epistemic_lesson_evidence_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.epistemic_lesson_evidence
    ADD CONSTRAINT epistemic_lesson_evidence_pkey PRIMARY KEY (evidence_id);


--
-- Name: epistemic_lessons epistemic_lessons_lesson_hash_unique; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.epistemic_lessons
    ADD CONSTRAINT epistemic_lessons_lesson_hash_unique UNIQUE (lesson_hash);


--
-- Name: epistemic_lessons epistemic_lessons_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.epistemic_lessons
    ADD CONSTRAINT epistemic_lessons_pkey PRIMARY KEY (lesson_id);


--
-- Name: epistemic_proposal_runs epistemic_proposal_runs_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.epistemic_proposal_runs
    ADD CONSTRAINT epistemic_proposal_runs_pkey PRIMARY KEY (run_id);


--
-- Name: epistemic_proposal_templates epistemic_proposal_templates_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.epistemic_proposal_templates
    ADD CONSTRAINT epistemic_proposal_templates_pkey PRIMARY KEY (template_id);


--
-- Name: epistemic_proposals epistemic_proposals_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.epistemic_proposals
    ADD CONSTRAINT epistemic_proposals_pkey PRIMARY KEY (proposal_id);


--
-- Name: epistemic_proposals epistemic_proposals_proposal_code_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.epistemic_proposals
    ADD CONSTRAINT epistemic_proposals_proposal_code_key UNIQUE (proposal_code);


--
-- Name: epistemic_schedule_config epistemic_schedule_config_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.epistemic_schedule_config
    ADD CONSTRAINT epistemic_schedule_config_pkey PRIMARY KEY (config_id);


--
-- Name: epistemic_suppression_ledger epistemic_suppression_ledger_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.epistemic_suppression_ledger
    ADD CONSTRAINT epistemic_suppression_ledger_pkey PRIMARY KEY (suppression_id);


--
-- Name: event_queue event_queue_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.event_queue
    ADD CONSTRAINT event_queue_pkey PRIMARY KEY (queue_id);


--
-- Name: event_trigger_registry event_trigger_registry_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.event_trigger_registry
    ADD CONSTRAINT event_trigger_registry_pkey PRIMARY KEY (trigger_id);


--
-- Name: event_trigger_registry event_trigger_registry_trigger_name_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.event_trigger_registry
    ADD CONSTRAINT event_trigger_registry_trigger_name_key UNIQUE (trigger_name);


--
-- Name: event_type_registry event_type_registry_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.event_type_registry
    ADD CONSTRAINT event_type_registry_pkey PRIMARY KEY (event_type);


--
-- Name: execution_attempts execution_attempts_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.execution_attempts
    ADD CONSTRAINT execution_attempts_pkey PRIMARY KEY (attempt_id);


--
-- Name: execution_boundary_control execution_boundary_control_control_name_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.execution_boundary_control
    ADD CONSTRAINT execution_boundary_control_control_name_key UNIQUE (control_name);


--
-- Name: execution_boundary_control execution_boundary_control_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.execution_boundary_control
    ADD CONSTRAINT execution_boundary_control_pkey PRIMARY KEY (control_id);


--
-- Name: execution_log execution_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.execution_log
    ADD CONSTRAINT execution_log_pkey PRIMARY KEY (execution_id);


--
-- Name: execution_mode execution_mode_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.execution_mode
    ADD CONSTRAINT execution_mode_pkey PRIMARY KEY (mode_id);


--
-- Name: execution_state_change_log execution_state_change_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.execution_state_change_log
    ADD CONSTRAINT execution_state_change_log_pkey PRIMARY KEY (change_id);


--
-- Name: execution_state execution_state_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.execution_state
    ADD CONSTRAINT execution_state_pkey PRIMARY KEY (state_id);


--
-- Name: executive_roles executive_roles_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.executive_roles
    ADD CONSTRAINT executive_roles_pkey PRIMARY KEY (role_id);


--
-- Name: executive_roles executive_roles_role_name_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.executive_roles
    ADD CONSTRAINT executive_roles_role_name_key UNIQUE (role_name);


--
-- Name: failure_mode_registry failure_mode_registry_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.failure_mode_registry
    ADD CONSTRAINT failure_mode_registry_pkey PRIMARY KEY (failure_mode_id);


--
-- Name: failure_mode_reopen_log failure_mode_reopen_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.failure_mode_reopen_log
    ADD CONSTRAINT failure_mode_reopen_log_pkey PRIMARY KEY (reopen_id);


--
-- Name: fortress_anchors fortress_anchors_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.fortress_anchors
    ADD CONSTRAINT fortress_anchors_pkey PRIMARY KEY (anchor_id);


--
-- Name: freshness_decoupling_rules freshness_decoupling_rules_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.freshness_decoupling_rules
    ADD CONSTRAINT freshness_decoupling_rules_pkey PRIMARY KEY (rule_id);


--
-- Name: freshness_thresholds freshness_thresholds_asset_class_gate_type_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.freshness_thresholds
    ADD CONSTRAINT freshness_thresholds_asset_class_gate_type_key UNIQUE (asset_class, gate_type);


--
-- Name: freshness_thresholds freshness_thresholds_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.freshness_thresholds
    ADD CONSTRAINT freshness_thresholds_pkey PRIMARY KEY (threshold_id);


--
-- Name: frozen_holdout_registry frozen_holdout_registry_holdout_name_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.frozen_holdout_registry
    ADD CONSTRAINT frozen_holdout_registry_holdout_name_key UNIQUE (holdout_name);


--
-- Name: frozen_holdout_registry frozen_holdout_registry_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.frozen_holdout_registry
    ADD CONSTRAINT frozen_holdout_registry_pkey PRIMARY KEY (holdout_id);


--
-- Name: g4_artifact_hashes g4_artifact_hashes_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.g4_artifact_hashes
    ADD CONSTRAINT g4_artifact_hashes_pkey PRIMARY KEY (hash_id);


--
-- Name: g4_review_constraints g4_review_constraints_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.g4_review_constraints
    ADD CONSTRAINT g4_review_constraints_pkey PRIMARY KEY (id);


--
-- Name: gate_violation_log gate_violation_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.gate_violation_log
    ADD CONSTRAINT gate_violation_log_pkey PRIMARY KEY (violation_id);


--
-- Name: gateway_integrity_signatures gateway_integrity_signatures_context_hash_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.gateway_integrity_signatures
    ADD CONSTRAINT gateway_integrity_signatures_context_hash_key UNIQUE (context_hash);


--
-- Name: gateway_integrity_signatures gateway_integrity_signatures_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.gateway_integrity_signatures
    ADD CONSTRAINT gateway_integrity_signatures_pkey PRIMARY KEY (signature_id);


--
-- Name: gateway_request_log gateway_request_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.gateway_request_log
    ADD CONSTRAINT gateway_request_log_pkey PRIMARY KEY (request_id);


--
-- Name: goal_completion_evidence goal_completion_evidence_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.goal_completion_evidence
    ADD CONSTRAINT goal_completion_evidence_pkey PRIMARY KEY (evidence_id);


--
-- Name: golden_alpha_testset golden_alpha_testset_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.golden_alpha_testset
    ADD CONSTRAINT golden_alpha_testset_pkey PRIMARY KEY (testcase_id);


--
-- Name: golden_scenario_registry golden_scenario_registry_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.golden_scenario_registry
    ADD CONSTRAINT golden_scenario_registry_pkey PRIMARY KEY (scenario_id);


--
-- Name: golden_scenario_registry golden_scenario_registry_scenario_code_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.golden_scenario_registry
    ADD CONSTRAINT golden_scenario_registry_scenario_code_key UNIQUE (scenario_code);


--
-- Name: governance_actions_log governance_actions_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.governance_actions_log
    ADD CONSTRAINT governance_actions_log_pkey PRIMARY KEY (action_id);


--
-- Name: governance_documents governance_documents_document_name_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.governance_documents
    ADD CONSTRAINT governance_documents_document_name_key UNIQUE (document_name);


--
-- Name: governance_documents governance_documents_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.governance_documents
    ADD CONSTRAINT governance_documents_pkey PRIMARY KEY (document_id);


--
-- Name: governance_instruments governance_instruments_instrument_name_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.governance_instruments
    ADD CONSTRAINT governance_instruments_instrument_name_key UNIQUE (instrument_name);


--
-- Name: governance_instruments governance_instruments_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.governance_instruments
    ADD CONSTRAINT governance_instruments_pkey PRIMARY KEY (instrument_id);


--
-- Name: governance_state governance_state_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.governance_state
    ADD CONSTRAINT governance_state_pkey PRIMARY KEY (state_id);


--
-- Name: governance_state governance_state_unique_component; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.governance_state
    ADD CONSTRAINT governance_state_unique_component UNIQUE (component_type, component_name, component_version);


--
-- Name: holdout_evaluation_results holdout_evaluation_results_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.holdout_evaluation_results
    ADD CONSTRAINT holdout_evaluation_results_pkey PRIMARY KEY (evaluation_id);


--
-- Name: ikea_validation_log ikea_validation_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ikea_validation_log
    ADD CONSTRAINT ikea_validation_log_pkey PRIMARY KEY (validation_id);


--
-- Name: inforage_config inforage_config_config_key_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.inforage_config
    ADD CONSTRAINT inforage_config_config_key_key UNIQUE (config_key);


--
-- Name: inforage_config inforage_config_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.inforage_config
    ADD CONSTRAINT inforage_config_pkey PRIMARY KEY (config_id);


--
-- Name: inforage_query_log inforage_query_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.inforage_query_log
    ADD CONSTRAINT inforage_query_log_pkey PRIMARY KEY (query_id);


--
-- Name: intent_drafts intent_drafts_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.intent_drafts
    ADD CONSTRAINT intent_drafts_pkey PRIMARY KEY (draft_id);


--
-- Name: ios008_mandate_authority ios008_mandate_authority_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ios008_mandate_authority
    ADD CONSTRAINT ios008_mandate_authority_pkey PRIMARY KEY (id);


--
-- Name: ios010_g0_verification ios010_g0_verification_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ios010_g0_verification
    ADD CONSTRAINT ios010_g0_verification_pkey PRIMARY KEY (id);


--
-- Name: ios012_g4_review ios012_g4_review_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ios012_g4_review
    ADD CONSTRAINT ios012_g4_review_pkey PRIMARY KEY (id);


--
-- Name: ios012_g4_review ios012_g4_review_review_id_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ios012_g4_review
    ADD CONSTRAINT ios012_g4_review_review_id_key UNIQUE (review_id);


--
-- Name: ios_execution_gates ios_execution_gates_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ios_execution_gates
    ADD CONSTRAINT ios_execution_gates_pkey PRIMARY KEY (gate_id);


--
-- Name: ios_quad_mapping ios_quad_mapping_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ios_quad_mapping
    ADD CONSTRAINT ios_quad_mapping_pkey PRIMARY KEY (mapping_id);


--
-- Name: ios_quad_mapping ios_quad_mapping_unique; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ios_quad_mapping
    ADD CONSTRAINT ios_quad_mapping_unique UNIQUE (ios_id, pillar_id);


--
-- Name: label_definition_registry label_definition_registry_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.label_definition_registry
    ADD CONSTRAINT label_definition_registry_pkey PRIMARY KEY (definition_id);


--
-- Name: label_definition_registry label_definition_registry_version_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.label_definition_registry
    ADD CONSTRAINT label_definition_registry_version_key UNIQUE (version);


--
-- Name: ldow_completion_thresholds ldow_completion_thresholds_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ldow_completion_thresholds
    ADD CONSTRAINT ldow_completion_thresholds_pkey PRIMARY KEY (threshold_id);


--
-- Name: ldow_completion_thresholds ldow_completion_thresholds_threshold_name_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ldow_completion_thresholds
    ADD CONSTRAINT ldow_completion_thresholds_threshold_name_key UNIQUE (threshold_name);


--
-- Name: ldow_cycle_completion ldow_cycle_completion_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ldow_cycle_completion
    ADD CONSTRAINT ldow_cycle_completion_pkey PRIMARY KEY (completion_id);


--
-- Name: ldow_cycle_metrics ldow_cycle_metrics_ldow_id_cycle_number_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ldow_cycle_metrics
    ADD CONSTRAINT ldow_cycle_metrics_ldow_id_cycle_number_key UNIQUE (ldow_id, cycle_number);


--
-- Name: ldow_cycle_metrics ldow_cycle_metrics_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ldow_cycle_metrics
    ADD CONSTRAINT ldow_cycle_metrics_pkey PRIMARY KEY (metric_id);


--
-- Name: ldow_evaluation_log ldow_evaluation_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ldow_evaluation_log
    ADD CONSTRAINT ldow_evaluation_log_pkey PRIMARY KEY (evaluation_id);


--
-- Name: ldow_failure_incidents ldow_failure_incidents_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ldow_failure_incidents
    ADD CONSTRAINT ldow_failure_incidents_pkey PRIMARY KEY (incident_id);


--
-- Name: ldow_forecast_captures ldow_forecast_captures_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ldow_forecast_captures
    ADD CONSTRAINT ldow_forecast_captures_pkey PRIMARY KEY (capture_id);


--
-- Name: ldow_regime_metrics ldow_regime_metrics_ldow_id_cycle_number_regime_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ldow_regime_metrics
    ADD CONSTRAINT ldow_regime_metrics_ldow_id_cycle_number_regime_key UNIQUE (ldow_id, cycle_number, regime);


--
-- Name: ldow_regime_metrics ldow_regime_metrics_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ldow_regime_metrics
    ADD CONSTRAINT ldow_regime_metrics_pkey PRIMARY KEY (metric_id);


--
-- Name: ldow_strategy_metrics ldow_strategy_metrics_ldow_id_cycle_number_strategy_id_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ldow_strategy_metrics
    ADD CONSTRAINT ldow_strategy_metrics_ldow_id_cycle_number_strategy_id_key UNIQUE (ldow_id, cycle_number, strategy_id);


--
-- Name: ldow_strategy_metrics ldow_strategy_metrics_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ldow_strategy_metrics
    ADD CONSTRAINT ldow_strategy_metrics_pkey PRIMARY KEY (metric_id);


--
-- Name: ldow_task_execution_log ldow_task_execution_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ldow_task_execution_log
    ADD CONSTRAINT ldow_task_execution_log_pkey PRIMARY KEY (execution_id);


--
-- Name: ldow_unattended_executions ldow_unattended_executions_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ldow_unattended_executions
    ADD CONSTRAINT ldow_unattended_executions_pkey PRIMARY KEY (execution_id);


--
-- Name: learning_delta_observation_window learning_delta_observation_window_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.learning_delta_observation_window
    ADD CONSTRAINT learning_delta_observation_window_pkey PRIMARY KEY (ldow_id);


--
-- Name: learning_mechanism_log learning_mechanism_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.learning_mechanism_log
    ADD CONSTRAINT learning_mechanism_log_pkey PRIMARY KEY (mechanism_id);


--
-- Name: learning_proposal_audit learning_proposal_audit_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.learning_proposal_audit
    ADD CONSTRAINT learning_proposal_audit_pkey PRIMARY KEY (audit_id);


--
-- Name: learning_proposals learning_proposals_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.learning_proposals
    ADD CONSTRAINT learning_proposals_pkey PRIMARY KEY (proposal_id);


--
-- Name: learning_versions learning_versions_engine_id_parameter_type_version_number_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.learning_versions
    ADD CONSTRAINT learning_versions_engine_id_parameter_type_version_number_key UNIQUE (engine_id, parameter_type, version_number);


--
-- Name: learning_versions learning_versions_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.learning_versions
    ADD CONSTRAINT learning_versions_pkey PRIMARY KEY (version_id);


--
-- Name: llm_provider_balance llm_provider_balance_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.llm_provider_balance
    ADD CONSTRAINT llm_provider_balance_pkey PRIMARY KEY (balance_id);


--
-- Name: llm_provider_balance llm_provider_balance_provider_fetched_at_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.llm_provider_balance
    ADD CONSTRAINT llm_provider_balance_provider_fetched_at_key UNIQUE (provider, fetched_at);


--
-- Name: llm_routing_log llm_routing_log_envelope_id_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.llm_routing_log
    ADD CONSTRAINT llm_routing_log_envelope_id_key UNIQUE (envelope_id);


--
-- Name: llm_routing_log llm_routing_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.llm_routing_log
    ADD CONSTRAINT llm_routing_log_pkey PRIMARY KEY (log_id);


--
-- Name: market_event_types market_event_types_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.market_event_types
    ADD CONSTRAINT market_event_types_pkey PRIMARY KEY (event_type_id);


--
-- Name: market_temporal_windows market_temporal_windows_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.market_temporal_windows
    ADD CONSTRAINT market_temporal_windows_pkey PRIMARY KEY (window_id);


--
-- Name: mit_quad_pillars mit_quad_pillars_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.mit_quad_pillars
    ADD CONSTRAINT mit_quad_pillars_pkey PRIMARY KEY (pillar_id);


--
-- Name: mock_positions mock_positions_asset_id_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.mock_positions
    ADD CONSTRAINT mock_positions_asset_id_key UNIQUE (asset_id);


--
-- Name: mock_positions mock_positions_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.mock_positions
    ADD CONSTRAINT mock_positions_pkey PRIMARY KEY (position_id);


--
-- Name: model_provider_policy model_provider_policy_agent_name_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.model_provider_policy
    ADD CONSTRAINT model_provider_policy_agent_name_key UNIQUE (agent_name);


--
-- Name: model_provider_policy model_provider_policy_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.model_provider_policy
    ADD CONSTRAINT model_provider_policy_pkey PRIMARY KEY (policy_id);


--
-- Name: model_tier_enforcement model_tier_enforcement_agent_id_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.model_tier_enforcement
    ADD CONSTRAINT model_tier_enforcement_agent_id_key UNIQUE (agent_id);


--
-- Name: model_tier_enforcement model_tier_enforcement_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.model_tier_enforcement
    ADD CONSTRAINT model_tier_enforcement_pkey PRIMARY KEY (enforcement_id);


--
-- Name: novelty_score_components novelty_score_components_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.novelty_score_components
    ADD CONSTRAINT novelty_score_components_pkey PRIMARY KEY (score_id);


--
-- Name: oracle_event_log oracle_event_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.oracle_event_log
    ADD CONSTRAINT oracle_event_log_pkey PRIMARY KEY (event_id);


--
-- Name: oracle_staging oracle_staging_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.oracle_staging
    ADD CONSTRAINT oracle_staging_pkey PRIMARY KEY (submission_id);


--
-- Name: orchestrator_authority orchestrator_authority_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.orchestrator_authority
    ADD CONSTRAINT orchestrator_authority_pkey PRIMARY KEY (orchestrator_id);


--
-- Name: orchestrator_cycles orchestrator_cycles_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.orchestrator_cycles
    ADD CONSTRAINT orchestrator_cycles_pkey PRIMARY KEY (cycle_id);


--
-- Name: output_bindings output_bindings_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.output_bindings
    ADD CONSTRAINT output_bindings_pkey PRIMARY KEY (binding_id);


--
-- Name: paper_decision_plan paper_decision_plan_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.paper_decision_plan
    ADD CONSTRAINT paper_decision_plan_pkey PRIMARY KEY (plan_id);


--
-- Name: paper_execution_authority paper_execution_authority_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.paper_execution_authority
    ADD CONSTRAINT paper_execution_authority_pkey PRIMARY KEY (id);


--
-- Name: paper_execution_loop paper_execution_loop_loop_id_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.paper_execution_loop
    ADD CONSTRAINT paper_execution_loop_loop_id_key UNIQUE (loop_id);


--
-- Name: paper_execution_loop paper_execution_loop_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.paper_execution_loop
    ADD CONSTRAINT paper_execution_loop_pkey PRIMARY KEY (id);


--
-- Name: paper_ledger paper_ledger_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.paper_ledger
    ADD CONSTRAINT paper_ledger_pkey PRIMARY KEY (trade_id);


--
-- Name: pending_constraints pending_constraints_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.pending_constraints
    ADD CONSTRAINT pending_constraints_pkey PRIMARY KEY (constraint_id);


--
-- Name: plps_gate_config plps_gate_config_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.plps_gate_config
    ADD CONSTRAINT plps_gate_config_pkey PRIMARY KEY (config_id);


--
-- Name: plps_graduation_attempts plps_graduation_attempts_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.plps_graduation_attempts
    ADD CONSTRAINT plps_graduation_attempts_pkey PRIMARY KEY (attempt_id);


--
-- Name: preflight_checklist preflight_checklist_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.preflight_checklist
    ADD CONSTRAINT preflight_checklist_pkey PRIMARY KEY (checklist_id);


--
-- Name: production_monitoring production_monitoring_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.production_monitoring
    ADD CONSTRAINT production_monitoring_pkey PRIMARY KEY (monitoring_id);


--
-- Name: protocol_omega_executions protocol_omega_executions_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.protocol_omega_executions
    ADD CONSTRAINT protocol_omega_executions_pkey PRIMARY KEY (execution_id);


--
-- Name: protocol_omega_registry protocol_omega_registry_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.protocol_omega_registry
    ADD CONSTRAINT protocol_omega_registry_pkey PRIMARY KEY (omega_id);


--
-- Name: protocol_omega_registry protocol_omega_registry_protocol_name_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.protocol_omega_registry
    ADD CONSTRAINT protocol_omega_registry_protocol_name_key UNIQUE (protocol_name);


--
-- Name: quad_hash_registry quad_hash_registry_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.quad_hash_registry
    ADD CONSTRAINT quad_hash_registry_pkey PRIMARY KEY (quad_hash_id);


--
-- Name: quad_hash_registry quad_hash_registry_quad_hash_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.quad_hash_registry
    ADD CONSTRAINT quad_hash_registry_quad_hash_key UNIQUE (quad_hash);


--
-- Name: refinement_evidence_bundle refinement_evidence_bundle_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.refinement_evidence_bundle
    ADD CONSTRAINT refinement_evidence_bundle_pkey PRIMARY KEY (bundle_id);


--
-- Name: regime_scalar_config regime_scalar_config_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.regime_scalar_config
    ADD CONSTRAINT regime_scalar_config_pkey PRIMARY KEY (config_id);


--
-- Name: regime_scalar_config regime_scalar_config_regime_label_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.regime_scalar_config
    ADD CONSTRAINT regime_scalar_config_regime_label_key UNIQUE (regime_label);


--
-- Name: registry_reconciliation_log registry_reconciliation_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.registry_reconciliation_log
    ADD CONSTRAINT registry_reconciliation_log_pkey PRIMARY KEY (id);


--
-- Name: regret_computation_diagnostics regret_computation_diagnostics_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.regret_computation_diagnostics
    ADD CONSTRAINT regret_computation_diagnostics_pkey PRIMARY KEY (diagnostic_id);


--
-- Name: research_log research_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.research_log
    ADD CONSTRAINT research_log_pkey PRIMARY KEY (log_id);


--
-- Name: retest_validation_cycles retest_validation_cycles_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.retest_validation_cycles
    ADD CONSTRAINT retest_validation_cycles_pkey PRIMARY KEY (cycle_id);


--
-- Name: scheduled_audits scheduled_audits_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.scheduled_audits
    ADD CONSTRAINT scheduled_audits_pkey PRIMARY KEY (schedule_id);


--
-- Name: scheduled_tasks scheduled_tasks_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.scheduled_tasks
    ADD CONSTRAINT scheduled_tasks_pkey PRIMARY KEY (task_id);


--
-- Name: security_alerts security_alerts_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.security_alerts
    ADD CONSTRAINT security_alerts_pkey PRIMARY KEY (alert_id);


--
-- Name: shadow_decision_log shadow_decision_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.shadow_decision_log
    ADD CONSTRAINT shadow_decision_log_pkey PRIMARY KEY (decision_id);


--
-- Name: shared_state_snapshots shared_state_snapshots_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.shared_state_snapshots
    ADD CONSTRAINT shared_state_snapshots_pkey PRIMARY KEY (snapshot_id);


--
-- Name: shared_state_snapshots shared_state_snapshots_state_vector_hash_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.shared_state_snapshots
    ADD CONSTRAINT shared_state_snapshots_state_vector_hash_key UNIQUE (state_vector_hash);


--
-- Name: skill_damper_config skill_damper_config_fss_min_fss_max_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.skill_damper_config
    ADD CONSTRAINT skill_damper_config_fss_min_fss_max_key UNIQUE (fss_min, fss_max);


--
-- Name: skill_damper_config skill_damper_config_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.skill_damper_config
    ADD CONSTRAINT skill_damper_config_pkey PRIMARY KEY (config_id);


--
-- Name: split_brain_events split_brain_events_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.split_brain_events
    ADD CONSTRAINT split_brain_events_pkey PRIMARY KEY (event_id);


--
-- Name: sql_correction_guidelines sql_correction_guidelines_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.sql_correction_guidelines
    ADD CONSTRAINT sql_correction_guidelines_pkey PRIMARY KEY (guideline_id);


--
-- Name: sql_refinement_log sql_refinement_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.sql_refinement_log
    ADD CONSTRAINT sql_refinement_log_pkey PRIMARY KEY (refinement_id);


--
-- Name: state_retrieval_log state_retrieval_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.state_retrieval_log
    ADD CONSTRAINT state_retrieval_log_pkey PRIMARY KEY (retrieval_id);


--
-- Name: steady_state_criteria steady_state_criteria_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.steady_state_criteria
    ADD CONSTRAINT steady_state_criteria_pkey PRIMARY KEY (criteria_id);


--
-- Name: stig_engine_operations stig_engine_operations_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.stig_engine_operations
    ADD CONSTRAINT stig_engine_operations_pkey PRIMARY KEY (operation_id);


--
-- Name: stillness_checkpoint_log stillness_checkpoint_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.stillness_checkpoint_log
    ADD CONSTRAINT stillness_checkpoint_log_pkey PRIMARY KEY (checkpoint_id);


--
-- Name: stillness_day_goals stillness_day_goals_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.stillness_day_goals
    ADD CONSTRAINT stillness_day_goals_pkey PRIMARY KEY (goal_id);


--
-- Name: suppression_regret_index suppression_regret_index_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.suppression_regret_index
    ADD CONSTRAINT suppression_regret_index_pkey PRIMARY KEY (regret_id);


--
-- Name: suspension_audit_log suspension_audit_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.suspension_audit_log
    ADD CONSTRAINT suspension_audit_log_pkey PRIMARY KEY (audit_id);


--
-- Name: system_events system_events_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.system_events
    ADD CONSTRAINT system_events_pkey PRIMARY KEY (event_id);


--
-- Name: system_heartbeats system_heartbeats_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.system_heartbeats
    ADD CONSTRAINT system_heartbeats_pkey PRIMARY KEY (id);


--
-- Name: system_state system_state_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.system_state
    ADD CONSTRAINT system_state_pkey PRIMARY KEY (state_id);


--
-- Name: task_activation_status task_activation_status_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.task_activation_status
    ADD CONSTRAINT task_activation_status_pkey PRIMARY KEY (activation_id);


--
-- Name: task_registry task_registry_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.task_registry
    ADD CONSTRAINT task_registry_pkey PRIMARY KEY (task_id);


--
-- Name: task_registry task_registry_task_name_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.task_registry
    ADD CONSTRAINT task_registry_task_name_key UNIQUE (task_name);


--
-- Name: telemetry_config telemetry_config_config_key_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.telemetry_config
    ADD CONSTRAINT telemetry_config_config_key_key UNIQUE (config_key);


--
-- Name: telemetry_config telemetry_config_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.telemetry_config
    ADD CONSTRAINT telemetry_config_pkey PRIMARY KEY (config_id);


--
-- Name: telemetry_cost_ledger telemetry_cost_ledger_agent_id_ledger_date_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.telemetry_cost_ledger
    ADD CONSTRAINT telemetry_cost_ledger_agent_id_ledger_date_key UNIQUE (agent_id, ledger_date);


--
-- Name: telemetry_cost_ledger telemetry_cost_ledger_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.telemetry_cost_ledger
    ADD CONSTRAINT telemetry_cost_ledger_pkey PRIMARY KEY (ledger_id);


--
-- Name: telemetry_errors telemetry_errors_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.telemetry_errors
    ADD CONSTRAINT telemetry_errors_pkey PRIMARY KEY (error_id);


--
-- Name: agent_heartbeats unique_agent_heartbeat; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.agent_heartbeats
    ADD CONSTRAINT unique_agent_heartbeat UNIQUE (agent_id);


--
-- Name: ldow_cycle_completion unique_cycle_number; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ldow_cycle_completion
    ADD CONSTRAINT unique_cycle_number UNIQUE (cycle_number);


--
-- Name: stillness_day_goals unique_day_goal; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.stillness_day_goals
    ADD CONSTRAINT unique_day_goal UNIQUE (day_number, day_label);


--
-- Name: ios_execution_gates unique_ios_gate; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ios_execution_gates
    ADD CONSTRAINT unique_ios_gate UNIQUE (ios_id, gate_type);


--
-- Name: daily_goal_calendar unique_phase_day_goal; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.daily_goal_calendar
    ADD CONSTRAINT unique_phase_day_goal UNIQUE (phase_name, day_number, calendar_date, goal_title);


--
-- Name: retest_validation_cycles uq_failure_cycle; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.retest_validation_cycles
    ADD CONSTRAINT uq_failure_cycle UNIQUE (failure_mode_id, cycle_number);


--
-- Name: system_heartbeats uq_heartbeats_component_name; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.system_heartbeats
    ADD CONSTRAINT uq_heartbeats_component_name UNIQUE (component_name);


--
-- Name: vega_attestations vega_attestations_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.vega_attestations
    ADD CONSTRAINT vega_attestations_pkey PRIMARY KEY (attestation_id);


--
-- Name: vega_rhythm_schedule vega_rhythm_schedule_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.vega_rhythm_schedule
    ADD CONSTRAINT vega_rhythm_schedule_pkey PRIMARY KEY (rhythm_id);


--
-- Name: vega_rhythm_schedule vega_rhythm_schedule_rhythm_name_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.vega_rhythm_schedule
    ADD CONSTRAINT vega_rhythm_schedule_rhythm_name_key UNIQUE (rhythm_name);


--
-- Name: vega_triage_log vega_triage_log_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.vega_triage_log
    ADD CONSTRAINT vega_triage_log_pkey PRIMARY KEY (triage_id);


--
-- Name: vega_triage_rules vega_triage_rules_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.vega_triage_rules
    ADD CONSTRAINT vega_triage_rules_pkey PRIMARY KEY (rule_id);


--
-- Name: vega_triage_rules vega_triage_rules_rule_name_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.vega_triage_rules
    ADD CONSTRAINT vega_triage_rules_rule_name_key UNIQUE (rule_name);


--
-- Name: vega_validation_rules vega_validation_rules_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.vega_validation_rules
    ADD CONSTRAINT vega_validation_rules_pkey PRIMARY KEY (rule_id);


--
-- Name: vega_validation_rules vega_validation_rules_rule_name_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.vega_validation_rules
    ADD CONSTRAINT vega_validation_rules_rule_name_key UNIQUE (rule_name);


--
-- Name: vendor_quota_events vendor_quota_events_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.vendor_quota_events
    ADD CONSTRAINT vendor_quota_events_pkey PRIMARY KEY (event_id);


--
-- Name: weekly_learning_runs weekly_learning_runs_iso_year_iso_week_key; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.weekly_learning_runs
    ADD CONSTRAINT weekly_learning_runs_iso_year_iso_week_key UNIQUE (iso_year, iso_week);


--
-- Name: weekly_learning_runs weekly_learning_runs_pkey; Type: CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.weekly_learning_runs
    ADD CONSTRAINT weekly_learning_runs_pkey PRIMARY KEY (run_id);


--
-- Name: aci_cognitive_memory aci_cognitive_memory_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.aci_cognitive_memory
    ADD CONSTRAINT aci_cognitive_memory_pkey PRIMARY KEY (memory_id);


--
-- Name: aci_cognitive_memory aci_cognitive_memory_session_id_sequence_number_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.aci_cognitive_memory
    ADD CONSTRAINT aci_cognitive_memory_session_id_sequence_number_key UNIQUE (session_id, sequence_number);


--
-- Name: aci_console_sessions aci_console_sessions_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.aci_console_sessions
    ADD CONSTRAINT aci_console_sessions_pkey PRIMARY KEY (session_id);


--
-- Name: aci_state_snapshot_log aci_state_snapshot_log_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.aci_state_snapshot_log
    ADD CONSTRAINT aci_state_snapshot_log_pkey PRIMARY KEY (snapshot_id);


--
-- Name: aci_system_prompts aci_system_prompts_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.aci_system_prompts
    ADD CONSTRAINT aci_system_prompts_pkey PRIMARY KEY (prompt_id);


--
-- Name: aci_system_prompts aci_system_prompts_prompt_name_prompt_version_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.aci_system_prompts
    ADD CONSTRAINT aci_system_prompts_prompt_name_prompt_version_key UNIQUE (prompt_name, prompt_version);


--
-- Name: adr_archive adr_archive_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_archive
    ADD CONSTRAINT adr_archive_pkey PRIMARY KEY (archive_id);


--
-- Name: adr_audit_log adr_audit_log_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_audit_log
    ADD CONSTRAINT adr_audit_log_pkey PRIMARY KEY (audit_id);


--
-- Name: adr_dependencies adr_dependencies_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_dependencies
    ADD CONSTRAINT adr_dependencies_pkey PRIMARY KEY (parent_adr_id, child_adr_id);


--
-- Name: adr_drift_events adr_drift_events_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_drift_events
    ADD CONSTRAINT adr_drift_events_pkey PRIMARY KEY (event_id);


--
-- Name: adr_ingestion_staging adr_ingestion_staging_file_name_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_ingestion_staging
    ADD CONSTRAINT adr_ingestion_staging_file_name_key UNIQUE (file_name);


--
-- Name: adr_ingestion_staging adr_ingestion_staging_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_ingestion_staging
    ADD CONSTRAINT adr_ingestion_staging_pkey PRIMARY KEY (id);


--
-- Name: adr_registry_local adr_registry_local_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_registry_local
    ADD CONSTRAINT adr_registry_local_pkey PRIMARY KEY (adr_id);


--
-- Name: adr_registry adr_registry_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_registry
    ADD CONSTRAINT adr_registry_pkey PRIMARY KEY (adr_id);


--
-- Name: adr_registry_preapproval adr_registry_preapproval_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_registry_preapproval
    ADD CONSTRAINT adr_registry_preapproval_pkey PRIMARY KEY (id);


--
-- Name: adr_registry_snapshots adr_registry_snapshots_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_registry_snapshots
    ADD CONSTRAINT adr_registry_snapshots_pkey PRIMARY KEY (snapshot_id);


--
-- Name: adr_registry_snapshots adr_registry_snapshots_snapshot_tag_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_registry_snapshots
    ADD CONSTRAINT adr_registry_snapshots_snapshot_tag_key UNIQUE (snapshot_tag);


--
-- Name: adr_version_history adr_version_history_adr_id_version_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_version_history
    ADD CONSTRAINT adr_version_history_adr_id_version_key UNIQUE (adr_id, version);


--
-- Name: adr_version_history adr_version_history_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_version_history
    ADD CONSTRAINT adr_version_history_pkey PRIMARY KEY (version_id);


--
-- Name: agent_interaction_log agent_interaction_log_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.agent_interaction_log
    ADD CONSTRAINT agent_interaction_log_pkey PRIMARY KEY (interaction_id);


--
-- Name: agent_keys agent_keys_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.agent_keys
    ADD CONSTRAINT agent_keys_pkey PRIMARY KEY (key_id);


--
-- Name: alpha_veto_config alpha_veto_config_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.alpha_veto_config
    ADD CONSTRAINT alpha_veto_config_pkey PRIMARY KEY (config_id);


--
-- Name: api_schema_registry api_schema_registry_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.api_schema_registry
    ADD CONSTRAINT api_schema_registry_pkey PRIMARY KEY (schema_id);


--
-- Name: api_schema_registry api_schema_registry_provider_endpoint_version_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.api_schema_registry
    ADD CONSTRAINT api_schema_registry_provider_endpoint_version_key UNIQUE (provider, endpoint, version);


--
-- Name: asset_classes asset_classes_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.asset_classes
    ADD CONSTRAINT asset_classes_pkey PRIMARY KEY (asset_class_id);


--
-- Name: asset_vendor_policy asset_vendor_policy_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.asset_vendor_policy
    ADD CONSTRAINT asset_vendor_policy_pkey PRIMARY KEY (asset_class_id);


--
-- Name: assets assets_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.assets
    ADD CONSTRAINT assets_pkey PRIMARY KEY (canonical_id);


--
-- Name: baseline_locks baseline_locks_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.baseline_locks
    ADD CONSTRAINT baseline_locks_pkey PRIMARY KEY (lock_id);


--
-- Name: baseline_registry baseline_registry_baseline_name_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.baseline_registry
    ADD CONSTRAINT baseline_registry_baseline_name_key UNIQUE (baseline_name);


--
-- Name: baseline_registry baseline_registry_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.baseline_registry
    ADD CONSTRAINT baseline_registry_pkey PRIMARY KEY (baseline_id);


--
-- Name: canonical_access_log canonical_access_log_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_access_log
    ADD CONSTRAINT canonical_access_log_pkey PRIMARY KEY (access_id);


--
-- Name: canonical_asset_groups canonical_asset_groups_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_asset_groups
    ADD CONSTRAINT canonical_asset_groups_pkey PRIMARY KEY (group_id);


--
-- Name: canonical_asset_members canonical_asset_members_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_asset_members
    ADD CONSTRAINT canonical_asset_members_pkey PRIMARY KEY (group_id, listing_id);


--
-- Name: canonical_decision_log canonical_decision_log_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_decision_log
    ADD CONSTRAINT canonical_decision_log_pkey PRIMARY KEY (decision_id);


--
-- Name: canonical_document_queue canonical_document_queue_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_document_queue
    ADD CONSTRAINT canonical_document_queue_pkey PRIMARY KEY (queue_id);


--
-- Name: canonical_documents canonical_documents_document_code_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_documents
    ADD CONSTRAINT canonical_documents_document_code_key UNIQUE (document_code);


--
-- Name: canonical_documents canonical_documents_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_documents
    ADD CONSTRAINT canonical_documents_pkey PRIMARY KEY (document_id);


--
-- Name: canonical_domain_registry canonical_domain_registry_domain_name_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_domain_registry
    ADD CONSTRAINT canonical_domain_registry_domain_name_key UNIQUE (domain_name);


--
-- Name: canonical_domain_registry canonical_domain_registry_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_domain_registry
    ADD CONSTRAINT canonical_domain_registry_pkey PRIMARY KEY (domain_id);


--
-- Name: canonical_indicator_registry canonical_indicator_registry_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_indicator_registry
    ADD CONSTRAINT canonical_indicator_registry_pkey PRIMARY KEY (indicator_id);


--
-- Name: canonical_indicator_registry canonical_indicator_unique; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_indicator_registry
    ADD CONSTRAINT canonical_indicator_unique UNIQUE (indicator_name, indicator_version, calculation_method);


--
-- Name: canonical_ingestion_registry canonical_ingestion_registry_job_name_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_ingestion_registry
    ADD CONSTRAINT canonical_ingestion_registry_job_name_key UNIQUE (job_name);


--
-- Name: canonical_ingestion_registry canonical_ingestion_registry_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_ingestion_registry
    ADD CONSTRAINT canonical_ingestion_registry_pkey PRIMARY KEY (ingestion_id);


--
-- Name: canonical_mismatches canonical_mismatches_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_mismatches
    ADD CONSTRAINT canonical_mismatches_pkey PRIMARY KEY (mismatch_id);


--
-- Name: canonical_series_registry canonical_series_registry_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_series_registry
    ADD CONSTRAINT canonical_series_registry_pkey PRIMARY KEY (series_id);


--
-- Name: canonical_series_registry canonical_series_unique; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_series_registry
    ADD CONSTRAINT canonical_series_unique UNIQUE (asset_id, frequency, price_type, listing_id);


--
-- Name: canonical_violation_log canonical_violation_log_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_violation_log
    ADD CONSTRAINT canonical_violation_log_pkey PRIMARY KEY (violation_id);


--
-- Name: chain_of_query chain_of_query_interaction_id_node_index_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.chain_of_query
    ADD CONSTRAINT chain_of_query_interaction_id_node_index_key UNIQUE (interaction_id, node_index);


--
-- Name: chain_of_query chain_of_query_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.chain_of_query
    ADD CONSTRAINT chain_of_query_pkey PRIMARY KEY (coq_id);


--
-- Name: cognitive_engine_evidence cognitive_engine_evidence_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.cognitive_engine_evidence
    ADD CONSTRAINT cognitive_engine_evidence_pkey PRIMARY KEY (evidence_id);


--
-- Name: cot_reasoning_logs cot_reasoning_logs_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.cot_reasoning_logs
    ADD CONSTRAINT cot_reasoning_logs_pkey PRIMARY KEY (log_id);


--
-- Name: data_lineage_log data_lineage_log_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.data_lineage_log
    ADD CONSTRAINT data_lineage_log_pkey PRIMARY KEY (lineage_id);


--
-- Name: data_source_registry data_source_registry_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.data_source_registry
    ADD CONSTRAINT data_source_registry_pkey PRIMARY KEY (source_id);


--
-- Name: document_claims document_claims_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.document_claims
    ADD CONSTRAINT document_claims_pkey PRIMARY KEY (claim_id);


--
-- Name: document_database_reconciliation document_database_reconciliation_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.document_database_reconciliation
    ADD CONSTRAINT document_database_reconciliation_pkey PRIMARY KEY (reconciliation_id);


--
-- Name: dynamic_regime_weights_audit dynamic_regime_weights_audit_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.dynamic_regime_weights_audit
    ADD CONSTRAINT dynamic_regime_weights_audit_pkey PRIMARY KEY (id);


--
-- Name: dynamic_regime_weights dynamic_regime_weights_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.dynamic_regime_weights
    ADD CONSTRAINT dynamic_regime_weights_pkey PRIMARY KEY (id);


--
-- Name: ec_authority_resolutions ec_authority_resolutions_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.ec_authority_resolutions
    ADD CONSTRAINT ec_authority_resolutions_pkey PRIMARY KEY (resolution_id);


--
-- Name: exchanges exchanges_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.exchanges
    ADD CONSTRAINT exchanges_pkey PRIMARY KEY (mic);


--
-- Name: external_taxonomy_map external_taxonomy_map_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.external_taxonomy_map
    ADD CONSTRAINT external_taxonomy_map_pkey PRIMARY KEY (external_id, external_system);


--
-- Name: finn_pamphlets finn_pamphlets_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.finn_pamphlets
    ADD CONSTRAINT finn_pamphlets_pkey PRIMARY KEY (pamphlet_id);


--
-- Name: freedom_metrics freedom_metrics_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.freedom_metrics
    ADD CONSTRAINT freedom_metrics_pkey PRIMARY KEY (metric_id);


--
-- Name: function_registry function_registry_function_schema_function_name_function_si_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.function_registry
    ADD CONSTRAINT function_registry_function_schema_function_name_function_si_key UNIQUE (function_schema, function_name, function_signature);


--
-- Name: function_registry function_registry_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.function_registry
    ADD CONSTRAINT function_registry_pkey PRIMARY KEY (registry_id);


--
-- Name: g1_activation_registry g1_activation_registry_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.g1_activation_registry
    ADD CONSTRAINT g1_activation_registry_pkey PRIMARY KEY (activation_id);


--
-- Name: g1_alpha_evidence g1_alpha_evidence_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.g1_alpha_evidence
    ADD CONSTRAINT g1_alpha_evidence_pkey PRIMARY KEY (evidence_id);


--
-- Name: g1_evidence_accumulation g1_evidence_accumulation_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.g1_evidence_accumulation
    ADD CONSTRAINT g1_evidence_accumulation_pkey PRIMARY KEY (accumulation_id);


--
-- Name: g1_evidence_daily_snapshot g1_evidence_daily_snapshot_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.g1_evidence_daily_snapshot
    ADD CONSTRAINT g1_evidence_daily_snapshot_pkey PRIMARY KEY (snapshot_id);


--
-- Name: g1_evidence_daily_snapshot g1_evidence_daily_snapshot_snapshot_date_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.g1_evidence_daily_snapshot
    ADD CONSTRAINT g1_evidence_daily_snapshot_snapshot_date_key UNIQUE (snapshot_date);


--
-- Name: g1_qualification_thresholds g1_qualification_thresholds_domain_metric_name_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.g1_qualification_thresholds
    ADD CONSTRAINT g1_qualification_thresholds_domain_metric_name_key UNIQUE (domain, metric_name);


--
-- Name: g1_qualification_thresholds g1_qualification_thresholds_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.g1_qualification_thresholds
    ADD CONSTRAINT g1_qualification_thresholds_pkey PRIMARY KEY (threshold_id);


--
-- Name: gate_registry gate_registry_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.gate_registry
    ADD CONSTRAINT gate_registry_pkey PRIMARY KEY (gate_id);


--
-- Name: golden_samples golden_samples_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.golden_samples
    ADD CONSTRAINT golden_samples_pkey PRIMARY KEY (sample_id);


--
-- Name: hallucination_rejection_events hallucination_rejection_events_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.hallucination_rejection_events
    ADD CONSTRAINT hallucination_rejection_events_pkey PRIMARY KEY (event_id);


--
-- Name: identity_state_snapshots identity_state_snapshots_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.identity_state_snapshots
    ADD CONSTRAINT identity_state_snapshots_pkey PRIMARY KEY (snapshot_id);


--
-- Name: indicator_definitions indicator_definitions_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.indicator_definitions
    ADD CONSTRAINT indicator_definitions_pkey PRIMARY KEY (indicator_id);


--
-- Name: indicator_registry indicator_registry_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.indicator_registry
    ADD CONSTRAINT indicator_registry_pkey PRIMARY KEY (calc_method_id);


--
-- Name: input_contracts input_contracts_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.input_contracts
    ADD CONSTRAINT input_contracts_pkey PRIMARY KEY (contract_id);


--
-- Name: ios_appendix_registry ios_appendix_registry_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.ios_appendix_registry
    ADD CONSTRAINT ios_appendix_registry_pkey PRIMARY KEY (appendix_id);


--
-- Name: ios_appendix_registry ios_appendix_unique; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.ios_appendix_registry
    ADD CONSTRAINT ios_appendix_unique UNIQUE (ios_id, appendix_code);


--
-- Name: ios_audit_log ios_audit_log_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.ios_audit_log
    ADD CONSTRAINT ios_audit_log_pkey PRIMARY KEY (audit_id);


--
-- Name: ios_registry ios_registry_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.ios_registry
    ADD CONSTRAINT ios_registry_pkey PRIMARY KEY (ios_id);


--
-- Name: ios_version_history ios_version_history_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.ios_version_history
    ADD CONSTRAINT ios_version_history_pkey PRIMARY KEY (history_id);


--
-- Name: key_archival_log key_archival_log_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.key_archival_log
    ADD CONSTRAINT key_archival_log_pkey PRIMARY KEY (archival_id);


--
-- Name: key_ceremonies key_ceremonies_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.key_ceremonies
    ADD CONSTRAINT key_ceremonies_pkey PRIMARY KEY (ceremony_id);


--
-- Name: knowledge_boundary_log knowledge_boundary_log_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.knowledge_boundary_log
    ADD CONSTRAINT knowledge_boundary_log_pkey PRIMARY KEY (boundary_id);


--
-- Name: learning_state_artifacts learning_state_artifacts_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.learning_state_artifacts
    ADD CONSTRAINT learning_state_artifacts_pkey PRIMARY KEY (lsa_id);


--
-- Name: listings listings_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.listings
    ADD CONSTRAINT listings_pkey PRIMARY KEY (listing_id);


--
-- Name: listings listings_yahoo_symbol_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.listings
    ADD CONSTRAINT listings_yahoo_symbol_key UNIQUE (yahoo_symbol);


--
-- Name: llm_provider_config llm_provider_config_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.llm_provider_config
    ADD CONSTRAINT llm_provider_config_pkey PRIMARY KEY (config_id);


--
-- Name: learning_state_artifacts lsa_unique_batch; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.learning_state_artifacts
    ADD CONSTRAINT lsa_unique_batch UNIQUE (batch_id);


--
-- Name: market_requirements market_requirements_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.market_requirements
    ADD CONSTRAINT market_requirements_pkey PRIMARY KEY (requirement_id);


--
-- Name: model_certifications model_certifications_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.model_certifications
    ADD CONSTRAINT model_certifications_pkey PRIMARY KEY (certification_id);


--
-- Name: model_configurations model_configurations_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.model_configurations
    ADD CONSTRAINT model_configurations_pkey PRIMARY KEY (config_id);


--
-- Name: model_context_registry model_context_registry_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.model_context_registry
    ADD CONSTRAINT model_context_registry_pkey PRIMARY KEY (context_id);


--
-- Name: model_registry model_registry_model_id_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.model_registry
    ADD CONSTRAINT model_registry_model_id_key UNIQUE (model_id);


--
-- Name: model_registry model_registry_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.model_registry
    ADD CONSTRAINT model_registry_pkey PRIMARY KEY (registry_id);


--
-- Name: narrative_vectors narrative_vectors_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.narrative_vectors
    ADD CONSTRAINT narrative_vectors_pkey PRIMARY KEY (vector_id);


--
-- Name: agent_keys one_active_key_per_agent; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.agent_keys
    ADD CONSTRAINT one_active_key_per_agent UNIQUE (agent_id, key_state) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: price_class_ontology price_class_ontology_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.price_class_ontology
    ADD CONSTRAINT price_class_ontology_pkey PRIMARY KEY (price_class_id);


--
-- Name: rate_limit_policy rate_limit_policy_group_name_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.rate_limit_policy
    ADD CONSTRAINT rate_limit_policy_group_name_key UNIQUE (group_name);


--
-- Name: rate_limit_policy rate_limit_policy_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.rate_limit_policy
    ADD CONSTRAINT rate_limit_policy_pkey PRIMARY KEY (policy_id);


--
-- Name: reconciliation_evidence reconciliation_evidence_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.reconciliation_evidence
    ADD CONSTRAINT reconciliation_evidence_pkey PRIMARY KEY (evidence_id);


--
-- Name: reconciliation_field_weights reconciliation_field_weights_component_name_field_name_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.reconciliation_field_weights
    ADD CONSTRAINT reconciliation_field_weights_component_name_field_name_key UNIQUE (component_name, field_name);


--
-- Name: reconciliation_field_weights reconciliation_field_weights_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.reconciliation_field_weights
    ADD CONSTRAINT reconciliation_field_weights_pkey PRIMARY KEY (weight_id);


--
-- Name: reconciliation_snapshots reconciliation_snapshots_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.reconciliation_snapshots
    ADD CONSTRAINT reconciliation_snapshots_pkey PRIMARY KEY (snapshot_id);


--
-- Name: regime_state regime_state_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.regime_state
    ADD CONSTRAINT regime_state_pkey PRIMARY KEY (state_id);


--
-- Name: regime_weight_config regime_weight_config_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.regime_weight_config
    ADD CONSTRAINT regime_weight_config_pkey PRIMARY KEY (config_id);


--
-- Name: search_foraging_log search_foraging_log_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.search_foraging_log
    ADD CONSTRAINT search_foraging_log_pkey PRIMARY KEY (forage_id);


--
-- Name: g1_evidence_accumulation single_active_eam; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.g1_evidence_accumulation
    ADD CONSTRAINT single_active_eam UNIQUE (eam_status) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: sleep_cycle_runs sleep_cycle_runs_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.sleep_cycle_runs
    ADD CONSTRAINT sleep_cycle_runs_pkey PRIMARY KEY (cycle_id);


--
-- Name: stig_allowed_operations stig_allowed_operations_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.stig_allowed_operations
    ADD CONSTRAINT stig_allowed_operations_pkey PRIMARY KEY (operation_type);


--
-- Name: strategies strategies_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.strategies
    ADD CONSTRAINT strategies_pkey PRIMARY KEY (id);


--
-- Name: strategy_families strategy_families_family_name_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.strategy_families
    ADD CONSTRAINT strategy_families_family_name_key UNIQUE (family_name);


--
-- Name: strategy_families strategy_families_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.strategy_families
    ADD CONSTRAINT strategy_families_pkey PRIMARY KEY (family_id);


--
-- Name: strategy_family_members strategy_family_members_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.strategy_family_members
    ADD CONSTRAINT strategy_family_members_pkey PRIMARY KEY (membership_id);


--
-- Name: strategy_registry strategy_registry_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.strategy_registry
    ADD CONSTRAINT strategy_registry_pkey PRIMARY KEY (id);


--
-- Name: strategy_registry strategy_registry_strategy_code_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.strategy_registry
    ADD CONSTRAINT strategy_registry_strategy_code_key UNIQUE (strategy_code);


--
-- Name: system_documents system_documents_document_code_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.system_documents
    ADD CONSTRAINT system_documents_document_code_key UNIQUE (document_code);


--
-- Name: system_documents system_documents_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.system_documents
    ADD CONSTRAINT system_documents_pkey PRIMARY KEY (document_id);


--
-- Name: tickers tickers_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.tickers
    ADD CONSTRAINT tickers_pkey PRIMARY KEY (ticker);


--
-- Name: tickers tickers_yahoo_symbol_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.tickers
    ADD CONSTRAINT tickers_yahoo_symbol_key UNIQUE (yahoo_symbol);


--
-- Name: tool_usage_log tool_usage_log_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.tool_usage_log
    ADD CONSTRAINT tool_usage_log_pkey PRIMARY KEY (usage_id);


--
-- Name: dynamic_regime_weights unique_calibration_asset_state; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.dynamic_regime_weights
    ADD CONSTRAINT unique_calibration_asset_state UNIQUE (calibration_id, asset_id, state_id);


--
-- Name: sleep_cycle_runs unique_cycle_date; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.sleep_cycle_runs
    ADD CONSTRAINT unique_cycle_date UNIQUE (cycle_date, cycle_type);


--
-- Name: freedom_metrics unique_metric_date; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.freedom_metrics
    ADD CONSTRAINT unique_metric_date UNIQUE (metric_date);


--
-- Name: llm_provider_config unique_use_case; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.llm_provider_config
    ADD CONSTRAINT unique_use_case UNIQUE (use_case, model_type);


--
-- Name: vega_identity unique_vega_identity; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vega_identity
    ADD CONSTRAINT unique_vega_identity UNIQUE (agent_name);


--
-- Name: vendor_usage_counters unique_vendor_interval; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vendor_usage_counters
    ADD CONSTRAINT unique_vendor_interval UNIQUE (vendor_id, interval_start, interval_type);


--
-- Name: dynamic_regime_weights_audit unique_weight_calibration; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.dynamic_regime_weights_audit
    ADD CONSTRAINT unique_weight_calibration UNIQUE (listing_id, regime_state, calibration_date, model_id);


--
-- Name: regime_weight_config uq_regime_family; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.regime_weight_config
    ADD CONSTRAINT uq_regime_family UNIQUE (regime_label, family_id);


--
-- Name: strategy_family_members uq_strategy_family; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.strategy_family_members
    ADD CONSTRAINT uq_strategy_family UNIQUE (strategy_id, family_id);


--
-- Name: vega_attestations vega_attestations_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vega_attestations
    ADD CONSTRAINT vega_attestations_pkey PRIMARY KEY (attestation_id);


--
-- Name: vega_constitutional_duties vega_constitutional_duties_duty_code_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vega_constitutional_duties
    ADD CONSTRAINT vega_constitutional_duties_duty_code_key UNIQUE (duty_code);


--
-- Name: vega_constitutional_duties vega_constitutional_duties_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vega_constitutional_duties
    ADD CONSTRAINT vega_constitutional_duties_pkey PRIMARY KEY (duty_id);


--
-- Name: vega_constraints vega_constraints_constraint_code_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vega_constraints
    ADD CONSTRAINT vega_constraints_constraint_code_key UNIQUE (constraint_code);


--
-- Name: vega_constraints vega_constraints_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vega_constraints
    ADD CONSTRAINT vega_constraints_pkey PRIMARY KEY (constraint_id);


--
-- Name: vega_employment_contract vega_employment_contract_contract_number_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vega_employment_contract
    ADD CONSTRAINT vega_employment_contract_contract_number_key UNIQUE (contract_number);


--
-- Name: vega_employment_contract vega_employment_contract_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vega_employment_contract
    ADD CONSTRAINT vega_employment_contract_pkey PRIMARY KEY (contract_id);


--
-- Name: vega_identity vega_identity_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vega_identity
    ADD CONSTRAINT vega_identity_pkey PRIMARY KEY (identity_id);


--
-- Name: vega_rights vega_rights_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vega_rights
    ADD CONSTRAINT vega_rights_pkey PRIMARY KEY (right_id);


--
-- Name: vega_rights vega_rights_right_code_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vega_rights
    ADD CONSTRAINT vega_rights_right_code_key UNIQUE (right_code);


--
-- Name: vega_sovereignty_log vega_sovereignty_log_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vega_sovereignty_log
    ADD CONSTRAINT vega_sovereignty_log_pkey PRIMARY KEY (sovereignty_id);


--
-- Name: vendor_limits vendor_limits_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vendor_limits
    ADD CONSTRAINT vendor_limits_pkey PRIMARY KEY (vendor_id);


--
-- Name: vendor_limits vendor_limits_vendor_name_key; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vendor_limits
    ADD CONSTRAINT vendor_limits_vendor_name_key UNIQUE (vendor_name);


--
-- Name: vendor_role_definitions vendor_role_definitions_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vendor_role_definitions
    ADD CONSTRAINT vendor_role_definitions_pkey PRIMARY KEY (role_id);


--
-- Name: vendor_usage_counters vendor_usage_counters_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vendor_usage_counters
    ADD CONSTRAINT vendor_usage_counters_pkey PRIMARY KEY (counter_id);


--
-- Name: vendors vendors_pkey; Type: CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vendors
    ADD CONSTRAINT vendors_pkey PRIMARY KEY (vendor_id);


--
-- Name: function_registry function_registry_function_name_key; Type: CONSTRAINT; Schema: fhq_org; Owner: -
--

ALTER TABLE ONLY fhq_org.function_registry
    ADD CONSTRAINT function_registry_function_name_key UNIQUE (function_name);


--
-- Name: function_registry function_registry_pkey; Type: CONSTRAINT; Schema: fhq_org; Owner: -
--

ALTER TABLE ONLY fhq_org.function_registry
    ADD CONSTRAINT function_registry_pkey PRIMARY KEY (function_id);


--
-- Name: org_activity_log org_activity_log_idempotency_key_key; Type: CONSTRAINT; Schema: fhq_org; Owner: -
--

ALTER TABLE ONLY fhq_org.org_activity_log
    ADD CONSTRAINT org_activity_log_idempotency_key_key UNIQUE (idempotency_key);


--
-- Name: org_activity_log org_activity_log_pkey; Type: CONSTRAINT; Schema: fhq_org; Owner: -
--

ALTER TABLE ONLY fhq_org.org_activity_log
    ADD CONSTRAINT org_activity_log_pkey PRIMARY KEY (event_id);


--
-- Name: org_agents org_agents_agent_name_key; Type: CONSTRAINT; Schema: fhq_org; Owner: -
--

ALTER TABLE ONLY fhq_org.org_agents
    ADD CONSTRAINT org_agents_agent_name_key UNIQUE (agent_name);


--
-- Name: org_agents org_agents_pkey; Type: CONSTRAINT; Schema: fhq_org; Owner: -
--

ALTER TABLE ONLY fhq_org.org_agents
    ADD CONSTRAINT org_agents_pkey PRIMARY KEY (agent_id);


--
-- Name: org_memory org_memory_pkey; Type: CONSTRAINT; Schema: fhq_org; Owner: -
--

ALTER TABLE ONLY fhq_org.org_memory
    ADD CONSTRAINT org_memory_pkey PRIMARY KEY (memory_id);


--
-- Name: org_state_reconciliation org_state_reconciliation_pkey; Type: CONSTRAINT; Schema: fhq_org; Owner: -
--

ALTER TABLE ONLY fhq_org.org_state_reconciliation
    ADD CONSTRAINT org_state_reconciliation_pkey PRIMARY KEY (snapshot_id);


--
-- Name: org_tasks org_tasks_idempotency_key_key; Type: CONSTRAINT; Schema: fhq_org; Owner: -
--

ALTER TABLE ONLY fhq_org.org_tasks
    ADD CONSTRAINT org_tasks_idempotency_key_key UNIQUE (idempotency_key);


--
-- Name: org_tasks org_tasks_pkey; Type: CONSTRAINT; Schema: fhq_org; Owner: -
--

ALTER TABLE ONLY fhq_org.org_tasks
    ADD CONSTRAINT org_tasks_pkey PRIMARY KEY (task_id);


--
-- Name: hash_chains hash_chains_pkey; Type: CONSTRAINT; Schema: fhq_security; Owner: -
--

ALTER TABLE ONLY fhq_security.hash_chains
    ADD CONSTRAINT hash_chains_pkey PRIMARY KEY (chain_id);


--
-- Name: key_deployment_log key_deployment_log_pkey; Type: CONSTRAINT; Schema: fhq_security; Owner: -
--

ALTER TABLE ONLY fhq_security.key_deployment_log
    ADD CONSTRAINT key_deployment_log_pkey PRIMARY KEY (deployment_id);


--
-- Name: key_rotation_policy key_rotation_policy_agent_id_key; Type: CONSTRAINT; Schema: fhq_security; Owner: -
--

ALTER TABLE ONLY fhq_security.key_rotation_policy
    ADD CONSTRAINT key_rotation_policy_agent_id_key UNIQUE (agent_id);


--
-- Name: key_rotation_policy key_rotation_policy_pkey; Type: CONSTRAINT; Schema: fhq_security; Owner: -
--

ALTER TABLE ONLY fhq_security.key_rotation_policy
    ADD CONSTRAINT key_rotation_policy_pkey PRIMARY KEY (policy_id);


--
-- Name: keystore keystore_pkey; Type: CONSTRAINT; Schema: fhq_security; Owner: -
--

ALTER TABLE ONLY fhq_security.keystore
    ADD CONSTRAINT keystore_pkey PRIMARY KEY (keystore_id);


--
-- Name: action_level_veto action_level_veto_pkey; Type: CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.action_level_veto
    ADD CONSTRAINT action_level_veto_pkey PRIMARY KEY (veto_id);


--
-- Name: agent_test_execution agent_test_execution_pkey; Type: CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.agent_test_execution
    ADD CONSTRAINT agent_test_execution_pkey PRIMARY KEY (execution_id);


--
-- Name: api_endpoint_tests api_endpoint_tests_pkey; Type: CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.api_endpoint_tests
    ADD CONSTRAINT api_endpoint_tests_pkey PRIMARY KEY (test_id);


--
-- Name: llm_cost_limits llm_cost_limits_agent_provider_unique; Type: CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.llm_cost_limits
    ADD CONSTRAINT llm_cost_limits_agent_provider_unique UNIQUE (agent_id, provider);


--
-- Name: llm_cost_limits llm_cost_limits_pkey; Type: CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.llm_cost_limits
    ADD CONSTRAINT llm_cost_limits_pkey PRIMARY KEY (cost_limit_id);


--
-- Name: llm_economic_safety_config llm_economic_safety_config_config_name_key; Type: CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.llm_economic_safety_config
    ADD CONSTRAINT llm_economic_safety_config_config_name_key UNIQUE (config_name);


--
-- Name: llm_economic_safety_config llm_economic_safety_config_pkey; Type: CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.llm_economic_safety_config
    ADD CONSTRAINT llm_economic_safety_config_pkey PRIMARY KEY (config_id);


--
-- Name: llm_execution_limits llm_execution_limits_agent_provider_unique; Type: CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.llm_execution_limits
    ADD CONSTRAINT llm_execution_limits_agent_provider_unique UNIQUE (agent_id, provider);


--
-- Name: llm_execution_limits llm_execution_limits_pkey; Type: CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.llm_execution_limits
    ADD CONSTRAINT llm_execution_limits_pkey PRIMARY KEY (execution_limit_id);


--
-- Name: llm_rate_limits llm_rate_limits_agent_provider_unique; Type: CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.llm_rate_limits
    ADD CONSTRAINT llm_rate_limits_agent_provider_unique UNIQUE (agent_id, provider);


--
-- Name: llm_rate_limits llm_rate_limits_pkey; Type: CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.llm_rate_limits
    ADD CONSTRAINT llm_rate_limits_pkey PRIMARY KEY (rate_limit_id);


--
-- Name: llm_usage_log llm_usage_log_pkey; Type: CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.llm_usage_log
    ADD CONSTRAINT llm_usage_log_pkey PRIMARY KEY (usage_id);


--
-- Name: llm_violation_events llm_violation_events_pkey; Type: CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.llm_violation_events
    ADD CONSTRAINT llm_violation_events_pkey PRIMARY KEY (violation_id);


--
-- Name: quality_gate_results quality_gate_results_pkey; Type: CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.quality_gate_results
    ADD CONSTRAINT quality_gate_results_pkey PRIMARY KEY (gate_id);


--
-- Name: test_coverage test_coverage_pkey; Type: CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.test_coverage
    ADD CONSTRAINT test_coverage_pkey PRIMARY KEY (coverage_id);


--
-- Name: test_failures test_failures_pkey; Type: CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.test_failures
    ADD CONSTRAINT test_failures_pkey PRIMARY KEY (failure_id);


--
-- Name: test_runs test_runs_pkey; Type: CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.test_runs
    ADD CONSTRAINT test_runs_pkey PRIMARY KEY (run_id);


--
-- Name: governance_decisions governance_decisions_pkey; Type: CONSTRAINT; Schema: vision_autonomy; Owner: -
--

ALTER TABLE ONLY vision_autonomy.governance_decisions
    ADD CONSTRAINT governance_decisions_pkey PRIMARY KEY (decision_id);


--
-- Name: meta_state_sync meta_state_sync_pkey; Type: CONSTRAINT; Schema: vision_autonomy; Owner: -
--

ALTER TABLE ONLY vision_autonomy.meta_state_sync
    ADD CONSTRAINT meta_state_sync_pkey PRIMARY KEY (sync_id);


--
-- Name: cinematic_events cinematic_events_pkey; Type: CONSTRAINT; Schema: vision_cinematic; Owner: -
--

ALTER TABLE ONLY vision_cinematic.cinematic_events
    ADD CONSTRAINT cinematic_events_pkey PRIMARY KEY (event_id);


--
-- Name: defcon_visual_rules defcon_visual_rules_defcon_level_key; Type: CONSTRAINT; Schema: vision_cinematic; Owner: -
--

ALTER TABLE ONLY vision_cinematic.defcon_visual_rules
    ADD CONSTRAINT defcon_visual_rules_defcon_level_key UNIQUE (defcon_level);


--
-- Name: defcon_visual_rules defcon_visual_rules_pkey; Type: CONSTRAINT; Schema: vision_cinematic; Owner: -
--

ALTER TABLE ONLY vision_cinematic.defcon_visual_rules
    ADD CONSTRAINT defcon_visual_rules_pkey PRIMARY KEY (rule_id);


--
-- Name: mapping_versions mapping_versions_pkey; Type: CONSTRAINT; Schema: vision_cinematic; Owner: -
--

ALTER TABLE ONLY vision_cinematic.mapping_versions
    ADD CONSTRAINT mapping_versions_pkey PRIMARY KEY (version_id);


--
-- Name: mapping_versions mapping_versions_version_tag_key; Type: CONSTRAINT; Schema: vision_cinematic; Owner: -
--

ALTER TABLE ONLY vision_cinematic.mapping_versions
    ADD CONSTRAINT mapping_versions_version_tag_key UNIQUE (version_tag);


--
-- Name: render_evidence render_evidence_pkey; Type: CONSTRAINT; Schema: vision_cinematic; Owner: -
--

ALTER TABLE ONLY vision_cinematic.render_evidence
    ADD CONSTRAINT render_evidence_pkey PRIMARY KEY (evidence_id);


--
-- Name: visual_state_vectors visual_state_vectors_pkey; Type: CONSTRAINT; Schema: vision_cinematic; Owner: -
--

ALTER TABLE ONLY vision_cinematic.visual_state_vectors
    ADD CONSTRAINT visual_state_vectors_pkey PRIMARY KEY (vsv_id);


--
-- Name: visual_state_vectors vsv_asset_timestamp_unique; Type: CONSTRAINT; Schema: vision_cinematic; Owner: -
--

ALTER TABLE ONLY vision_cinematic.visual_state_vectors
    ADD CONSTRAINT vsv_asset_timestamp_unique UNIQUE (asset_id, "timestamp");


--
-- Name: economic_safety_gate economic_safety_gate_gate_name_key; Type: CONSTRAINT; Schema: vision_core; Owner: -
--

ALTER TABLE ONLY vision_core.economic_safety_gate
    ADD CONSTRAINT economic_safety_gate_gate_name_key UNIQUE (gate_name);


--
-- Name: economic_safety_gate economic_safety_gate_pkey; Type: CONSTRAINT; Schema: vision_core; Owner: -
--

ALTER TABLE ONLY vision_core.economic_safety_gate
    ADD CONSTRAINT economic_safety_gate_pkey PRIMARY KEY (gate_id);


--
-- Name: execution_state execution_state_pkey; Type: CONSTRAINT; Schema: vision_core; Owner: -
--

ALTER TABLE ONLY vision_core.execution_state
    ADD CONSTRAINT execution_state_pkey PRIMARY KEY (state_id);


--
-- Name: live_mode_activations live_mode_activations_pkey; Type: CONSTRAINT; Schema: vision_core; Owner: -
--

ALTER TABLE ONLY vision_core.live_mode_activations
    ADD CONSTRAINT live_mode_activations_pkey PRIMARY KEY (activation_id);


--
-- Name: live_mode_authorizations live_mode_authorizations_pkey; Type: CONSTRAINT; Schema: vision_core; Owner: -
--

ALTER TABLE ONLY vision_core.live_mode_authorizations
    ADD CONSTRAINT live_mode_authorizations_pkey PRIMARY KEY (authorization_id);


--
-- Name: live_mode_proposals live_mode_proposals_pkey; Type: CONSTRAINT; Schema: vision_core; Owner: -
--

ALTER TABLE ONLY vision_core.live_mode_proposals
    ADD CONSTRAINT live_mode_proposals_pkey PRIMARY KEY (proposal_id);


--
-- Name: live_mode_reviews live_mode_reviews_pkey; Type: CONSTRAINT; Schema: vision_core; Owner: -
--

ALTER TABLE ONLY vision_core.live_mode_reviews
    ADD CONSTRAINT live_mode_reviews_pkey PRIMARY KEY (review_id);


--
-- Name: noise_profile noise_profile_pkey; Type: CONSTRAINT; Schema: vision_core; Owner: -
--

ALTER TABLE ONLY vision_core.noise_profile
    ADD CONSTRAINT noise_profile_pkey PRIMARY KEY (profile_id);


--
-- Name: aci_execution_state aci_execution_state_pkey; Type: CONSTRAINT; Schema: vision_signals; Owner: -
--

ALTER TABLE ONLY vision_signals.aci_execution_state
    ADD CONSTRAINT aci_execution_state_pkey PRIMARY KEY (state_id);


--
-- Name: aci_rehydration_status aci_rehydration_status_pkey; Type: CONSTRAINT; Schema: vision_signals; Owner: -
--

ALTER TABLE ONLY vision_signals.aci_rehydration_status
    ADD CONSTRAINT aci_rehydration_status_pkey PRIMARY KEY (status_id);


--
-- Name: alpha_graph_edges alpha_graph_edges_pkey; Type: CONSTRAINT; Schema: vision_signals; Owner: -
--

ALTER TABLE ONLY vision_signals.alpha_graph_edges
    ADD CONSTRAINT alpha_graph_edges_pkey PRIMARY KEY (edge_id);


--
-- Name: alpha_graph_edges alpha_graph_edges_source_target_unique; Type: CONSTRAINT; Schema: vision_signals; Owner: -
--

ALTER TABLE ONLY vision_signals.alpha_graph_edges
    ADD CONSTRAINT alpha_graph_edges_source_target_unique UNIQUE (source_node, target_node);


--
-- Name: alpha_graph_nodes alpha_graph_nodes_pkey; Type: CONSTRAINT; Schema: vision_signals; Owner: -
--

ALTER TABLE ONLY vision_signals.alpha_graph_nodes
    ADD CONSTRAINT alpha_graph_nodes_pkey PRIMARY KEY (node_id);


--
-- Name: alpha_signals alpha_signals_pkey; Type: CONSTRAINT; Schema: vision_signals; Owner: -
--

ALTER TABLE ONLY vision_signals.alpha_signals
    ADD CONSTRAINT alpha_signals_pkey PRIMARY KEY (signal_id);


--
-- Name: ceio_cycle_state ceio_cycle_state_pkey; Type: CONSTRAINT; Schema: vision_signals; Owner: -
--

ALTER TABLE ONLY vision_signals.ceio_cycle_state
    ADD CONSTRAINT ceio_cycle_state_pkey PRIMARY KEY (cycle_id);


--
-- Name: decision_surface_state decision_surface_state_pkey; Type: CONSTRAINT; Schema: vision_signals; Owner: -
--

ALTER TABLE ONLY vision_signals.decision_surface_state
    ADD CONSTRAINT decision_surface_state_pkey PRIMARY KEY (surface_id);


--
-- Name: regime_engine_state regime_engine_state_pkey; Type: CONSTRAINT; Schema: vision_signals; Owner: -
--

ALTER TABLE ONLY vision_signals.regime_engine_state
    ADD CONSTRAINT regime_engine_state_pkey PRIMARY KEY (engine_id);


--
-- Name: regime_inference_packs regime_inference_packs_pkey; Type: CONSTRAINT; Schema: vision_signals; Owner: -
--

ALTER TABLE ONLY vision_signals.regime_inference_packs
    ADD CONSTRAINT regime_inference_packs_pkey PRIMARY KEY (pack_id);


--
-- Name: regime_position_rules regime_position_rules_asset_id_regime_label_key; Type: CONSTRAINT; Schema: vision_signals; Owner: -
--

ALTER TABLE ONLY vision_signals.regime_position_rules
    ADD CONSTRAINT regime_position_rules_asset_id_regime_label_key UNIQUE (asset_id, regime_label);


--
-- Name: regime_position_rules regime_position_rules_pkey; Type: CONSTRAINT; Schema: vision_signals; Owner: -
--

ALTER TABLE ONLY vision_signals.regime_position_rules
    ADD CONSTRAINT regime_position_rules_pkey PRIMARY KEY (rule_id);


--
-- Name: safety_validations safety_validations_pkey; Type: CONSTRAINT; Schema: vision_signals; Owner: -
--

ALTER TABLE ONLY vision_signals.safety_validations
    ADD CONSTRAINT safety_validations_pkey PRIMARY KEY (validation_id);


--
-- Name: shadow_ledger_snapshots shadow_ledger_snapshots_pkey; Type: CONSTRAINT; Schema: vision_signals; Owner: -
--

ALTER TABLE ONLY vision_signals.shadow_ledger_snapshots
    ADD CONSTRAINT shadow_ledger_snapshots_pkey PRIMARY KEY (snapshot_id);


--
-- Name: signal_baseline signal_baseline_pkey; Type: CONSTRAINT; Schema: vision_signals; Owner: -
--

ALTER TABLE ONLY vision_signals.signal_baseline
    ADD CONSTRAINT signal_baseline_pkey PRIMARY KEY (baseline_id);


--
-- Name: state_snapshots state_snapshots_pkey; Type: CONSTRAINT; Schema: vision_signals; Owner: -
--

ALTER TABLE ONLY vision_signals.state_snapshots
    ADD CONSTRAINT state_snapshots_pkey PRIMARY KEY (snapshot_id);


--
-- Name: strategy_state strategy_state_pkey; Type: CONSTRAINT; Schema: vision_signals; Owner: -
--

ALTER TABLE ONLY vision_signals.strategy_state
    ADD CONSTRAINT strategy_state_pkey PRIMARY KEY (state_id);


--
-- Name: cognitive_engine_evidence cognitive_engine_evidence_pkey; Type: CONSTRAINT; Schema: vision_verification; Owner: -
--

ALTER TABLE ONLY vision_verification.cognitive_engine_evidence
    ADD CONSTRAINT cognitive_engine_evidence_pkey PRIMARY KEY (id);


--
-- Name: dashboard_truth_attestation dashboard_truth_attestation_pkey; Type: CONSTRAINT; Schema: vision_verification; Owner: -
--

ALTER TABLE ONLY vision_verification.dashboard_truth_attestation
    ADD CONSTRAINT dashboard_truth_attestation_pkey PRIMARY KEY (attestation_id);


--
-- Name: deterministic_evidence_standard deterministic_evidence_standard_pkey; Type: CONSTRAINT; Schema: vision_verification; Owner: -
--

ALTER TABLE ONLY vision_verification.deterministic_evidence_standard
    ADD CONSTRAINT deterministic_evidence_standard_pkey PRIMARY KEY (standard_id);


--
-- Name: eqs_configuration eqs_configuration_config_key_key; Type: CONSTRAINT; Schema: vision_verification; Owner: -
--

ALTER TABLE ONLY vision_verification.eqs_configuration
    ADD CONSTRAINT eqs_configuration_config_key_key UNIQUE (config_key);


--
-- Name: eqs_configuration eqs_configuration_pkey; Type: CONSTRAINT; Schema: vision_verification; Owner: -
--

ALTER TABLE ONLY vision_verification.eqs_configuration
    ADD CONSTRAINT eqs_configuration_pkey PRIMARY KEY (id);


--
-- Name: eqs_v2_calculation_log eqs_v2_calculation_log_pkey; Type: CONSTRAINT; Schema: vision_verification; Owner: -
--

ALTER TABLE ONLY vision_verification.eqs_v2_calculation_log
    ADD CONSTRAINT eqs_v2_calculation_log_pkey PRIMARY KEY (log_id);


--
-- Name: eqs_v2_hard_stop_events eqs_v2_hard_stop_events_pkey; Type: CONSTRAINT; Schema: vision_verification; Owner: -
--

ALTER TABLE ONLY vision_verification.eqs_v2_hard_stop_events
    ADD CONSTRAINT eqs_v2_hard_stop_events_pkey PRIMARY KEY (event_id);


--
-- Name: eqs_v2_monitoring_snapshots eqs_v2_monitoring_snapshots_pkey; Type: CONSTRAINT; Schema: vision_verification; Owner: -
--

ALTER TABLE ONLY vision_verification.eqs_v2_monitoring_snapshots
    ADD CONSTRAINT eqs_v2_monitoring_snapshots_pkey PRIMARY KEY (id);


--
-- Name: evidence_break_glass_log evidence_break_glass_log_pkey; Type: CONSTRAINT; Schema: vision_verification; Owner: -
--

ALTER TABLE ONLY vision_verification.evidence_break_glass_log
    ADD CONSTRAINT evidence_break_glass_log_pkey PRIMARY KEY (break_glass_id);


--
-- Name: evidence_verification_log evidence_verification_log_pkey; Type: CONSTRAINT; Schema: vision_verification; Owner: -
--

ALTER TABLE ONLY vision_verification.evidence_verification_log
    ADD CONSTRAINT evidence_verification_log_pkey PRIMARY KEY (verification_id);


--
-- Name: hash_chains hash_chains_pkey; Type: CONSTRAINT; Schema: vision_verification; Owner: -
--

ALTER TABLE ONLY vision_verification.hash_chains
    ADD CONSTRAINT hash_chains_pkey PRIMARY KEY (chain_id);


--
-- Name: operation_signatures operation_signatures_pkey; Type: CONSTRAINT; Schema: vision_verification; Owner: -
--

ALTER TABLE ONLY vision_verification.operation_signatures
    ADD CONSTRAINT operation_signatures_pkey PRIMARY KEY (signature_id);


--
-- Name: regime_coverage_sentinel_log regime_coverage_sentinel_log_pkey; Type: CONSTRAINT; Schema: vision_verification; Owner: -
--

ALTER TABLE ONLY vision_verification.regime_coverage_sentinel_log
    ADD CONSTRAINT regime_coverage_sentinel_log_pkey PRIMARY KEY (id);


--
-- Name: summary_evidence_ledger summary_evidence_ledger_pkey; Type: CONSTRAINT; Schema: vision_verification; Owner: -
--

ALTER TABLE ONLY vision_verification.summary_evidence_ledger
    ADD CONSTRAINT summary_evidence_ledger_pkey PRIMARY KEY (evidence_id);


--
-- Name: idx_aci_shadow_evaluated_at; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_aci_shadow_evaluated_at ON fhq_canonical.aci_triangle_shadow_evaluations USING btree (evaluated_at DESC);


--
-- Name: idx_aci_shadow_ikea_flags; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_aci_shadow_ikea_flags ON fhq_canonical.aci_triangle_shadow_evaluations USING btree (ikea_flagged) WHERE (ikea_flagged = true);


--
-- Name: idx_aci_shadow_needle; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_aci_shadow_needle ON fhq_canonical.aci_shadow_evaluations USING btree (needle_id);


--
-- Name: idx_aci_shadow_sitc_failures; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_aci_shadow_sitc_failures ON fhq_canonical.aci_triangle_shadow_evaluations USING btree (sitc_chain_valid, sitc_failure_reason) WHERE (sitc_chain_valid = false);


--
-- Name: idx_aci_shadow_time; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_aci_shadow_time ON fhq_canonical.aci_shadow_evaluations USING btree (evaluated_at);


--
-- Name: idx_canonical_outcomes_exit_timestamp; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_canonical_outcomes_exit_timestamp ON fhq_canonical.canonical_outcomes USING btree (exit_timestamp DESC);


--
-- Name: idx_canonical_outcomes_needle; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_canonical_outcomes_needle ON fhq_canonical.canonical_outcomes USING btree (needle_id);


--
-- Name: idx_canonical_outcomes_symbol; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_canonical_outcomes_symbol ON fhq_canonical.canonical_outcomes USING btree (symbol);


--
-- Name: idx_eqs_regime_baseline_active; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_eqs_regime_baseline_active ON fhq_canonical.eqs_regime_baseline USING btree (target_asset, regime) WHERE (is_active = true);


--
-- Name: idx_eqs_snapshot_date; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_eqs_snapshot_date ON fhq_canonical.eqs_distribution_snapshots USING btree (snapshot_date DESC);


--
-- Name: idx_eqs_snapshot_unique; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE UNIQUE INDEX idx_eqs_snapshot_unique ON fhq_canonical.eqs_distribution_snapshots USING btree (snapshot_date, asset, regime, signal_state);


--
-- Name: idx_eqs_threshold_active_unique; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE UNIQUE INDEX idx_eqs_threshold_active_unique ON fhq_canonical.eqs_threshold_config USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_eqs_threshold_version; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_eqs_threshold_version ON fhq_canonical.eqs_threshold_config USING btree (version DESC);


--
-- Name: idx_evidence_bundles_created; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_evidence_bundles_created ON fhq_canonical.evidence_bundles USING btree (created_at DESC);


--
-- Name: idx_evidence_bundles_defcon; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_evidence_bundles_defcon ON fhq_canonical.evidence_bundles USING btree (defcon_level);


--
-- Name: idx_evidence_content_gin; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_evidence_content_gin ON fhq_canonical.evidence_nodes USING gin (content_tsvector);


--
-- Name: idx_evidence_domain; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_evidence_domain ON fhq_canonical.evidence_nodes USING btree (domain);


--
-- Name: idx_evidence_entity; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_evidence_entity ON fhq_canonical.evidence_nodes USING btree (entity_type, entity_id);


--
-- Name: idx_evidence_expires; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_evidence_expires ON fhq_canonical.evidence_nodes USING btree (expires_at) WHERE (expires_at IS NOT NULL);


--
-- Name: idx_evidence_nodes_content_hash; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE UNIQUE INDEX idx_evidence_nodes_content_hash ON fhq_canonical.evidence_nodes USING btree (content_hash);


--
-- Name: idx_evidence_nodes_retrieval_eligible; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_evidence_nodes_retrieval_eligible ON fhq_canonical.evidence_nodes USING btree (court_proof_verified, trusted, quarantined) WHERE ((court_proof_verified = true) AND (quarantined = false));


--
-- Name: idx_evidence_qdrant; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_evidence_qdrant ON fhq_canonical.evidence_nodes USING btree (qdrant_point_id);


--
-- Name: idx_evidence_rel_from; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_evidence_rel_from ON fhq_canonical.evidence_relationships USING btree (from_evidence_id);


--
-- Name: idx_evidence_rel_to; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_evidence_rel_to ON fhq_canonical.evidence_relationships USING btree (to_evidence_id);


--
-- Name: idx_evidence_rel_type; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_evidence_rel_type ON fhq_canonical.evidence_relationships USING btree (relationship_type);


--
-- Name: idx_evidence_temporal; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_evidence_temporal ON fhq_canonical.evidence_nodes USING btree (data_timestamp DESC);


--
-- Name: idx_evidence_verification; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_evidence_verification ON fhq_canonical.evidence_nodes USING btree (verification_status);


--
-- Name: idx_g4_1_density_needle; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_1_density_needle ON fhq_canonical.g4_1_density_results USING btree (needle_id);


--
-- Name: idx_g4_1_regime_needle; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_1_regime_needle ON fhq_canonical.g4_1_regime_rotation_results USING btree (needle_id);


--
-- Name: idx_g4_1_sensitivity_needle; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_1_sensitivity_needle ON fhq_canonical.g4_1_sensitivity_results USING btree (needle_id);


--
-- Name: idx_g4_1_stability_needle; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_1_stability_needle ON fhq_canonical.g4_1_stability_results USING btree (needle_id);


--
-- Name: idx_g4_1_stability_verdict; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_1_stability_verdict ON fhq_canonical.g4_1_stability_results USING btree (stability_verdict);


--
-- Name: idx_g4_1_verdict_assessment; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_1_verdict_assessment ON fhq_canonical.g4_1_composite_verdict USING btree (edge_assessment);


--
-- Name: idx_g4_1_verdict_g5; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_1_verdict_g5 ON fhq_canonical.g4_1_composite_verdict USING btree (g5_eligible) WHERE (g5_eligible = true);


--
-- Name: idx_g4_2_backtest_classification; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_2_backtest_classification ON fhq_canonical.g4_2_contextual_backtest USING btree (classification);


--
-- Name: idx_g4_2_backtest_needle; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_2_backtest_needle ON fhq_canonical.g4_2_contextual_backtest USING btree (needle_id);


--
-- Name: idx_g4_2_context_profiles_needle; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_2_context_profiles_needle ON fhq_canonical.g4_2_context_profiles USING btree (needle_id);


--
-- Name: idx_g4_2_context_profiles_status; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_2_context_profiles_status ON fhq_canonical.g4_2_context_profiles USING btree (status);


--
-- Name: idx_g4_2_suppression_action; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_2_suppression_action ON fhq_canonical.g4_2_suppression_log USING btree (action);


--
-- Name: idx_g4_2_suppression_needle; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_2_suppression_needle ON fhq_canonical.g4_2_suppression_log USING btree (needle_id);


--
-- Name: idx_g4_2_suppression_ts; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_2_suppression_ts ON fhq_canonical.g4_2_suppression_log USING btree (signal_timestamp);


--
-- Name: idx_g4_2_verdict_classification; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_2_verdict_classification ON fhq_canonical.g4_2_composite_verdict USING btree (final_classification);


--
-- Name: idx_g4_2_verdict_g5; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_2_verdict_g5 ON fhq_canonical.g4_2_composite_verdict USING btree (g5_eligible);


--
-- Name: idx_g4_logic_category; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_logic_category ON fhq_canonical.g4_logic_translation_registry USING btree (hypothesis_category);


--
-- Name: idx_g4_physics_needle; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_physics_needle ON fhq_canonical.g4_physics_results USING btree (needle_id);


--
-- Name: idx_g4_physics_survivability; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_physics_survivability ON fhq_canonical.g4_physics_results USING btree (survivability);


--
-- Name: idx_g4_queue_status; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_queue_status ON fhq_canonical.g4_validation_queue USING btree (refinery_status, physics_status, priority, queued_at);


--
-- Name: idx_g4_refinery_cull; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_refinery_cull ON fhq_canonical.g4_refinery_results USING btree (cull_classification);


--
-- Name: idx_g4_refinery_needle; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_refinery_needle ON fhq_canonical.g4_refinery_results USING btree (needle_id);


--
-- Name: idx_g4_refinery_sharpe; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_refinery_sharpe ON fhq_canonical.g4_refinery_results USING btree (oos_sharpe_ratio DESC);


--
-- Name: idx_g4_scorecard_class; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_scorecard_class ON fhq_canonical.g4_composite_scorecard USING btree (classification);


--
-- Name: idx_g4_scorecard_g5; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g4_scorecard_g5 ON fhq_canonical.g4_composite_scorecard USING btree (eligible_for_g5) WHERE (eligible_for_g5 = true);


--
-- Name: idx_g5_cco_health_time; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g5_cco_health_time ON fhq_canonical.g5_cco_health_log USING btree (check_timestamp DESC);


--
-- Name: idx_g5_cco_state_active; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g5_cco_state_active ON fhq_canonical.g5_cco_state USING btree (is_active);


--
-- Name: idx_g5_paper_trades_entry; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g5_paper_trades_entry ON fhq_canonical.g5_paper_trades USING btree (entry_timestamp DESC);


--
-- Name: idx_g5_paper_trades_needle; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g5_paper_trades_needle ON fhq_canonical.g5_paper_trades USING btree (needle_id);


--
-- Name: idx_g5_paper_trades_outcome; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g5_paper_trades_outcome ON fhq_canonical.g5_paper_trades USING btree (trade_outcome);


--
-- Name: idx_g5_pipeline_batch; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g5_pipeline_batch ON fhq_canonical.g5_ingestion_pipeline USING btree (batch_timestamp DESC);


--
-- Name: idx_g5_pipeline_status; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g5_pipeline_status ON fhq_canonical.g5_ingestion_pipeline USING btree (pipeline_status);


--
-- Name: idx_g5_queue_context; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g5_queue_context ON fhq_canonical.g5_signal_priority_queue USING btree (context_window_id);


--
-- Name: idx_g5_queue_created; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g5_queue_created ON fhq_canonical.g5_signal_priority_queue USING btree (created_at DESC);


--
-- Name: idx_g5_queue_status; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g5_queue_status ON fhq_canonical.g5_signal_priority_queue USING btree (execution_status);


--
-- Name: idx_g5_signal_state_current; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g5_signal_state_current ON fhq_canonical.g5_signal_state USING btree (current_state);


--
-- Name: idx_g5_signal_state_needle; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g5_signal_state_needle ON fhq_canonical.g5_signal_state USING btree (needle_id);


--
-- Name: idx_g5_transitions_needle; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g5_transitions_needle ON fhq_canonical.g5_state_transitions USING btree (needle_id);


--
-- Name: idx_g5_transitions_time; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_g5_transitions_time ON fhq_canonical.g5_state_transitions USING btree (transitioned_at DESC);


--
-- Name: idx_golden_needles_asrp_hash; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_golden_needles_asrp_hash ON fhq_canonical.golden_needles USING btree (asrp_hash);


--
-- Name: idx_golden_needles_confluence; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_golden_needles_confluence ON fhq_canonical.golden_needles USING btree (confluence_factor_count DESC);


--
-- Name: idx_golden_needles_created; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_golden_needles_created ON fhq_canonical.golden_needles USING btree (created_at DESC);


--
-- Name: idx_golden_needles_current; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_golden_needles_current ON fhq_canonical.golden_needles USING btree (is_current) WHERE (is_current = true);


--
-- Name: idx_golden_needles_dedup_hash; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_golden_needles_dedup_hash ON fhq_canonical.golden_needles USING btree (dedup_hash);


--
-- Name: idx_golden_needles_eqs; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_golden_needles_eqs ON fhq_canonical.golden_needles USING btree (eqs_score DESC);


--
-- Name: idx_golden_needles_hunt_session; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_golden_needles_hunt_session ON fhq_canonical.golden_needles USING btree (hunt_session_id);


--
-- Name: idx_golden_needles_regime; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_golden_needles_regime ON fhq_canonical.golden_needles USING btree (regime_sovereign, regime_technical);


--
-- Name: idx_golden_needles_sitc_plan; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_golden_needles_sitc_plan ON fhq_canonical.golden_needles USING btree (sitc_plan_id);


--
-- Name: idx_golden_needles_witness; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_golden_needles_witness ON fhq_canonical.golden_needles USING btree (price_witness_id);


--
-- Name: idx_needle_chain_links_needle; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_needle_chain_links_needle ON fhq_canonical.needle_chain_links USING btree (needle_id);


--
-- Name: idx_needle_chain_links_node; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_needle_chain_links_node ON fhq_canonical.needle_chain_links USING btree (chain_node_id);


--
-- Name: idx_ontology_parent; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_ontology_parent ON fhq_canonical.financial_ontology USING btree (parent_concept_id);


--
-- Name: idx_ontology_path; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_ontology_path ON fhq_canonical.financial_ontology USING btree (path_from_root);


--
-- Name: idx_pipeline_events_time; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_pipeline_events_time ON fhq_canonical.g5_pipeline_events USING btree (created_at DESC);


--
-- Name: idx_pipeline_events_type; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_pipeline_events_type ON fhq_canonical.g5_pipeline_events USING btree (event_type);


--
-- Name: idx_promotion_ledger_needle; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_promotion_ledger_needle ON fhq_canonical.g5_promotion_ledger USING btree (needle_id);


--
-- Name: idx_promotion_ledger_status; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_promotion_ledger_status ON fhq_canonical.g5_promotion_ledger USING btree (current_status);


--
-- Name: idx_rate_log_hour; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_rate_log_hour ON fhq_canonical.g5_promotion_rate_log USING btree (hour_bucket);


--
-- Name: idx_signal_state_ephemeral; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_signal_state_ephemeral ON fhq_canonical.g5_signal_state USING btree (ephemeral_expires_at) WHERE (is_ephemeral_promotion = true);


--
-- Name: idx_ttl_extension_pending; Type: INDEX; Schema: fhq_canonical; Owner: -
--

CREATE INDEX idx_ttl_extension_pending ON fhq_canonical.g5_ttl_extension_requests USING btree (needle_id) WHERE (is_active = false);


--
-- Name: idx_ab_test_date; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_ab_test_date ON fhq_finn.ab_test_results USING btree (test_date DESC);


--
-- Name: idx_cds_structural_top; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_cds_structural_top ON fhq_finn.cognitive_dissonance_scores USING btree (structural_top_risk, analysis_date DESC);


--
-- Name: idx_cds_symbol_date; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_cds_symbol_date ON fhq_finn.cognitive_dissonance_scores USING btree (symbol, analysis_date DESC);


--
-- Name: idx_daily_briefings_date; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_daily_briefings_date ON fhq_finn.daily_briefings USING btree (briefing_date DESC);


--
-- Name: idx_daily_briefings_regime; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_daily_briefings_regime ON fhq_finn.daily_briefings USING btree (detected_regime, briefing_date DESC);


--
-- Name: idx_derivative_metrics_date; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_derivative_metrics_date ON fhq_finn.derivative_metrics USING btree (metric_date DESC);


--
-- Name: idx_derivative_metrics_fels; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_derivative_metrics_fels ON fhq_finn.derivative_metrics USING btree (fels_score DESC NULLS LAST);


--
-- Name: idx_derivative_metrics_stress; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_derivative_metrics_stress ON fhq_finn.derivative_metrics USING btree (stress_level, metric_date DESC);


--
-- Name: idx_derivative_metrics_symbol; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_derivative_metrics_symbol ON fhq_finn.derivative_metrics USING btree (symbol, metric_date DESC);


--
-- Name: idx_execution_plans_status; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_execution_plans_status ON fhq_finn.optimal_execution_plans USING btree (execution_status);


--
-- Name: idx_execution_plans_symbol; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_execution_plans_symbol ON fhq_finn.optimal_execution_plans USING btree (symbol, plan_date DESC);


--
-- Name: idx_finn_anomaly_asset; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_finn_anomaly_asset ON fhq_finn.anomalies USING btree (asset_id);


--
-- Name: idx_finn_anomaly_flagged; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_finn_anomaly_flagged ON fhq_finn.anomalies USING btree (is_anomaly) WHERE (is_anomaly = true);


--
-- Name: idx_finn_anomaly_timestamp; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_finn_anomaly_timestamp ON fhq_finn.anomalies USING btree ("timestamp");


--
-- Name: idx_finn_predictions_asset; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_finn_predictions_asset ON fhq_finn.model_predictions USING btree (asset_id);


--
-- Name: idx_finn_predictions_model; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_finn_predictions_model ON fhq_finn.model_predictions USING btree (model_name);


--
-- Name: idx_finn_predictions_timestamp; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_finn_predictions_timestamp ON fhq_finn.model_predictions USING btree ("timestamp");


--
-- Name: idx_finn_regime_asset; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_finn_regime_asset ON fhq_finn.regime_states USING btree (asset_id);


--
-- Name: idx_finn_regime_timestamp; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_finn_regime_timestamp ON fhq_finn.regime_states USING btree ("timestamp");


--
-- Name: idx_finn_signals_asset; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_finn_signals_asset ON fhq_finn.ensemble_signals USING btree (asset_id);


--
-- Name: idx_finn_signals_decision; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_finn_signals_decision ON fhq_finn.ensemble_signals USING btree (ensemble_decision);


--
-- Name: idx_finn_signals_timestamp; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_finn_signals_timestamp ON fhq_finn.ensemble_signals USING btree ("timestamp");


--
-- Name: idx_funding_rates_exchange; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_funding_rates_exchange ON fhq_finn.funding_rates USING btree (exchange, symbol, "timestamp" DESC);


--
-- Name: idx_funding_rates_symbol; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_funding_rates_symbol ON fhq_finn.funding_rates USING btree (symbol, "timestamp" DESC);


--
-- Name: idx_funding_rates_time; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_funding_rates_time ON fhq_finn.funding_rates USING btree ("timestamp" DESC);


--
-- Name: idx_futures_basis_symbol; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_futures_basis_symbol ON fhq_finn.futures_basis USING btree (symbol, "timestamp" DESC);


--
-- Name: idx_futures_basis_time; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_futures_basis_time ON fhq_finn.futures_basis USING btree ("timestamp" DESC);


--
-- Name: idx_monte_carlo_date; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_monte_carlo_date ON fhq_finn.monte_carlo_robustness USING btree (test_date DESC);


--
-- Name: idx_narrative_date; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_narrative_date ON fhq_finn.narrative_analysis USING btree (analysis_date DESC);


--
-- Name: idx_options_gamma_exposure; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_options_gamma_exposure ON fhq_finn.options_gamma USING btree (gamma_exposure DESC NULLS LAST);


--
-- Name: idx_options_gamma_symbol; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_options_gamma_symbol ON fhq_finn.options_gamma USING btree (symbol, "timestamp" DESC);


--
-- Name: idx_options_gamma_time; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_options_gamma_time ON fhq_finn.options_gamma USING btree ("timestamp" DESC);


--
-- Name: idx_regime_weights_regime; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_regime_weights_regime ON fhq_finn.regime_adaptive_weights USING btree (regime, "timestamp" DESC);


--
-- Name: idx_relevance_scores_event_id; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_relevance_scores_event_id ON fhq_finn.relevance_scores USING btree (event_id);


--
-- Name: idx_relevance_scores_relevance_score; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_relevance_scores_relevance_score ON fhq_finn.relevance_scores USING btree (relevance_score);


--
-- Name: idx_relevance_scores_signal_type; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_relevance_scores_signal_type ON fhq_finn.relevance_scores USING btree (signal_type);


--
-- Name: idx_risk_dashboard_date; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_risk_dashboard_date ON fhq_finn.risk_dashboard USING btree (report_date DESC);


--
-- Name: idx_risk_dashboard_stress; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_risk_dashboard_stress ON fhq_finn.risk_dashboard USING btree (stress_score DESC);


--
-- Name: idx_serper_events_detected; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_serper_events_detected ON fhq_finn.serper_events USING btree (detected_at_utc DESC);


--
-- Name: idx_serper_events_detected_at; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_serper_events_detected_at ON fhq_finn.serper_events USING btree (detected_at_utc DESC);


--
-- Name: idx_serper_events_query; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_serper_events_query ON fhq_finn.serper_events USING btree (query_name, detected_at_utc DESC);


--
-- Name: idx_serper_events_sentiment; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_serper_events_sentiment ON fhq_finn.serper_events USING btree (sentiment_score, detected_at_utc DESC);


--
-- Name: idx_serper_events_type; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_serper_events_type ON fhq_finn.serper_events USING btree (event_type, detected_at_utc DESC);


--
-- Name: idx_signal_events_date; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_signal_events_date ON fhq_finn.signal_events USING btree (event_date DESC);


--
-- Name: idx_signal_events_entities; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_signal_events_entities ON fhq_finn.signal_events USING gin (entities);


--
-- Name: idx_signal_events_relevance; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_signal_events_relevance ON fhq_finn.signal_events USING btree (relevance_score DESC, event_date DESC) WHERE (relevance_score >= 0.7);


--
-- Name: idx_signal_events_type; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_signal_events_type ON fhq_finn.signal_events USING btree (event_type, event_date DESC);


--
-- Name: idx_signal_events_vendor; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_signal_events_vendor ON fhq_finn.signal_events USING btree (vendor_id, event_date DESC);


--
-- Name: idx_uncertainty_confidence; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_uncertainty_confidence ON fhq_finn.uncertainty_history USING btree (confidence_score);


--
-- Name: idx_uncertainty_symbol_timestamp; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_uncertainty_symbol_timestamp ON fhq_finn.uncertainty_history USING btree (symbol, "timestamp" DESC);


--
-- Name: idx_vendor_raw_ingest_processed; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_vendor_raw_ingest_processed ON fhq_finn.vendor_raw_ingest USING btree (processed, ingested_at DESC) WHERE (processed = false);


--
-- Name: idx_vendor_raw_ingest_time; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_vendor_raw_ingest_time ON fhq_finn.vendor_raw_ingest USING btree (ingested_at DESC);


--
-- Name: idx_vendor_status_date; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_vendor_status_date ON fhq_finn.vendor_status USING btree (status_date DESC);


--
-- Name: idx_vendor_status_health; Type: INDEX; Schema: fhq_finn; Owner: -
--

CREATE INDEX idx_vendor_status_health ON fhq_finn.vendor_status USING btree (health_status, status_date DESC);


--
-- Name: idx_ael_intervention_category; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ael_intervention_category ON fhq_governance.ael_intervention_registry USING btree (intervention_category);


--
-- Name: idx_ael_intervention_hash; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ael_intervention_hash ON fhq_governance.ael_intervention_registry USING btree (intervention_hash);


--
-- Name: idx_ael_intervention_phase; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ael_intervention_phase ON fhq_governance.ael_intervention_registry USING btree (ael_phase);


--
-- Name: idx_ael_intervention_proposed_at; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ael_intervention_proposed_at ON fhq_governance.ael_intervention_registry USING btree (proposed_at DESC);


--
-- Name: idx_ael_intervention_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ael_intervention_status ON fhq_governance.ael_intervention_registry USING btree (intervention_status);


--
-- Name: idx_agent_health_agent; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_agent_health_agent ON fhq_governance.agent_health_attestations USING btree (agent_id, attested_at DESC);


--
-- Name: idx_agent_health_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_agent_health_status ON fhq_governance.agent_health_attestations USING btree (health_status);


--
-- Name: idx_agent_health_timestamp; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_agent_health_timestamp ON fhq_governance.agent_health_attestations USING btree (attested_at DESC);


--
-- Name: idx_agent_memory_agent; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_agent_memory_agent ON fhq_governance.agent_memory_ledger USING btree (agent_id, created_at DESC);


--
-- Name: idx_agent_memory_sequence; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE UNIQUE INDEX idx_agent_memory_sequence ON fhq_governance.agent_memory_ledger USING btree (agent_id, sequence_number);


--
-- Name: idx_agent_memory_state; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_agent_memory_state ON fhq_governance.agent_memory_ledger USING btree (state_vector_hash);


--
-- Name: idx_agent_memory_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_agent_memory_type ON fhq_governance.agent_memory_ledger USING btree (memory_type);


--
-- Name: idx_agent_task_envelope; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_agent_task_envelope ON fhq_governance.agent_task_log USING btree (telemetry_envelope_id);


--
-- Name: idx_agent_task_log_agent_id; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_agent_task_log_agent_id ON fhq_governance.agent_task_log USING btree (agent_id);


--
-- Name: idx_agent_task_log_created_at; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_agent_task_log_created_at ON fhq_governance.agent_task_log USING btree (created_at DESC);


--
-- Name: idx_agent_task_log_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_agent_task_log_status ON fhq_governance.agent_task_log USING btree (status);


--
-- Name: idx_api_budget_log_date; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_api_budget_log_date ON fhq_governance.api_budget_log USING btree (usage_date);


--
-- Name: idx_api_usage_events_provider_date; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_api_usage_events_provider_date ON fhq_governance.api_usage_events USING btree (provider_name, "timestamp");


--
-- Name: idx_artifact_created; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_artifact_created ON fhq_governance.artifact_time_registry USING btree (canonical_created_at DESC);


--
-- Name: idx_artifact_time_integrity; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_artifact_time_integrity ON fhq_governance.artifact_time_registry USING btree (time_integrity_status, artifact_type);


--
-- Name: idx_asrp_state_log_agent; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_asrp_state_log_agent ON fhq_governance.asrp_state_log USING btree (agent_id);


--
-- Name: idx_asrp_state_log_mismatch; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_asrp_state_log_mismatch ON fhq_governance.asrp_state_log USING btree (state_mismatch) WHERE (state_mismatch = true);


--
-- Name: idx_asrp_violations_agent; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_asrp_violations_agent ON fhq_governance.asrp_violations USING btree (agent_id);


--
-- Name: idx_asrp_violations_timestamp; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_asrp_violations_timestamp ON fhq_governance.asrp_violations USING btree (created_at DESC);


--
-- Name: idx_asrp_violations_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_asrp_violations_type ON fhq_governance.asrp_violations USING btree (violation_type);


--
-- Name: idx_attempts_epoch_seq; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE UNIQUE INDEX idx_attempts_epoch_seq ON fhq_governance.execution_attempts USING btree (chain_epoch_id, chain_sequence);


--
-- Name: idx_attempts_needle; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_attempts_needle ON fhq_governance.execution_attempts USING btree (needle_id);


--
-- Name: idx_attempts_outcome; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_attempts_outcome ON fhq_governance.execution_attempts USING btree (final_outcome);


--
-- Name: idx_attempts_started; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_attempts_started ON fhq_governance.execution_attempts USING btree (attempt_started_at DESC);


--
-- Name: idx_audit_log_actor; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_audit_log_actor ON fhq_governance.audit_log USING btree (actor_id);


--
-- Name: idx_audit_log_category; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_audit_log_category ON fhq_governance.audit_log USING btree (event_category);


--
-- Name: idx_audit_log_gate; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_audit_log_gate ON fhq_governance.audit_log USING btree (governance_gate);


--
-- Name: idx_audit_log_target; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_audit_log_target ON fhq_governance.audit_log USING btree (target_type, target_id);


--
-- Name: idx_audit_log_timestamp; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_audit_log_timestamp ON fhq_governance.audit_log USING btree (event_timestamp DESC);


--
-- Name: idx_audit_log_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_audit_log_type ON fhq_governance.audit_log USING btree (event_type);


--
-- Name: idx_benchmark_active; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_benchmark_active ON fhq_governance.aiqf_benchmark_registry USING btree (is_active, benchmark_name);


--
-- Name: idx_benchmark_certified; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_benchmark_certified ON fhq_governance.aiqf_benchmark_registry USING btree (vega_certified) WHERE (vega_certified = true);


--
-- Name: idx_benchmark_runs_benchmark; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_benchmark_runs_benchmark ON fhq_governance.aiqf_benchmark_runs USING btree (benchmark_id, executed_at DESC);


--
-- Name: idx_benchmark_runs_drift; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_benchmark_runs_drift ON fhq_governance.aiqf_benchmark_runs USING btree (drift_alert_triggered) WHERE (drift_alert_triggered = true);


--
-- Name: idx_benchmark_runs_passed; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_benchmark_runs_passed ON fhq_governance.aiqf_benchmark_runs USING btree (passed, gate_decision);


--
-- Name: idx_brier_by_asset_class; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_brier_by_asset_class ON fhq_governance.brier_score_ledger USING btree (asset_class, created_at DESC) WHERE (asset_class IS NOT NULL);


--
-- Name: idx_brier_by_forecast_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_brier_by_forecast_type ON fhq_governance.brier_score_ledger USING btree (forecast_type, created_at DESC);


--
-- Name: idx_brier_by_regime; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_brier_by_regime ON fhq_governance.brier_score_ledger USING btree (regime, created_at DESC);


--
-- Name: idx_calibration_active; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_calibration_active ON fhq_governance.calibration_versions USING btree (parameter_name, is_active) WHERE (is_active = true);


--
-- Name: idx_calibration_history; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_calibration_history ON fhq_governance.calibration_versions USING btree (parameter_name, frozen_at DESC);


--
-- Name: idx_canonical_evidence_category; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_canonical_evidence_category ON fhq_governance.canonical_evidence USING btree (evidence_category);


--
-- Name: idx_canonical_evidence_cycle_id; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_canonical_evidence_cycle_id ON fhq_governance.canonical_evidence USING btree (cycle_id);


--
-- Name: idx_canonical_evidence_hash; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_canonical_evidence_hash ON fhq_governance.canonical_evidence USING btree (evidence_hash);


--
-- Name: idx_canonical_mutation_domain; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_canonical_mutation_domain ON fhq_governance.canonical_mutation_gates USING btree (target_domain);


--
-- Name: idx_canonical_mutation_pending; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_canonical_mutation_pending ON fhq_governance.canonical_mutation_gates USING btree (gate_status) WHERE (gate_status <> ALL (ARRAY['COMPLETED'::text, 'REJECTED'::text, 'CANCELLED'::text]));


--
-- Name: idx_canonical_mutation_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_canonical_mutation_status ON fhq_governance.canonical_mutation_gates USING btree (gate_status);


--
-- Name: idx_canonical_mutation_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_canonical_mutation_type ON fhq_governance.canonical_mutation_gates USING btree (mutation_type);


--
-- Name: idx_canonical_strategy_active; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE UNIQUE INDEX idx_canonical_strategy_active ON fhq_governance.canonical_strategy USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_canonical_strategy_posture; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_canonical_strategy_posture ON fhq_governance.canonical_strategy USING btree (posture);


--
-- Name: idx_canonical_strategy_timestamp; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_canonical_strategy_timestamp ON fhq_governance.canonical_strategy USING btree (authorization_timestamp DESC);


--
-- Name: idx_causal_edge_log_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_causal_edge_log_type ON fhq_governance.causal_edge_log USING btree (edge_type);


--
-- Name: idx_causal_entropy_audit_entity; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_causal_entropy_audit_entity ON fhq_governance.causal_entropy_audit USING btree (entity_type, entity_id);


--
-- Name: idx_causal_entropy_audit_gate; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_causal_entropy_audit_gate ON fhq_governance.causal_entropy_audit USING btree (gate);


--
-- Name: idx_cb_events_breaker; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_cb_events_breaker ON fhq_governance.circuit_breaker_events USING btree (breaker_name);


--
-- Name: idx_cb_events_timestamp; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_cb_events_timestamp ON fhq_governance.circuit_breaker_events USING btree (event_timestamp DESC);


--
-- Name: idx_ceo_access_log_auth_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ceo_access_log_auth_status ON fhq_governance.ceo_access_log USING btree (auth_status);


--
-- Name: idx_ceo_access_log_chat_id; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ceo_access_log_chat_id ON fhq_governance.ceo_access_log USING btree (chat_id);


--
-- Name: idx_ceo_access_log_command; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ceo_access_log_command ON fhq_governance.ceo_access_log USING btree (command);


--
-- Name: idx_ceo_access_log_timestamp; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ceo_access_log_timestamp ON fhq_governance.ceo_access_log USING btree (access_timestamp DESC);


--
-- Name: idx_ceo_whitelist_chat_id; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ceo_whitelist_chat_id ON fhq_governance.ceo_access_whitelist USING btree (telegram_chat_id) WHERE (is_active = true);


--
-- Name: idx_change_approvals_module_gate; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_change_approvals_module_gate ON fhq_governance.change_approvals USING btree (ios_module, gate);


--
-- Name: idx_change_log_created; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_change_log_created ON fhq_governance.change_log USING btree (created_at);


--
-- Name: idx_change_log_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_change_log_type ON fhq_governance.change_log USING btree (change_type);


--
-- Name: idx_chl_bypass_open; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_chl_bypass_open ON fhq_governance.chl_bypass_detections USING btree (resolution_status) WHERE (resolution_status = 'OPEN'::text);


--
-- Name: idx_chl_bypass_severity; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_chl_bypass_severity ON fhq_governance.chl_bypass_detections USING btree (severity, detection_timestamp DESC);


--
-- Name: idx_chl_llm_requests_advisor; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_chl_llm_requests_advisor ON fhq_governance.chl_llm_requests USING btree (advisor_id, request_timestamp DESC);


--
-- Name: idx_chl_llm_requests_context_hash; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_chl_llm_requests_context_hash ON fhq_governance.chl_llm_requests USING btree (context_hash);


--
-- Name: idx_chl_llm_requests_governance; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_chl_llm_requests_governance ON fhq_governance.chl_llm_requests USING btree (governance_event_raised) WHERE (governance_event_raised = true);


--
-- Name: idx_chl_llm_requests_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_chl_llm_requests_status ON fhq_governance.chl_llm_requests USING btree (request_status);


--
-- Name: idx_chl_request_log_agent; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_chl_request_log_agent ON fhq_governance.chl_request_log USING btree (requesting_agent, request_timestamp DESC);


--
-- Name: idx_chl_request_log_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_chl_request_log_status ON fhq_governance.chl_request_log USING btree (hydration_status);


--
-- Name: idx_cnrp_exec_cycle; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_cnrp_exec_cycle ON fhq_governance.cnrp_execution_log USING btree (cycle_id);


--
-- Name: idx_cnrp_exec_phase; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_cnrp_exec_phase ON fhq_governance.cnrp_execution_log USING btree (phase);


--
-- Name: idx_cnrp_exec_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_cnrp_exec_status ON fhq_governance.cnrp_execution_log USING btree (status);


--
-- Name: idx_cognitive_query_set_enabled; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_cognitive_query_set_enabled ON fhq_governance.cognitive_query_set USING btree (enabled, query_type) WHERE (enabled = true);


--
-- Name: idx_context_packages_hash; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_context_packages_hash ON fhq_governance.context_packages USING btree (package_hash);


--
-- Name: idx_context_packages_state_hash; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_context_packages_state_hash ON fhq_governance.context_packages USING btree (state_snapshot_hash);


--
-- Name: idx_context_packages_valid; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_context_packages_valid ON fhq_governance.context_packages USING btree (is_valid, valid_until) WHERE ((is_valid = true) AND (valid_until IS NULL));


--
-- Name: idx_cycles_defcon; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_cycles_defcon ON fhq_governance.orchestrator_cycles USING btree (defcon_level);


--
-- Name: idx_cycles_mode; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_cycles_mode ON fhq_governance.orchestrator_cycles USING btree (execution_mode);


--
-- Name: idx_cycles_started; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_cycles_started ON fhq_governance.orchestrator_cycles USING btree (started_at);


--
-- Name: idx_data_availability_critical; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_data_availability_critical ON fhq_governance.data_availability_registry USING btree (is_critical, is_holdout_eligible);


--
-- Name: idx_data_provider_policy_agent; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_data_provider_policy_agent ON fhq_governance.data_provider_policy USING btree (agent_id);


--
-- Name: idx_data_provider_policy_tier; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_data_provider_policy_tier ON fhq_governance.data_provider_policy USING btree (usage_tier);


--
-- Name: idx_decision_log_execution_state; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_decision_log_execution_state ON fhq_governance.decision_log USING btree (execution_state);


--
-- Name: idx_decision_log_sequence; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_decision_log_sequence ON fhq_governance.decision_log USING btree (sequence_number);


--
-- Name: idx_decision_log_valid_until; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_decision_log_valid_until ON fhq_governance.decision_log USING btree (valid_until);


--
-- Name: idx_defcon_current; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE UNIQUE INDEX idx_defcon_current ON fhq_governance.defcon_state USING btree (is_current) WHERE (is_current = true);


--
-- Name: idx_defcon_level; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_defcon_level ON fhq_governance.defcon_state USING btree (defcon_level);


--
-- Name: idx_defcon_transitions_timestamp; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_defcon_transitions_timestamp ON fhq_governance.defcon_transitions USING btree (transition_timestamp DESC);


--
-- Name: idx_discrepancy_events_created; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_discrepancy_events_created ON fhq_governance.discrepancy_events USING btree (created_at DESC);


--
-- Name: idx_discrepancy_events_ios_id; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_discrepancy_events_ios_id ON fhq_governance.discrepancy_events USING btree (ios_id);


--
-- Name: idx_discrepancy_events_severity; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_discrepancy_events_severity ON fhq_governance.discrepancy_events USING btree (severity);


--
-- Name: idx_discrepancy_events_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_discrepancy_events_status ON fhq_governance.discrepancy_events USING btree (resolution_status);


--
-- Name: idx_drift_alerts_unresolved; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_drift_alerts_unresolved ON fhq_governance.aiqf_drift_alerts USING btree (resolved, severity) WHERE (resolved = false);


--
-- Name: idx_ep_expires; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ep_expires ON fhq_governance.epistemic_proposals USING btree (expires_at) WHERE (status = 'GENERATED'::text);


--
-- Name: idx_ep_generated; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ep_generated ON fhq_governance.epistemic_proposals USING btree (generated_at DESC);


--
-- Name: idx_ep_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ep_status ON fhq_governance.epistemic_proposals USING btree (status);


--
-- Name: idx_ep_target; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ep_target ON fhq_governance.epistemic_proposals USING btree (target_parameter);


--
-- Name: idx_ep_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ep_type ON fhq_governance.epistemic_proposals USING btree (proposal_type);


--
-- Name: idx_epistemic_lesson_evidence_created_at; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_epistemic_lesson_evidence_created_at ON fhq_governance.epistemic_lesson_evidence USING btree (created_at DESC);


--
-- Name: idx_epistemic_lesson_evidence_lesson_id; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_epistemic_lesson_evidence_lesson_id ON fhq_governance.epistemic_lesson_evidence USING btree (lesson_id);


--
-- Name: idx_epistemic_lessons_asset; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_epistemic_lessons_asset ON fhq_governance.epistemic_lessons USING btree (affected_asset_id);


--
-- Name: idx_epistemic_lessons_category; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_epistemic_lessons_category ON fhq_governance.epistemic_lessons USING btree (lesson_category);


--
-- Name: idx_epistemic_lessons_evidence_id; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_epistemic_lessons_evidence_id ON fhq_governance.epistemic_lessons USING btree (evidence_id);


--
-- Name: idx_epistemic_lessons_severity; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_epistemic_lessons_severity ON fhq_governance.epistemic_lessons USING btree (lesson_severity);


--
-- Name: idx_epistemic_lessons_source; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_epistemic_lessons_source ON fhq_governance.epistemic_lessons USING btree (lesson_source);


--
-- Name: idx_epistemic_lessons_timestamp; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_epistemic_lessons_timestamp ON fhq_governance.epistemic_lessons USING btree (lesson_timestamp);


--
-- Name: idx_epistemic_suppression_by_category; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_epistemic_suppression_by_category ON fhq_governance.epistemic_suppression_ledger USING btree (suppression_category, created_at DESC);


--
-- Name: idx_epistemic_suppression_unreviewed; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_epistemic_suppression_unreviewed ON fhq_governance.epistemic_suppression_ledger USING btree (created_at DESC) WHERE (reviewed_at IS NULL);


--
-- Name: idx_evidence_bundle_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_evidence_bundle_type ON fhq_governance.refinement_evidence_bundle USING btree (bundle_type, created_at DESC);


--
-- Name: idx_execution_log_decision; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_execution_log_decision ON fhq_governance.execution_log USING btree (decision_id);


--
-- Name: idx_execution_log_detected; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_execution_log_detected ON fhq_governance.execution_log USING btree (detected_at);


--
-- Name: idx_execution_log_security; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_execution_log_security ON fhq_governance.execution_log USING btree (security_status);


--
-- Name: idx_execution_state_change_log_change_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_execution_state_change_log_change_type ON fhq_governance.execution_state_change_log USING btree (change_type);


--
-- Name: idx_execution_state_change_log_initiated_at; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_execution_state_change_log_initiated_at ON fhq_governance.execution_state_change_log USING btree (initiated_at DESC);


--
-- Name: idx_execution_state_cycle; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_execution_state_cycle ON fhq_governance.execution_state USING btree (cycle_id);


--
-- Name: idx_fm_registry_category; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_fm_registry_category ON fhq_governance.failure_mode_registry USING btree (failure_category, fmcl_stage);


--
-- Name: idx_fm_registry_closed; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_fm_registry_closed ON fhq_governance.failure_mode_registry USING btree (closed_at DESC) WHERE (fmcl_stage = 'CLOSED'::text);


--
-- Name: idx_fm_registry_created; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_fm_registry_created ON fhq_governance.failure_mode_registry USING btree (created_at DESC);


--
-- Name: idx_fm_registry_source_date; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_fm_registry_source_date ON fhq_governance.failure_mode_registry USING btree (source_date DESC);


--
-- Name: idx_fm_registry_stage; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_fm_registry_stage ON fhq_governance.failure_mode_registry USING btree (fmcl_stage, failure_severity);


--
-- Name: idx_gal_action_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_gal_action_type ON fhq_governance.governance_actions_log USING btree (action_type);


--
-- Name: idx_gal_timestamp; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_gal_timestamp ON fhq_governance.governance_actions_log USING btree ("timestamp" DESC);


--
-- Name: idx_gates_active; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_gates_active ON fhq_governance.confidence_calibration_gates USING btree (forecast_type, regime, effective_from, effective_until);


--
-- Name: idx_gateway_request_agent; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_gateway_request_agent ON fhq_governance.gateway_request_log USING btree (requesting_agent, request_timestamp DESC);


--
-- Name: idx_gateway_request_context_hash; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_gateway_request_context_hash ON fhq_governance.gateway_request_log USING btree (context_hash);


--
-- Name: idx_gateway_request_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_gateway_request_status ON fhq_governance.gateway_request_log USING btree (gateway_status);


--
-- Name: idx_gateway_sig_context_hash; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_gateway_sig_context_hash ON fhq_governance.gateway_integrity_signatures USING btree (context_hash) WHERE (is_valid = true);


--
-- Name: idx_goal_calendar_date; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_goal_calendar_date ON fhq_governance.daily_goal_calendar USING btree (calendar_date);


--
-- Name: idx_goal_calendar_phase; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_goal_calendar_phase ON fhq_governance.daily_goal_calendar USING btree (phase_name, day_number);


--
-- Name: idx_goal_calendar_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_goal_calendar_status ON fhq_governance.daily_goal_calendar USING btree (status, calendar_date);


--
-- Name: idx_goal_evidence_chain; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_goal_evidence_chain ON fhq_governance.goal_completion_evidence USING btree (previous_hash);


--
-- Name: idx_goal_evidence_goal; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_goal_evidence_goal ON fhq_governance.goal_completion_evidence USING btree (goal_id);


--
-- Name: idx_golden_alpha_difficulty; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_golden_alpha_difficulty ON fhq_governance.golden_alpha_testset USING btree (difficulty);


--
-- Name: idx_golden_alpha_domain; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_golden_alpha_domain ON fhq_governance.golden_alpha_testset USING btree (domain);


--
-- Name: idx_golden_alpha_signed; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_golden_alpha_signed ON fhq_governance.golden_alpha_testset USING btree (vega_signature) WHERE (vega_signature IS NOT NULL);


--
-- Name: idx_governance_actions_initiator; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_governance_actions_initiator ON fhq_governance.governance_actions_log USING btree (initiated_by);


--
-- Name: idx_governance_actions_target; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_governance_actions_target ON fhq_governance.governance_actions_log USING btree (action_target);


--
-- Name: idx_governance_actions_timestamp; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_governance_actions_timestamp ON fhq_governance.governance_actions_log USING btree (initiated_at);


--
-- Name: idx_governance_actions_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_governance_actions_type ON fhq_governance.governance_actions_log USING btree (action_type);


--
-- Name: idx_graduation_batch; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_graduation_batch ON fhq_governance.batch_graduation_log USING btree (batch_id);


--
-- Name: idx_graduation_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_graduation_status ON fhq_governance.batch_graduation_log USING btree (graduation_status);


--
-- Name: idx_guidelines_active_global; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_guidelines_active_global ON fhq_governance.sql_correction_guidelines USING btree (is_active, is_global_default) WHERE (is_active = true);


--
-- Name: idx_guidelines_pattern; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_guidelines_pattern ON fhq_governance.sql_correction_guidelines USING btree (error_pattern, success_rate DESC);


--
-- Name: idx_guidelines_taxonomy; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_guidelines_taxonomy ON fhq_governance.sql_correction_guidelines USING btree (error_taxonomy, is_active);


--
-- Name: idx_heartbeats_component_unique; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE UNIQUE INDEX idx_heartbeats_component_unique ON fhq_governance.system_heartbeats USING btree (component_name);


--
-- Name: idx_heartbeats_time; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_heartbeats_time ON fhq_governance.system_heartbeats USING btree (last_heartbeat);


--
-- Name: idx_holdout_eval_model; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_holdout_eval_model ON fhq_governance.holdout_evaluation_results USING btree (model_version);


--
-- Name: idx_ikea_validation_needle; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ikea_validation_needle ON fhq_governance.ikea_validation_log USING btree (needle_id);


--
-- Name: idx_ikea_validation_passed; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ikea_validation_passed ON fhq_governance.ikea_validation_log USING btree (passed);


--
-- Name: idx_ikea_validation_rule; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ikea_validation_rule ON fhq_governance.ikea_validation_log USING btree (rule_violated);


--
-- Name: idx_inforage_log_agent; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_inforage_log_agent ON fhq_governance.inforage_query_log USING btree (querying_agent);


--
-- Name: idx_inforage_log_created; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_inforage_log_created ON fhq_governance.inforage_query_log USING btree (created_at DESC);


--
-- Name: idx_inforage_log_defcon; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_inforage_log_defcon ON fhq_governance.inforage_query_log USING btree (defcon_level);


--
-- Name: idx_inforage_query_log_ecr; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_inforage_query_log_ecr ON fhq_governance.inforage_query_log USING btree (evidence_coverage_ratio, created_at DESC) WHERE (evidence_coverage_ratio IS NOT NULL);


--
-- Name: idx_inforage_query_log_result_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_inforage_query_log_result_type ON fhq_governance.inforage_query_log USING btree (result_type, created_at DESC);


--
-- Name: idx_intent_drafts_created; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_intent_drafts_created ON fhq_governance.intent_drafts USING btree (created_at DESC);


--
-- Name: idx_intent_drafts_needle; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_intent_drafts_needle ON fhq_governance.intent_drafts USING btree (needle_id);


--
-- Name: idx_ios_gates_lookup; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ios_gates_lookup ON fhq_governance.ios_execution_gates USING btree (ios_id, gate_status);


--
-- Name: idx_label_def_single_active; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE UNIQUE INDEX idx_label_def_single_active ON fhq_governance.label_definition_registry USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_ldow_captures_ldow_id; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ldow_captures_ldow_id ON fhq_governance.ldow_forecast_captures USING btree (ldow_id);


--
-- Name: idx_ldow_captures_timestamp; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ldow_captures_timestamp ON fhq_governance.ldow_forecast_captures USING btree (captured_at);


--
-- Name: idx_ldow_completion_scheduled; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ldow_completion_scheduled ON fhq_governance.ldow_cycle_completion USING btree (scheduled_at);


--
-- Name: idx_ldow_completion_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ldow_completion_status ON fhq_governance.ldow_cycle_completion USING btree (completion_status);


--
-- Name: idx_ldow_cycle_metrics_ldow; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ldow_cycle_metrics_ldow ON fhq_governance.ldow_cycle_metrics USING btree (ldow_id, cycle_number);


--
-- Name: idx_ldow_failure_cycle; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ldow_failure_cycle ON fhq_governance.ldow_failure_incidents USING btree (cycle_number);


--
-- Name: idx_ldow_failure_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ldow_failure_status ON fhq_governance.ldow_failure_incidents USING btree (incident_status);


--
-- Name: idx_ldow_regime_metrics_ldow; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ldow_regime_metrics_ldow ON fhq_governance.ldow_regime_metrics USING btree (ldow_id, cycle_number);


--
-- Name: idx_ldow_strategy_metrics_ldow; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_ldow_strategy_metrics_ldow ON fhq_governance.ldow_strategy_metrics USING btree (ldow_id, cycle_number);


--
-- Name: idx_learning_audit_proposal; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_learning_audit_proposal ON fhq_governance.learning_proposal_audit USING btree (proposal_id);


--
-- Name: idx_learning_mechanism_date; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_learning_mechanism_date ON fhq_governance.learning_mechanism_log USING btree (logged_at DESC);


--
-- Name: idx_learning_proposals_engine; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_learning_proposals_engine ON fhq_governance.learning_proposals USING btree (engine_id);


--
-- Name: idx_learning_proposals_expires; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_learning_proposals_expires ON fhq_governance.learning_proposals USING btree (expires_at) WHERE ((status)::text = 'PENDING'::text);


--
-- Name: idx_learning_proposals_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_learning_proposals_status ON fhq_governance.learning_proposals USING btree (status);


--
-- Name: idx_learning_proposals_submitted; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_learning_proposals_submitted ON fhq_governance.learning_proposals USING btree (submitted_at DESC);


--
-- Name: idx_learning_versions_active; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_learning_versions_active ON fhq_governance.learning_versions USING btree (engine_id, parameter_type) WHERE (is_active = true);


--
-- Name: idx_llm_provider_balance_fetched; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_llm_provider_balance_fetched ON fhq_governance.llm_provider_balance USING btree (fetched_at DESC);


--
-- Name: idx_llm_provider_balance_provider; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_llm_provider_balance_provider ON fhq_governance.llm_provider_balance USING btree (provider);


--
-- Name: idx_llm_routing_agent; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_llm_routing_agent ON fhq_governance.llm_routing_log USING btree (agent_id);


--
-- Name: idx_llm_routing_correlation; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_llm_routing_correlation ON fhq_governance.llm_routing_log USING btree (correlation_id);


--
-- Name: idx_llm_routing_envelope; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_llm_routing_envelope ON fhq_governance.llm_routing_log USING btree (envelope_id);


--
-- Name: idx_llm_routing_timestamp; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_llm_routing_timestamp ON fhq_governance.llm_routing_log USING btree (timestamp_utc DESC);


--
-- Name: idx_mode_current; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE UNIQUE INDEX idx_mode_current ON fhq_governance.execution_mode USING btree (is_current) WHERE (is_current = true);


--
-- Name: idx_mv_agent_integrity_ledger_created; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_mv_agent_integrity_ledger_created ON fhq_governance.mv_agent_integrity_ledger USING btree (created_at DESC);


--
-- Name: idx_mv_aol_agent_metrics; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE UNIQUE INDEX idx_mv_aol_agent_metrics ON fhq_governance.mv_aol_agent_metrics USING btree (agent_id);


--
-- Name: idx_mv_aol_agent_metrics_agent_id; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE UNIQUE INDEX idx_mv_aol_agent_metrics_agent_id ON fhq_governance.mv_aol_agent_metrics USING btree (agent_id);


--
-- Name: idx_mv_evpi_proxy_week_category; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE UNIQUE INDEX idx_mv_evpi_proxy_week_category ON fhq_governance.mv_evpi_proxy USING btree (week, suppression_category);


--
-- Name: idx_oracle_event_log_created; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_oracle_event_log_created ON fhq_governance.oracle_event_log USING btree (created_at DESC);


--
-- Name: idx_oracle_event_log_operator; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_oracle_event_log_operator ON fhq_governance.oracle_event_log USING btree (operator);


--
-- Name: idx_oracle_event_log_vector; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_oracle_event_log_vector ON fhq_governance.oracle_event_log USING btree (vector_id);


--
-- Name: idx_oracle_staging_domain; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_oracle_staging_domain ON fhq_governance.oracle_staging USING btree (domain);


--
-- Name: idx_oracle_staging_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_oracle_staging_status ON fhq_governance.oracle_staging USING btree (review_status);


--
-- Name: idx_oracle_staging_submitted_at; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_oracle_staging_submitted_at ON fhq_governance.oracle_staging USING btree (submitted_at DESC);


--
-- Name: idx_output_bindings_agent; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_output_bindings_agent ON fhq_governance.output_bindings USING btree (agent_id, created_at DESC);


--
-- Name: idx_output_bindings_output; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_output_bindings_output ON fhq_governance.output_bindings USING btree (output_type, output_id);


--
-- Name: idx_output_bindings_state_hash; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_output_bindings_state_hash ON fhq_governance.output_bindings USING btree (state_snapshot_hash);


--
-- Name: idx_paper_ledger_asset; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_paper_ledger_asset ON fhq_governance.paper_ledger USING btree (canonical_id);


--
-- Name: idx_paper_ledger_date; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_paper_ledger_date ON fhq_governance.paper_ledger USING btree (decision_timestamp DESC);


--
-- Name: idx_paper_ledger_gate; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_paper_ledger_gate ON fhq_governance.paper_ledger USING btree (calibration_gate_id);


--
-- Name: idx_plans_attempt; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_plans_attempt ON fhq_governance.decision_plans USING btree (attempt_id);


--
-- Name: idx_plans_created; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_plans_created ON fhq_governance.decision_plans USING btree (created_at DESC);


--
-- Name: idx_plans_needle; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_plans_needle ON fhq_governance.decision_plans USING btree (needle_id);


--
-- Name: idx_plps_graduation_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_plps_graduation_status ON fhq_governance.plps_graduation_attempts USING btree (graduation_status);


--
-- Name: idx_quad_hash_registry_hash; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_quad_hash_registry_hash ON fhq_governance.quad_hash_registry USING btree (quad_hash);


--
-- Name: idx_quad_hash_registry_state; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_quad_hash_registry_state ON fhq_governance.quad_hash_registry USING btree (state_snapshot_hash);


--
-- Name: idx_quad_hash_registry_valid; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_quad_hash_registry_valid ON fhq_governance.quad_hash_registry USING btree (is_valid) WHERE (is_valid = true);


--
-- Name: idx_queue_agent; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_queue_agent ON fhq_governance.event_queue USING btree (target_agent, status);


--
-- Name: idx_queue_event; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_queue_event ON fhq_governance.event_queue USING btree (event_id);


--
-- Name: idx_queue_pending; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_queue_pending ON fhq_governance.event_queue USING btree (status, priority, queued_at) WHERE ((status)::text = 'PENDING'::text);


--
-- Name: idx_quota_events_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_quota_events_type ON fhq_governance.vendor_quota_events USING btree (event_type);


--
-- Name: idx_quota_events_vendor; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_quota_events_vendor ON fhq_governance.vendor_quota_events USING btree (vendor_id);


--
-- Name: idx_refinement_agent; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_refinement_agent ON fhq_governance.sql_refinement_log USING btree (agent_id, created_at DESC);


--
-- Name: idx_refinement_circuit_state; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_refinement_circuit_state ON fhq_governance.sql_refinement_log USING btree (circuit_state) WHERE ((circuit_state)::text <> 'CLOSED'::text);


--
-- Name: idx_refinement_escalated; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_refinement_escalated ON fhq_governance.sql_refinement_log USING btree (escalated_to_human) WHERE (escalated_to_human = true);


--
-- Name: idx_refinement_exceeded; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_refinement_exceeded ON fhq_governance.sql_refinement_log USING btree (latency_exceeded, tokens_exceeded, cost_exceeded) WHERE (latency_exceeded OR tokens_exceeded OR cost_exceeded);


--
-- Name: idx_refinement_success; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_refinement_success ON fhq_governance.sql_refinement_log USING btree (success, created_at DESC);


--
-- Name: idx_regret_attribution; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_regret_attribution ON fhq_governance.epistemic_suppression_ledger USING btree (regret_attribution_type) WHERE (regret_classification = 'REGRET'::text);


--
-- Name: idx_regret_diagnostics_regret_id; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_regret_diagnostics_regret_id ON fhq_governance.regret_computation_diagnostics USING btree (regret_id);


--
-- Name: idx_regret_diagnostics_timestamp; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_regret_diagnostics_timestamp ON fhq_governance.regret_computation_diagnostics USING btree (computation_timestamp);


--
-- Name: idx_regret_magnitude_category; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_regret_magnitude_category ON fhq_governance.epistemic_suppression_ledger USING btree (regret_magnitude_category) WHERE (regret_classification = 'REGRET'::text);


--
-- Name: idx_reopen_log_fm; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_reopen_log_fm ON fhq_governance.failure_mode_reopen_log USING btree (failure_mode_id);


--
-- Name: idx_research_log_agent; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_research_log_agent ON fhq_governance.research_log USING btree (agent_id, created_at DESC);


--
-- Name: idx_research_log_event; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_research_log_event ON fhq_governance.research_log USING btree (event_type);


--
-- Name: idx_research_log_research_id; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_research_log_research_id ON fhq_governance.research_log USING btree (research_id);


--
-- Name: idx_retest_validation_fm; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_retest_validation_fm ON fhq_governance.retest_validation_cycles USING btree (failure_mode_id, cycle_number);


--
-- Name: idx_retest_validation_time; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_retest_validation_time ON fhq_governance.retest_validation_cycles USING btree (cycle_timestamp DESC);


--
-- Name: idx_security_alerts_severity; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_security_alerts_severity ON fhq_governance.security_alerts USING btree (alert_severity);


--
-- Name: idx_security_alerts_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_security_alerts_type ON fhq_governance.security_alerts USING btree (alert_type);


--
-- Name: idx_shadow_decision_eval_time; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_shadow_decision_eval_time ON fhq_governance.shadow_decision_log USING btree (evaluation_time DESC);


--
-- Name: idx_shadow_decision_signal; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_shadow_decision_signal ON fhq_governance.shadow_decision_log USING btree (signal_id);


--
-- Name: idx_shadow_decision_verdict; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_shadow_decision_verdict ON fhq_governance.shadow_decision_log USING btree (lids_verdict, evaluation_time DESC);


--
-- Name: idx_shadow_decision_would_exec; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_shadow_decision_would_exec ON fhq_governance.shadow_decision_log USING btree (would_have_executed, evaluation_time DESC) WHERE (would_have_executed = true);


--
-- Name: idx_shared_state_current; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_shared_state_current ON fhq_governance.shared_state_snapshots USING btree (is_valid, valid_until) WHERE ((is_valid = true) AND (valid_until IS NULL));


--
-- Name: idx_shared_state_hash; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_shared_state_hash ON fhq_governance.shared_state_snapshots USING btree (state_vector_hash);


--
-- Name: idx_shared_state_timestamp; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_shared_state_timestamp ON fhq_governance.shared_state_snapshots USING btree (snapshot_timestamp DESC);


--
-- Name: idx_split_brain_detected_at; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_split_brain_detected_at ON fhq_governance.split_brain_events USING btree (detected_at DESC);


--
-- Name: idx_state_retrieval_agent; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_state_retrieval_agent ON fhq_governance.state_retrieval_log USING btree (agent_id, retrieval_timestamp DESC);


--
-- Name: idx_state_retrieval_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_state_retrieval_status ON fhq_governance.state_retrieval_log USING btree (retrieval_status);


--
-- Name: idx_state_retrieval_timestamp; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_state_retrieval_timestamp ON fhq_governance.state_retrieval_log USING btree (retrieval_timestamp DESC);


--
-- Name: idx_stig_engine_ops_decision; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_stig_engine_ops_decision ON fhq_governance.stig_engine_operations USING btree (decision);


--
-- Name: idx_stig_engine_ops_operation; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_stig_engine_ops_operation ON fhq_governance.stig_engine_operations USING btree (operation_type, target_schema, target_table);


--
-- Name: idx_stig_engine_ops_timestamp; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_stig_engine_ops_timestamp ON fhq_governance.stig_engine_operations USING btree (request_timestamp DESC);


--
-- Name: idx_stillness_checkpoint_pass; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_stillness_checkpoint_pass ON fhq_governance.stillness_checkpoint_log USING btree (checkpoint_pass);


--
-- Name: idx_stillness_checkpoint_time; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_stillness_checkpoint_time ON fhq_governance.stillness_checkpoint_log USING btree (checkpoint_at);


--
-- Name: idx_stillness_day_goals_date; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_stillness_day_goals_date ON fhq_governance.stillness_day_goals USING btree (day_date);


--
-- Name: idx_stillness_day_goals_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_stillness_day_goals_status ON fhq_governance.stillness_day_goals USING btree (goal_status);


--
-- Name: idx_suppression_regret_period; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_suppression_regret_period ON fhq_governance.suppression_regret_index USING btree (period_start, period_end);


--
-- Name: idx_suspension_audit_action_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_suspension_audit_action_type ON fhq_governance.suspension_audit_log USING btree (action_type);


--
-- Name: idx_suspension_audit_performed_by; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_suspension_audit_performed_by ON fhq_governance.suspension_audit_log USING btree (performed_by);


--
-- Name: idx_suspension_audit_request; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_suspension_audit_request ON fhq_governance.suspension_audit_log USING btree (request_id);


--
-- Name: idx_suspension_audit_timestamp; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_suspension_audit_timestamp ON fhq_governance.suspension_audit_log USING btree ("timestamp" DESC);


--
-- Name: idx_suspension_requests_agent_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_suspension_requests_agent_status ON fhq_governance.agent_suspension_requests USING btree (agent_id, status);


--
-- Name: idx_suspension_requests_created; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_suspension_requests_created ON fhq_governance.agent_suspension_requests USING btree (created_at DESC);


--
-- Name: idx_suspension_requests_pending; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_suspension_requests_pending ON fhq_governance.agent_suspension_requests USING btree (status) WHERE (status = 'PENDING'::text);


--
-- Name: idx_suspension_requests_requested_by; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_suspension_requests_requested_by ON fhq_governance.agent_suspension_requests USING btree (requested_by);


--
-- Name: idx_suspension_requests_reviewed_by; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_suspension_requests_reviewed_by ON fhq_governance.agent_suspension_requests USING btree (reviewed_by) WHERE (reviewed_by IS NOT NULL);


--
-- Name: idx_suspension_requests_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_suspension_requests_status ON fhq_governance.agent_suspension_requests USING btree (status);


--
-- Name: idx_system_events_agent; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_system_events_agent ON fhq_governance.system_events USING btree (agent_id);


--
-- Name: idx_system_events_created; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_system_events_created ON fhq_governance.system_events USING btree (created_at DESC);


--
-- Name: idx_system_events_severity; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_system_events_severity ON fhq_governance.system_events USING btree (event_severity) WHERE ((event_severity)::text = ANY (ARRAY[('WARNING'::character varying)::text, ('ERROR'::character varying)::text, ('CRITICAL'::character varying)::text]));


--
-- Name: idx_system_events_time; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_system_events_time ON fhq_governance.system_events USING btree (created_at DESC);


--
-- Name: idx_system_events_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_system_events_type ON fhq_governance.system_events USING btree (event_type);


--
-- Name: idx_system_state_active; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_system_state_active ON fhq_governance.system_state USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_task_activation_enabled; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_task_activation_enabled ON fhq_governance.task_activation_status USING btree (is_enabled);


--
-- Name: idx_task_activation_task_id; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_task_activation_task_id ON fhq_governance.task_activation_status USING btree (task_id);


--
-- Name: idx_task_execution_cycle; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_task_execution_cycle ON fhq_governance.ldow_task_execution_log USING btree (cycle_completion_id);


--
-- Name: idx_task_execution_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_task_execution_type ON fhq_governance.ldow_task_execution_log USING btree (task_type);


--
-- Name: idx_task_registry_name; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_task_registry_name ON fhq_governance.task_registry USING btree (task_name);


--
-- Name: idx_telemetry_config_key; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_telemetry_config_key ON fhq_governance.telemetry_config USING btree (config_key);


--
-- Name: idx_telemetry_cost_ledger_agent; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_telemetry_cost_ledger_agent ON fhq_governance.telemetry_cost_ledger USING btree (agent_id);


--
-- Name: idx_telemetry_cost_ledger_date; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_telemetry_cost_ledger_date ON fhq_governance.telemetry_cost_ledger USING btree (ledger_date DESC);


--
-- Name: idx_telemetry_errors_agent; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_telemetry_errors_agent ON fhq_governance.telemetry_errors USING btree (agent_id);


--
-- Name: idx_telemetry_errors_created; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_telemetry_errors_created ON fhq_governance.telemetry_errors USING btree (created_at DESC);


--
-- Name: idx_telemetry_errors_envelope; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_telemetry_errors_envelope ON fhq_governance.telemetry_errors USING btree (envelope_id);


--
-- Name: idx_telemetry_errors_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_telemetry_errors_type ON fhq_governance.telemetry_errors USING btree (error_type);


--
-- Name: idx_temporal_snapshots_defcon; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_temporal_snapshots_defcon ON fhq_governance.ceo_temporal_snapshots USING btree (defcon_level);


--
-- Name: idx_temporal_snapshots_event_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_temporal_snapshots_event_type ON fhq_governance.ceo_temporal_snapshots USING btree (event_type);


--
-- Name: idx_temporal_snapshots_regime; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_temporal_snapshots_regime ON fhq_governance.ceo_temporal_snapshots USING btree (regime_label);


--
-- Name: idx_temporal_snapshots_timestamp; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_temporal_snapshots_timestamp ON fhq_governance.ceo_temporal_snapshots USING btree (event_timestamp DESC);


--
-- Name: idx_triage_escalated; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_triage_escalated ON fhq_governance.vega_triage_log USING btree (escalated_to_ceo) WHERE (escalated_to_ceo = true);


--
-- Name: idx_triage_pending; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_triage_pending ON fhq_governance.vega_triage_log USING btree (vega_decision) WHERE (vega_decision = 'PENDING_REVIEW'::text);


--
-- Name: idx_trigger_active; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_trigger_active ON fhq_governance.event_trigger_registry USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_trigger_event_type; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_trigger_event_type ON fhq_governance.event_trigger_registry USING btree (source_event_type);


--
-- Name: idx_trigger_target; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_trigger_target ON fhq_governance.event_trigger_registry USING btree (target_agent, target_action);


--
-- Name: idx_unattended_executions_ldow; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_unattended_executions_ldow ON fhq_governance.ldow_unattended_executions USING btree (ldow_id, cycle_number);


--
-- Name: idx_unattended_executions_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_unattended_executions_status ON fhq_governance.ldow_unattended_executions USING btree (status);


--
-- Name: idx_violations_timestamp; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_violations_timestamp ON fhq_governance.gate_violation_log USING btree (violation_timestamp DESC);


--
-- Name: idx_weekly_learning_runs_initiated_at; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_weekly_learning_runs_initiated_at ON fhq_governance.weekly_learning_runs USING btree (initiated_at DESC);


--
-- Name: idx_weekly_learning_runs_iso_week; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_weekly_learning_runs_iso_week ON fhq_governance.weekly_learning_runs USING btree (iso_year DESC, iso_week DESC);


--
-- Name: idx_weekly_learning_runs_status; Type: INDEX; Schema: fhq_governance; Owner: -
--

CREATE INDEX idx_weekly_learning_runs_status ON fhq_governance.weekly_learning_runs USING btree (run_status);


--
-- Name: idx_aci_state_snapshot_created; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_aci_state_snapshot_created ON fhq_meta.aci_state_snapshot_log USING btree (created_at DESC);


--
-- Name: idx_aci_state_snapshot_hash; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_aci_state_snapshot_hash ON fhq_meta.aci_state_snapshot_log USING btree (state_snapshot_hash);


--
-- Name: idx_aci_state_snapshot_interaction; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_aci_state_snapshot_interaction ON fhq_meta.aci_state_snapshot_log USING btree (bound_to_interaction_id);


--
-- Name: idx_acm_active; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_acm_active ON fhq_meta.aci_cognitive_memory USING btree (is_active, created_at DESC);


--
-- Name: idx_acm_session; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_acm_session ON fhq_meta.aci_cognitive_memory USING btree (session_id);


--
-- Name: idx_acm_state; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_acm_state ON fhq_meta.aci_cognitive_memory USING btree (state_snapshot_hash);


--
-- Name: idx_acm_type; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_acm_type ON fhq_meta.aci_cognitive_memory USING btree (memory_type);


--
-- Name: idx_acs_activity; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_acs_activity ON fhq_meta.aci_console_sessions USING btree (last_activity_at DESC);


--
-- Name: idx_acs_status; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_acs_status ON fhq_meta.aci_console_sessions USING btree (status);


--
-- Name: idx_ade_created; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_ade_created ON fhq_meta.adr_drift_events USING btree (created_at DESC);


--
-- Name: idx_ade_doc; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_ade_doc ON fhq_meta.adr_drift_events USING btree (doc_id);


--
-- Name: idx_ade_interaction; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_ade_interaction ON fhq_meta.adr_drift_events USING btree (interaction_id);


--
-- Name: idx_adr_archive_adr_id; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_adr_archive_adr_id ON fhq_meta.adr_archive USING btree (adr_id);


--
-- Name: idx_adr_archive_superseded; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_adr_archive_superseded ON fhq_meta.adr_archive USING btree (superseded_by);


--
-- Name: idx_adr_audit_log_adr; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_adr_audit_log_adr ON fhq_meta.adr_audit_log USING btree (adr_id);


--
-- Name: idx_adr_registry_hash; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_adr_registry_hash ON fhq_meta.adr_registry USING btree (hash);


--
-- Name: idx_adr_registry_local_adr; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_adr_registry_local_adr ON fhq_meta.adr_registry_local USING btree (adr_id);


--
-- Name: idx_adr_registry_owner; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_adr_registry_owner ON fhq_meta.adr_registry USING btree (owner);


--
-- Name: idx_adr_registry_status; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_adr_registry_status ON fhq_meta.adr_registry USING btree (adr_status);


--
-- Name: idx_adr_registry_tier; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_adr_registry_tier ON fhq_meta.adr_registry USING btree (governance_tier);


--
-- Name: idx_adr_registry_type; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_adr_registry_type ON fhq_meta.adr_registry USING btree (adr_type);


--
-- Name: idx_adr_staging_adr; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_adr_staging_adr ON fhq_meta.adr_ingestion_staging USING btree (adr_id);


--
-- Name: idx_adr_staging_adr_id; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_adr_staging_adr_id ON fhq_meta.adr_ingestion_staging USING btree (adr_id);


--
-- Name: idx_adr_staging_status; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_adr_staging_status ON fhq_meta.adr_ingestion_staging USING btree (status);


--
-- Name: idx_adr_version_history_adr; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_adr_version_history_adr ON fhq_meta.adr_version_history USING btree (adr_id);


--
-- Name: idx_adr_version_history_adr_id; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_adr_version_history_adr_id ON fhq_meta.adr_version_history USING btree (adr_id);


--
-- Name: idx_adr_version_history_canonical; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_adr_version_history_canonical ON fhq_meta.adr_version_history USING btree (adr_id, canonical_version) WHERE (canonical_version = true);


--
-- Name: idx_adr_version_unique; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE UNIQUE INDEX idx_adr_version_unique ON fhq_meta.adr_version_history USING btree (adr_id, version);


--
-- Name: idx_agent_keys_agent; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_agent_keys_agent ON fhq_meta.agent_keys USING btree (agent_id);


--
-- Name: idx_agent_keys_attested; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_agent_keys_attested ON fhq_meta.agent_keys USING btree (vega_attested);


--
-- Name: idx_agent_keys_ceremony; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_agent_keys_ceremony ON fhq_meta.agent_keys USING btree (ceremony_id);


--
-- Name: idx_agent_keys_public_key; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_agent_keys_public_key ON fhq_meta.agent_keys USING btree (public_key_hex);


--
-- Name: idx_agent_keys_state; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_agent_keys_state ON fhq_meta.agent_keys USING btree (key_state);


--
-- Name: idx_ai_created; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_ai_created ON fhq_meta.agent_interaction_log USING btree (created_at DESC);


--
-- Name: idx_ai_session; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_ai_session ON fhq_meta.agent_interaction_log USING btree (session_id);


--
-- Name: idx_ai_state; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_ai_state ON fhq_meta.agent_interaction_log USING btree (state_snapshot_hash);


--
-- Name: idx_ai_status; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_ai_status ON fhq_meta.agent_interaction_log USING btree (status);


--
-- Name: idx_api_schema_provider; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_api_schema_provider ON fhq_meta.api_schema_registry USING btree (provider);


--
-- Name: idx_api_schema_status; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_api_schema_status ON fhq_meta.api_schema_registry USING btree (status);


--
-- Name: idx_api_schema_verified; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_api_schema_verified ON fhq_meta.api_schema_registry USING btree (verified_date);


--
-- Name: idx_assets_active; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_assets_active ON fhq_meta.assets USING btree (active_flag) WHERE (active_flag = true);


--
-- Name: idx_assets_exchange_mic; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_assets_exchange_mic ON fhq_meta.assets USING btree (exchange_mic);


--
-- Name: idx_assets_ticker; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_assets_ticker ON fhq_meta.assets USING btree (ticker);


--
-- Name: idx_baseline_locks_scope; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_baseline_locks_scope ON fhq_meta.baseline_locks USING btree (lock_scope);


--
-- Name: idx_baseline_locks_type; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_baseline_locks_type ON fhq_meta.baseline_locks USING btree (lock_type);


--
-- Name: idx_baseline_registry_model; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_baseline_registry_model ON fhq_meta.baseline_registry USING btree (model_id);


--
-- Name: idx_canonical_access_agent; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_access_agent ON fhq_meta.canonical_access_log USING btree (agent_id);


--
-- Name: idx_canonical_access_bypass; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_access_bypass ON fhq_meta.canonical_access_log USING btree (bypass_attempted) WHERE (bypass_attempted = true);


--
-- Name: idx_canonical_access_domain; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_access_domain ON fhq_meta.canonical_access_log USING btree (domain_name);


--
-- Name: idx_canonical_access_timestamp; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_access_timestamp ON fhq_meta.canonical_access_log USING btree (access_timestamp DESC);


--
-- Name: idx_canonical_access_unauthorized; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_access_unauthorized ON fhq_meta.canonical_access_log USING btree (access_authorized) WHERE (access_authorized = false);


--
-- Name: idx_canonical_docs_code; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_docs_code ON fhq_meta.canonical_documents USING btree (document_code);


--
-- Name: idx_canonical_docs_content_fts; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_docs_content_fts ON fhq_meta.canonical_documents USING gin (to_tsvector('english'::regconfig, COALESCE(content_text, ''::text)));


--
-- Name: idx_canonical_docs_governing; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_docs_governing ON fhq_meta.canonical_documents USING gin (governing_adrs);


--
-- Name: idx_canonical_docs_hash; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_docs_hash ON fhq_meta.canonical_documents USING btree (content_hash);


--
-- Name: idx_canonical_docs_owner; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_docs_owner ON fhq_meta.canonical_documents USING btree (owner);


--
-- Name: idx_canonical_docs_status; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_docs_status ON fhq_meta.canonical_documents USING btree (status);


--
-- Name: idx_canonical_docs_type; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_docs_type ON fhq_meta.canonical_documents USING btree (document_type);


--
-- Name: idx_canonical_domain_active; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_domain_active ON fhq_meta.canonical_domain_registry USING btree (is_active);


--
-- Name: idx_canonical_domain_category; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_domain_category ON fhq_meta.canonical_domain_registry USING btree (domain_category);


--
-- Name: idx_canonical_domain_name; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_domain_name ON fhq_meta.canonical_domain_registry USING btree (domain_name);


--
-- Name: idx_canonical_domain_store; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_domain_store ON fhq_meta.canonical_domain_registry USING btree (canonical_store);


--
-- Name: idx_canonical_indicator_active; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_indicator_active ON fhq_meta.canonical_indicator_registry USING btree (is_active);


--
-- Name: idx_canonical_indicator_domain; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_indicator_domain ON fhq_meta.canonical_indicator_registry USING btree (domain_id);


--
-- Name: idx_canonical_indicator_name; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_indicator_name ON fhq_meta.canonical_indicator_registry USING btree (indicator_name);


--
-- Name: idx_canonical_ingestion_active; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_ingestion_active ON fhq_meta.canonical_ingestion_registry USING btree (is_active);


--
-- Name: idx_canonical_ingestion_domain; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_ingestion_domain ON fhq_meta.canonical_ingestion_registry USING btree (domain_id);


--
-- Name: idx_canonical_ingestion_orchestrator; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_ingestion_orchestrator ON fhq_meta.canonical_ingestion_registry USING btree (orchestrator_registered);


--
-- Name: idx_canonical_mismatches_severity; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_mismatches_severity ON fhq_meta.canonical_mismatches USING btree (severity);


--
-- Name: idx_canonical_mismatches_status; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_mismatches_status ON fhq_meta.canonical_mismatches USING btree (resolution_status);


--
-- Name: idx_canonical_mismatches_type; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_mismatches_type ON fhq_meta.canonical_mismatches USING btree (mismatch_type);


--
-- Name: idx_canonical_series_active; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_series_active ON fhq_meta.canonical_series_registry USING btree (is_active);


--
-- Name: idx_canonical_series_asset; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_series_asset ON fhq_meta.canonical_series_registry USING btree (asset_id);


--
-- Name: idx_canonical_series_domain; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_series_domain ON fhq_meta.canonical_series_registry USING btree (domain_id);


--
-- Name: idx_canonical_series_frequency; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_series_frequency ON fhq_meta.canonical_series_registry USING btree (frequency);


--
-- Name: idx_canonical_violation_class; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_violation_class ON fhq_meta.canonical_violation_log USING btree (discrepancy_class);


--
-- Name: idx_canonical_violation_escalated; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_violation_escalated ON fhq_meta.canonical_violation_log USING btree (vega_escalated) WHERE (vega_escalated = true);


--
-- Name: idx_canonical_violation_open; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_violation_open ON fhq_meta.canonical_violation_log USING btree (resolution_status) WHERE (resolution_status = 'OPEN'::text);


--
-- Name: idx_canonical_violation_status; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_violation_status ON fhq_meta.canonical_violation_log USING btree (resolution_status);


--
-- Name: idx_canonical_violation_timestamp; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_canonical_violation_timestamp ON fhq_meta.canonical_violation_log USING btree (violation_timestamp DESC);


--
-- Name: idx_ce_created; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_ce_created ON fhq_meta.cognitive_engine_evidence USING btree (created_at DESC);


--
-- Name: idx_ce_engine; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_ce_engine ON fhq_meta.cognitive_engine_evidence USING btree (engine_id);


--
-- Name: idx_ce_interaction; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_ce_interaction ON fhq_meta.cognitive_engine_evidence USING btree (interaction_id);


--
-- Name: idx_coq_created; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_coq_created ON fhq_meta.chain_of_query USING btree (created_at DESC);


--
-- Name: idx_coq_interaction; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_coq_interaction ON fhq_meta.chain_of_query USING btree (interaction_id);


--
-- Name: idx_coq_node_type; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_coq_node_type ON fhq_meta.chain_of_query USING btree (node_type);


--
-- Name: idx_coq_verification; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_coq_verification ON fhq_meta.chain_of_query USING btree (verification_status);


--
-- Name: idx_cot_logs_agent; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_cot_logs_agent ON fhq_meta.cot_reasoning_logs USING btree (agent_id);


--
-- Name: idx_cot_logs_audit; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_cot_logs_audit ON fhq_meta.cot_reasoning_logs USING btree (vega_audit_status);


--
-- Name: idx_cot_logs_chain; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_cot_logs_chain ON fhq_meta.cot_reasoning_logs USING btree (reasoning_chain_id);


--
-- Name: idx_data_lineage_log_source; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_data_lineage_log_source ON fhq_meta.data_lineage_log USING btree (source_table, source_id);


--
-- Name: idx_data_lineage_log_target; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_data_lineage_log_target ON fhq_meta.data_lineage_log USING btree (target_table, target_id);


--
-- Name: idx_ddr_document; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_ddr_document ON fhq_meta.document_database_reconciliation USING btree (document_id);


--
-- Name: idx_ddr_severity; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_ddr_severity ON fhq_meta.document_database_reconciliation USING btree (divergence_severity);


--
-- Name: idx_ddr_status; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_ddr_status ON fhq_meta.document_database_reconciliation USING btree (alignment_status);


--
-- Name: idx_ddr_type; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_ddr_type ON fhq_meta.document_database_reconciliation USING btree (reconciliation_type);


--
-- Name: idx_document_claims_document; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_document_claims_document ON fhq_meta.document_claims USING btree (document_id);


--
-- Name: idx_document_claims_status; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_document_claims_status ON fhq_meta.document_claims USING btree (verification_status);


--
-- Name: idx_document_claims_type; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_document_claims_type ON fhq_meta.document_claims USING btree (claim_type);


--
-- Name: idx_dynamic_weights_asset; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_dynamic_weights_asset ON fhq_meta.dynamic_regime_weights USING btree (asset_id);


--
-- Name: idx_dynamic_weights_calibration; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_dynamic_weights_calibration ON fhq_meta.dynamic_regime_weights USING btree (calibration_id);


--
-- Name: idx_dynamic_weights_date; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_dynamic_weights_date ON fhq_meta.dynamic_regime_weights USING btree (calibration_date DESC);


--
-- Name: idx_dynamic_weights_listing_date; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_dynamic_weights_listing_date ON fhq_meta.dynamic_regime_weights_audit USING btree (listing_id, calibration_date DESC);


--
-- Name: idx_ec_auth_res_agent; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_ec_auth_res_agent ON fhq_meta.ec_authority_resolutions USING btree (agent_id);


--
-- Name: idx_ec_auth_res_directive; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_ec_auth_res_directive ON fhq_meta.ec_authority_resolutions USING btree (directive_id);


--
-- Name: idx_ec_auth_res_ec; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_ec_auth_res_ec ON fhq_meta.ec_authority_resolutions USING btree (ec_id);


--
-- Name: idx_family_members_family; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_family_members_family ON fhq_meta.strategy_family_members USING btree (family_id);


--
-- Name: idx_family_members_strategy; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_family_members_strategy ON fhq_meta.strategy_family_members USING btree (strategy_id);


--
-- Name: idx_function_registry_hash; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_function_registry_hash ON fhq_meta.function_registry USING btree (canonical_hash);


--
-- Name: idx_function_registry_owner; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_function_registry_owner ON fhq_meta.function_registry USING btree (owned_by_agent);


--
-- Name: idx_function_registry_schema_name; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_function_registry_schema_name ON fhq_meta.function_registry USING btree (function_schema, function_name);


--
-- Name: idx_function_registry_status; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_function_registry_status ON fhq_meta.function_registry USING btree (registry_status);


--
-- Name: idx_function_registry_task; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_function_registry_task ON fhq_meta.function_registry USING btree (task_name);


--
-- Name: idx_g1_alpha_evidence_evaluator; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_g1_alpha_evidence_evaluator ON fhq_meta.g1_alpha_evidence USING btree (evaluator);


--
-- Name: idx_g1_alpha_evidence_session; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_g1_alpha_evidence_session ON fhq_meta.g1_alpha_evidence USING btree (session_id);


--
-- Name: idx_g1_alpha_evidence_timestamp; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_g1_alpha_evidence_timestamp ON fhq_meta.g1_alpha_evidence USING btree ("timestamp");


--
-- Name: idx_g1_snapshot_date; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_g1_snapshot_date ON fhq_meta.g1_evidence_daily_snapshot USING btree (snapshot_date);


--
-- Name: idx_hre_created; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_hre_created ON fhq_meta.hallucination_rejection_events USING btree (created_at DESC);


--
-- Name: idx_hre_interaction; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_hre_interaction ON fhq_meta.hallucination_rejection_events USING btree (interaction_id);


--
-- Name: idx_hre_severity; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_hre_severity ON fhq_meta.hallucination_rejection_events USING btree (severity);


--
-- Name: idx_hre_type; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_hre_type ON fhq_meta.hallucination_rejection_events USING btree (rejection_type);


--
-- Name: idx_identity_snapshots_attested; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_identity_snapshots_attested ON fhq_meta.identity_state_snapshots USING btree (vega_attested);


--
-- Name: idx_identity_snapshots_ceremony; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_identity_snapshots_ceremony ON fhq_meta.identity_state_snapshots USING btree (ceremony_id);


--
-- Name: idx_indicator_ace_family; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_indicator_ace_family ON fhq_meta.indicator_definitions USING btree (ace_family);


--
-- Name: idx_indicator_active; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_indicator_active ON fhq_meta.indicator_definitions USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_indicator_category; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_indicator_category ON fhq_meta.indicator_definitions USING btree (category);


--
-- Name: idx_indicator_display_priority; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_indicator_display_priority ON fhq_meta.indicator_definitions USING btree (display_priority);


--
-- Name: idx_ios_appendix_registry_ios; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_ios_appendix_registry_ios ON fhq_meta.ios_appendix_registry USING btree (ios_id);


--
-- Name: idx_kb_classification; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_kb_classification ON fhq_meta.knowledge_boundary_log USING btree (classification);


--
-- Name: idx_kb_created; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_kb_created ON fhq_meta.knowledge_boundary_log USING btree (created_at DESC);


--
-- Name: idx_kb_hallucination; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_kb_hallucination ON fhq_meta.knowledge_boundary_log USING btree (hallucination_blocked);


--
-- Name: idx_kb_interaction; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_kb_interaction ON fhq_meta.knowledge_boundary_log USING btree (interaction_id);


--
-- Name: idx_key_archival_log_agent; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_key_archival_log_agent ON fhq_meta.key_archival_log USING btree (agent_id);


--
-- Name: idx_key_archival_log_key; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_key_archival_log_key ON fhq_meta.key_archival_log USING btree (key_id);


--
-- Name: idx_key_archival_log_timestamp; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_key_archival_log_timestamp ON fhq_meta.key_archival_log USING btree ("timestamp" DESC);


--
-- Name: idx_key_ceremonies_status; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_key_ceremonies_status ON fhq_meta.key_ceremonies USING btree (ceremony_status);


--
-- Name: idx_key_ceremonies_type; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_key_ceremonies_type ON fhq_meta.key_ceremonies USING btree (ceremony_type);


--
-- Name: idx_lsa_batch; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_lsa_batch ON fhq_meta.learning_state_artifacts USING btree (batch_id);


--
-- Name: idx_lsa_canonical; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_lsa_canonical ON fhq_meta.learning_state_artifacts USING btree (is_canonical) WHERE (is_canonical = true);


--
-- Name: idx_model_certifications_model; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_model_certifications_model ON fhq_meta.model_certifications USING btree (model_name, model_version);


--
-- Name: idx_model_certifications_status; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_model_certifications_status ON fhq_meta.model_certifications USING btree (certification_status);


--
-- Name: idx_model_context_canonical_id; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_model_context_canonical_id ON fhq_meta.model_context_registry USING btree (canonical_id);


--
-- Name: idx_model_context_regime; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_model_context_regime ON fhq_meta.model_context_registry USING btree (regime_model_ref);


--
-- Name: idx_model_registry_status; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_model_registry_status ON fhq_meta.model_registry USING btree (status);


--
-- Name: idx_narrative_vectors_active; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_narrative_vectors_active ON fhq_meta.narrative_vectors USING btree (created_at, half_life_hours) WHERE (is_expired = false);


--
-- Name: idx_narrative_vectors_created_at; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_narrative_vectors_created_at ON fhq_meta.narrative_vectors USING btree (created_at DESC);


--
-- Name: idx_narrative_vectors_domain; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_narrative_vectors_domain ON fhq_meta.narrative_vectors USING btree (domain);


--
-- Name: idx_pamphlets_active; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_pamphlets_active ON fhq_meta.finn_pamphlets USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_pamphlets_regime; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_pamphlets_regime ON fhq_meta.finn_pamphlets USING gin (regime_tags);


--
-- Name: idx_pamphlets_trigger; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_pamphlets_trigger ON fhq_meta.finn_pamphlets USING btree (trigger_type);


--
-- Name: idx_pamphlets_volatility; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_pamphlets_volatility ON fhq_meta.finn_pamphlets USING btree (volatility_band);


--
-- Name: idx_sf_created; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_sf_created ON fhq_meta.search_foraging_log USING btree (created_at DESC);


--
-- Name: idx_sf_executed; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_sf_executed ON fhq_meta.search_foraging_log USING btree (search_executed);


--
-- Name: idx_sf_interaction; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_sf_interaction ON fhq_meta.search_foraging_log USING btree (interaction_id);


--
-- Name: idx_sf_termination; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_sf_termination ON fhq_meta.search_foraging_log USING btree (termination_reason);


--
-- Name: idx_tickers_active_mic; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_tickers_active_mic ON fhq_meta.tickers USING btree (mic, is_active);


--
-- Name: idx_tickers_is_active; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_tickers_is_active ON fhq_meta.tickers USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_tickers_isin; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_tickers_isin ON fhq_meta.tickers USING btree (isin);


--
-- Name: idx_tickers_mic; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_tickers_mic ON fhq_meta.tickers USING btree (mic);


--
-- Name: idx_tickers_rate_limit_group; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_tickers_rate_limit_group ON fhq_meta.tickers USING btree (rate_limit_group);


--
-- Name: idx_tickers_yahoo_symbol; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_tickers_yahoo_symbol ON fhq_meta.tickers USING btree (yahoo_symbol);


--
-- Name: idx_tool_created; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_tool_created ON fhq_meta.tool_usage_log USING btree (created_at DESC);


--
-- Name: idx_tool_interaction; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_tool_interaction ON fhq_meta.tool_usage_log USING btree (interaction_id);


--
-- Name: idx_tool_name; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_tool_name ON fhq_meta.tool_usage_log USING btree (tool_name);


--
-- Name: idx_tool_status; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_tool_status ON fhq_meta.tool_usage_log USING btree (execution_status);


--
-- Name: idx_vega_attestations_hash; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_vega_attestations_hash ON fhq_meta.vega_attestations USING btree (function_hash);


--
-- Name: idx_vega_attestations_revoked; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_vega_attestations_revoked ON fhq_meta.vega_attestations USING btree (revoked);


--
-- Name: idx_vega_attestations_status; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_vega_attestations_status ON fhq_meta.vega_attestations USING btree (attestation_status);


--
-- Name: idx_vega_attestations_target; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_vega_attestations_target ON fhq_meta.vega_attestations USING btree (attestation_target);


--
-- Name: idx_vega_attestations_type; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_vega_attestations_type ON fhq_meta.vega_attestations USING btree (attestation_type);


--
-- Name: idx_vega_sovereignty_log_component; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_vega_sovereignty_log_component ON fhq_meta.vega_sovereignty_log USING btree (component_name);


--
-- Name: idx_vega_sovereignty_log_timestamp; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_vega_sovereignty_log_timestamp ON fhq_meta.vega_sovereignty_log USING btree ("timestamp" DESC);


--
-- Name: idx_vendor_limits_active; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_vendor_limits_active ON fhq_meta.vendor_limits USING btree (is_active);


--
-- Name: idx_vendor_limits_domains; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_vendor_limits_domains ON fhq_meta.vendor_limits USING gin (data_domains);


--
-- Name: idx_vendor_limits_tier; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_vendor_limits_tier ON fhq_meta.vendor_limits USING btree (tier);


--
-- Name: idx_vendor_usage_interval; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_vendor_usage_interval ON fhq_meta.vendor_usage_counters USING btree (interval_start);


--
-- Name: idx_vendor_usage_vendor; Type: INDEX; Schema: fhq_meta; Owner: -
--

CREATE INDEX idx_vendor_usage_vendor ON fhq_meta.vendor_usage_counters USING btree (vendor_id);


--
-- Name: idx_org_activity_log_agent; Type: INDEX; Schema: fhq_org; Owner: -
--

CREATE INDEX idx_org_activity_log_agent ON fhq_org.org_activity_log USING btree (agent_id);


--
-- Name: idx_org_activity_log_event_type; Type: INDEX; Schema: fhq_org; Owner: -
--

CREATE INDEX idx_org_activity_log_event_type ON fhq_org.org_activity_log USING btree (event_type);


--
-- Name: idx_org_activity_log_idempotency; Type: INDEX; Schema: fhq_org; Owner: -
--

CREATE INDEX idx_org_activity_log_idempotency ON fhq_org.org_activity_log USING btree (idempotency_key);


--
-- Name: idx_org_activity_log_timestamp; Type: INDEX; Schema: fhq_org; Owner: -
--

CREATE INDEX idx_org_activity_log_timestamp ON fhq_org.org_activity_log USING btree ("timestamp" DESC);


--
-- Name: idx_org_agents_name; Type: INDEX; Schema: fhq_org; Owner: -
--

CREATE INDEX idx_org_agents_name ON fhq_org.org_agents USING btree (agent_name);


--
-- Name: idx_org_agents_status; Type: INDEX; Schema: fhq_org; Owner: -
--

CREATE INDEX idx_org_agents_status ON fhq_org.org_agents USING btree (status);


--
-- Name: idx_org_memory_agent; Type: INDEX; Schema: fhq_org; Owner: -
--

CREATE INDEX idx_org_memory_agent ON fhq_org.org_memory USING btree (agent_id);


--
-- Name: idx_org_memory_relevance; Type: INDEX; Schema: fhq_org; Owner: -
--

CREATE INDEX idx_org_memory_relevance ON fhq_org.org_memory USING btree (relevance_score DESC);


--
-- Name: idx_org_memory_source_event; Type: INDEX; Schema: fhq_org; Owner: -
--

CREATE INDEX idx_org_memory_source_event ON fhq_org.org_memory USING btree (source_event_id);


--
-- Name: idx_org_state_reconciliation_agent; Type: INDEX; Schema: fhq_org; Owner: -
--

CREATE INDEX idx_org_state_reconciliation_agent ON fhq_org.org_state_reconciliation USING btree (agent_id);


--
-- Name: idx_org_state_reconciliation_discrepancy; Type: INDEX; Schema: fhq_org; Owner: -
--

CREATE INDEX idx_org_state_reconciliation_discrepancy ON fhq_org.org_state_reconciliation USING btree (discrepancy_score DESC);


--
-- Name: idx_org_state_reconciliation_unresolved; Type: INDEX; Schema: fhq_org; Owner: -
--

CREATE INDEX idx_org_state_reconciliation_unresolved ON fhq_org.org_state_reconciliation USING btree (is_resolved) WHERE (is_resolved = false);


--
-- Name: idx_org_tasks_agent; Type: INDEX; Schema: fhq_org; Owner: -
--

CREATE INDEX idx_org_tasks_agent ON fhq_org.org_tasks USING btree (agent_id);


--
-- Name: idx_org_tasks_idempotency; Type: INDEX; Schema: fhq_org; Owner: -
--

CREATE INDEX idx_org_tasks_idempotency ON fhq_org.org_tasks USING btree (idempotency_key);


--
-- Name: idx_org_tasks_priority; Type: INDEX; Schema: fhq_org; Owner: -
--

CREATE INDEX idx_org_tasks_priority ON fhq_org.org_tasks USING btree (priority DESC, created_at);


--
-- Name: idx_org_tasks_status; Type: INDEX; Schema: fhq_org; Owner: -
--

CREATE INDEX idx_org_tasks_status ON fhq_org.org_tasks USING btree (status);


--
-- Name: idx_deployment_agent; Type: INDEX; Schema: fhq_security; Owner: -
--

CREATE INDEX idx_deployment_agent ON fhq_security.key_deployment_log USING btree (agent_id);


--
-- Name: idx_deployment_event; Type: INDEX; Schema: fhq_security; Owner: -
--

CREATE INDEX idx_deployment_event ON fhq_security.key_deployment_log USING btree (deployment_event);


--
-- Name: idx_keystore_active; Type: INDEX; Schema: fhq_security; Owner: -
--

CREATE INDEX idx_keystore_active ON fhq_security.keystore USING btree (is_active);


--
-- Name: idx_keystore_agent; Type: INDEX; Schema: fhq_security; Owner: -
--

CREATE INDEX idx_keystore_agent ON fhq_security.keystore USING btree (agent_id);


--
-- Name: idx_keystore_agent_active; Type: INDEX; Schema: fhq_security; Owner: -
--

CREATE UNIQUE INDEX idx_keystore_agent_active ON fhq_security.keystore USING btree (agent_id) WHERE (is_active = true);


--
-- Name: idx_action_veto_agent; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_action_veto_agent ON vega.action_level_veto USING btree (requesting_agent);


--
-- Name: idx_action_veto_decision; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_action_veto_decision ON vega.action_level_veto USING btree (veto_decision);


--
-- Name: idx_action_veto_timestamp; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_action_veto_timestamp ON vega.action_level_veto USING btree (evaluation_timestamp);


--
-- Name: idx_llm_config_status; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_config_status ON vega.llm_economic_safety_config USING btree (config_status);


--
-- Name: idx_llm_cost_limits_active; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_cost_limits_active ON vega.llm_cost_limits USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_llm_cost_limits_agent; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_cost_limits_agent ON vega.llm_cost_limits USING btree (agent_id);


--
-- Name: idx_llm_cost_limits_provider; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_cost_limits_provider ON vega.llm_cost_limits USING btree (provider);


--
-- Name: idx_llm_execution_limits_active; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_execution_limits_active ON vega.llm_execution_limits USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_llm_execution_limits_agent; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_execution_limits_agent ON vega.llm_execution_limits USING btree (agent_id);


--
-- Name: idx_llm_rate_limits_active; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_rate_limits_active ON vega.llm_rate_limits USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_llm_rate_limits_agent; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_rate_limits_agent ON vega.llm_rate_limits USING btree (agent_id);


--
-- Name: idx_llm_rate_limits_provider; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_rate_limits_provider ON vega.llm_rate_limits USING btree (provider);


--
-- Name: idx_llm_usage_log_agent; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_usage_log_agent ON vega.llm_usage_log USING btree (agent_id);


--
-- Name: idx_llm_usage_log_cycle; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_usage_log_cycle ON vega.llm_usage_log USING btree (cycle_id) WHERE (cycle_id IS NOT NULL);


--
-- Name: idx_llm_usage_log_mode; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_usage_log_mode ON vega.llm_usage_log USING btree (mode);


--
-- Name: idx_llm_usage_log_provider; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_usage_log_provider ON vega.llm_usage_log USING btree (provider);


--
-- Name: idx_llm_usage_log_task; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_usage_log_task ON vega.llm_usage_log USING btree (task_id) WHERE (task_id IS NOT NULL);


--
-- Name: idx_llm_usage_log_timestamp; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_usage_log_timestamp ON vega.llm_usage_log USING btree ("timestamp" DESC);


--
-- Name: idx_llm_violation_events_action; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_violation_events_action ON vega.llm_violation_events USING btree (governance_action);


--
-- Name: idx_llm_violation_events_agent; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_violation_events_agent ON vega.llm_violation_events USING btree (agent_id);


--
-- Name: idx_llm_violation_events_hash_chain; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_violation_events_hash_chain ON vega.llm_violation_events USING btree (hash_prev);


--
-- Name: idx_llm_violation_events_severity; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_violation_events_severity ON vega.llm_violation_events USING btree (severity);


--
-- Name: idx_llm_violation_events_timestamp; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_violation_events_timestamp ON vega.llm_violation_events USING btree ("timestamp" DESC);


--
-- Name: idx_llm_violation_events_type; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_violation_events_type ON vega.llm_violation_events USING btree (violation_type);


--
-- Name: idx_llm_violation_events_unresolved; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_llm_violation_events_unresolved ON vega.llm_violation_events USING btree (is_resolved) WHERE (is_resolved = false);


--
-- Name: idx_vega_agent_execution_agent; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_vega_agent_execution_agent ON vega.agent_test_execution USING btree (agent_id);


--
-- Name: idx_vega_agent_execution_run; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_vega_agent_execution_run ON vega.agent_test_execution USING btree (run_id);


--
-- Name: idx_vega_agent_execution_status; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_vega_agent_execution_status ON vega.agent_test_execution USING btree (integration_status);


--
-- Name: idx_vega_api_tests_endpoint; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_vega_api_tests_endpoint ON vega.api_endpoint_tests USING btree (endpoint_path, endpoint_method);


--
-- Name: idx_vega_api_tests_run; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_vega_api_tests_run ON vega.api_endpoint_tests USING btree (run_id);


--
-- Name: idx_vega_api_tests_status; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_vega_api_tests_status ON vega.api_endpoint_tests USING btree (test_status);


--
-- Name: idx_vega_quality_gates_code; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_vega_quality_gates_code ON vega.quality_gate_results USING btree (gate_code);


--
-- Name: idx_vega_quality_gates_run; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_vega_quality_gates_run ON vega.quality_gate_results USING btree (run_id);


--
-- Name: idx_vega_quality_gates_status; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_vega_quality_gates_status ON vega.quality_gate_results USING btree (gate_status);


--
-- Name: idx_vega_test_coverage_module; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_vega_test_coverage_module ON vega.test_coverage USING btree (module_name);


--
-- Name: idx_vega_test_coverage_run; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_vega_test_coverage_run ON vega.test_coverage USING btree (run_id);


--
-- Name: idx_vega_test_coverage_threshold; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_vega_test_coverage_threshold ON vega.test_coverage USING btree (meets_threshold);


--
-- Name: idx_vega_test_failures_module; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_vega_test_failures_module ON vega.test_failures USING btree (test_module);


--
-- Name: idx_vega_test_failures_run; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_vega_test_failures_run ON vega.test_failures USING btree (run_id);


--
-- Name: idx_vega_test_failures_status; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_vega_test_failures_status ON vega.test_failures USING btree (resolution_status);


--
-- Name: idx_vega_test_runs_attested; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_vega_test_runs_attested ON vega.test_runs USING btree (vega_attested);


--
-- Name: idx_vega_test_runs_status; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_vega_test_runs_status ON vega.test_runs USING btree (run_status);


--
-- Name: idx_vega_test_runs_timestamp; Type: INDEX; Schema: vega; Owner: -
--

CREATE INDEX idx_vega_test_runs_timestamp ON vega.test_runs USING btree (run_timestamp DESC);


--
-- Name: idx_governance_decision_type; Type: INDEX; Schema: vision_autonomy; Owner: -
--

CREATE INDEX idx_governance_decision_type ON vision_autonomy.governance_decisions USING btree (decision_type);


--
-- Name: idx_governance_gate; Type: INDEX; Schema: vision_autonomy; Owner: -
--

CREATE INDEX idx_governance_gate ON vision_autonomy.governance_decisions USING btree (gate_level, gate_passed);


--
-- Name: idx_governance_vega; Type: INDEX; Schema: vision_autonomy; Owner: -
--

CREATE INDEX idx_governance_vega ON vision_autonomy.governance_decisions USING btree (vega_reviewed, vega_approved);


--
-- Name: idx_meta_sync_status; Type: INDEX; Schema: vision_autonomy; Owner: -
--

CREATE INDEX idx_meta_sync_status ON vision_autonomy.meta_state_sync USING btree (sync_status);


--
-- Name: idx_meta_sync_timestamp; Type: INDEX; Schema: vision_autonomy; Owner: -
--

CREATE INDEX idx_meta_sync_timestamp ON vision_autonomy.meta_state_sync USING btree (sync_timestamp);


--
-- Name: idx_meta_sync_type; Type: INDEX; Schema: vision_autonomy; Owner: -
--

CREATE INDEX idx_meta_sync_type ON vision_autonomy.meta_state_sync USING btree (sync_type);


--
-- Name: idx_events_asset; Type: INDEX; Schema: vision_cinematic; Owner: -
--

CREATE INDEX idx_events_asset ON vision_cinematic.cinematic_events USING btree (asset_id);


--
-- Name: idx_events_timestamp; Type: INDEX; Schema: vision_cinematic; Owner: -
--

CREATE INDEX idx_events_timestamp ON vision_cinematic.cinematic_events USING btree (event_timestamp DESC);


--
-- Name: idx_events_type; Type: INDEX; Schema: vision_cinematic; Owner: -
--

CREATE INDEX idx_events_type ON vision_cinematic.cinematic_events USING btree (event_type);


--
-- Name: idx_mapping_current; Type: INDEX; Schema: vision_cinematic; Owner: -
--

CREATE INDEX idx_mapping_current ON vision_cinematic.mapping_versions USING btree (is_current) WHERE (is_current = true);


--
-- Name: idx_render_timestamp; Type: INDEX; Schema: vision_cinematic; Owner: -
--

CREATE INDEX idx_render_timestamp ON vision_cinematic.render_evidence USING btree (frame_timestamp DESC);


--
-- Name: idx_render_vsv; Type: INDEX; Schema: vision_cinematic; Owner: -
--

CREATE INDEX idx_render_vsv ON vision_cinematic.render_evidence USING btree (vsv_id);


--
-- Name: idx_vsv_asset_id; Type: INDEX; Schema: vision_cinematic; Owner: -
--

CREATE INDEX idx_vsv_asset_id ON vision_cinematic.visual_state_vectors USING btree (asset_id);


--
-- Name: idx_vsv_defcon; Type: INDEX; Schema: vision_cinematic; Owner: -
--

CREATE INDEX idx_vsv_defcon ON vision_cinematic.visual_state_vectors USING btree (defcon_level);


--
-- Name: idx_vsv_timestamp; Type: INDEX; Schema: vision_cinematic; Owner: -
--

CREATE INDEX idx_vsv_timestamp ON vision_cinematic.visual_state_vectors USING btree ("timestamp" DESC);


--
-- Name: idx_execution_state_component; Type: INDEX; Schema: vision_core; Owner: -
--

CREATE INDEX idx_execution_state_component ON vision_core.execution_state USING btree (component_name);


--
-- Name: idx_execution_state_type; Type: INDEX; Schema: vision_core; Owner: -
--

CREATE INDEX idx_execution_state_type ON vision_core.execution_state USING btree (state_type);


--
-- Name: idx_live_mode_activations_status; Type: INDEX; Schema: vision_core; Owner: -
--

CREATE INDEX idx_live_mode_activations_status ON vision_core.live_mode_activations USING btree (activation_status);


--
-- Name: idx_live_mode_activations_timestamp; Type: INDEX; Schema: vision_core; Owner: -
--

CREATE INDEX idx_live_mode_activations_timestamp ON vision_core.live_mode_activations USING btree (activation_timestamp DESC);


--
-- Name: idx_live_mode_auth_decision; Type: INDEX; Schema: vision_core; Owner: -
--

CREATE INDEX idx_live_mode_auth_decision ON vision_core.live_mode_authorizations USING btree (authorization_decision);


--
-- Name: idx_live_mode_auth_proposal; Type: INDEX; Schema: vision_core; Owner: -
--

CREATE INDEX idx_live_mode_auth_proposal ON vision_core.live_mode_authorizations USING btree (proposal_id);


--
-- Name: idx_live_mode_proposals_status; Type: INDEX; Schema: vision_core; Owner: -
--

CREATE INDEX idx_live_mode_proposals_status ON vision_core.live_mode_proposals USING btree (proposal_status);


--
-- Name: idx_live_mode_proposals_timestamp; Type: INDEX; Schema: vision_core; Owner: -
--

CREATE INDEX idx_live_mode_proposals_timestamp ON vision_core.live_mode_proposals USING btree (proposal_timestamp DESC);


--
-- Name: idx_live_mode_reviews_decision; Type: INDEX; Schema: vision_core; Owner: -
--

CREATE INDEX idx_live_mode_reviews_decision ON vision_core.live_mode_reviews USING btree (review_decision);


--
-- Name: idx_live_mode_reviews_proposal; Type: INDEX; Schema: vision_core; Owner: -
--

CREATE INDEX idx_live_mode_reviews_proposal ON vision_core.live_mode_reviews USING btree (proposal_id);


--
-- Name: idx_noise_profile_timestamp; Type: INDEX; Schema: vision_core; Owner: -
--

CREATE INDEX idx_noise_profile_timestamp ON vision_core.noise_profile USING btree (analysis_timestamp);


--
-- Name: idx_noise_profile_window; Type: INDEX; Schema: vision_core; Owner: -
--

CREATE INDEX idx_noise_profile_window ON vision_core.noise_profile USING btree (window_start, window_end);


--
-- Name: idx_alpha_signals_executable; Type: INDEX; Schema: vision_signals; Owner: -
--

CREATE INDEX idx_alpha_signals_executable ON vision_signals.alpha_signals USING btree (is_executable);


--
-- Name: idx_alpha_signals_generated; Type: INDEX; Schema: vision_signals; Owner: -
--

CREATE INDEX idx_alpha_signals_generated ON vision_signals.alpha_signals USING btree (generated_at);


--
-- Name: idx_alpha_signals_type; Type: INDEX; Schema: vision_signals; Owner: -
--

CREATE INDEX idx_alpha_signals_type ON vision_signals.alpha_signals USING btree (signal_type);


--
-- Name: idx_signal_baseline_name; Type: INDEX; Schema: vision_signals; Owner: -
--

CREATE INDEX idx_signal_baseline_name ON vision_signals.signal_baseline USING btree (signal_name);


--
-- Name: idx_signal_baseline_timestamp; Type: INDEX; Schema: vision_signals; Owner: -
--

CREATE INDEX idx_signal_baseline_timestamp ON vision_signals.signal_baseline USING btree (baseline_timestamp);


--
-- Name: idx_signal_baseline_type; Type: INDEX; Schema: vision_signals; Owner: -
--

CREATE INDEX idx_signal_baseline_type ON vision_signals.signal_baseline USING btree (signal_type);


--
-- Name: idx_attestation_created_at; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_attestation_created_at ON vision_verification.dashboard_truth_attestation USING btree (created_at DESC);


--
-- Name: idx_attestation_route_listing_date; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_attestation_route_listing_date ON vision_verification.dashboard_truth_attestation USING btree (route_path, listing_id, attestation_date DESC);


--
-- Name: idx_attestation_truth_hash; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_attestation_truth_hash ON vision_verification.dashboard_truth_attestation USING btree (truth_hash);


--
-- Name: idx_cee_agent; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_cee_agent ON vision_verification.cognitive_engine_evidence USING btree (generating_agent);


--
-- Name: idx_cee_synced; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_cee_synced ON vision_verification.cognitive_engine_evidence USING btree (synced_to_graph, created_at);


--
-- Name: idx_cee_type; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_cee_type ON vision_verification.cognitive_engine_evidence USING btree (evidence_type);


--
-- Name: idx_coverage_sentinel_status; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_coverage_sentinel_status ON vision_verification.regime_coverage_sentinel_log USING btree (status, check_timestamp DESC);


--
-- Name: idx_coverage_sentinel_timestamp; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_coverage_sentinel_timestamp ON vision_verification.regime_coverage_sentinel_log USING btree (check_timestamp DESC);


--
-- Name: idx_eqs_v2_hard_stop_time; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_eqs_v2_hard_stop_time ON vision_verification.eqs_v2_hard_stop_events USING btree (triggered_at DESC);


--
-- Name: idx_eqs_v2_log_hard_stop; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_eqs_v2_log_hard_stop ON vision_verification.eqs_v2_calculation_log USING btree (hard_stop_triggered) WHERE (hard_stop_triggered = true);


--
-- Name: idx_eqs_v2_log_needle; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_eqs_v2_log_needle ON vision_verification.eqs_v2_calculation_log USING btree (needle_id);


--
-- Name: idx_eqs_v2_log_time; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_eqs_v2_log_time ON vision_verification.eqs_v2_calculation_log USING btree (calculated_at DESC);


--
-- Name: idx_evl_evidence_id; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_evl_evidence_id ON vision_verification.evidence_verification_log USING btree (evidence_id);


--
-- Name: idx_evl_verified_at; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_evl_verified_at ON vision_verification.evidence_verification_log USING btree (verified_at);


--
-- Name: idx_hash_chains_integrity; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_hash_chains_integrity ON vision_verification.hash_chains USING btree (integrity_verified);


--
-- Name: idx_hash_chains_type; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_hash_chains_type ON vision_verification.hash_chains USING btree (chain_type);


--
-- Name: idx_operation_signatures_agent; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_operation_signatures_agent ON vision_verification.operation_signatures USING btree (signing_agent);


--
-- Name: idx_operation_signatures_chain; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_operation_signatures_chain ON vision_verification.operation_signatures USING btree (hash_chain_id);


--
-- Name: idx_operation_signatures_operation; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_operation_signatures_operation ON vision_verification.operation_signatures USING btree (operation_schema, operation_table, operation_id);


--
-- Name: idx_operation_signatures_verified; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_operation_signatures_verified ON vision_verification.operation_signatures USING btree (verified);


--
-- Name: idx_sel_created_at; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_sel_created_at ON vision_verification.summary_evidence_ledger USING btree (created_at);


--
-- Name: idx_sel_generating_agent; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_sel_generating_agent ON vision_verification.summary_evidence_ledger USING btree (generating_agent);


--
-- Name: idx_sel_query_result_hash; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_sel_query_result_hash ON vision_verification.summary_evidence_ledger USING btree (query_result_hash);


--
-- Name: idx_sel_summary_id; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_sel_summary_id ON vision_verification.summary_evidence_ledger USING btree (summary_id);


--
-- Name: idx_sel_summary_type; Type: INDEX; Schema: vision_verification; Owner: -
--

CREATE INDEX idx_sel_summary_type ON vision_verification.summary_evidence_ledger USING btree (summary_type);


--
-- Name: evidence_bundles tr_evidence_bundle_hash; Type: TRIGGER; Schema: fhq_canonical; Owner: -
--

CREATE TRIGGER tr_evidence_bundle_hash BEFORE INSERT ON fhq_canonical.evidence_bundles FOR EACH ROW EXECUTE FUNCTION fhq_canonical.evidence_bundle_hash_trigger();


--
-- Name: evidence_nodes tr_evidence_hash_chain; Type: TRIGGER; Schema: fhq_canonical; Owner: -
--

CREATE TRIGGER tr_evidence_hash_chain BEFORE INSERT ON fhq_canonical.evidence_nodes FOR EACH ROW EXECUTE FUNCTION fhq_canonical.evidence_hash_chain_trigger();


--
-- Name: golden_needles trg_block_needle_delete; Type: TRIGGER; Schema: fhq_canonical; Owner: -
--

CREATE TRIGGER trg_block_needle_delete BEFORE DELETE ON fhq_canonical.golden_needles FOR EACH ROW EXECUTE FUNCTION fhq_canonical.block_needle_deletion();


--
-- Name: eqs_distribution_snapshots trg_eqs_collapse_detection; Type: TRIGGER; Schema: fhq_canonical; Owner: -
--

CREATE TRIGGER trg_eqs_collapse_detection BEFORE INSERT OR UPDATE ON fhq_canonical.eqs_distribution_snapshots FOR EACH ROW EXECUTE FUNCTION fhq_canonical.detect_eqs_collapse();


--
-- Name: evidence_nodes trg_evidence_tsvector_update; Type: TRIGGER; Schema: fhq_canonical; Owner: -
--

CREATE TRIGGER trg_evidence_tsvector_update BEFORE INSERT OR UPDATE OF content ON fhq_canonical.evidence_nodes FOR EACH ROW EXECUTE FUNCTION fhq_canonical.update_evidence_tsvector();


--
-- Name: golden_needles trg_generate_needle_hash; Type: TRIGGER; Schema: fhq_canonical; Owner: -
--

CREATE TRIGGER trg_generate_needle_hash BEFORE INSERT ON fhq_canonical.golden_needles FOR EACH ROW EXECUTE FUNCTION fhq_canonical.generate_needle_hash();


--
-- Name: golden_needles trg_golden_needle_to_g4; Type: TRIGGER; Schema: fhq_canonical; Owner: -
--

CREATE TRIGGER trg_golden_needle_to_g4 AFTER INSERT ON fhq_canonical.golden_needles FOR EACH ROW EXECUTE FUNCTION fhq_canonical.fn_queue_needle_for_g4();


--
-- Name: golden_needles trg_needle_immutability; Type: TRIGGER; Schema: fhq_canonical; Owner: -
--

CREATE TRIGGER trg_needle_immutability BEFORE UPDATE ON fhq_canonical.golden_needles FOR EACH ROW EXECUTE FUNCTION fhq_canonical.enforce_needle_immutability();


--
-- Name: g4_2_parameters trg_protect_g4_2_parameters; Type: TRIGGER; Schema: fhq_canonical; Owner: -
--

CREATE TRIGGER trg_protect_g4_2_parameters BEFORE DELETE OR UPDATE ON fhq_canonical.g4_2_parameters FOR EACH ROW EXECUTE FUNCTION fhq_canonical.protect_g4_2_parameters();


--
-- Name: g5_paper_trades trg_sync_paper_trade_to_plps; Type: TRIGGER; Schema: fhq_canonical; Owner: -
--

CREATE TRIGGER trg_sync_paper_trade_to_plps AFTER INSERT ON fhq_canonical.g5_paper_trades FOR EACH ROW EXECUTE FUNCTION fhq_execution.sync_paper_trade_to_plps();


--
-- Name: serper_events trg_serper_event_audit; Type: TRIGGER; Schema: fhq_finn; Owner: -
--

CREATE TRIGGER trg_serper_event_audit AFTER INSERT ON fhq_finn.serper_events FOR EACH ROW EXECUTE FUNCTION fhq_finn.log_serper_event_insert();


--
-- Name: decision_log enforce_decision_log_immutability; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER enforce_decision_log_immutability BEFORE DELETE OR UPDATE ON fhq_governance.decision_log FOR EACH ROW EXECUTE FUNCTION fhq_governance.prevent_decision_log_modification();


--
-- Name: ael_intervention_registry trg_ael_intervention_updated; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_ael_intervention_updated BEFORE UPDATE ON fhq_governance.ael_intervention_registry FOR EACH ROW EXECUTE FUNCTION fhq_governance.update_ael_intervention_timestamp();


--
-- Name: aiqf_benchmark_runs trg_aiqf_pass_check; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_aiqf_pass_check BEFORE INSERT OR UPDATE ON fhq_governance.aiqf_benchmark_runs FOR EACH ROW EXECUTE FUNCTION fhq_governance.check_aiqf_pass();


--
-- Name: ldow_cycle_completion trg_compute_rung_d_eligible; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_compute_rung_d_eligible BEFORE INSERT OR UPDATE ON fhq_governance.ldow_cycle_completion FOR EACH ROW EXECUTE FUNCTION fhq_governance.compute_rung_d_eligible();


--
-- Name: output_bindings trg_detect_asrp_violation; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_detect_asrp_violation BEFORE INSERT ON fhq_governance.output_bindings FOR EACH ROW EXECUTE FUNCTION fhq_governance.detect_asrp_violation();


--
-- Name: agent_contracts trg_immutability_agent_contracts; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_agent_contracts BEFORE DELETE OR UPDATE ON fhq_governance.agent_contracts FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: agent_suspension_requests trg_immutability_agent_suspension_requests; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_agent_suspension_requests BEFORE DELETE OR UPDATE ON fhq_governance.agent_suspension_requests FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: api_provider_registry trg_immutability_api_provider_registry; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_api_provider_registry BEFORE DELETE OR UPDATE ON fhq_governance.api_provider_registry FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: api_usage_events trg_immutability_api_usage_events; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_api_usage_events BEFORE DELETE OR UPDATE ON fhq_governance.api_usage_events FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: asrp_violations trg_immutability_asrp_violations; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_asrp_violations BEFORE DELETE OR UPDATE ON fhq_governance.asrp_violations FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: audit_log trg_immutability_audit_log; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_audit_log BEFORE DELETE OR UPDATE ON fhq_governance.audit_log FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: authority_matrix trg_immutability_authority_matrix; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_authority_matrix BEFORE DELETE OR UPDATE ON fhq_governance.authority_matrix FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: canonical_evidence trg_immutability_canonical_evidence; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_canonical_evidence BEFORE DELETE OR UPDATE ON fhq_governance.canonical_evidence FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: canonical_mutation_gates trg_immutability_canonical_mutation_gates; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_canonical_mutation_gates BEFORE DELETE OR UPDATE ON fhq_governance.canonical_mutation_gates FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: canonical_strategy trg_immutability_canonical_strategy; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_canonical_strategy BEFORE DELETE OR UPDATE ON fhq_governance.canonical_strategy FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: change_approvals trg_immutability_change_approvals; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_change_approvals BEFORE DELETE OR UPDATE ON fhq_governance.change_approvals FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: change_log trg_immutability_change_log; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_change_log BEFORE DELETE OR UPDATE ON fhq_governance.change_log FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: chl_bypass_detections trg_immutability_chl_bypass_detections; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_chl_bypass_detections BEFORE DELETE OR UPDATE ON fhq_governance.chl_bypass_detections FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: chl_llm_requests trg_immutability_chl_llm_requests; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_chl_llm_requests BEFORE DELETE OR UPDATE ON fhq_governance.chl_llm_requests FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: chl_request_log trg_immutability_chl_request_log; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_chl_request_log BEFORE DELETE OR UPDATE ON fhq_governance.chl_request_log FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: circuit_breaker_events trg_immutability_circuit_breaker_events; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_circuit_breaker_events BEFORE DELETE OR UPDATE ON fhq_governance.circuit_breaker_events FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: circuit_breakers trg_immutability_circuit_breakers; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_circuit_breakers BEFORE DELETE OR UPDATE ON fhq_governance.circuit_breakers FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: constitutional_violations trg_immutability_constitutional_violations; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_constitutional_violations BEFORE DELETE OR UPDATE ON fhq_governance.constitutional_violations FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: context_packages trg_immutability_context_packages; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_context_packages BEFORE DELETE OR UPDATE ON fhq_governance.context_packages FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: data_provider_policy trg_immutability_data_provider_policy; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_data_provider_policy BEFORE DELETE OR UPDATE ON fhq_governance.data_provider_policy FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: decision_log trg_immutability_decision_log; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_decision_log BEFORE DELETE OR UPDATE ON fhq_governance.decision_log FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: decision_sequence trg_immutability_decision_sequence; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_decision_sequence BEFORE DELETE OR UPDATE ON fhq_governance.decision_sequence FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: defcon_transitions trg_immutability_defcon_transitions; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_defcon_transitions BEFORE DELETE OR UPDATE ON fhq_governance.defcon_transitions FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: discrepancy_events trg_immutability_discrepancy_events; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_discrepancy_events BEFORE DELETE OR UPDATE ON fhq_governance.discrepancy_events FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: economic_safety_limits trg_immutability_economic_safety_limits; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_economic_safety_limits BEFORE DELETE OR UPDATE ON fhq_governance.economic_safety_limits FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: execution_log trg_immutability_execution_log; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_execution_log BEFORE DELETE OR UPDATE ON fhq_governance.execution_log FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: executive_roles trg_immutability_executive_roles; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_executive_roles BEFORE DELETE OR UPDATE ON fhq_governance.executive_roles FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: fortress_anchors trg_immutability_fortress_anchors; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_fortress_anchors BEFORE DELETE OR UPDATE ON fhq_governance.fortress_anchors FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: g4_artifact_hashes trg_immutability_g4_artifact_hashes; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_g4_artifact_hashes BEFORE DELETE OR UPDATE ON fhq_governance.g4_artifact_hashes FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: g4_review_constraints trg_immutability_g4_review_constraints; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_g4_review_constraints BEFORE DELETE OR UPDATE ON fhq_governance.g4_review_constraints FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: gateway_integrity_signatures trg_immutability_gateway_integrity_signatures; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_gateway_integrity_signatures BEFORE DELETE OR UPDATE ON fhq_governance.gateway_integrity_signatures FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: gateway_request_log trg_immutability_gateway_request_log; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_gateway_request_log BEFORE DELETE OR UPDATE ON fhq_governance.gateway_request_log FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: governance_actions_log trg_immutability_governance_actions_log; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_governance_actions_log BEFORE DELETE OR UPDATE ON fhq_governance.governance_actions_log FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: governance_documents trg_immutability_governance_documents; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_governance_documents BEFORE DELETE OR UPDATE ON fhq_governance.governance_documents FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: governance_instruments trg_immutability_governance_instruments; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_governance_instruments BEFORE DELETE OR UPDATE ON fhq_governance.governance_instruments FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: governance_state trg_immutability_governance_state; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_governance_state BEFORE DELETE OR UPDATE ON fhq_governance.governance_state FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: ios008_mandate_authority trg_immutability_ios008_mandate_authority; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_ios008_mandate_authority BEFORE DELETE OR UPDATE ON fhq_governance.ios008_mandate_authority FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: ios010_g0_verification trg_immutability_ios010_g0_verification; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_ios010_g0_verification BEFORE DELETE OR UPDATE ON fhq_governance.ios010_g0_verification FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: ios012_g4_review trg_immutability_ios012_g4_review; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_ios012_g4_review BEFORE DELETE OR UPDATE ON fhq_governance.ios012_g4_review FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: ios_quad_mapping trg_immutability_ios_quad_mapping; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_ios_quad_mapping BEFORE DELETE OR UPDATE ON fhq_governance.ios_quad_mapping FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: llm_routing_log trg_immutability_llm_routing_log; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_llm_routing_log BEFORE DELETE OR UPDATE ON fhq_governance.llm_routing_log FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: mit_quad_pillars trg_immutability_mit_quad_pillars; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_mit_quad_pillars BEFORE DELETE OR UPDATE ON fhq_governance.mit_quad_pillars FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: mock_positions trg_immutability_mock_positions; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_mock_positions BEFORE DELETE OR UPDATE ON fhq_governance.mock_positions FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: model_provider_policy trg_immutability_model_provider_policy; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_model_provider_policy BEFORE DELETE OR UPDATE ON fhq_governance.model_provider_policy FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: model_tier_enforcement trg_immutability_model_tier_enforcement; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_model_tier_enforcement BEFORE DELETE OR UPDATE ON fhq_governance.model_tier_enforcement FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: oracle_event_log trg_immutability_oracle_event_log; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_oracle_event_log BEFORE DELETE OR UPDATE ON fhq_governance.oracle_event_log FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: output_bindings trg_immutability_output_bindings; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_output_bindings BEFORE DELETE OR UPDATE ON fhq_governance.output_bindings FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: paper_execution_authority trg_immutability_paper_execution_authority; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_paper_execution_authority BEFORE DELETE OR UPDATE ON fhq_governance.paper_execution_authority FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: paper_execution_loop trg_immutability_paper_execution_loop; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_paper_execution_loop BEFORE DELETE OR UPDATE ON fhq_governance.paper_execution_loop FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: preflight_checklist trg_immutability_preflight_checklist; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_preflight_checklist BEFORE DELETE OR UPDATE ON fhq_governance.preflight_checklist FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: production_monitoring trg_immutability_production_monitoring; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_production_monitoring BEFORE DELETE OR UPDATE ON fhq_governance.production_monitoring FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: quad_hash_registry trg_immutability_quad_hash_registry; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_quad_hash_registry BEFORE DELETE OR UPDATE ON fhq_governance.quad_hash_registry FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: regime_scalar_config trg_immutability_regime_scalar_config; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_regime_scalar_config BEFORE DELETE OR UPDATE ON fhq_governance.regime_scalar_config FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: registry_reconciliation_log trg_immutability_registry_reconciliation_log; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_registry_reconciliation_log BEFORE DELETE OR UPDATE ON fhq_governance.registry_reconciliation_log FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: scheduled_audits trg_immutability_scheduled_audits; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_scheduled_audits BEFORE DELETE OR UPDATE ON fhq_governance.scheduled_audits FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: security_alerts trg_immutability_security_alerts; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_security_alerts BEFORE DELETE OR UPDATE ON fhq_governance.security_alerts FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: skill_damper_config trg_immutability_skill_damper_config; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_skill_damper_config BEFORE DELETE OR UPDATE ON fhq_governance.skill_damper_config FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: state_retrieval_log trg_immutability_state_retrieval_log; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_state_retrieval_log BEFORE DELETE OR UPDATE ON fhq_governance.state_retrieval_log FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: suspension_audit_log trg_immutability_suspension_audit_log; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_suspension_audit_log BEFORE DELETE OR UPDATE ON fhq_governance.suspension_audit_log FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: system_state trg_immutability_system_state; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_system_state BEFORE DELETE OR UPDATE ON fhq_governance.system_state FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: task_registry trg_immutability_task_registry; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_task_registry BEFORE DELETE OR UPDATE ON fhq_governance.task_registry FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: vega_attestations trg_immutability_vega_attestations; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_vega_attestations BEFORE DELETE OR UPDATE ON fhq_governance.vega_attestations FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: vega_rhythm_schedule trg_immutability_vega_rhythm_schedule; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_vega_rhythm_schedule BEFORE DELETE OR UPDATE ON fhq_governance.vega_rhythm_schedule FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: vega_validation_rules trg_immutability_vega_validation_rules; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_immutability_vega_validation_rules BEFORE DELETE OR UPDATE ON fhq_governance.vega_validation_rules FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_immutability();


--
-- Name: llm_routing_log trg_llm_routing_budget_increment; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_llm_routing_budget_increment AFTER INSERT ON fhq_governance.llm_routing_log FOR EACH ROW EXECUTE FUNCTION fhq_governance.fn_increment_api_budget();


--
-- Name: llm_routing_log trg_llm_routing_cost_ledger; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_llm_routing_cost_ledger AFTER INSERT ON fhq_governance.llm_routing_log FOR EACH ROW EXECUTE FUNCTION fhq_governance.fn_update_cost_ledger();


--
-- Name: execution_state_change_log trg_prevent_change_log_update; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_prevent_change_log_update BEFORE DELETE OR UPDATE ON fhq_governance.execution_state_change_log FOR EACH ROW EXECUTE FUNCTION fhq_governance.prevent_change_log_modification();


--
-- Name: ael_intervention_registry trg_stillness_protocol_insert; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_stillness_protocol_insert BEFORE INSERT ON fhq_governance.ael_intervention_registry FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_stillness_protocol();


--
-- Name: ael_intervention_registry trg_stillness_protocol_update; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_stillness_protocol_update BEFORE UPDATE ON fhq_governance.ael_intervention_registry FOR EACH ROW EXECUTE FUNCTION fhq_governance.enforce_stillness_protocol();


--
-- Name: vega_attestations trg_sync_attestation_gov; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trg_sync_attestation_gov AFTER INSERT ON fhq_governance.vega_attestations FOR EACH ROW EXECUTE FUNCTION fhq_governance.sync_attestation_gov_to_registry();


--
-- Name: agent_suspension_requests trigger_suspension_request_updated; Type: TRIGGER; Schema: fhq_governance; Owner: -
--

CREATE TRIGGER trigger_suspension_request_updated BEFORE UPDATE ON fhq_governance.agent_suspension_requests FOR EACH ROW EXECUTE FUNCTION fhq_governance.update_suspension_request_timestamp();


--
-- Name: assets trg_assets_updated_at; Type: TRIGGER; Schema: fhq_meta; Owner: -
--

CREATE TRIGGER trg_assets_updated_at BEFORE UPDATE ON fhq_meta.assets FOR EACH ROW EXECUTE FUNCTION fhq_meta.assets_set_updated_at();


--
-- Name: canonical_documents trg_canonical_documents_updated; Type: TRIGGER; Schema: fhq_meta; Owner: -
--

CREATE TRIGGER trg_canonical_documents_updated BEFORE UPDATE ON fhq_meta.canonical_documents FOR EACH ROW EXECUTE FUNCTION fhq_meta.update_canonical_documents_timestamp();


--
-- Name: ios_registry trg_ios_registry_updated_at; Type: TRIGGER; Schema: fhq_meta; Owner: -
--

CREATE TRIGGER trg_ios_registry_updated_at BEFORE UPDATE ON fhq_meta.ios_registry FOR EACH ROW EXECUTE FUNCTION fhq_meta.ios_registry_set_updated_at();


--
-- Name: narrative_vectors trg_log_bpav_computation; Type: TRIGGER; Schema: fhq_meta; Owner: -
--

CREATE TRIGGER trg_log_bpav_computation AFTER UPDATE ON fhq_meta.narrative_vectors FOR EACH ROW EXECUTE FUNCTION fhq_governance.log_bpav_computation();


--
-- Name: narrative_vectors trg_log_narrative_vector_create; Type: TRIGGER; Schema: fhq_meta; Owner: -
--

CREATE TRIGGER trg_log_narrative_vector_create AFTER INSERT ON fhq_meta.narrative_vectors FOR EACH ROW EXECUTE FUNCTION fhq_governance.log_narrative_vector_create();


--
-- Name: model_context_registry trg_model_context_registry_updated_at; Type: TRIGGER; Schema: fhq_meta; Owner: -
--

CREATE TRIGGER trg_model_context_registry_updated_at BEFORE UPDATE ON fhq_meta.model_context_registry FOR EACH ROW EXECUTE FUNCTION fhq_meta.model_context_registry_set_updated_at();


--
-- Name: narrative_vectors trg_narrative_vectors_protect; Type: TRIGGER; Schema: fhq_meta; Owner: -
--

CREATE TRIGGER trg_narrative_vectors_protect BEFORE DELETE OR UPDATE ON fhq_meta.narrative_vectors FOR EACH ROW EXECUTE FUNCTION fhq_meta.narrative_vectors_protect_records();


--
-- Name: vega_attestations trg_sync_attestation_meta; Type: TRIGGER; Schema: fhq_meta; Owner: -
--

CREATE TRIGGER trg_sync_attestation_meta AFTER INSERT ON fhq_meta.vega_attestations FOR EACH ROW EXECUTE FUNCTION fhq_governance.sync_attestation_meta_to_registry();


--
-- Name: summary_evidence_ledger trg_evidence_immutability; Type: TRIGGER; Schema: vision_verification; Owner: -
--

CREATE TRIGGER trg_evidence_immutability BEFORE DELETE OR UPDATE ON vision_verification.summary_evidence_ledger FOR EACH ROW EXECUTE FUNCTION vision_verification.enforce_evidence_immutability();


--
-- Name: eqs_threshold_config eqs_threshold_config_supersedes_config_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.eqs_threshold_config
    ADD CONSTRAINT eqs_threshold_config_supersedes_config_id_fkey FOREIGN KEY (supersedes_config_id) REFERENCES fhq_canonical.eqs_threshold_config(config_id);


--
-- Name: evidence_relationships evidence_relationships_from_evidence_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.evidence_relationships
    ADD CONSTRAINT evidence_relationships_from_evidence_id_fkey FOREIGN KEY (from_evidence_id) REFERENCES fhq_canonical.evidence_nodes(evidence_id);


--
-- Name: evidence_relationships evidence_relationships_to_evidence_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.evidence_relationships
    ADD CONSTRAINT evidence_relationships_to_evidence_id_fkey FOREIGN KEY (to_evidence_id) REFERENCES fhq_canonical.evidence_nodes(evidence_id);


--
-- Name: financial_ontology financial_ontology_parent_concept_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.financial_ontology
    ADD CONSTRAINT financial_ontology_parent_concept_id_fkey FOREIGN KEY (parent_concept_id) REFERENCES fhq_canonical.financial_ontology(concept_id);


--
-- Name: canonical_outcomes fk_needle; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.canonical_outcomes
    ADD CONSTRAINT fk_needle FOREIGN KEY (needle_id) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: g4_1_composite_verdict g4_1_composite_verdict_needle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_1_composite_verdict
    ADD CONSTRAINT g4_1_composite_verdict_needle_id_fkey FOREIGN KEY (needle_id) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: g4_1_density_results g4_1_density_results_needle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_1_density_results
    ADD CONSTRAINT g4_1_density_results_needle_id_fkey FOREIGN KEY (needle_id) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: g4_1_regime_rotation_results g4_1_regime_rotation_results_needle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_1_regime_rotation_results
    ADD CONSTRAINT g4_1_regime_rotation_results_needle_id_fkey FOREIGN KEY (needle_id) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: g4_1_sensitivity_results g4_1_sensitivity_results_needle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_1_sensitivity_results
    ADD CONSTRAINT g4_1_sensitivity_results_needle_id_fkey FOREIGN KEY (needle_id) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: g4_1_stability_results g4_1_stability_results_needle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_1_stability_results
    ADD CONSTRAINT g4_1_stability_results_needle_id_fkey FOREIGN KEY (needle_id) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: g4_2_composite_verdict g4_2_composite_verdict_best_context_profile_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_2_composite_verdict
    ADD CONSTRAINT g4_2_composite_verdict_best_context_profile_id_fkey FOREIGN KEY (best_context_profile_id) REFERENCES fhq_canonical.g4_2_context_profiles(profile_id);


--
-- Name: g4_2_composite_verdict g4_2_composite_verdict_needle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_2_composite_verdict
    ADD CONSTRAINT g4_2_composite_verdict_needle_id_fkey FOREIGN KEY (needle_id) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: g4_2_context_profiles g4_2_context_profiles_needle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_2_context_profiles
    ADD CONSTRAINT g4_2_context_profiles_needle_id_fkey FOREIGN KEY (needle_id) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: g4_2_contextual_backtest g4_2_contextual_backtest_needle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_2_contextual_backtest
    ADD CONSTRAINT g4_2_contextual_backtest_needle_id_fkey FOREIGN KEY (needle_id) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: g4_2_contextual_backtest g4_2_contextual_backtest_profile_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_2_contextual_backtest
    ADD CONSTRAINT g4_2_contextual_backtest_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES fhq_canonical.g4_2_context_profiles(profile_id);


--
-- Name: g4_composite_scorecard g4_composite_scorecard_needle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_composite_scorecard
    ADD CONSTRAINT g4_composite_scorecard_needle_id_fkey FOREIGN KEY (needle_id) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: g4_composite_scorecard g4_composite_scorecard_physics_result_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_composite_scorecard
    ADD CONSTRAINT g4_composite_scorecard_physics_result_id_fkey FOREIGN KEY (physics_result_id) REFERENCES fhq_canonical.g4_physics_results(result_id);


--
-- Name: g4_composite_scorecard g4_composite_scorecard_refinery_result_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_composite_scorecard
    ADD CONSTRAINT g4_composite_scorecard_refinery_result_id_fkey FOREIGN KEY (refinery_result_id) REFERENCES fhq_canonical.g4_refinery_results(result_id);


--
-- Name: g4_physics_results g4_physics_results_needle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_physics_results
    ADD CONSTRAINT g4_physics_results_needle_id_fkey FOREIGN KEY (needle_id) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: g4_refinery_results g4_refinery_results_needle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_refinery_results
    ADD CONSTRAINT g4_refinery_results_needle_id_fkey FOREIGN KEY (needle_id) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: g4_validation_queue g4_validation_queue_needle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g4_validation_queue
    ADD CONSTRAINT g4_validation_queue_needle_id_fkey FOREIGN KEY (needle_id) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: g5_paper_trades g5_paper_trades_needle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_paper_trades
    ADD CONSTRAINT g5_paper_trades_needle_id_fkey FOREIGN KEY (needle_id) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: g5_promotion_ledger g5_promotion_ledger_needle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_promotion_ledger
    ADD CONSTRAINT g5_promotion_ledger_needle_id_fkey FOREIGN KEY (needle_id) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: g5_shadow_decisions g5_shadow_decisions_needle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_shadow_decisions
    ADD CONSTRAINT g5_shadow_decisions_needle_id_fkey FOREIGN KEY (needle_id) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: g5_signal_state g5_signal_state_needle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_signal_state
    ADD CONSTRAINT g5_signal_state_needle_id_fkey FOREIGN KEY (needle_id) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: g5_sla_metrics g5_sla_metrics_needle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_sla_metrics
    ADD CONSTRAINT g5_sla_metrics_needle_id_fkey FOREIGN KEY (needle_id) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: g5_sla_metrics g5_sla_metrics_promotion_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_sla_metrics
    ADD CONSTRAINT g5_sla_metrics_promotion_id_fkey FOREIGN KEY (promotion_id) REFERENCES fhq_canonical.g5_promotion_ledger(promotion_id);


--
-- Name: g5_ttl_extension_requests g5_ttl_extension_requests_needle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.g5_ttl_extension_requests
    ADD CONSTRAINT g5_ttl_extension_requests_needle_id_fkey FOREIGN KEY (needle_id) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: golden_needles golden_needles_superseded_by_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.golden_needles
    ADD CONSTRAINT golden_needles_superseded_by_fkey FOREIGN KEY (superseded_by) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: needle_chain_links needle_chain_links_needle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_canonical; Owner: -
--

ALTER TABLE ONLY fhq_canonical.needle_chain_links
    ADD CONSTRAINT needle_chain_links_needle_id_fkey FOREIGN KEY (needle_id) REFERENCES fhq_canonical.golden_needles(needle_id);


--
-- Name: ensemble_signals ensemble_signals_anomaly_input_id_fkey; Type: FK CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.ensemble_signals
    ADD CONSTRAINT ensemble_signals_anomaly_input_id_fkey FOREIGN KEY (anomaly_input_id) REFERENCES fhq_finn.anomalies(id);


--
-- Name: ensemble_signals ensemble_signals_regime_input_id_fkey; Type: FK CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.ensemble_signals
    ADD CONSTRAINT ensemble_signals_regime_input_id_fkey FOREIGN KEY (regime_input_id) REFERENCES fhq_finn.regime_states(id);


--
-- Name: model_predictions model_predictions_contract_version_fkey; Type: FK CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.model_predictions
    ADD CONSTRAINT model_predictions_contract_version_fkey FOREIGN KEY (contract_version) REFERENCES fhq_finn.contract_versions(version);


--
-- Name: relevance_scores relevance_scores_event_id_fkey; Type: FK CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.relevance_scores
    ADD CONSTRAINT relevance_scores_event_id_fkey FOREIGN KEY (event_id) REFERENCES fhq_finn.signal_events(event_id) ON DELETE CASCADE;


--
-- Name: risk_dashboard risk_dashboard_briefing_id_fkey; Type: FK CONSTRAINT; Schema: fhq_finn; Owner: -
--

ALTER TABLE ONLY fhq_finn.risk_dashboard
    ADD CONSTRAINT risk_dashboard_briefing_id_fkey FOREIGN KEY (briefing_id) REFERENCES fhq_finn.daily_briefings(briefing_id);


--
-- Name: ael_intervention_registry ael_intervention_registry_parent_intervention_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ael_intervention_registry
    ADD CONSTRAINT ael_intervention_registry_parent_intervention_id_fkey FOREIGN KEY (parent_intervention_id) REFERENCES fhq_governance.ael_intervention_registry(intervention_id);


--
-- Name: agent_health_attestations agent_health_attestations_state_snapshot_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.agent_health_attestations
    ADD CONSTRAINT agent_health_attestations_state_snapshot_id_fkey FOREIGN KEY (state_snapshot_id) REFERENCES fhq_governance.shared_state_snapshots(snapshot_id);


--
-- Name: aiqf_benchmark_registry aiqf_benchmark_registry_supersedes_benchmark_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.aiqf_benchmark_registry
    ADD CONSTRAINT aiqf_benchmark_registry_supersedes_benchmark_id_fkey FOREIGN KEY (supersedes_benchmark_id) REFERENCES fhq_governance.aiqf_benchmark_registry(benchmark_id);


--
-- Name: aiqf_benchmark_runs aiqf_benchmark_runs_baseline_run_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.aiqf_benchmark_runs
    ADD CONSTRAINT aiqf_benchmark_runs_baseline_run_id_fkey FOREIGN KEY (baseline_run_id) REFERENCES fhq_governance.aiqf_benchmark_runs(run_id);


--
-- Name: aiqf_benchmark_runs aiqf_benchmark_runs_benchmark_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.aiqf_benchmark_runs
    ADD CONSTRAINT aiqf_benchmark_runs_benchmark_id_fkey FOREIGN KEY (benchmark_id) REFERENCES fhq_governance.aiqf_benchmark_registry(benchmark_id);


--
-- Name: aiqf_drift_alerts aiqf_drift_alerts_benchmark_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.aiqf_drift_alerts
    ADD CONSTRAINT aiqf_drift_alerts_benchmark_id_fkey FOREIGN KEY (benchmark_id) REFERENCES fhq_governance.aiqf_benchmark_registry(benchmark_id);


--
-- Name: aiqf_drift_alerts aiqf_drift_alerts_run_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.aiqf_drift_alerts
    ADD CONSTRAINT aiqf_drift_alerts_run_id_fkey FOREIGN KEY (run_id) REFERENCES fhq_governance.aiqf_benchmark_runs(run_id);


--
-- Name: batch_graduation_log batch_graduation_log_criteria_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.batch_graduation_log
    ADD CONSTRAINT batch_graduation_log_criteria_id_fkey FOREIGN KEY (criteria_id) REFERENCES fhq_governance.steady_state_criteria(criteria_id);


--
-- Name: calibration_audit_log calibration_audit_log_calibration_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.calibration_audit_log
    ADD CONSTRAINT calibration_audit_log_calibration_id_fkey FOREIGN KEY (calibration_id) REFERENCES fhq_governance.calibration_versions(id);


--
-- Name: ceio_postmortem ceio_postmortem_reactivation_cycle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ceio_postmortem
    ADD CONSTRAINT ceio_postmortem_reactivation_cycle_id_fkey FOREIGN KEY (reactivation_cycle_id) REFERENCES fhq_governance.aci_reactivation_cycles(cycle_id);


--
-- Name: chl_request_log chl_request_log_package_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.chl_request_log
    ADD CONSTRAINT chl_request_log_package_id_fkey FOREIGN KEY (package_id) REFERENCES fhq_governance.context_packages(package_id);


--
-- Name: circuit_breaker_events circuit_breaker_events_breaker_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.circuit_breaker_events
    ADD CONSTRAINT circuit_breaker_events_breaker_id_fkey FOREIGN KEY (breaker_id) REFERENCES fhq_governance.circuit_breakers(breaker_id);


--
-- Name: decision_plans decision_plans_attempt_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.decision_plans
    ADD CONSTRAINT decision_plans_attempt_id_fkey FOREIGN KEY (attempt_id) REFERENCES fhq_governance.execution_attempts(attempt_id);


--
-- Name: decision_plans decision_plans_intent_draft_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.decision_plans
    ADD CONSTRAINT decision_plans_intent_draft_id_fkey FOREIGN KEY (intent_draft_id) REFERENCES fhq_governance.intent_drafts(draft_id);


--
-- Name: epistemic_lessons epistemic_lessons_evidence_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.epistemic_lessons
    ADD CONSTRAINT epistemic_lessons_evidence_id_fkey FOREIGN KEY (evidence_id) REFERENCES fhq_governance.epistemic_lesson_evidence(evidence_id);


--
-- Name: epistemic_lessons epistemic_lessons_source_forecast_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.epistemic_lessons
    ADD CONSTRAINT epistemic_lessons_source_forecast_id_fkey FOREIGN KEY (source_forecast_id) REFERENCES fhq_research.forecast_ledger(forecast_id);


--
-- Name: epistemic_lessons epistemic_lessons_source_outcome_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.epistemic_lessons
    ADD CONSTRAINT epistemic_lessons_source_outcome_id_fkey FOREIGN KEY (source_outcome_id) REFERENCES fhq_research.outcome_ledger(outcome_id);


--
-- Name: epistemic_lessons epistemic_lessons_source_pair_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.epistemic_lessons
    ADD CONSTRAINT epistemic_lessons_source_pair_id_fkey FOREIGN KEY (source_pair_id) REFERENCES fhq_research.forecast_outcome_pairs(pair_id);


--
-- Name: epistemic_lessons epistemic_lessons_source_skill_metric_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.epistemic_lessons
    ADD CONSTRAINT epistemic_lessons_source_skill_metric_id_fkey FOREIGN KEY (source_skill_metric_id) REFERENCES fhq_research.forecast_skill_metrics(metric_id);


--
-- Name: epistemic_suppression_ledger epistemic_suppression_ledger_belief_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.epistemic_suppression_ledger
    ADD CONSTRAINT epistemic_suppression_ledger_belief_id_fkey FOREIGN KEY (belief_id) REFERENCES fhq_perception.model_belief_state(belief_id);


--
-- Name: epistemic_suppression_ledger epistemic_suppression_ledger_policy_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.epistemic_suppression_ledger
    ADD CONSTRAINT epistemic_suppression_ledger_policy_id_fkey FOREIGN KEY (policy_id) REFERENCES fhq_perception.sovereign_policy_state(policy_id);


--
-- Name: event_queue event_queue_trigger_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.event_queue
    ADD CONSTRAINT event_queue_trigger_id_fkey FOREIGN KEY (trigger_id) REFERENCES fhq_governance.event_trigger_registry(trigger_id);


--
-- Name: execution_attempts execution_attempts_intent_draft_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.execution_attempts
    ADD CONSTRAINT execution_attempts_intent_draft_id_fkey FOREIGN KEY (intent_draft_id) REFERENCES fhq_governance.intent_drafts(draft_id);


--
-- Name: failure_mode_reopen_log failure_mode_reopen_log_failure_mode_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.failure_mode_reopen_log
    ADD CONSTRAINT failure_mode_reopen_log_failure_mode_id_fkey FOREIGN KEY (failure_mode_id) REFERENCES fhq_governance.failure_mode_registry(failure_mode_id);


--
-- Name: aiqf_benchmark_registry fk_aiqf_vega_attestation; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.aiqf_benchmark_registry
    ADD CONSTRAINT fk_aiqf_vega_attestation FOREIGN KEY (vega_certification_attestation_id) REFERENCES fhq_governance.vega_attestations(attestation_id);


--
-- Name: refinement_evidence_bundle fk_evidence_refinement; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.refinement_evidence_bundle
    ADD CONSTRAINT fk_evidence_refinement FOREIGN KEY (refinement_id) REFERENCES fhq_governance.sql_refinement_log(refinement_id);


--
-- Name: sql_correction_guidelines fk_guideline_benchmark_validation; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.sql_correction_guidelines
    ADD CONSTRAINT fk_guideline_benchmark_validation FOREIGN KEY (validated_on_benchmark_run_id) REFERENCES fhq_governance.aiqf_benchmark_runs(run_id);


--
-- Name: sql_correction_guidelines fk_guideline_vega_signoff; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.sql_correction_guidelines
    ADD CONSTRAINT fk_guideline_vega_signoff FOREIGN KEY (vega_signoff_attestation_id) REFERENCES fhq_governance.vega_attestations(attestation_id);


--
-- Name: ldow_forecast_captures fk_ldow_id; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ldow_forecast_captures
    ADD CONSTRAINT fk_ldow_id FOREIGN KEY (ldow_id) REFERENCES fhq_governance.learning_delta_observation_window(ldow_id);


--
-- Name: sql_refinement_log fk_refinement_benchmark_run; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.sql_refinement_log
    ADD CONSTRAINT fk_refinement_benchmark_run FOREIGN KEY (benchmark_run_id) REFERENCES fhq_governance.aiqf_benchmark_runs(run_id);


--
-- Name: goal_completion_evidence goal_completion_evidence_goal_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.goal_completion_evidence
    ADD CONSTRAINT goal_completion_evidence_goal_id_fkey FOREIGN KEY (goal_id) REFERENCES fhq_governance.daily_goal_calendar(goal_id);


--
-- Name: governance_instruments governance_instruments_ios_reference_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.governance_instruments
    ADD CONSTRAINT governance_instruments_ios_reference_fkey FOREIGN KEY (ios_reference) REFERENCES fhq_meta.ios_registry(ios_id);


--
-- Name: holdout_evaluation_results holdout_evaluation_results_holdout_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.holdout_evaluation_results
    ADD CONSTRAINT holdout_evaluation_results_holdout_id_fkey FOREIGN KEY (holdout_id) REFERENCES fhq_governance.frozen_holdout_registry(holdout_id);


--
-- Name: holdout_evaluation_results holdout_evaluation_results_prev_evaluation_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.holdout_evaluation_results
    ADD CONSTRAINT holdout_evaluation_results_prev_evaluation_id_fkey FOREIGN KEY (prev_evaluation_id) REFERENCES fhq_governance.holdout_evaluation_results(evaluation_id);


--
-- Name: inforage_query_log inforage_query_log_bundle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.inforage_query_log
    ADD CONSTRAINT inforage_query_log_bundle_id_fkey FOREIGN KEY (bundle_id) REFERENCES fhq_canonical.evidence_bundles(bundle_id);


--
-- Name: ios_quad_mapping ios_quad_mapping_pillar_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ios_quad_mapping
    ADD CONSTRAINT ios_quad_mapping_pillar_id_fkey FOREIGN KEY (pillar_id) REFERENCES fhq_governance.mit_quad_pillars(pillar_id);


--
-- Name: ldow_cycle_metrics ldow_cycle_metrics_ldow_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ldow_cycle_metrics
    ADD CONSTRAINT ldow_cycle_metrics_ldow_id_fkey FOREIGN KEY (ldow_id) REFERENCES fhq_governance.learning_delta_observation_window(ldow_id);


--
-- Name: ldow_evaluation_log ldow_evaluation_log_ldow_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ldow_evaluation_log
    ADD CONSTRAINT ldow_evaluation_log_ldow_id_fkey FOREIGN KEY (ldow_id) REFERENCES fhq_governance.learning_delta_observation_window(ldow_id);


--
-- Name: ldow_task_execution_log ldow_task_execution_log_cycle_completion_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.ldow_task_execution_log
    ADD CONSTRAINT ldow_task_execution_log_cycle_completion_id_fkey FOREIGN KEY (cycle_completion_id) REFERENCES fhq_governance.ldow_cycle_completion(completion_id);


--
-- Name: learning_mechanism_log learning_mechanism_log_failure_mode_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.learning_mechanism_log
    ADD CONSTRAINT learning_mechanism_log_failure_mode_id_fkey FOREIGN KEY (failure_mode_id) REFERENCES fhq_governance.failure_mode_registry(failure_mode_id);


--
-- Name: learning_proposal_audit learning_proposal_audit_proposal_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.learning_proposal_audit
    ADD CONSTRAINT learning_proposal_audit_proposal_id_fkey FOREIGN KEY (proposal_id) REFERENCES fhq_governance.learning_proposals(proposal_id);


--
-- Name: learning_versions learning_versions_previous_version_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.learning_versions
    ADD CONSTRAINT learning_versions_previous_version_id_fkey FOREIGN KEY (previous_version_id) REFERENCES fhq_governance.learning_versions(version_id);


--
-- Name: learning_versions learning_versions_source_proposal_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.learning_versions
    ADD CONSTRAINT learning_versions_source_proposal_id_fkey FOREIGN KEY (source_proposal_id) REFERENCES fhq_governance.learning_proposals(proposal_id);


--
-- Name: llm_routing_log llm_routing_log_policy_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.llm_routing_log
    ADD CONSTRAINT llm_routing_log_policy_id_fkey FOREIGN KEY (policy_id) REFERENCES fhq_governance.model_provider_policy(policy_id);


--
-- Name: oracle_event_log oracle_event_log_vector_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.oracle_event_log
    ADD CONSTRAINT oracle_event_log_vector_id_fkey FOREIGN KEY (vector_id) REFERENCES fhq_meta.narrative_vectors(vector_id);


--
-- Name: paper_ledger paper_ledger_calibration_gate_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.paper_ledger
    ADD CONSTRAINT paper_ledger_calibration_gate_id_fkey FOREIGN KEY (calibration_gate_id) REFERENCES fhq_governance.confidence_calibration_gates(gate_id);


--
-- Name: plps_graduation_attempts plps_graduation_attempts_config_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.plps_graduation_attempts
    ADD CONSTRAINT plps_graduation_attempts_config_id_fkey FOREIGN KEY (config_id) REFERENCES fhq_governance.plps_gate_config(config_id);


--
-- Name: preflight_checklist preflight_checklist_validation_rule_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.preflight_checklist
    ADD CONSTRAINT preflight_checklist_validation_rule_fkey FOREIGN KEY (validation_rule) REFERENCES fhq_governance.vega_validation_rules(rule_name);


--
-- Name: protocol_omega_executions protocol_omega_executions_omega_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.protocol_omega_executions
    ADD CONSTRAINT protocol_omega_executions_omega_id_fkey FOREIGN KEY (omega_id) REFERENCES fhq_governance.protocol_omega_registry(omega_id);


--
-- Name: regret_computation_diagnostics regret_computation_diagnostics_regret_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.regret_computation_diagnostics
    ADD CONSTRAINT regret_computation_diagnostics_regret_id_fkey FOREIGN KEY (regret_id) REFERENCES fhq_governance.suppression_regret_index(regret_id);


--
-- Name: retest_validation_cycles retest_validation_cycles_failure_mode_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.retest_validation_cycles
    ADD CONSTRAINT retest_validation_cycles_failure_mode_id_fkey FOREIGN KEY (failure_mode_id) REFERENCES fhq_governance.failure_mode_registry(failure_mode_id);


--
-- Name: sql_correction_guidelines sql_correction_guidelines_supersedes_guideline_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.sql_correction_guidelines
    ADD CONSTRAINT sql_correction_guidelines_supersedes_guideline_id_fkey FOREIGN KEY (supersedes_guideline_id) REFERENCES fhq_governance.sql_correction_guidelines(guideline_id);


--
-- Name: sql_refinement_log sql_refinement_log_correction_guideline_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.sql_refinement_log
    ADD CONSTRAINT sql_refinement_log_correction_guideline_id_fkey FOREIGN KEY (correction_guideline_id) REFERENCES fhq_governance.sql_correction_guidelines(guideline_id);


--
-- Name: sql_refinement_log sql_refinement_log_escalation_bundle_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.sql_refinement_log
    ADD CONSTRAINT sql_refinement_log_escalation_bundle_id_fkey FOREIGN KEY (escalation_bundle_id) REFERENCES fhq_governance.refinement_evidence_bundle(bundle_id);


--
-- Name: state_retrieval_log state_retrieval_log_snapshot_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.state_retrieval_log
    ADD CONSTRAINT state_retrieval_log_snapshot_id_fkey FOREIGN KEY (snapshot_id) REFERENCES fhq_governance.shared_state_snapshots(snapshot_id);


--
-- Name: steady_state_criteria steady_state_criteria_superseded_by_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.steady_state_criteria
    ADD CONSTRAINT steady_state_criteria_superseded_by_fkey FOREIGN KEY (superseded_by) REFERENCES fhq_governance.steady_state_criteria(criteria_id);


--
-- Name: stillness_checkpoint_log stillness_checkpoint_log_day_goal_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.stillness_checkpoint_log
    ADD CONSTRAINT stillness_checkpoint_log_day_goal_id_fkey FOREIGN KEY (day_goal_id) REFERENCES fhq_governance.stillness_day_goals(goal_id);


--
-- Name: suspension_audit_log suspension_audit_log_previous_audit_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.suspension_audit_log
    ADD CONSTRAINT suspension_audit_log_previous_audit_id_fkey FOREIGN KEY (previous_audit_id) REFERENCES fhq_governance.suspension_audit_log(audit_id);


--
-- Name: suspension_audit_log suspension_audit_log_request_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.suspension_audit_log
    ADD CONSTRAINT suspension_audit_log_request_id_fkey FOREIGN KEY (request_id) REFERENCES fhq_governance.agent_suspension_requests(request_id);


--
-- Name: task_activation_status task_activation_status_task_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.task_activation_status
    ADD CONSTRAINT task_activation_status_task_id_fkey FOREIGN KEY (task_id) REFERENCES fhq_governance.task_registry(task_id);


--
-- Name: task_registry task_registry_assigned_to_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.task_registry
    ADD CONSTRAINT task_registry_assigned_to_fkey FOREIGN KEY (assigned_to) REFERENCES fhq_governance.executive_roles(role_name);


--
-- Name: vega_triage_log vega_triage_log_rule_matched_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.vega_triage_log
    ADD CONSTRAINT vega_triage_log_rule_matched_fkey FOREIGN KEY (rule_matched) REFERENCES fhq_governance.vega_triage_rules(rule_id);


--
-- Name: vendor_quota_events vendor_quota_events_vendor_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.vendor_quota_events
    ADD CONSTRAINT vendor_quota_events_vendor_id_fkey FOREIGN KEY (vendor_id) REFERENCES fhq_meta.vendor_limits(vendor_id);


--
-- Name: weekly_learning_runs weekly_learning_runs_evidence_id_fkey; Type: FK CONSTRAINT; Schema: fhq_governance; Owner: -
--

ALTER TABLE ONLY fhq_governance.weekly_learning_runs
    ADD CONSTRAINT weekly_learning_runs_evidence_id_fkey FOREIGN KEY (evidence_id) REFERENCES fhq_governance.epistemic_lesson_evidence(evidence_id);


--
-- Name: aci_cognitive_memory aci_cognitive_memory_interaction_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.aci_cognitive_memory
    ADD CONSTRAINT aci_cognitive_memory_interaction_id_fkey FOREIGN KEY (interaction_id) REFERENCES fhq_meta.agent_interaction_log(interaction_id);


--
-- Name: adr_drift_events adr_drift_events_tool_usage_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_drift_events
    ADD CONSTRAINT adr_drift_events_tool_usage_id_fkey FOREIGN KEY (tool_usage_id) REFERENCES fhq_meta.tool_usage_log(usage_id);


--
-- Name: adr_registry adr_registry_superseded_by_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_registry
    ADD CONSTRAINT adr_registry_superseded_by_fkey FOREIGN KEY (superseded_by) REFERENCES fhq_meta.adr_registry(adr_id);


--
-- Name: adr_version_history adr_version_history_adr_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.adr_version_history
    ADD CONSTRAINT adr_version_history_adr_id_fkey FOREIGN KEY (adr_id) REFERENCES fhq_meta.adr_registry(adr_id);


--
-- Name: agent_interaction_log agent_interaction_log_state_snapshot_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.agent_interaction_log
    ADD CONSTRAINT agent_interaction_log_state_snapshot_id_fkey FOREIGN KEY (state_snapshot_id) REFERENCES fhq_meta.aci_state_snapshot_log(snapshot_id);


--
-- Name: asset_vendor_policy asset_vendor_policy_asset_class_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.asset_vendor_policy
    ADD CONSTRAINT asset_vendor_policy_asset_class_id_fkey FOREIGN KEY (asset_class_id) REFERENCES fhq_meta.asset_classes(asset_class_id);


--
-- Name: baseline_registry baseline_registry_model_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.baseline_registry
    ADD CONSTRAINT baseline_registry_model_id_fkey FOREIGN KEY (model_id) REFERENCES fhq_meta.model_registry(model_id);


--
-- Name: canonical_asset_groups canonical_asset_groups_asset_class_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_asset_groups
    ADD CONSTRAINT canonical_asset_groups_asset_class_id_fkey FOREIGN KEY (asset_class_id) REFERENCES fhq_meta.asset_classes(asset_class_id);


--
-- Name: canonical_asset_members canonical_asset_members_group_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_asset_members
    ADD CONSTRAINT canonical_asset_members_group_id_fkey FOREIGN KEY (group_id) REFERENCES fhq_meta.canonical_asset_groups(group_id);


--
-- Name: canonical_indicator_registry canonical_indicator_registry_domain_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_indicator_registry
    ADD CONSTRAINT canonical_indicator_registry_domain_id_fkey FOREIGN KEY (domain_id) REFERENCES fhq_meta.canonical_domain_registry(domain_id);


--
-- Name: canonical_ingestion_registry canonical_ingestion_registry_domain_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_ingestion_registry
    ADD CONSTRAINT canonical_ingestion_registry_domain_id_fkey FOREIGN KEY (domain_id) REFERENCES fhq_meta.canonical_domain_registry(domain_id);


--
-- Name: canonical_mismatches canonical_mismatches_claim_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_mismatches
    ADD CONSTRAINT canonical_mismatches_claim_id_fkey FOREIGN KEY (claim_id) REFERENCES fhq_meta.document_claims(claim_id);


--
-- Name: canonical_series_registry canonical_series_registry_domain_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.canonical_series_registry
    ADD CONSTRAINT canonical_series_registry_domain_id_fkey FOREIGN KEY (domain_id) REFERENCES fhq_meta.canonical_domain_registry(domain_id);


--
-- Name: chain_of_query chain_of_query_parent_node_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.chain_of_query
    ADD CONSTRAINT chain_of_query_parent_node_id_fkey FOREIGN KEY (parent_node_id) REFERENCES fhq_meta.chain_of_query(coq_id);


--
-- Name: cognitive_engine_evidence cognitive_engine_evidence_coq_node_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.cognitive_engine_evidence
    ADD CONSTRAINT cognitive_engine_evidence_coq_node_id_fkey FOREIGN KEY (coq_node_id) REFERENCES fhq_meta.chain_of_query(coq_id);


--
-- Name: document_claims document_claims_document_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.document_claims
    ADD CONSTRAINT document_claims_document_id_fkey FOREIGN KEY (document_id) REFERENCES fhq_meta.canonical_document_queue(queue_id);


--
-- Name: document_database_reconciliation document_database_reconciliation_interaction_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.document_database_reconciliation
    ADD CONSTRAINT document_database_reconciliation_interaction_id_fkey FOREIGN KEY (interaction_id) REFERENCES fhq_meta.agent_interaction_log(interaction_id);


--
-- Name: ec_authority_resolutions ec_authority_resolutions_supersedes_resolution_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.ec_authority_resolutions
    ADD CONSTRAINT ec_authority_resolutions_supersedes_resolution_id_fkey FOREIGN KEY (supersedes_resolution_id) REFERENCES fhq_meta.ec_authority_resolutions(resolution_id);


--
-- Name: external_taxonomy_map external_taxonomy_map_internal_group_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.external_taxonomy_map
    ADD CONSTRAINT external_taxonomy_map_internal_group_id_fkey FOREIGN KEY (internal_group_id) REFERENCES fhq_meta.canonical_asset_groups(group_id);


--
-- Name: finn_pamphlets finn_pamphlets_superseded_by_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.finn_pamphlets
    ADD CONSTRAINT finn_pamphlets_superseded_by_fkey FOREIGN KEY (superseded_by) REFERENCES fhq_meta.finn_pamphlets(pamphlet_id);


--
-- Name: strategy_family_members fk_family; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.strategy_family_members
    ADD CONSTRAINT fk_family FOREIGN KEY (family_id) REFERENCES fhq_meta.strategy_families(family_id) ON DELETE CASCADE;


--
-- Name: regime_weight_config fk_family_regime_weight; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.regime_weight_config
    ADD CONSTRAINT fk_family_regime_weight FOREIGN KEY (family_id) REFERENCES fhq_meta.strategy_families(family_id) ON DELETE CASCADE;


--
-- Name: model_context_registry fk_model_context_asset; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.model_context_registry
    ADD CONSTRAINT fk_model_context_asset FOREIGN KEY (canonical_id) REFERENCES fhq_meta.assets(canonical_id) ON UPDATE CASCADE;


--
-- Name: strategy_family_members fk_strategy; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.strategy_family_members
    ADD CONSTRAINT fk_strategy FOREIGN KEY (strategy_id) REFERENCES fhq_research.strategy_registry(strategy_id) ON DELETE CASCADE;


--
-- Name: g1_alpha_evidence g1_alpha_evidence_activation_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.g1_alpha_evidence
    ADD CONSTRAINT g1_alpha_evidence_activation_id_fkey FOREIGN KEY (activation_id) REFERENCES fhq_meta.g1_activation_registry(activation_id);


--
-- Name: g1_evidence_daily_snapshot g1_evidence_daily_snapshot_accumulation_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.g1_evidence_daily_snapshot
    ADD CONSTRAINT g1_evidence_daily_snapshot_accumulation_id_fkey FOREIGN KEY (accumulation_id) REFERENCES fhq_meta.g1_evidence_accumulation(accumulation_id);


--
-- Name: hallucination_rejection_events hallucination_rejection_events_boundary_log_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.hallucination_rejection_events
    ADD CONSTRAINT hallucination_rejection_events_boundary_log_id_fkey FOREIGN KEY (boundary_log_id) REFERENCES fhq_meta.knowledge_boundary_log(boundary_id);


--
-- Name: hallucination_rejection_events hallucination_rejection_events_interaction_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.hallucination_rejection_events
    ADD CONSTRAINT hallucination_rejection_events_interaction_id_fkey FOREIGN KEY (interaction_id) REFERENCES fhq_meta.agent_interaction_log(interaction_id);


--
-- Name: identity_state_snapshots identity_state_snapshots_ceremony_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.identity_state_snapshots
    ADD CONSTRAINT identity_state_snapshots_ceremony_id_fkey FOREIGN KEY (ceremony_id) REFERENCES fhq_meta.key_ceremonies(ceremony_id);


--
-- Name: key_archival_log key_archival_log_key_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.key_archival_log
    ADD CONSTRAINT key_archival_log_key_id_fkey FOREIGN KEY (key_id) REFERENCES fhq_meta.agent_keys(key_id);


--
-- Name: knowledge_boundary_log knowledge_boundary_log_coq_node_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.knowledge_boundary_log
    ADD CONSTRAINT knowledge_boundary_log_coq_node_id_fkey FOREIGN KEY (coq_node_id) REFERENCES fhq_meta.chain_of_query(coq_id);


--
-- Name: learning_state_artifacts learning_state_artifacts_superseded_by_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.learning_state_artifacts
    ADD CONSTRAINT learning_state_artifacts_superseded_by_fkey FOREIGN KEY (superseded_by) REFERENCES fhq_meta.learning_state_artifacts(lsa_id);


--
-- Name: model_configurations model_configurations_group_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.model_configurations
    ADD CONSTRAINT model_configurations_group_id_fkey FOREIGN KEY (group_id) REFERENCES fhq_meta.canonical_asset_groups(group_id);


--
-- Name: reconciliation_evidence reconciliation_evidence_snapshot_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.reconciliation_evidence
    ADD CONSTRAINT reconciliation_evidence_snapshot_id_fkey FOREIGN KEY (snapshot_id) REFERENCES fhq_meta.reconciliation_snapshots(snapshot_id);


--
-- Name: search_foraging_log search_foraging_log_coq_node_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.search_foraging_log
    ADD CONSTRAINT search_foraging_log_coq_node_id_fkey FOREIGN KEY (coq_node_id) REFERENCES fhq_meta.chain_of_query(coq_id);


--
-- Name: tickers tickers_mic_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.tickers
    ADD CONSTRAINT tickers_mic_fkey FOREIGN KEY (mic) REFERENCES fhq_meta.exchanges(mic);


--
-- Name: tool_usage_log tool_usage_log_coq_node_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.tool_usage_log
    ADD CONSTRAINT tool_usage_log_coq_node_id_fkey FOREIGN KEY (coq_node_id) REFERENCES fhq_meta.chain_of_query(coq_id);


--
-- Name: vendor_limits vendor_limits_fallback_vendor_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vendor_limits
    ADD CONSTRAINT vendor_limits_fallback_vendor_id_fkey FOREIGN KEY (fallback_vendor_id) REFERENCES fhq_meta.vendor_limits(vendor_id);


--
-- Name: vendor_usage_counters vendor_usage_counters_vendor_id_fkey; Type: FK CONSTRAINT; Schema: fhq_meta; Owner: -
--

ALTER TABLE ONLY fhq_meta.vendor_usage_counters
    ADD CONSTRAINT vendor_usage_counters_vendor_id_fkey FOREIGN KEY (vendor_id) REFERENCES fhq_meta.vendor_limits(vendor_id);


--
-- Name: org_activity_log org_activity_log_agent_id_fkey; Type: FK CONSTRAINT; Schema: fhq_org; Owner: -
--

ALTER TABLE ONLY fhq_org.org_activity_log
    ADD CONSTRAINT org_activity_log_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES fhq_org.org_agents(agent_id);


--
-- Name: org_memory org_memory_agent_id_fkey; Type: FK CONSTRAINT; Schema: fhq_org; Owner: -
--

ALTER TABLE ONLY fhq_org.org_memory
    ADD CONSTRAINT org_memory_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES fhq_org.org_agents(agent_id);


--
-- Name: org_memory org_memory_source_event_id_fkey; Type: FK CONSTRAINT; Schema: fhq_org; Owner: -
--

ALTER TABLE ONLY fhq_org.org_memory
    ADD CONSTRAINT org_memory_source_event_id_fkey FOREIGN KEY (source_event_id) REFERENCES fhq_org.org_activity_log(event_id);


--
-- Name: org_state_reconciliation org_state_reconciliation_agent_id_fkey; Type: FK CONSTRAINT; Schema: fhq_org; Owner: -
--

ALTER TABLE ONLY fhq_org.org_state_reconciliation
    ADD CONSTRAINT org_state_reconciliation_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES fhq_org.org_agents(agent_id);


--
-- Name: org_state_reconciliation org_state_reconciliation_vega_review_id_fkey; Type: FK CONSTRAINT; Schema: fhq_org; Owner: -
--

ALTER TABLE ONLY fhq_org.org_state_reconciliation
    ADD CONSTRAINT org_state_reconciliation_vega_review_id_fkey FOREIGN KEY (vega_review_id) REFERENCES fhq_org.org_activity_log(event_id);


--
-- Name: org_tasks org_tasks_agent_id_fkey; Type: FK CONSTRAINT; Schema: fhq_org; Owner: -
--

ALTER TABLE ONLY fhq_org.org_tasks
    ADD CONSTRAINT org_tasks_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES fhq_org.org_agents(agent_id);


--
-- Name: agent_test_execution agent_test_execution_run_id_fkey; Type: FK CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.agent_test_execution
    ADD CONSTRAINT agent_test_execution_run_id_fkey FOREIGN KEY (run_id) REFERENCES vega.test_runs(run_id);


--
-- Name: api_endpoint_tests api_endpoint_tests_run_id_fkey; Type: FK CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.api_endpoint_tests
    ADD CONSTRAINT api_endpoint_tests_run_id_fkey FOREIGN KEY (run_id) REFERENCES vega.test_runs(run_id);


--
-- Name: quality_gate_results quality_gate_results_run_id_fkey; Type: FK CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.quality_gate_results
    ADD CONSTRAINT quality_gate_results_run_id_fkey FOREIGN KEY (run_id) REFERENCES vega.test_runs(run_id);


--
-- Name: test_coverage test_coverage_run_id_fkey; Type: FK CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.test_coverage
    ADD CONSTRAINT test_coverage_run_id_fkey FOREIGN KEY (run_id) REFERENCES vega.test_runs(run_id);


--
-- Name: test_failures test_failures_run_id_fkey; Type: FK CONSTRAINT; Schema: vega; Owner: -
--

ALTER TABLE ONLY vega.test_failures
    ADD CONSTRAINT test_failures_run_id_fkey FOREIGN KEY (run_id) REFERENCES vega.test_runs(run_id);


--
-- Name: render_evidence render_evidence_vsv_id_fkey; Type: FK CONSTRAINT; Schema: vision_cinematic; Owner: -
--

ALTER TABLE ONLY vision_cinematic.render_evidence
    ADD CONSTRAINT render_evidence_vsv_id_fkey FOREIGN KEY (vsv_id) REFERENCES vision_cinematic.visual_state_vectors(vsv_id);


--
-- Name: live_mode_activations live_mode_activations_authorization_id_fkey; Type: FK CONSTRAINT; Schema: vision_core; Owner: -
--

ALTER TABLE ONLY vision_core.live_mode_activations
    ADD CONSTRAINT live_mode_activations_authorization_id_fkey FOREIGN KEY (authorization_id) REFERENCES vision_core.live_mode_authorizations(authorization_id);


--
-- Name: live_mode_activations live_mode_activations_proposal_id_fkey; Type: FK CONSTRAINT; Schema: vision_core; Owner: -
--

ALTER TABLE ONLY vision_core.live_mode_activations
    ADD CONSTRAINT live_mode_activations_proposal_id_fkey FOREIGN KEY (proposal_id) REFERENCES vision_core.live_mode_proposals(proposal_id);


--
-- Name: live_mode_activations live_mode_activations_review_id_fkey; Type: FK CONSTRAINT; Schema: vision_core; Owner: -
--

ALTER TABLE ONLY vision_core.live_mode_activations
    ADD CONSTRAINT live_mode_activations_review_id_fkey FOREIGN KEY (review_id) REFERENCES vision_core.live_mode_reviews(review_id);


--
-- Name: live_mode_authorizations live_mode_authorizations_proposal_id_fkey; Type: FK CONSTRAINT; Schema: vision_core; Owner: -
--

ALTER TABLE ONLY vision_core.live_mode_authorizations
    ADD CONSTRAINT live_mode_authorizations_proposal_id_fkey FOREIGN KEY (proposal_id) REFERENCES vision_core.live_mode_proposals(proposal_id);


--
-- Name: live_mode_authorizations live_mode_authorizations_review_id_fkey; Type: FK CONSTRAINT; Schema: vision_core; Owner: -
--

ALTER TABLE ONLY vision_core.live_mode_authorizations
    ADD CONSTRAINT live_mode_authorizations_review_id_fkey FOREIGN KEY (review_id) REFERENCES vision_core.live_mode_reviews(review_id);


--
-- Name: live_mode_reviews live_mode_reviews_proposal_id_fkey; Type: FK CONSTRAINT; Schema: vision_core; Owner: -
--

ALTER TABLE ONLY vision_core.live_mode_reviews
    ADD CONSTRAINT live_mode_reviews_proposal_id_fkey FOREIGN KEY (proposal_id) REFERENCES vision_core.live_mode_proposals(proposal_id);


--
-- Name: alpha_signals alpha_signals_baseline_id_fkey; Type: FK CONSTRAINT; Schema: vision_signals; Owner: -
--

ALTER TABLE ONLY vision_signals.alpha_signals
    ADD CONSTRAINT alpha_signals_baseline_id_fkey FOREIGN KEY (baseline_id) REFERENCES vision_signals.signal_baseline(baseline_id);


--
-- Name: evidence_verification_log evidence_verification_log_evidence_id_fkey; Type: FK CONSTRAINT; Schema: vision_verification; Owner: -
--

ALTER TABLE ONLY vision_verification.evidence_verification_log
    ADD CONSTRAINT evidence_verification_log_evidence_id_fkey FOREIGN KEY (evidence_id) REFERENCES vision_verification.summary_evidence_ledger(evidence_id);


--
-- Name: operation_signatures operation_signatures_previous_signature_id_fkey; Type: FK CONSTRAINT; Schema: vision_verification; Owner: -
--

ALTER TABLE ONLY vision_verification.operation_signatures
    ADD CONSTRAINT operation_signatures_previous_signature_id_fkey FOREIGN KEY (previous_signature_id) REFERENCES vision_verification.operation_signatures(signature_id);


--
-- Name: governance_decisions; Type: ROW SECURITY; Schema: vision_autonomy; Owner: -
--

ALTER TABLE vision_autonomy.governance_decisions ENABLE ROW LEVEL SECURITY;

--
-- Name: meta_state_sync; Type: ROW SECURITY; Schema: vision_autonomy; Owner: -
--

ALTER TABLE vision_autonomy.meta_state_sync ENABLE ROW LEVEL SECURITY;

--
-- Name: execution_state; Type: ROW SECURITY; Schema: vision_core; Owner: -
--

ALTER TABLE vision_core.execution_state ENABLE ROW LEVEL SECURITY;

--
-- Name: noise_profile; Type: ROW SECURITY; Schema: vision_core; Owner: -
--

ALTER TABLE vision_core.noise_profile ENABLE ROW LEVEL SECURITY;

--
-- Name: alpha_signals; Type: ROW SECURITY; Schema: vision_signals; Owner: -
--

ALTER TABLE vision_signals.alpha_signals ENABLE ROW LEVEL SECURITY;

--
-- Name: signal_baseline; Type: ROW SECURITY; Schema: vision_signals; Owner: -
--

ALTER TABLE vision_signals.signal_baseline ENABLE ROW LEVEL SECURITY;

--
-- Name: hash_chains; Type: ROW SECURITY; Schema: vision_verification; Owner: -
--

ALTER TABLE vision_verification.hash_chains ENABLE ROW LEVEL SECURITY;

--
-- Name: operation_signatures; Type: ROW SECURITY; Schema: vision_verification; Owner: -
--

ALTER TABLE vision_verification.operation_signatures ENABLE ROW LEVEL SECURITY;

--
-- PostgreSQL database dump complete
--

\unrestrict UKAhqHDxjHnNz2oIBwVn7f9I1jonQcZLQ0n5NntB1pKFlMj0uJQtVN0IRmXPAzz

