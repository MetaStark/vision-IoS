"""
STIG Court-Proof Evidence Enforcer
==================================
CEO Directive: No Summary Without Raw Query Evidence

This module enforces the court-proof evidence requirement at the code level.
Every summary generated by any agent MUST attach:
  1. raw_query: The exact SQL that produced the data
  2. query_result: The actual data returned
  3. query_result_hash: SHA-256 of the result (computed automatically)

Split-brain prevention: Summaries cannot diverge from underlying data
because the evidence chain is cryptographically bound.

Usage:
    from stig_court_proof_enforcer import CourtProofEnforcer

    enforcer = CourtProofEnforcer(db_connection)

    # Wrap your summary generation
    evidence = enforcer.attach_evidence(
        summary_id="SIGNAL-2025-001",
        summary_type="ALPHA_SIGNAL",
        generating_agent="FINN",
        raw_query="SELECT * FROM vision_signals.alpha_signals WHERE...",
        query_result=df.to_dict(),  # The raw data
        summary_content={"signal": "BUY", "confidence": 0.85}
    )
"""

import hashlib
import json
import uuid
from datetime import datetime, timezone
from typing import Any, Dict, Optional
import psycopg2
from psycopg2.extras import RealDictCursor, Json


class CourtProofViolation(Exception):
    """Raised when evidence requirements are not met."""
    pass


class SplitBrainDetected(Exception):
    """Raised when conflicting evidence hashes are found."""
    pass


class CourtProofEnforcer:
    """
    Enforces the CEO directive: No Summary Without Raw Query Evidence.

    This class ensures that every summary generated in the system has
    cryptographic proof of its data origin, making all claims verifiable.
    """

    VALID_AGENTS = {'FINN', 'STIG', 'LINE', 'LARS', 'VEGA'}
    VALID_SUMMARY_TYPES = {
        'ALPHA_SIGNAL', 'REGIME_SUMMARY', 'FACTOR_SUMMARY',
        'GOLDEN_NEEDLE', 'EXECUTION_RESULT', 'GOVERNANCE_DECISION',
        'MACRO_SYNTHESIS', 'LIQUIDITY_ANALYSIS', 'CREDIT_ANALYSIS',
        'INGEST_SUMMARY', 'VALIDATION_REPORT', 'AUDIT_FINDING'
    }

    def __init__(self, db_connection):
        """
        Initialize the enforcer with a database connection.

        Args:
            db_connection: psycopg2 connection object
        """
        self.conn = db_connection

    def _compute_hash(self, data: Any) -> str:
        """Compute SHA-256 hash of data."""
        if isinstance(data, dict) or isinstance(data, list):
            data_str = json.dumps(data, sort_keys=True, default=str)
        else:
            data_str = str(data)
        return hashlib.sha256(data_str.encode('utf-8')).hexdigest()

    def _validate_inputs(
        self,
        summary_id: str,
        summary_type: str,
        generating_agent: str,
        raw_query: str,
        query_result: Any,
        summary_content: Dict
    ) -> None:
        """Validate all inputs meet court-proof requirements."""

        if not summary_id or len(summary_id) < 3:
            raise CourtProofViolation(
                "summary_id is mandatory and must be meaningful"
            )

        if generating_agent not in self.VALID_AGENTS:
            raise CourtProofViolation(
                f"generating_agent must be one of {self.VALID_AGENTS}, "
                f"got: {generating_agent}"
            )

        if not raw_query or len(raw_query) < 10:
            raise CourtProofViolation(
                "COURT_PROOF_VIOLATION: raw_query is mandatory and must "
                "contain valid SQL (minimum 10 characters). "
                "No summary without query evidence!"
            )

        if query_result is None:
            raise CourtProofViolation(
                "COURT_PROOF_VIOLATION: query_result is mandatory. "
                "No summary without raw data evidence!"
            )

        if not isinstance(summary_content, dict):
            raise CourtProofViolation(
                "summary_content must be a dictionary"
            )

    def attach_evidence(
        self,
        summary_id: str,
        summary_type: str,
        generating_agent: str,
        raw_query: str,
        query_result: Any,
        summary_content: Dict,
        execution_context: Optional[Dict] = None
    ) -> Dict:
        """
        Attach court-proof evidence to a summary.

        This is the MANDATORY function that must be called for every summary.
        It creates an immutable evidence record linking the summary to its
        underlying data with cryptographic proof.

        Args:
            summary_id: Unique identifier for this summary
            summary_type: Type of summary (e.g., 'ALPHA_SIGNAL', 'REGIME_SUMMARY')
            generating_agent: The agent creating this summary (FINN, STIG, etc.)
            raw_query: The exact SQL query that produced the data
            query_result: The raw data returned by the query
            summary_content: The summary itself (dict)
            execution_context: Optional additional context

        Returns:
            Dict containing evidence_id, hashes, and verification info

        Raises:
            CourtProofViolation: If any required evidence is missing
        """
        # Validate all inputs
        self._validate_inputs(
            summary_id, summary_type, generating_agent,
            raw_query, query_result, summary_content
        )

        # Compute hashes
        query_result_hash = self._compute_hash(query_result)
        summary_hash = self._compute_hash(summary_content)

        # Convert query_result to JSON-serializable format
        if hasattr(query_result, 'to_dict'):
            query_result_json = query_result.to_dict()
        elif hasattr(query_result, '__iter__') and not isinstance(query_result, (str, dict)):
            query_result_json = list(query_result)
        else:
            query_result_json = query_result

        evidence_id = str(uuid.uuid4())
        created_at = datetime.now(timezone.utc)

        # Insert into database
        with self.conn.cursor() as cur:
            cur.execute("""
                INSERT INTO vision_verification.summary_evidence_ledger (
                    evidence_id,
                    summary_id,
                    summary_type,
                    generating_agent,
                    raw_query,
                    query_result_hash,
                    query_result_snapshot,
                    summary_content,
                    summary_hash,
                    execution_context,
                    created_at
                ) VALUES (
                    %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s
                )
            """, (
                evidence_id,
                summary_id,
                summary_type,
                generating_agent,
                raw_query,
                query_result_hash,
                Json(query_result_json),
                Json(summary_content),
                summary_hash,
                Json(execution_context) if execution_context else None,
                created_at
            ))

            # Log to governance
            cur.execute("""
                INSERT INTO fhq_governance.governance_actions_log (
                    action_type,
                    action_target,
                    decision,
                    decision_rationale,
                    initiated_by,
                    initiated_at
                ) VALUES (
                    'EVIDENCE_ATTACHMENT',
                    %s,
                    'ENFORCED',
                    %s,
                    %s,
                    %s
                )
            """, (
                summary_id,
                f"Court-proof evidence attached: query_hash={query_result_hash}, "
                f"summary_type={summary_type}",
                generating_agent,
                created_at
            ))

            self.conn.commit()

        return {
            'evidence_id': evidence_id,
            'summary_id': summary_id,
            'summary_type': summary_type,
            'generating_agent': generating_agent,
            'query_result_hash': query_result_hash,
            'summary_hash': summary_hash,
            'created_at': created_at.isoformat(),
            'court_proof_status': 'VERIFIED'
        }

    def verify_evidence(self, evidence_id: str) -> Dict:
        """
        Verify the integrity of stored evidence.

        Re-computes the hash from stored data and compares to stored hash.
        This is how court-proof verification works.

        Args:
            evidence_id: UUID of the evidence record

        Returns:
            Dict with verification result
        """
        with self.conn.cursor(cursor_factory=RealDictCursor) as cur:
            cur.execute("""
                SELECT * FROM vision_verification.summary_evidence_ledger
                WHERE evidence_id = %s
            """, (evidence_id,))
            record = cur.fetchone()

        if not record:
            return {
                'valid': False,
                'error': 'Evidence record not found',
                'evidence_id': evidence_id
            }

        # Recompute hash
        recomputed_hash = self._compute_hash(record['query_result_snapshot'])
        is_valid = (recomputed_hash == record['query_result_hash'])

        # Log verification
        with self.conn.cursor() as cur:
            cur.execute("""
                INSERT INTO vision_verification.evidence_verification_log (
                    evidence_id,
                    verified_by,
                    verification_result,
                    verification_details
                ) VALUES (%s, 'STIG', %s, %s)
            """, (
                evidence_id,
                is_valid,
                Json({
                    'stored_hash': record['query_result_hash'],
                    'recomputed_hash': recomputed_hash,
                    'match': is_valid
                })
            ))
            self.conn.commit()

        return {
            'valid': is_valid,
            'evidence_id': evidence_id,
            'summary_id': record['summary_id'],
            'stored_hash': record['query_result_hash'],
            'recomputed_hash': recomputed_hash,
            'generating_agent': record['generating_agent'],
            'created_at': record['created_at'].isoformat(),
            'verification_timestamp': datetime.now(timezone.utc).isoformat()
        }

    def detect_split_brain(self) -> list:
        """
        Detect any split-brain conditions in the evidence ledger.

        Split-brain occurs when the same query produces different hashes,
        indicating data divergence.

        Returns:
            List of detected split-brain conditions
        """
        with self.conn.cursor(cursor_factory=RealDictCursor) as cur:
            cur.execute("""
                SELECT * FROM vision_verification.split_brain_detector
                WHERE status = 'HASH_MISMATCH'
                ORDER BY created_at_2 DESC
                LIMIT 100
            """)
            conflicts = cur.fetchall()

        if conflicts:
            # Log the detection
            for conflict in conflicts:
                with self.conn.cursor() as cur:
                    cur.execute("""
                        INSERT INTO fhq_governance.governance_actions_log (
                            action_type,
                            action_target,
                            decision,
                            decision_rationale,
                            initiated_by,
                            initiated_at
                        ) VALUES (
                            'SPLIT_BRAIN_DETECTED',
                            %s,
                            'ALERT',
                            %s,
                            'STIG',
                            NOW()
                        )
                    """, (
                        conflict['summary_1'],
                        f"Hash mismatch detected between {conflict['summary_1']} "
                        f"and {conflict['summary_2']}: {conflict['query_result_hash']} "
                        f"vs {conflict['conflicting_hash']}"
                    ))
                self.conn.commit()

        return [dict(c) for c in conflicts]


# ============================================================================
# Decorator for automatic evidence attachment
# ============================================================================

def require_evidence(summary_type: str, generating_agent: str):
    """
    Decorator to enforce evidence attachment on summary-generating functions.

    Usage:
        @require_evidence('ALPHA_SIGNAL', 'FINN')
        def generate_signal(db_conn, query, ...):
            # Must return (summary_content, query_result)
            result = execute_query(query)
            summary = process_result(result)
            return summary, result

    The decorator automatically:
        1. Extracts the query and result from the function
        2. Attaches court-proof evidence
        3. Returns the evidence record
    """
    def decorator(func):
        def wrapper(db_conn, query: str, *args, **kwargs):
            # Execute the wrapped function
            summary_content, query_result = func(db_conn, query, *args, **kwargs)

            # Generate summary_id from function name and timestamp
            summary_id = f"{func.__name__.upper()}-{datetime.now().strftime('%Y%m%d%H%M%S')}"

            # Attach evidence
            enforcer = CourtProofEnforcer(db_conn)
            evidence = enforcer.attach_evidence(
                summary_id=summary_id,
                summary_type=summary_type,
                generating_agent=generating_agent,
                raw_query=query,
                query_result=query_result,
                summary_content=summary_content,
                execution_context=kwargs.get('context')
            )

            return {
                'summary': summary_content,
                'evidence': evidence
            }
        return wrapper
    return decorator


# ============================================================================
# Standalone verification utility
# ============================================================================

def verify_all_evidence(db_connection) -> Dict:
    """
    Verify all evidence records in the ledger.

    Returns a summary of verification results.
    """
    enforcer = CourtProofEnforcer(db_connection)

    with db_connection.cursor(cursor_factory=RealDictCursor) as cur:
        cur.execute("""
            SELECT evidence_id FROM vision_verification.summary_evidence_ledger
            ORDER BY created_at DESC
            LIMIT 1000
        """)
        evidence_ids = [row['evidence_id'] for row in cur.fetchall()]

    results = {
        'total': len(evidence_ids),
        'valid': 0,
        'invalid': 0,
        'invalid_records': []
    }

    for eid in evidence_ids:
        verification = enforcer.verify_evidence(str(eid))
        if verification['valid']:
            results['valid'] += 1
        else:
            results['invalid'] += 1
            results['invalid_records'].append(verification)

    # Check for split-brain
    split_brain = enforcer.detect_split_brain()
    results['split_brain_detected'] = len(split_brain)
    results['split_brain_records'] = split_brain

    return results


if __name__ == '__main__':
    # Self-test
    print("STIG Court-Proof Enforcer loaded successfully")
    print("CEO Directive: No Summary Without Raw Query Evidence")
    print("Split-brain prevention: ACTIVE")
